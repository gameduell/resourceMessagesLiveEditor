(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

/**
 * Error constants
 *
 * @type {{PROJECT_NOT_EXISTS: number, INVALID_URL: number, NO_PERMISSION: number}}
 */
module.exports = {
  PROJECT_NOT_EXISTS: 'PROJECT_NOT_EXISTS',
  VALIDATION: 'VALIDATION',
  NO_PERMISSION: 'NO_PERMISSION'
};

},{}],2:[function(require,module,exports){
'use strict';

var C = {
    FILE_MANAGER: {
        FILE_TYPES: {
            IMAGE: 'image',
            FILE: 'file'
        },
        ENCODING: {
            image: 'base64',
            file: 'utf8'
        }
    },
    SESSION: {
        renewal_interval_in_ms: 1000 * 15
    }
};

module.exports = C;

},{}],3:[function(require,module,exports){
'use strict';

/**
 * TODO fade out when maxLengthOfMessages exceeded looks not so nice
 * @param id
 * @return {Object}
 * @constructor
 */
var toast = new function Toast(id) {
    var DELAY = 4000,
        opacityFadeSteps = 0.04,
        maxLengthOfMessages = 4,
        toastNode = document.getElementById(id),
        isReadyForStartAgain = true,
        newMessage = true,
        initToast = function initToast() {
        var rootNode = document.getElementsByTagName('body')[0];
        toastNode = document.createElement('div');
        toastNode.id = id;
        toastNode.style.cssText = "position:fixed;z-index:999;top:4.5em;right:2em;border-radius:5px;color:#fff;font-size:1.2em;font-weight:bold;background-color:rgba(63,143,251,0.9);padding: 1em 0.5em; box-sizing: border-box; max-width: 50%; text-align: center; word-wrap: break-word; break-word: break-all;";
        rootNode.appendChild(toastNode);
    },
        toast = {
        fadeOut: function fadeOut(_node, _done) {
            var node = _node;
            var done = _done;
            var opacity = 1;
            (function decrementOpacity() {
                if (opacity > opacityFadeSteps) {
                    opacity = opacity - opacityFadeSteps;
                    node.style.opacity = opacity;
                    setTimeout(function () {
                        decrementOpacity();
                    }, 40);
                } else {
                    console.log('PARENT NODE:');
                    console.log(node);
                    console.log(node.parentNode);
                    if (node.parentNode != null) {
                        node.parentNode.removeChild(node);
                    }
                    done();
                }
            })();
        },
        showMessage: function showMessage(msg) {
            if (!toastNode) {
                initToast();
            }
            toastNode.style.opacity = 1;
            var p = document.createElement('p');
            p.style.cssText = "padding:0px 10px";
            p.innerHTML = msg;
            toastNode.insertBefore(p, toastNode.firstChild);
            (function fadeOutToMuchMessages() {
                if (toastNode.childNodes.length > maxLengthOfMessages) {
                    toast.fadeOut(toastNode.children[toastNode.children.length - 1], function () {
                        fadeOutToMuchMessages();
                    });
                }
            })();
            var timeOut = DELAY;
            newMessage = true;
            function fadeOut(_fc) {
                var fc = _fc;
                var opacity = toastNode.style.opacity;
                if (opacity > opacityFadeSteps) {
                    if (newMessage) {
                        // resetMessage
                        newMessage = false;
                        timeOut = DELAY;
                        toastNode.style.opacity = 1;
                    } else {
                        opacity = opacity - opacityFadeSteps;
                        toastNode.style.opacity = opacity;
                        timeOut = 40;
                    }
                    // start timer
                    setTimeout(function () {
                        fadeOut(fc);
                    }, timeOut);
                } else {
                    while (toastNode.firstChild) {
                        toastNode.removeChild(toastNode.firstChild);
                    }
                    toastNode.style.opacity = 0;
                    // callback
                    fc(true);
                }
            }
            if (isReadyForStartAgain) {
                isReadyForStartAgain = false;
                timeOut = DELAY;
                fadeOut(function (_b) {
                    isReadyForStartAgain = true;
                });
            }
        }
    };
    return toast;
}('toast');

if (typeof module != "undefined") {
    console.log('exports');
    module.exports = toast;
} else {
    console.log('asign to global scope');
    window.toast = toast;
}

},{}],4:[function(require,module,exports){
'use strict';

/**
 * controller for the image uplaoder view - calls the server to upload a image and notifier the ui event handler
 * @type {{}}
 */
var canny = require('canny'),
    JMBFUploader = canny.JMBFUploader,
    displayManager = canny.displayManager,
    uiEvents = require('../uiEventManager.js'),
    uploadId,
    projectInfo;
/**
 * Call this for each file - will call a call back with the server answer
 * @param file
 */
function sendFile(file, directCallback) {
    var uri = '/uploadJMBFFile?projectId=' + projectInfo.id + '&project=' + projectInfo.name,
        xhr = new XMLHttpRequest(),
        fd = new FormData();

    xhr.open("POST", uri, true);
    xhr.onreadystatechange = function () {
        var data;
        if (xhr.readyState == 4 && xhr.status == 200) {
            // Handle response.
            data = JSON.parse(xhr.responseText);
            directCallback && directCallback(data); // handle response.
            // {file: "//sub/sub1/sub1_blue_coke.jpg", name: "sub1_blue_coke.jpg", type: "image/jpg"}
            console.log(data);
            uiEvents.callUievent('JMBFFileUploaded', projectInfo.id, uploadId, data.name);
        } else if (xhr.readyState == 4 && xhr.status === 406) {
            toast.showMessage('Upload failure. The file language is not supported');
        }
    };
    fd.append('myFile', file);
    // Initiate a multipart/form-data upload
    xhr.send(fd);
}

/**
 * Save data in member variable used by further upload operations
 * @param data: Project data
 */
function applyProjectData(data, project) {
    projectInfo = project;
}

uiEvents.addUiEventListener({
    showJMBFUploader: function showJMBFUploader(id) {
        displayManager.show('JMBFUploaderView');
    }
});

JMBFUploader.onUpload(function (file) {
    // TODO additional to the upload id we need the project ID
    console.log('uploadController:upload id: file:', uploadId, file);
    sendFile(file);
});

module.exports = {
    onNewProjectCreated: applyProjectData,
    onLoadProject: applyProjectData
};

},{"../uiEventManager.js":24,"canny":71}],5:[function(require,module,exports){
'use strict';

var canny = require('canny'),
    JsonImport = canny.JsonImport,
    displayManager = canny.displayManager,
    uiEvents = require('../uiEventManager.js'),
    uploadId,
    projectInfo;

function sendFile(file) {
    var uri = '/importJSON?projectId=' + projectInfo.id + '&project=' + projectInfo.name,
        xhr = new XMLHttpRequest(),
        fd = new FormData();

    xhr.open("POST", uri, true);
    xhr.onreadystatechange = function () {
        if (xhr.readyState == 4) {
            var data = JSON.parse(xhr.responseText);
            if (xhr.status == 200) {
                // data.name does not exist - and is also not used, is it ?
                uiEvents.callUievent('jsonImported', projectInfo.id, uploadId, data.name);
            } else if (xhr.status === 406) {
                toast.showMessage('Upload failure. There is an error:<br />' + data.msg);
            }
        }
    };
    fd.append('myFile', file);
    xhr.send(fd);
}

function applyProjectData(data, project) {
    projectInfo = project;
}

uiEvents.addUiEventListener({
    showJSONImport: function showJSONImport(id) {
        displayManager.show('JSONImportView');
    }
});

JsonImport.onUpload(function (file) {
    sendFile(file);
});

module.exports = {
    onNewProjectCreated: applyProjectData,
    onLoadProject: applyProjectData
};

},{"../uiEventManager.js":24,"canny":71}],6:[function(require,module,exports){
'use strict';

var async = require('canny/mod/async'),
    auth = require('canny').auth;

auth.onLogout(function () {
    async.doAjax({
        path: '/logout',
        onSuccess: function onSuccess(response) {
            location.reload();
        }
    });
});

module.exports = {};

},{"canny":71,"canny/mod/async":72}],7:[function(require,module,exports){
'use strict';

var breadcrumb = require('../uiModules/breadcrumb'),
    canny = require('canny'),
    trade = require('../trade'),
    uiEvents = require('../uiEventManager');

canny.add('breadcrumb', breadcrumb);

breadcrumb.onClick(function (directoryId) {
    trade.getDirectory(directoryId, function (err) {
        if (err !== false) {
            // TODO call the
            uiEvents.callUievent('showOverviewPage');
        } else {
            console.log('breadcrumbController:getDirectory can not load project for directory name:', directoryId);
        }
    });
});

module.exports = {
    setPath: function setPath(url) {
        var path = '/';
        if (url === '/') return breadcrumb.updateFolders([{ id: '/', name: '' }]);

        breadcrumb.updateFolders(url.split('/').map(function (folder) {
            path = path[path.length - 1] !== '/' ? path + '/' + folder : path + folder;
            return {
                id: path, name: folder
            };
        }));
    },
    getDirectory: function getDirectory(data) {
        console.log('breadcrumbController:parentDirectories', data.parentDirectories);
        breadcrumb.updateFolders(data.parentDirectories);
    }
};

},{"../trade":23,"../uiEventManager":24,"../uiModules/breadcrumb":29,"canny":71}],8:[function(require,module,exports){
'use strict';

var createNewProject = require('canny').createNewProject,
    displayManager = require('canny').displayManager,
    trade = require('../trade');

var currentDirectory;

createNewProject.onCreateNewProject(function (projectName) {
    trade.createNewProject(projectName, currentDirectory);
    displayManager.hide('createNewProjectView');
});

createNewProject.onCreateNewDirectoy(function (directoryName) {
    trade.createNewDirectory(directoryName, currentDirectory);
    displayManager.hide('createNewDirectoryView');
});

module.exports = {
    // TODO introduce new event: onDirectoryChanged - because a "getDirectory" event does not really explain what's
    // happening here
    getDirectory: function getDirectory(data) {
        currentDirectory = data.currentDirectory;
    }
};

},{"../trade":23,"canny":71}],9:[function(require,module,exports){
'use strict';

var anchorMenu = require('canny').anchorMenu,
    translationViewConfig = require('../uiModules/translationView').config,
    uiEvents = require('../uiEventManager');

/**
 * Nice approach but the order is different from the DOM.
 * TODO It would be better to read the elements from the DOM
 *  1. it's easier to reinitialize if a key is renamed or created new (Y)
 *  2. the order will be same as in the DOM (Y)
 *  con: we need to wait until the DOM is rendered - otherwise elements will be missing
 *
 *  We need:
 *  * DOM render success event (the translationView controller has to throw it) (so far the controller is added after the translationController it looks like that this is not an issue)
 *  * an a if anchor is clicked (in view) event ; then also focus the correct menu right element
 *  * the right menu element interact only as scroll overview - not as anchor helper as it is right now
 *
 * @param keys
 */

anchorMenu.onSelect(function (id) {
    var dom = document.getElementById(translationViewConfig.rowPrefix + id);
    if (dom) {
        var bodyRect = document.body.getBoundingClientRect(),
            elemRect = dom.getBoundingClientRect(),
            offset = elemRect.top - bodyRect.top;
        window.scrollTo(0, offset - 60);
        uiEvents.callUievent('anchorFocus', '#' + id);
    }
});

uiEvents.addUiEventListener({
    anchorFocus: function anchorFocus(id) {
        anchorMenu.focusElement(id.replace('#', ''));
    }
});

module.exports = {
    renameCategory: function renameCategory(oldName, newName) {
        anchorMenu.renderMenu();
    },
    removeCategory: function removeCategory(categoryName) {
        anchorMenu.renderMenu();
    },
    renameKey: function renameKey(oldKey, newKey) {
        anchorMenu.renderMenu();
    },
    removeKey: function removeKey(key) {
        anchorMenu.renderMenu();
    },
    onCreateKey: function onCreateKey() {
        anchorMenu.renderMenu();
    },
    onKeyCloned: function onKeyCloned(projectId, data) {
        anchorMenu.renderMenu();
    },
    /**
     * Will be called with the complete JSON object from a specific project
     * @param projectData
     */
    onLoadProject: function onLoadProject(projectData) {
        anchorMenu.renderMenu();
    },
    onNewProjectCreated: function onNewProjectCreated() {
        anchorMenu.renderMenu();
    }
};

},{"../uiEventManager":24,"../uiModules/translationView":53,"canny":71}],10:[function(require,module,exports){
'use strict';

var whisker = require('canny/mod/whisker');
var canny = require('canny');
var displayManager = canny.displayManager;
var trade = require('../trade');
var ERRORS = require('../../../ERRORS');

var inputNodes = {
    name: undefined,
    url: undefined
    // whisker callback for rendering the ui module
};var renderUi = void 0;
// save the actual loaded project config - needed for comparision
var project = void 0;

function noReturn(node) {
    node.addEventListener('keypress', function (e) {
        var key = e.keyCode || e.which;
        if (key === 13) e.returnValue = false;
        return true;
    });
    return node;
}

function noSpaces(node) {
    node.addEventListener('keypress', function (e) {
        var key = e.keyCode || e.which;
        if (key === 32) e.returnValue = false;
        return true;
    });
    return node;
}

function trimSlashes(url) {

    while (/\/\//.test(url)) {
        url = url.replace('//', '/');
    } // remove last slash if there is one
    if (url.length > 1 && url[url.length - 1] === '/') url = url.slice(0, -1);

    return url;
}

function removeSpaces(s) {
    while (/ /.test(s)) {
        s = s.replace(' ', '_');
    }return s;
}

function _submit() {
    trade.moveProject({
        id: project.id,
        url: removeSpaces(trimSlashes(inputNodes.url.value || ui.url)),
        name: inputNodes.name.value || ui.name
    }, function (err, _ref) {
        var id = _ref.id,
            name = _ref.name,
            url = _ref.url;

        if (err) {
            displayManager.hide('moveProject');
            if (ERRORS[err.error]) {
                toast.showMessage('Changing ' + inputNodes.name.value + ' failed: ' + err.message);
                toast.showMessage(err.error);
            } else {
                toast.showMessage('Failure ' + inputNodes.name.value + ' failed: ' + err.message);
                toast.showMessage('ERROR UNKNOWN');
            }
        } else {
            displayManager.hide('moveProject');
            // show/reload actual directory
            trade.getDirectory(url);
            if (project.url !== url) toast.showMessage('Change project location successfully to ' + url);
            if (project.name !== name) toast.showMessage('Rename project successfully to ' + name);
        }
    });
}

var ui = {
    inputName: function inputName(n) {
        return inputNodes.name = noReturn(n);
    },
    inputUrl: function inputUrl(n) {
        return inputNodes.url = noReturn(noSpaces(n));
    },
    submit: function submit(n) {
        return n.addEventListener('click', function () {
            return _submit();
        });
    },
    cancel: function cancel(n) {
        return n.addEventListener('click', function () {
            return displayManager.hide('moveProject');
        });
    },
    name: '',
    url: '',
    id: '',
    projectLink: ''
};

canny.add('moveProject', {
    add: function add(node) {
        whisker.add(node, function (fc) {
            renderUi = fc;
            renderUi(ui);
        });
    }
});

module.exports = {
    show: function show(_ref2) {
        var id = _ref2.id,
            url = _ref2.url,
            name = _ref2.name;


        project = { id: id, url: url, name: name };

        renderUi({
            id: id,
            url: url,
            name: name,
            projectLink: '/' + id + '.prj'
        });
        displayManager.show('moveProject');
    }
};

},{"../../../ERRORS":1,"../trade":23,"canny":71,"canny/mod/whisker":75}],11:[function(require,module,exports){
'use strict';

var canny = require('canny');

/**
 * just the implementation of the callbacks
 */

/**
 * Apply project description data to dom elements
 * @param data: Project configuration data
 */
function applyProjectData(data, project) {
    if (project.hasOwnProperty('name')) {
        // project specific config
        canny.texts.setTexts({ projectName: project.name });
    }

    // FIXME: Categories should not be named "__description" as they would override the project description
    if (data.hasOwnProperty('keyDescriptions')) {
        // project specific config - if property is present
        canny.texts.setTexts({
            projectDescription: data.keyDescriptions['__description'] ? data.keyDescriptions['__description'] : ''
        });
    }
}

module.exports = {
    onNewProjectCreated: applyProjectData,
    onLoadProject: applyProjectData,
    onNewDirectoryCreated: function onNewDirectoryCreated(data) {
        canny.texts.setTexts({
            projectName: data.directoryId
        });
    }
};

},{"canny":71}],12:[function(require,module,exports){
'use strict';

var canny = require('canny'),
    domOpts = require('dom-opts'),
    trade = require('../trade.js'),
    events = require('../events.js'),
    uiEvents = require('../uiEventManager.js'),
    keyValueCounter = {
    projectMap: {},
    getCountObj: function getCountObj() {
        return {
            keyMap: {}, // just collect all unique keys for getting total number of existing keys
            langMap: {} // save for each language all "valid" keys
        };
    }
},
    projectConfig = {},
    projectInfo = {},
    availableLanguages = [];

canny.projectMainNavigation.onLanguageSelect(function (obj) {
    var eventName;
    if (obj.isActive) {
        eventName = obj.isInactive ? 'deActivateLanguage' : 'activateLanguage';
        uiEvents.callUievent(eventName, obj.language);
    } else {
        uiEvents.callUievent('addLanguage', obj.language);
    }
});

(function () {
    var editorModeEnabled = false;

    canny.projectMainNavigation.onEnableEditorMode(function () {
        console.log('projectMainNavigationController:onEnableEditorMode show JSON format in new tab.');
        uiEvents.callUievent('enableEditorMode', !editorModeEnabled);
    });
    //maybe someone else calls this too
    uiEvents.addUiEventListener({
        enableEditorMode: function enableEditorMode(enabled) {
            editorModeEnabled = enabled;
        }
    });
})();

(function () {
    var wordCountEnabled = false;

    canny.projectMainNavigation.onToggleWordCount(function () {
        wordCountEnabled = !wordCountEnabled;
        uiEvents.callUievent('toggleWordCount', wordCountEnabled);
    });
})();

canny.projectMainNavigation.onShowJSON(function () {
    console.log('projectMainNavigationController:onShowJSON show JSON format in new tab.');
    window.open('/' + projectInfo.id + '.json?category=true', '_blank' // <- This is what makes it open in a new window.
    );
});

canny.projectMainNavigation.onShowJMBFUploader(function () {
    console.log('projectMainNavigationController:onShowJMBFUploader show message bundle uploader');
    uiEvents.callUievent('showJMBFUploader');
});

canny.projectMainNavigation.onShowJSONImport(function () {
    console.log('projectMainNavigationController:onShowJSONImport show JSON import overlay');
    uiEvents.callUievent('showJSONImport');
});

canny.projectMainNavigation.onShowJMBF(function () {
    console.log('projectMainNavigationController:onShowJMBF show JMBF format in new tab.');

    var lang = window.prompt('Enter a language code. E.g.: ' + function () {
        var existingLanguages = [];
        Object.keys(projectConfig.keys).forEach(function (lang) {
            if (Object.keys(projectConfig.keys[lang]).length > 0) {
                existingLanguages.push(lang);
            }
        });
        return existingLanguages;
    }().join(', '));

    if (lang !== null) {
        window.open('/' + projectInfo.id + '.properties' + (lang !== '' ? '?lang=' + lang : ''), '_blank' // <- This is what makes it open in a new window.
        );
    }
});

/**
 * server event listener
 */
events.addServerListener('newProjectWasCreated', function (projectName) {
    toast.showMessage('A new project with name: "' + projectName + '" was created.');
});
/**
 * server event listener
 */
events.addServerListener('keyUpdated', function (projectId, language, keyName, keyValue) {
    // TODO more client changes are coming, we'll finish the code below then
    //if (projectId === currentProjectId) {
    //    var projectName = projectId.substring(projectId.lastIndexOf('/') + 1);
    //    updateKeyToProjectMap(projectName, language, keyName, keyValue);
    //    console.log('projectMainNavigationController:updateKey', projectId, language, keyName, keyValue);
    //}
});
/**
 * server event listener
 */
events.addServerListener('keyDeleted', function (bundleName, obj) {
    // TODO more client changes are coming, we'll finish the code below then
    //if (bundleName === projectConfig.project) {
    //    console.log('projectMainNavigationController:keyRenamed', bundleName, obj);
    //    // TODO update the statistics...
    //}
});

/**
 *
 * @param projectName
 * @param lang
 * @param key
 * @param value
 */
function saveKeyToProjectMap(projectName, lang, key, value) {

    // just collect all keys (only the unique keys are relevant)
    if (keyValueCounter.projectMap[projectName] === undefined) {
        console.log('projectMainNavigationController:saveKeyToProjectMap project name not exists:', projectName);
        keyValueCounter.projectMap[projectName] = keyValueCounter.getCountObj();
    }

    keyValueCounter.projectMap[projectName].keyMap[key] = true;
    if (keyValueCounter.projectMap[projectName].langMap[lang] === undefined) {
        keyValueCounter.projectMap[projectName].langMap[lang] = {};
    }
    // only save the keys as object if it is a valid key otherwise delete it
    if (value) {
        keyValueCounter.projectMap[projectName].langMap[lang][key] = true;
    } else if (keyValueCounter.projectMap[projectName].langMap[lang][key]) {
        // if this key exists than remove it
        delete keyValueCounter.projectMap[projectName].langMap[lang][key];
    }
}

// TODO should use projectId, not projectName
function updateKeyToProjectMap(projectName, lang, key, value) {
    saveKeyToProjectMap(projectName, lang, key, value);
    canny.projectMainNavigation.setNumberOfTranslatedLanguageKey(Object.keys(keyValueCounter.projectMap[projectName].langMap[lang]).length, lang);
    canny.projectMainNavigation.setNumberOfTranslationMaxKeys(Object.keys(keyValueCounter.projectMap[projectName].keyMap).length);
}

// register listener function to the ui events
uiEvents.addUiEventListener({
    /**
     * the internal updateKey event - the server will not trigger the updateKey for the own client
     */
    updateKey: function updateKey(projectName, lang, key, value) {
        console.log('projectMainNavigationController:updateKey', projectName, lang, key, value);
        updateKeyToProjectMap(projectName, lang, key, value);
    },
    projectSelected: function projectSelected(projectId) {
        console.log('projectMainNavigationController:projectSelected Click on project', projectId);
        trade.loadProject(projectId, function (error) {
            if (error === false) console.error('projectMainNavigationController:loadProject fails for projectId:', projectId);
        });
    },
    activateLanguage: function activateLanguage(lang) {
        canny.projectMainNavigation.activateLang(lang);
    },
    deActivateLanguage: function deActivateLanguage(lang) {
        canny.projectMainNavigation.deActivateLang(lang);
    },
    addLanguage: function addLanguage(lang) {
        canny.projectMainNavigation.activateLang(lang);
    }
});

function computeTotalTranslationProgree(translations) {
    var totalProgress = {};
    Object.keys(translations).forEach(function (lang) {
        Object.keys(translations[lang]).forEach(function (key) {
            totalProgress[key] = undefined;
        });
    });
    return Object.keys(totalProgress).length;
}

function computeTranslationProgress(translations) {
    var progressByLanguage = {};
    Object.keys(translations).forEach(function (lang) {
        progressByLanguage[lang] = Object.keys(translations[lang]).length;
    });
    return progressByLanguage;
}

/**
 * Callback implementation of the onLoadProject & onNewProjectCreated
 * @param projectData (see project JSON file)
 */
function applyProjectData(data, project) {
    projectConfig = data;
    projectInfo = project;

    canny.projectMainNavigation.setAvailableLanguages(data.availableLanguages);

    canny.projectMainNavigation.setActivatedProjectLanguages(computeTotalTranslationProgree(data.keys), computeTranslationProgress(data.keys));

    Object.keys(data.keys).forEach(function (lang) {
        if (Object.keys(data.keys[lang]).length > 0 && availableLanguages.indexOf(lang) !== -1) {

            Object.keys(data.keys[lang]).forEach(function (key) {
                saveKeyToProjectMap(data.project, lang, key, data.keys[lang][key]);
            });

            if (keyValueCounter.projectMap[data.project].langMap[lang]) {
                console.log('projectMainNavigationController:onLoadProject ', keyValueCounter.projectMap[data.project].langMap[lang]);
                console.log('projectMainNavigationController:onLoadProject maxKeys are', Object.keys(keyValueCounter.projectMap[data.project].keyMap).length);
                //canny.projectMainNavigation.setNumberOfTranslationMaxKeys(Object.keys(keyValueCounter.projectMap[projectData.project].keyMap).length);
                //canny.projectMainNavigation.setNumberOfTranslatedLanguageKey(Object.keys(keyValueCounter.projectMap[projectData.project].langMap[lang]).length, lang);
                // TODO refactor this and make one call ;)
                canny.projectMainNavigation.activateLang(lang);
                canny.projectMainNavigation.deActivateLang(lang);
            } else {
                console.log('projectMainNavigationController:onLoadProject get language without any keys for locale:', lang);
            }
        }
    });

    // reset or reinitialize or initialize the key value counter (otherwise the counter can't detect deleted keys. E.g. from the editor mode)
    keyValueCounter.projectMap[data.project] = keyValueCounter.getCountObj();
    // show default language as selected language in menu
    // TODO check who decides to show which language as default - and then call this event from there
    uiEvents.callUievent('activateLanguage', data.defaultLanguage);
}

/**
 * the implementation of the callbacks
 */
module.exports = {
    onNewProjectCreated: applyProjectData,
    onLoadProject: applyProjectData
};

},{"../events.js":19,"../trade.js":23,"../uiEventManager.js":24,"canny":71,"dom-opts":85}],13:[function(require,module,exports){
'use strict';

var projectOverview = require('canny').projectOverview,
    displayManager = require('canny').displayManager,
    trade = require('../trade.js'),
    uiEvents = require('../uiEventManager.js'),
    toast = require('../Toast.js'),
    events = require('../events.js');

var moveProject = require('./moveProjectComponent');

var projectOverviewController = function () {

    var currentParentDirectory, currentDirectory,
    /**
     * Maps project names to projects IDs
     */
    projects,
    /**
     * Maps directory names to directory IDs
     */
    directories;

    uiEvents.addUiEventListener({
        showOverviewPage: function showOverviewPage() {
            displayManager.show('projectsOverview');
        }
    });

    projectOverview.onParentDirectorySelected(function () {
        if (currentParentDirectory !== currentDirectory) {
            trade.getDirectory(currentParentDirectory);
        } else {
            console.log('No parent directory');
        }
    });

    projectOverview.onProjectSelected(function (projectName) {
        uiEvents.callUievent('projectSelected', projects[projectName].id);
    });

    projectOverview.onDirectorySelected(function (directoryName) {
        var directoryId = directories[directoryName];
        trade.getDirectory(directoryId, function () {
            console.log('projectOverviewController:can not load project for directory name:', directoryId);
        });
    });

    projectOverview.onCreateProjectPressed(function () {
        displayManager.show('createNewProjectView');
    });

    projectOverview.onCreateDirectoryPressed(function () {
        displayManager.show('createNewDirectoryView');
    });

    projectOverview.onDeleteFolderPressed(function (dirName) {
        var directoryname = currentDirectory;
        if (directoryname[directoryname.length - 1] !== '/') {
            directoryname += '/';
        }
        trade.deleteFolder(directoryname + dirName, function (err, dirName) {
            var toastMessage;
            if (!err) {
                projectOverview.deleteProjectListNode(dirName.split('/').slice(-1)[0]);
                toastMessage = 'Folder "' + dirName + '" has been deleted.';
            } else {
                toastMessage = 'There was an error: "' + err.message + '"';
            }
            toast.showMessage(toastMessage);
        });
    });

    projectOverview.onMoveDirectoryPressed(function (projectName) {
        return moveProject.show(projects[projectName]);
    });

    projectOverview.onDeleteProjectPressed(function (projectName) {
        trade.deleteProject(projects[projectName].id, function (err, project) {
            var toastMessage;
            if (!err) {
                projectOverview.deleteProjectListNode(project.name);
                toastMessage = 'Project "' + project.name + '" has been deleted.';
            } else {
                toastMessage = 'There was an error: "' + err.message + '"';
            }
            toast.showMessage(toastMessage);
        });
    });

    events.addServerListener('newDirectoryCreated', function (directoryId) {
        var lastDirSepIdx = directoryId.lastIndexOf('/');
        var parentDirectory = directoryId.substring(0, lastDirSepIdx + 1);
        if (parentDirectory === currentParentDirectory) {
            var directoryName = directoryId.substring(lastDirSepIdx + 1);
            directories[directoryName] = directoryId;
            // TODO show message only if projectOverview is currently visible - but canny.flowcontrol currently does not
            // have anything to find out which view is the active one
            toast.showMessage('A new directory "' + directoryName + '" has been created by another user.');
            projectOverview.setProjectsAndDirectories(Object.keys(projects), Object.keys(directories));
        }
    });

    return {
        /**
         * Callback from the server which handles a fresh directory/projects list
         *
         * @param {{currentDirectory:string, dirs:[{name, id}], parentDirectories:[{name, id}], parentDirectory:string, projects:[{name, id}] }} data - an object with 2 properties "projects" and "directories", each listing project/directory names.
         */
        getDirectory: function getDirectory(data) {
            console.log('ProjectOverviewController.getDirectory: ', data);
            if (data === false) {
                console.error("Server call failed");
            } else if (data.hasOwnProperty('projects') && data.hasOwnProperty('dirs')) {

                projects = {};
                data.projects.forEach(function (entry) {
                    projects[entry.name] = entry;
                });

                directories = {};
                data.dirs.forEach(function (entry) {
                    directories[entry.name] = entry.id;
                });

                projectOverview.setProjectsAndDirectories(Object.keys(projects), Object.keys(directories));
                currentParentDirectory = data.parentDirectory;
                currentDirectory = data.currentDirectory;
            } else {
                console.warn('Data rcvd from server is missing expected properties ("projects", "dirs")');
            }
        },
        onNewDirectoryCreated: function onNewDirectoryCreated(data) {
            displayManager.show('projectsOverview');
            trade.getDirectory(data.directoryId, function () {
                console.log('projectOverviewController.onNewDirectoryCreated: trade callback');
            });
        }
    };
}();

module.exports = projectOverviewController;

},{"../Toast.js":3,"../events.js":19,"../trade.js":23,"../uiEventManager.js":24,"./moveProjectComponent":10,"canny":71}],14:[function(require,module,exports){
"use strict";

var canny = require("canny");

var searchBar = canny.searchBar,
    loadingModal = canny.loadingModal,
    trade = require("../trade"),
    SearchResults = require("../uiModules/searchResults"),
    searchResultsUi = SearchResults({
    onClose: function onClose() {
        return searchResultsUi.destroy();
    }
});

canny.add("searchResults", SearchResults);

searchBar.onSearch(function () {
    loadingModal.show();
    var searchValue = searchBar.inputNode.value;
    if (searchValue.length > 2) {
        trade.searchTerm(searchValue, function (response) {
            loadingModal.hide();
            searchResultsUi.render(response);
        });
    }
});

module.exports = {};

},{"../trade":23,"../uiModules/searchResults":51,"canny":71}],15:[function(require,module,exports){
'use strict';

var textEditor = require('canny').textEditor,
    trade = require('../trade.js'),
    toast = require('../Toast.js'),
    events = require('../events.js'),
    currentProjectId;
/**
 * returns the language or false
 * @param fileName
 * @returns {*}
 */
function getLanguageFromFileName(fileName) {
    var reg = /messages_(.*)\..*./g.exec(fileName);
    if (reg && reg.length === 2) {
        return reg[1];
    }
    return false;
}

/**
 * handle the change project description event in the view
 */
textEditor.onChange(function (id, value, fc) {
    console.log('textEditorController:onChange', value);
    if (currentProjectId) {
        if (!id) {
            // TODO to keep backward functionality this is the "main" project description - will be changed in future
            id = '__description';
        }
        // TODO remove the tv_ from the id
        trade.saveProjectDescription(currentProjectId, id, value, function (success) {
            if (success) {
                fc(true);
                toast.showMessage('Project description changed for project ' + currentProjectId);
            } else {
                fc(false);
            }
        });
    }
});
/**
 * just the implementation of the callbacks
 *
 */
module.exports = {
    onLoadProject: function onLoadProject(data, _ref) {
        var id = _ref.id,
            name = _ref.name,
            url = _ref.url;

        if (id) currentProjectId = id;
    }
};

},{"../Toast.js":3,"../events.js":19,"../trade.js":23,"canny":71}],16:[function(require,module,exports){
'use strict';

var canny = require("canny"),
    translationView = require('../uiModules/translationView'),
    translationViewImageUpload = require('../uiModules/translationViewImageUpload'),
    wordCounter = require('../util/wordCounter'),
    domOpts = require('dom-opts'),
    uiEvents = require('../uiEventManager.js'),
    events = require('../events.js'),
    trade = require('../trade.js'),
    url = require('../util/url'),
    sortByKey = function sortByKey(a, b) {
    if (a.key < b.key) {
        return -1;
    }
    if (a.key > b.key) {
        return 1;
    }
    return 0;
},
    projectConfig,
    projectInfo,
    availableLanguages = [],

/**
 * An object (used as a set datastructure here) holding all existing keys of the project (no matter for how many
 * languages it is used). It is needed when adding a new language, see the function for addLanguage which is added
 * to uiEvents.
 * @type {{}}
 */
existingKeys = {},
    orderedLanguages = [],
    sortLanguages = function sortLanguages(a, b) {
    return orderedLanguages.indexOf(a) - orderedLanguages.indexOf(b);
};

translationViewImageUpload.onUploadButton(function (id) {
    uiEvents.callUievent('showFileUpload', id);
});

translationViewImageUpload.onDeleteButton(function (id) {
    if (confirm('Delete the image for category » ' + id + ' « forever?')) {
        trade.removeImage(projectInfo.id, id);
    }
});

translationView.onCategoryClicked(function (id) {
    uiEvents.callUievent('anchorFocus', '#' + id);
});
/**
 * Setup the UI events and manage the logic for them.
 *
 * TODO replace bundle with locale and refactor the calls from translationView
 */
translationView.onSaveKey(function (key, lang, value) {

    // TODO: Count words and tell word count label to update

    console.log('translationViewController:onSaveValue', [].slice.call(arguments));
    trade.saveKey(projectInfo.id, lang || projectConfig.defaultLanguage, {
        key: key,
        value: value || undefined
    }, function (projectId, language, key, value) {
        var catId;

        if (projectId === projectInfo.id) {
            // prevent applying the callback if project has been changed in the meantime
            catId = key.split('_')[0];
            existingKeys[key] = undefined; // save the key
            projectConfig.keys[lang][key] = value;
            translationView.printBundleTemplate([{
                key: key,
                value: value || ''
            }], language, availableLanguages, function () {
                updateCategoryWordCount(catId, language);
            });

            toast.showMessage('Auto save: "' + key + '" (success)');

            translationView.sendSuccess(key, 'value_');
            // TODO not sure if this is needed
            uiEvents.callUievent('updateKey', projectId, language, key, value);
        }
    });
});

/**
 * Setup the UI events and manage the logic for them.
 *
 * TODO replace bundle with locale and refactor the calls from translationView
 */
translationView.onCreateKey(function (key, lang, value) {
    console.log('translationViewController:onSaveValue', [].slice.call(arguments));
    trade.createKey(projectInfo.id, lang || projectConfig.defaultLanguage, {
        key: key,
        value: value || undefined
    }, function (projectId, language, key, value) {
        var catId = key.split('_')[0];
        if (projectId === projectInfo.id) {
            // prevent applying the callback if project has been changed in the meantime
            existingKeys[key] = undefined; // save the key
            projectConfig.keys[language] = projectConfig.keys[language] ? projectConfig.keys[language] : {};
            projectConfig.keys[language][key] = value;
            translationView.printBundleTemplate([{
                key: key,
                value: value || '',
                words: 0
            }], language, availableLanguages, function () {
                updateCategoryWordCount(catId, language);
            });
            toast.showMessage('Auto save: "' + key + '" (success)');

            translationView.sendSuccess(key, 'value_');
            // TODO not sure if this is needed
            uiEvents.callUievent('updateKey', projectId, language, key, value);
        }
    });
});

translationView.onCloneKey(function (keyId, keyName, fromCategory, toCategory) {
    trade.cloneKey(projectInfo.id, {
        id: keyId,
        key: keyName,
        sourceCategory: fromCategory,
        targetCategory: toCategory
    }, function (err, projectId, data) {
        var texts;
        if (projectId === projectInfo.id) {
            existingKeys[data.key] = undefined;
            texts = data.values;
            for (var lang in texts) {
                if (texts.hasOwnProperty(lang)) {
                    projectConfig.keys[lang][data.key] = texts[lang];
                    translationView.printBundleTemplate([{
                        key: data.key,
                        value: texts[lang] || ''
                    }], lang, availableLanguages, function () {
                        updateCategoryWordCount(toCategory, lang);
                    });
                }
            }
            canny.translationViewDescription.addDescriptions(data.keyDescriptions);
        }
    });
});

/**
 * Read the from param as default language otherwise take it from the project.json
 * @param config
 */
function saveProjectConfig(config, project) {
    var idx,

    // the from parameter can overwrite the default language (legacy)
    defaultLanguage = domOpts.params.from ? domOpts.params.from : config.defaultLanguage;
    projectConfig = config;
    projectInfo = project;

    // Set ${ defaultLanguage } as default in case a project was just created (i.e. does not contain any keys yet)
    // TODO: Better create / add check of object to functional helper object instead ?
    availableLanguages = Object.keys(projectConfig.keys).length === 0 && JSON.stringify(projectConfig.keys) === JSON.stringify({}) ? [defaultLanguage] : Object.keys(projectConfig.keys);

    availableLanguages = availableLanguages.sort(sortLanguages);

    idx = availableLanguages.indexOf(defaultLanguage);

    if (idx !== -1 && idx !== 0) {
        // move default to the begin of the list (this defines the order how the translation languages are shown)
        availableLanguages.splice(0, 0, availableLanguages.splice(idx, 1)[0]);
    }
}

///**
// * TODO replace bundle with locale and refactor the calls from translationView
// * TODO this code is not called!?
// */
//translationView.onAddNewKey(function (lang, key, value, cb) {
//    console.log('translationViewController:onAddNewKey', [].slice.call(arguments));
//    alert('huhu');
//    trade.sendResource({
//        bundle: projectConfig.project,
//        locale: lang
//    }, {
//        key: key,
//        value: value
//    }, function (key) {
//        cb(key)
//    });
//});

translationView.onCreateNewProject(function (prjName, obj) {
    trade.createNewProject(prjName, obj);
});

translationView.onRemoveCategory(function (obj) {
    console.log('translationViewController:onRemoveCategory', obj, projectInfo.id);
    trade.removeCategory(projectInfo.id, obj.category);
});

translationView.onRenameCategory(function (obj) {
    console.log('translationViewController:onRenameCategory', obj, projectInfo.id);
    trade.renameCategory(projectInfo.id, obj.oldName, obj.newName);
});

translationView.onRenameKey(function (obj) {
    console.log('translationViewController:onRenameKey', obj, projectInfo.id);
    trade.renameKey(projectInfo.id, {
        newKey: obj.newKey,
        oldKey: obj.oldKey
    });
});

translationView.onRemoveKey(function (obj) {
    console.log('translationViewController:onRemoveKey', obj, projectInfo.id);
    trade.removeKey(projectInfo.id, obj.key, function (key) {
        var catName = key.split('_')[0];
        for (var lang in projectConfig.keys) {
            if (projectConfig.keys.hasOwnProperty(lang)) {
                delete projectConfig.keys[lang][key];
                updateCategoryWordCount(catName, lang);
            }
        }
    });
});

// register listener function to the ui events
uiEvents.addUiEventListener({
    activateLanguage: function activateLanguage(lang) {
        //        translationViewHeader.showLang(lang);
        translationView.showLang(lang);
    },
    deActivateLanguage: function deActivateLanguage(lang) {
        //        translationViewHeader.hideLang(lang);
        translationView.hideLang(lang);
    },
    toggleWordCount: function toggleWordCount(active) {
        translationView.toggleWordCount(active);
    },
    // TODO  don't trigger it twice for the same language
    addLanguage: function addLanguage(lang) {
        availableLanguages.push(lang);
        availableLanguages = availableLanguages.sort(sortLanguages);
        projectConfig.keys[lang] = {};
        translationView.addLanguage(Object.keys(existingKeys), lang, availableLanguages.indexOf(lang));
        //        translationViewHeader.showLang(lang);
        translationView.showLang(lang);
    },
    enableEditorMode: function enableEditorMode(enabled) {
        translationView.enableEditorMode(enabled);
    },
    fileUploaded: function fileUploaded(projectId, key, url) {
        canny.translationViewImageUpload.appendImage(key, url);
    },
    JMBFFileUploaded: function JMBFFileUploaded(projectId) {
        trade.loadProject(projectId, function (error) {
            if (error === false) console.error('translationViewController:loadProject fails for projectId:', projectInfo.id);
        });
    },
    jsonImported: function jsonImported(projectId) {
        trade.loadProject(projectId, function (error) {
            if (error === false) {
                console.warn('Project with id ' + projectId + ' could not be loaded.');
                console.error(error.toString());
            }
        });
    }
});

/**
 * server event listener
 */
events.addServerListener('keyUpdated', function () {
    // TODO more client changes are coming, we'll finish the code below then
    //if (projectId === projectConfig.projectId) {
    //    existingKeys[keyName] = undefined; // save the key // what's happening here?
    //    var data = {};
    //    data[keyName] = keyValue;
    //    translationView.printBundleTemplate([data], language, availableLanguages, projectConfig.project);
    //}
});

/**
 * server event listener
 * all users will be notified of changes
 */
events.addServerListener('onKeyCloned', function () {
    console.log('events.listener::onKeyCloned' + [].slice.call(arguments));
});

/**
 * server event listener
 */
events.addServerListener('keyDeleted', function (bundleName, obj) {
    // TODO more client changes are coming, we'll finish the code below then
    //if (bundleName === projectConfig.project) {
    //    console.log('translationViewController:keyRenamed', bundleName, obj);
    //    toast.showMessage('Key deleted!' + obj.key);
    //    translationView.markKeyAsRemoved(obj.key);
    //}
});

events.addServerListener('categoryDeleted', function (bundleName, obj) {
    console.log('events.listener::categoryDeleted' + [].slice.call(arguments));
});

events.addServerListener('categoryRenamed', function (bundleName, obj) {
    console.log('events.listener::categoryRenamed' + [].slice.call(arguments));
});

/**
 * server event listener
 */
events.addServerListener('imageRemoved', function (bundleName, categoryName) {
    if (bundleName === projectInfo.id) {
        toast.showMessage('Image removed for category: ' + categoryName);
        translationView.removeImage(categoryName);
    }
});

/**
 * Get word count for given category and language
 * @param category
 * @param lang
 * @returns Number
 */
function countWordsInCategory(category, lang) {
    var wordCount = 0;
    Object.keys(projectConfig.keys[lang]).forEach(function (key) {
        if (key.split('_')[0] === category) {
            wordCount += wordCounter.countWordsInString(projectConfig.keys[lang][key]);
        }
    });
    return wordCount;
}

/**
 * Update overall word-count view for category language
 * @param catId
 * @param lang
 */
function updateCategoryWordCount(catId, lang) {
    translationView.updateCategoryWordCount({
        id: catId,
        language: lang,
        words: countWordsInCategory(catId, lang)
    });
}

/**
 * Filter category names by iterating through project keys
 * @param keys
 * @returns Array
 */
function getCategoriesByKeys(keys) {
    var currentCatName,
        defaultKeys,
        categories = [];
    for (var lang in keys) {
        if (keys.hasOwnProperty(lang)) {
            defaultKeys = keys[lang];
            for (var key in defaultKeys) {
                if (defaultKeys.hasOwnProperty(key)) {
                    currentCatName = key.split('_')[0];
                    if (categories.indexOf(currentCatName) === -1) {
                        categories.push(currentCatName);
                    }
                }
            }
        }
    }
    return categories;
}

/**
 * Removes category related keys from "session" data - stored in projectConfig.keys
 * (member var declared on top of this file)
 * Invoked by category was removed
 * @param category
 */
function removeCategoryData(category) {
    Object.keys(projectConfig.keys).forEach(function (lang) {
        var langData = projectConfig.keys[lang];
        Object.keys(langData).forEach(function (key) {
            if (key.split('_')[0] === category) {
                delete langData[key];
            }
        });
    });
}

function handleNewProjectConfig(newProjectConfig, project) {
    // project specific config
    console.log('translationViewController get new config', newProjectConfig);
    // n.b. nothing is saved here - "saving" only happens as in "store in our data structure"
    saveProjectConfig(newProjectConfig, project);
    // before there was a check do not clear the view if the actual project is the same.
    // The problem is if you remove a key in the editor view than the translation view can't
    // detect this.
    translationView.clearView();
    canny.flowControl.show('resourceBundle');
}

function renderProject(projectData, project, cb) {
    var categories = getCategoriesByKeys(projectData.keys);

    handleNewProjectConfig(projectData, project);

    Object.keys(projectData.keys).forEach(function (lang) {
        var sorted,
            datas = [];
        Object.keys(projectData.keys[lang]).forEach(function (key) {
            datas.push({
                key: key,
                value: projectData.keys[lang][key]
            });
        });
        sorted = datas.sort(sortByKey);

        sorted.forEach(function (data) {
            existingKeys[data.key] = undefined;
        });

        // TODO projectConfig.project will be removed if the trade call moved to this controller
        translationView.printBundleTemplate(sorted, lang, availableLanguages, cb || function () {});

        categories.forEach(function (category) {
            updateCategoryWordCount(category, lang);
        });
    });
}

module.exports = {
    renameCategory: function renameCategory(oldName, newName) {
        toast.showMessage('Renamed category ' + oldName + ' to ' + newName + '!');
        translationView.renameCategory(oldName, newName, availableLanguages);
    },
    removeCategory: function removeCategory(catName) {
        toast.showMessage('Removed category ' + catName + '!');
        removeCategoryData(catName);
        translationView.removeCategory(catName);
    },
    /**
     * is called if the user rename key request was successful
     * @param newKey
     * @param oldKey
     */
    renameKey: function renameKey(oldKey, newKey) {
        if (oldKey) {
            toast.showMessage('Key renamed successful! From ' + oldKey + ' to ' + newKey);
            translationView.renameKey(oldKey, newKey, availableLanguages);
        } else {
            toast.showMessage('Key renamed failed!');
        }
    },
    removeKey: function removeKey(key) {
        toast.showMessage('Key removed successful!', key);
        translationView.removeKey(key);
    },
    imageRemoved: function imageRemoved(categoryName) {
        toast.showMessage('Image removed for category: ' + categoryName);
        translationView.removeImage(categoryName);
    },
    /**
     * Will be called with the complete JSON object from a specific project
     * @param projectData
     */
    onLoadProject: function onLoadProject(projectData, project) {
        orderedLanguages = projectData.availableLanguages;
        var anchor = url.hasAnchor() ? url.getAnchor().replace('#', '') : false;
        renderProject(projectData, project, function (viewId) {
            if (anchor) {
                if (viewId === anchor) {
                    var dom = document.getElementById(translationView.config.rowPrefix + viewId);
                    // do the element exists?
                    if (dom) {
                        uiEvents.callUievent('anchorFocus', url.getAnchor());
                        setTimeout(function () {
                            var bodyRect = document.body.getBoundingClientRect(),
                                elemRect = dom.getBoundingClientRect(),
                                offset = elemRect.top - bodyRect.top;
                            window.scrollTo(0, offset);
                        }, 1000);
                    }
                }
            }
        });
        // add the descriptions
        canny.translationViewDescription.addDescriptions(projectData.keyDescriptions);
        Object.keys(projectData.images).forEach(function (key) {
            // images without a slash at front are old image upload - this is only to be backward compatible
            var url = projectData.images[key][0] === '/' ? projectData.images[key] : '/' + project.id + '/' + projectData.images[key];
            canny.translationViewImageUpload.appendImage(key, url);
        });
    },
    onNewProjectCreated: function onNewProjectCreated(projectData, project) {
        orderedLanguages = projectData.availableLanguages;
        renderProject(projectData, project);
    }
};

},{"../events.js":19,"../trade.js":23,"../uiEventManager.js":24,"../uiModules/translationView":53,"../uiModules/translationViewImageUpload":55,"../util/url":58,"../util/wordCounter":59,"canny":71,"dom-opts":85}],17:[function(require,module,exports){
'use strict';

/**
 * controller for the image uplaoder view - calls the server to upload a image and notifier the ui event handler
 * @type {{}}
 */
var canny = require('canny'),
    upload = canny.upload,
    displayManager = canny.displayManager,
    uiEvents = require('../uiEventManager.js'),
    uploadId,
    projectInfo;
/**
 * Call this for each file - will call a call back with the server answer
 * @param file
 */
function sendFile(file, directCallback) {
    var uri = '/uploadFile?projectId=' + projectInfo.id + '&key=' + uploadId + '&project=' + projectInfo.name,
        xhr = new XMLHttpRequest(),
        fd = new FormData();

    xhr.open("POST", uri, true);
    xhr.onreadystatechange = function () {
        var data;
        if (xhr.readyState == 4 && xhr.status == 200) {
            // Handle response.
            data = JSON.parse(xhr.responseText);
            directCallback && directCallback(data); // handle response.
            // {file: "//sub/sub1/sub1_blue_coke.jpg", name: "sub1_blue_coke.jpg", type: "image/jpg"}
            console.log(data);
            uiEvents.callUievent('fileUploaded', projectInfo.id, uploadId, data.file);
        }
    };
    fd.append('myFile', file);
    // Initiate a multipart/form-data upload
    xhr.send(fd);
}

/**
 * Save data in member variable used by further upload operations
 * @param data: Project data
 */
function applyProjectData(data, project) {
    projectInfo = project;
}

uiEvents.addUiEventListener({
    showFileUpload: function showFileUpload(id) {
        uploadId = id;
        displayManager.show('uploadView');
    }
});

upload.onUpload(function (file) {
    // TODO additional to the upload id we need the project ID
    console.log('uploadController:upload id: file:', uploadId, file);
    sendFile(file);
});

module.exports = {
    onNewProjectCreated: applyProjectData,
    onLoadProject: applyProjectData
};

},{"../uiEventManager.js":24,"canny":71}],18:[function(require,module,exports){
'use strict';

var trade = require('../trade'),
    uiEvents = require('../uiEventManager'),
    url = require('../util/url');
/**
 * TODO handle the browser back and next button and load the correct view
 */
function processAjaxData(response, urlPath) {
    document.title = response.pageTitle;
    window.history.pushState({
        "html": response.html,
        "pageTitle": response.pageTitle,
        id: response.id,
        isProject: response.isProject
    }, "", urlPath + url.getAnchor());
}

/**
 * Manipulate browser history / location with given project data
 * @param data: Project related data
 */
function applyProjectData(data, project) {
    // add the project path to the URL
    if (project.name) {
        processAjaxData({
            pageTitle: project.id,
            html: '',
            id: project.id,
            isProject: true
            // to persists the links we save the id in URL - it's not human readable but links will work forever
        }, '/' + project.id + '.prj');
    }
}

uiEvents.addUiEventListener({
    anchorFocus: function anchorFocus(id) {
        // set the anchor to the URL
        window.history.pushState(null, null, id);
    }
});

window.onpopstate = function (e) {
    //    console.log('onpopstate', e.state.id);
    if (e.state) {
        if (e.state.isProject) {
            trade.loadProject(e.state.id, function (err) {
                if (err === false) console.error('urlManipulator:loadProject fails for projectId:', e.state.id);
            });
        } else {
            trade.getDirectory(e.state.id, function (err) {
                if (err !== false) {
                    // TODO call the
                    uiEvents.callUievent('showOverviewPage');
                } else {
                    console.log('urlManipulator:getDirectory can not load project for directory name:', e.state.id);
                }
            });
        }
    }
};

/**
 * TODO there is a problem with activating the project view or the overview page...
 *
 * just the implementation of the callbacks
 *
 */
module.exports = {
    onLoadProject: applyProjectData,
    onNewProjectCreated: applyProjectData,
    getDirectory: function getDirectory(data) {
        processAjaxData({
            pageTitle: 'translatron overview',
            html: '',
            id: data.currentDirectory,
            isProject: false
        }, data.currentDirectory);
    }
};

},{"../trade":23,"../uiEventManager":24,"../util/url":58}],19:[function(require,module,exports){
'use strict';

/**
 * Created by eightyfour.
 *
 * All server events. Multiple clients can register on each event
 * and will be notified if method is called from server.
 *
 * TODO RENAME FILE
 * TODO to what? :)
 * What about "externalChangeNotifications"?
 *
 * TBD why don't we integrate this one with ui events? that would cut down on the number of components we have and we "only" (?)
 * have to do some sensible renaming of events, like renaming all events handled here by adding "external" or similar
 * (e.g. "keyUpdated" becomes "keyUpdatedExternally").
 */
var events = function () {
    "use strict";

    var eventQueue = {},
        callQueue = function callQueue(name, args) {
        console.log('got notification for ', name, 'with payload', args);
        if (eventQueue.hasOwnProperty(name)) {
            eventQueue[name].map(function (fc) {
                fc.apply(null, args);
            });
        }
    };
    return {
        serverEvents: {
            // TBD can be removed?
            sendFile: function sendFile() {
                callQueue('sendFile', [].slice.call(arguments));
            },
            // TBD can be removed?
            sendPathList: function sendPathList() {
                callQueue('sendPathList', [].slice.call(arguments));
            },
            keyUpdated: function keyUpdated(projectId, language, keyName, keyValue) {
                callQueue('keyUpdated', [projectId, language, keyName, keyValue]);
            },
            onKeyCloned: function onKeyCloned(projectId, data) {
                callQueue('onKeyCloned', [projectId, data]);
            },
            keyRenamed: function keyRenamed(projectId, oldKeyName, newKeyName) {
                callQueue('keyRenamed', [projectId, oldKeyName, newKeyName]);
            },
            /**
             * @param bundleObj {locale: string, bundle: string}
             * @param data {oldKey:string, newKey: string}
             */
            keyDeleted: function keyDeleted(projectId, keyName) {
                callQueue('keyDeleted', [projectId, keyName]);
            },
            imageRemoved: function imageRemoved(projectId, categoryName) {
                callQueue('imageRemoved', [projectId, categoryName]);
            },
            newProjectWasCreated: function newProjectWasCreated(projectId) {
                callQueue('newProjectWasCreated', [projectId]);
            },
            categoryRenamed: function categoryRenamed(projectId, oldName, newName) {
                callQueue('categoryRenamed', [projectId, oldName, newName]);
            },
            categoryDeleted: function categoryDeleted(projectId, catName) {
                callQueue('categoryDeleted', [projectId, catName]);
            },
            newDirectoryCreated: function newDirectoryCreated(directoryId) {
                callQueue('newDirectoryCreated', [directoryId]);
            },
            projectDescriptionUpdated: function projectDescriptionUpdated(projectId, id, description) {
                callQueue('projectDescriptionUpdated', [projectId, id, description]);
            }
        },
        addServerListener: function addServerListener(name, cb) {
            if (eventQueue.hasOwnProperty(name)) {
                eventQueue[name].push(cb);
            } else {
                eventQueue[name] = [cb];
            }
        }
    };
}();

module.exports = events;

},{}],20:[function(require,module,exports){
'use strict';

var C = require('./CONST');
var connectionLost = require('./uiModules/connectionLost');

/**
 * Refresh the user session and detects if the user is not authenticated anymore
 * useful for:
 *  * session keep alive
 *  * detect if the user is not authenticated anymore
 *  * detects server shut down
 */
module.exports = function handleSessionTimeOut() {
    var connectionLostUi = connectionLost({
        onReload: function onReload() {
            return location.reload();
        },
        onClose: function onClose() {
            return connectionLostUi.destroy();
        }
    });
    var interval = setInterval(function () {
        fetch(location.protocol + '//' + location.host + '/touchSession', {
            credentials: "same-origin"
        }).then(function (d) {
            if (d.status === 401) {
                clearInterval(interval);
                // whoops server has no authentication anymore...
                connectionLostUi.render('AUTH');
            }
        }).catch(function (e) {
            clearInterval(interval);
            connectionLostUi.render('SERVER_DOWN', 'Maybe a server restart happens. Please try to login again in few minutes');
        });
    }, C.SESSION.renewal_interval_in_ms);
};

},{"./CONST":2,"./uiModules/connectionLost":31}],21:[function(require,module,exports){
'use strict';

/*global domOpts */
/*jslint browser: true */
var unicode = require('./unicode.js');
var toast = require('./Toast.js');
var canny = require('canny');
var trade = require('./trade.js');
var handleSessionTimeOut = require('./handleSessionTimeOut');
var breadCrumbController = require('./controller/breadcrumbController.js');

var _require = require('jasmine'),
    ConsoleReporter = _require.ConsoleReporter;

window.domOpts = window.domOpts || require('dom-opts');
// made it public - just for development
window.canny = canny;

canny.add('repeat', require('canny/mod/repeat'));
canny.add('whisker', require('canny/mod/whisker'));
canny.add('async', require('canny/mod/async'));
canny.add('flowControl', require('canny/mod/flowControl')('flowControl'));
canny.add('displayManager', require('./uiModules/displayManager.js'));
canny.add('textEditor', require('./textEditor.js'));
canny.add('cookieManager', require('canny-cookieManager-lib'));

canny.add('texts', require('./uiModules/texts.js'));
canny.add('auth', require('./uiModules/auth.js'));
canny.add('projectMainNavigation', require('./uiModules/projectMainNavigation.js'));
canny.add('translationView', require('./uiModules/translationView.js'));
canny.add('translationViewImageUpload', require('./uiModules/translationViewImageUpload.js'));
//canny.add('translationViewHeader',  require('./uiModules/translationViewHeader.js'));
canny.add('imageViewer', require('./uiModules/imageViewer.js'));
canny.add('projectOverview', require('./uiModules/projectOverview.js'));
canny.add('createNewProject', require('./uiModules/createNewProject.js'));
canny.add('menuRight', require('./uiModules/menuRight.js'));
canny.add('anchorMenu', require('./uiModules/anchorMenu.js'));
// TODO: Put behind flag search
canny.add('searchBar', require('./uiModules/searchBar/index.js'));

canny.add('translationViewDescription', require('./uiModules/translationViewDescription.js'));
canny.add('upload', require('./uiModules/upload.js'));
canny.add('JMBFUploader', require('./uiModules/JMBFUploader.js'));
canny.add('JsonImport', require('./uiModules/JsonImport.js'));
canny.add('loadingModal', require('./uiModules/loadingModal'));

trade.addController(require('./controller/projectMainNavigationController.js'));
trade.addController(require('./controller/pageHeaderController.js'));
trade.addController(require('./controller/translationViewController.js'));
trade.addController(require('./controller/textEditorController.js'));
trade.addController(require('./controller/urlManipulator.js'));
trade.addController(require('./controller/projectOverviewController.js'));
trade.addController(require('./controller/createNewProjectController.js'));
trade.addController(breadCrumbController);
trade.addController(require('./controller/authController.js'));
trade.addController(require('./controller/menuRightController.js'));
trade.addController(require('./controller/uploadController.js'));
trade.addController(require('./controller/JMBFUploaderController.js'));
trade.addController(require('./controller/JsonImportController.js'));
// TODO: Put behind flag search
trade.addController(require('./controller/searchController.js'));

canny.ready(function () {
    "use strict";
    // create websocket connection via trade

    trade.initialize(function (userObject, sessionsEnabled) {

        if (userObject === null) {
            alert('A fatal error happens while loading the view');
            location.reload();
            return;
        }
        canny.texts.setTexts({ userName: userObject.name });

        if (userObject.isAdmin) {
            document.body.classList.add('isAdmin');
        }

        if (sessionsEnabled) {
            // trigger a "session keep alive" and detects if the user is not authenticated anymore or the server is down
            handleSessionTimeOut();
        }
    });
});

window.canny = canny;
window.domOpts = require('dom-opts');
window.unicode = unicode;
window.toast = toast;

// QUESTION: can it happen that the above call to trade.initialize (in canny.ready) finishes earlier than the next lines?
// i.e. the callback for trade.ready will never be executed? if yes: why not pass the callback already to trade.initialize?
trade.ready(function () {
    'use strict';

    var prj = function getProjectNameAndPathFromURL() {
        var split = location.pathname.split('/');
        var path = location.pathname;
        var prjName = void 0;

        if (/\.prj/.test(split[split.length - 1])) {
            // remove .prj extension and first slash
            prjName = path.replace('.prj', '').replace('/', '');
            path = split.slice(0, -1).join('/');
        }

        if (path[0] !== '/') {
            path = '/' + path;
        }

        return {
            path: path,
            projectId: prjName
        };
    }();

    // QUESTION: since this is working on the URL the application was loaded with and this URL can be either a directory URL
    // or a project URL: why can't we decide first what we actually have in the URL and then either call getDirectory
    // or loadProject? ANSWER: depends. if the URL points to a directory, we only have to do the getDirectory call.
    // if the URL is a project, two calls have to be made: one loadProject call and one extra getDirectory call for the
    // parent of the project (mainly for navigation component which needs to know the siblings of the project). But: take
    // care that this extra getDirectory must *not* change the state of the breadcrumb trail (that one should still show
    // the selected project)


    if (prj.projectId) {
        // this is the initial call to trigger a project load - you will get
        // the project.json and all translations
        trade.loadProject(prj.projectId, function (err, data, project) {
            // callback is only called if an error occurs
            if (err !== null) {
                toast.showMessage('Loading project \'' + prj.projectId + '\' failed - project doesn\'t exists');
                console.error('translationViewController:loadProject fails for projectId:', prj.projectId);
            } else {
                // required for the breadcrumb
                breadCrumbController.setPath(project.url);
            }
        });
    } else {
        trade.getDirectory(prj.path, function (obj) {});
    }
});

},{"./Toast.js":3,"./controller/JMBFUploaderController.js":4,"./controller/JsonImportController.js":5,"./controller/authController.js":6,"./controller/breadcrumbController.js":7,"./controller/createNewProjectController.js":8,"./controller/menuRightController.js":9,"./controller/pageHeaderController.js":11,"./controller/projectMainNavigationController.js":12,"./controller/projectOverviewController.js":13,"./controller/searchController.js":14,"./controller/textEditorController.js":15,"./controller/translationViewController.js":16,"./controller/uploadController.js":17,"./controller/urlManipulator.js":18,"./handleSessionTimeOut":20,"./textEditor.js":22,"./trade.js":23,"./uiModules/JMBFUploader.js":25,"./uiModules/JsonImport.js":26,"./uiModules/anchorMenu.js":27,"./uiModules/auth.js":28,"./uiModules/createNewProject.js":32,"./uiModules/displayManager.js":33,"./uiModules/imageViewer.js":35,"./uiModules/loadingModal":37,"./uiModules/menuRight.js":38,"./uiModules/projectMainNavigation.js":40,"./uiModules/projectOverview.js":41,"./uiModules/searchBar/index.js":42,"./uiModules/texts.js":52,"./uiModules/translationView.js":53,"./uiModules/translationViewDescription.js":54,"./uiModules/translationViewImageUpload.js":55,"./uiModules/upload.js":56,"./unicode.js":57,"canny":71,"canny-cookieManager-lib":70,"canny/mod/async":72,"canny/mod/flowControl":73,"canny/mod/repeat":74,"canny/mod/whisker":75,"dom-opts":85,"jasmine":100}],22:[function(require,module,exports){
'use strict';

/**
 * textEditor
 */
(function () {
    "use strict";

    var textEditor = function () {

        var texts = {
            originText: 'Double click to edit this text',
            editBtn: 'Edit',
            cancelBtn: 'Cancel',
            changeBtn: 'Save changes'
        },
            onChangeAllList = [];

        function findClosestAncestorWithId(element) {
            while ((element = element.parentElement) && !element.id) {}
            return element;
        }

        function callChangeList(id, value, fc) {
            onChangeAllList.forEach(function (cb) {
                return cb(id, value, fc);
            });
        }

        function editWithTextarea(node, buttonWrap, obj) {
            var open = false,
                divWrapper = document.createElement('div'),
                button = document.createElement('div'),
                cancelButton = document.createElement('div'),
                area = document.createElement('textarea'),
                jsTextN;

            if (obj && obj.hasOwnProperty('placeholder')) {
                area.setAttribute('placeholder', obj.placeholder);
            }

            function close() {
                node.classList.add('textEditor-hide');
                open = false;
            }

            function edit() {
                if (!open) {
                    jsTextN = node.querySelector('.js-text');
                    open = true;
                    area.value = jsTextN.innerHTML;
                    setTimeout(function () {
                        node.classList.remove('textEditor-hide');
                    }, 100);
                }
            }

            // set classes
            cancelButton.className = 'textEditor-button textEditor-button-cancel octicon octicon-x';
            button.className = 'textEditor-button textEditor-button-change octicon octicon-check';
            area.className = 'textEditor-area';
            divWrapper.className = 'textEditor-wrap-area';
            node.classList.add('textEditor-hide');

            // register listeners
            cancelButton.addEventListener('click', close);
            button.addEventListener('click', function () {
                var val = area.value,
                    id = findClosestAncestorWithId(this).id,
                    ret = callChangeList(id, val, function (success) {
                    if (success) {
                        jsTextN.innerHTML = val;
                        close();
                    } else {
                        console.warn('textEditor:toTextareaNode text not accepted! Ignore changes.');
                    }
                });
            });
            node.addEventListener('dblclick', edit);

            // set titles
            node.setAttribute('title', texts.originText);
            cancelButton.setAttribute('title', texts.cancelBtn);
            button.setAttribute('title', texts.changeBtn);

            // append to wrapper div
            divWrapper.appendChild(area);
            buttonWrap.appendChild(cancelButton);
            buttonWrap.appendChild(button);

            // append to parent
            node.appendChild(divWrapper);

            // return click function
            return function () {
                if (!open) {
                    // show input
                    edit();
                } else {
                    // show text
                    close();
                }
            };
        }

        return {
            /**
             * Register a function to a specific editor.
             * If the function returns undefined than the editor expect that the passed callback
             * is called with true or false. If the method returns true the text will change.
             * If the method returns false the text is not changed.
             *
             * @param id
             * @param fc <- is called with (textValue, callbackFunction) can return undefined, false and true
             */
            onChange: function onChange(fc) {
                onChangeAllList.push(fc);
            },
            /**
             *
             * @param node
             * @param id
             */
            add: function add(node, obj) {
                var buttonWrap = document.createElement('div'),
                    editIconButton = document.createElement('div');
                buttonWrap.className = 'textEditor-buttonWrap';
                editIconButton.className = 'textEditor-button textEditor-button-edit octicon octicon-pencil';
                editIconButton.addEventListener('click', editWithTextarea(node, buttonWrap, obj));
                editIconButton.setAttribute('title', texts.editBtn);
                // append editIconButton to parent
                node.classList.add('textEditor-main-wrap');
                buttonWrap.appendChild(editIconButton);
                node.appendChild(buttonWrap);
            }
        };
    }();

    // export as module or bind to global
    if (typeof module !== 'undefined' && module.hasOwnProperty('exports')) {
        module.exports = textEditor;
    } else {
        canny.add('textEditor', textEditor);
    }
})();

},{}],23:[function(require,module,exports){
'use strict';

/*jslint browser: true */
/**
 * handle the connection between server and client
 */
var canny = require('canny');
var events = require('./events.js');
var shoe = require('shoe');
var dnode = require('dnode-weak-napi');
var connectionLost = require('./uiModules/connectionLost/index.js');

window.domOpts = window.domOpts || require('dom-opts');

/**
 * Some of the callbacks are handled via the registered controller - addController method.
 */
var trade = function () {
    "use strict";
    // ready queue call registered call backs when trade is ready

    var cbs = [],
        server,
        registeredController = [],

    // this flag should be true if there is a stable server connection
    hasServerConnection = false,
        tryToReconnect = false,
        connectionLostUi = connectionLost({
        onReload: function onReload() {
            return location.reload();
        },
        onReconnect: function onReconnect() {
            tryToReconnect = true;
            connectionLostUi.showProgress();
            stream = shoe('/trade');
            createConnection(function (userObject, sessionsEnabled) {
                if (userObject === null) {
                    // this is the case when the session ends on server side
                    connectionLostUi.render('RECONNECT_FAIL');
                } else {
                    connectionLostUi.destroy();
                    tryToReconnect = false;
                }
            });
        },
        onClose: function onClose() {
            connectionLostUi.destroy();
        }
    });
    var stream = shoe('/trade');
    var d = void 0;

    function init(s, fc) {
        server = s;

        if (server.searchTerm !== undefined) {
            canny.searchBar.show();
        }

        if (server.setUserRights) {
            server.setUserRights(canny.cookieManager.forSessionCookie('translatron_session').getValues(), fc);
        } else {
            fc({ name: 'Logout', isAdmin: true }, false);
        }

        server.attachClientCallbacks(events.serverEvents);
        // call ready queue
        cbs.map(function (cb) {
            cb && cb();
            return null;
        });
    }

    function createConnection(fc) {
        d = dnode();
        d.on('remote', function (server) {
            hasServerConnection = true;
            init(server, fc);
        });
        d.on('fail', function (err) {
            console.log(err);
            hasServerConnection = false;
            connectionLostUi.render('CONNECTION_FAIL');
        });
        d.on('error', function (err) {
            console.log(err);
            // something happens
            // e.g. a UI update throws an exception
            hasServerConnection = false;
            connectionLostUi.render('EXCEPTION', err.name);
        });
        d.on('end', function (err) {
            // this is called if the connection is closes from server
            hasServerConnection = false;
            console.error('trade:end', err);
            // the setTimeout is for avoid flickering if page reload via e.g. F5
            if (tryToReconnect) connectionLostUi.render('RECONNECT_FAIL');else setTimeout(function () {
                return connectionLostUi.render('CONNECTION_END');
            }, 1000);
        });
        d.pipe(stream).pipe(d);
    }
    /**
     * Check if connection is available - otherwise send view error
     * @returns {boolean}
     */
    function isConnected() {
        if (hasServerConnection) return true;
        connectionLostUi.render('RECONNECT');
        return false;
    }

    /**
     *
     * @param functionName the function to call
     * @param args an array of parameters which are passed to the function
     */
    function callController(functionName, args) {
        registeredController.forEach(function (controller) {
            if (controller.hasOwnProperty(functionName)) {
                try {
                    console.log('controller:', functionName);
                    controller[functionName].apply(null, args);
                } catch (e) {
                    connectionLostUi.render('FATAL', e.message);
                    console.error(e);
                }
            }
        });
    }

    return {
        initialize: function initialize(fc) {
            createConnection(fc);
        },
        addController: function addController(obj) {
            registeredController.push(obj);
        },
        /**
         * Load the whole project files with all required data (project specific json)
         * @param {string} projectId
         * @param {function} cb
         */
        loadProject: function loadProject(projectId, cb) {
            server.loadProject(projectId, function (data, _ref) {
                var id = _ref.id,
                    name = _ref.name,
                    url = _ref.url;

                if (data) {
                    // overwrite project id
                    data.projectId = id;
                    data.project = name;
                    callController('onLoadProject', [data, { id: id, name: name, url: url }]);
                    cb && cb(null, data, { id: id, name: name, url: url });
                } else {
                    // callback a error so the caller has the control about error handling
                    // TODO refactor code and make use of error object instead of false - and pass empty object to other args instead of nothing
                    cb && cb(false);
                }
            });
        },
        /**
         * actually same as saveKey but the internal controller call is different
         * @param projectId
         * @param language
         * @param keyAndValue
         * @param cb
         */
        createKey: function createKey(projectId, language, keyAndValue, cb) {
            if (isConnected()) server.saveKey(projectId, language, keyAndValue, function (err, key, value) {
                // TODO handle error case
                if (!err) {
                    cb(projectId, language, key, value);
                    callController('onCreateKey', [projectId, language, key, value]);
                }
            });
        },
        /**
         *
         * @param projectId
         * @param {{id :string, sourceCategory:string, targetCategory:string}} keyAndValue
         * @param cb
         */
        cloneKey: function cloneKey(projectId, keyAndValue, cb) {
            if (isConnected()) server.cloneKey(projectId, keyAndValue, function (err, projectId, data) {
                cb(err, projectId, data);
                callController('onKeyCloned', [projectId, data]);
            });
        },
        /**
         * Save changes to a key's value. Change will be broadcast to other clients.
         * @param {string} projectId
         * @param {string} language
         * @param {{key:string, value:string}} keyAndValue
         * @param {function} cb - callback to execute after saving
         */
        saveKey: function saveKey(projectId, language, keyAndValue, cb) {
            if (isConnected()) server.saveKey(projectId, language, keyAndValue, function (err, key, value) {
                // TODO handle error case
                if (!err) {
                    cb(projectId, language, key, value);
                }
            });
        },
        /**
         *
         * @param {string} projectName
         * @param currentDirId if of the directory in which the new project will be created
         */
        createNewProject: function createNewProject(projectName, currentDirId) {
            if (isConnected()) server.createNewProject(currentDirId, projectName, {}, function (err, projectData, project) {
                // TODO handle error case
                if (!err) {
                    callController('onNewProjectCreated', [projectData, project]);
                }
            });
        },
        /**
         *
         * @param {string} directoryName
         * @param {string} currentDirectory
         */
        createNewDirectory: function createNewDirectory(directoryName, currentDirectory) {
            if (isConnected()) server.createNewDirectory(directoryName, currentDirectory, function (err, directoryData) {
                // TODO handle error case
                if (!err) {
                    callController('onNewDirectoryCreated', [directoryData]);
                }
            });
        },
        /**
         * Renames a category.
         * @param {string} projectId
         * @param {string} oldName
         * @param {string} newName
         */
        renameCategory: function renameCategory(projectId, oldName, newName) {
            if (isConnected()) server.renameCategory(projectId, oldName, newName, function (err, oldName, newName) {
                if (!err) {
                    callController('renameCategory', [oldName, newName]);
                }
            });
        },
        /**
         * Removes a category with all it's child keys.
         * @param {string} projectId
         * @param {string} catName
         */
        removeCategory: function removeCategory(projectId, catName) {
            if (isConnected()) server.removeCategory(projectId, catName, function (err, catName) {
                if (!err) {
                    callController('removeCategory', [catName]);
                }
            });
        },
        /**
         * Renames a key for all languages
         * @param {string} projectId
         * @param {{newKey: string, oldKey: string}} obj
         */
        renameKey: function renameKey(projectId, obj) {
            if (isConnected()) server.renameKey(projectId, {
                newKey: obj.newKey,
                oldKey: obj.oldKey
            }, function (err, oldKey, newKey) {
                if (!err) {
                    callController('renameKey', [oldKey, newKey]);
                } else {
                    callController('renameKey', [false]);
                }
            });
        },
        /**
         * Removes a key for all languages.
         * @param {string} projectId
         * @param {string} keyName
         * @param {function} cb
         */
        removeKey: function removeKey(projectId, keyName, cb) {
            if (isConnected()) server.removeKey(projectId, keyName, function (err, keyName) {
                if (!err) {
                    cb(keyName);
                    callController('removeKey', [keyName]);
                }
            });
        },
        /**
         *
         * @param {string} projectId
         * @param {string} categoryName
         */
        removeImage: function removeImage(projectId, categoryName) {
            if (isConnected()) server.removeImage(projectId, categoryName, function (err, categoryName) {
                if (!err) {
                    callController('imageRemoved', [categoryName]);
                } else {
                    toast.showMessage(err.message);
                }
            });
        },
        /**
         *
         * Get the contents of the directory.
         *
         * @param dir the selected directory.
         * @param cb {projects:[String]:dirs:[String]}
         */
        getDirectory: function getDirectory(dir, cb) {
            if (isConnected()) server.getDirectory(dir, function (err, args) {
                if (err !== null) {
                    toast.showMessage('Internal server error! Please report this message to a developer: ' + err.message);
                    console.error(err.message);
                    return;
                }
                // only call the controller if not false
                cb && cb(args);
                if (args !== false) {
                    callController('getDirectory', [args]);
                }
            });
        },
        /**
         * save the project description
         * @param projectId
         * @param id
         * @param description
         * @param callback
         */
        saveProjectDescription: function saveProjectDescription(projectId, id, description, callback) {
            if (isConnected()) server.saveProjectDescription(projectId, id, description, function (err) {
                if (!err) {
                    callback && callback(true);
                    callController('savedProjectDescription', []);
                } else {
                    callback && callback(false);
                }
            });
        },
        /**
         * Move a project. Can be used for:
         *  * move project
         *  * rename project
         *
         * @param {string} id
         * @param {string} url - the new URL (optional)
         * @param {string} name - the new name (optional)
         * @param {function} cb - callback will be called
         */
        moveProject: function moveProject(_ref2, cb) {
            var id = _ref2.id,
                url = _ref2.url,
                name = _ref2.name;

            if (isConnected()) {
                server.moveProject({ id: id, url: url, name: name }, function (err, project) {
                    cb(err, project || {});
                });
            }
        },
        /**
         * TODO summarize projectName + currentDirId to one projectId
         * Delete a project.
         * @param projectName
         * @param currentDirId - @deprecated
         * @param callback
         */
        deleteProject: function deleteProject(id, cb) {
            if (isConnected()) {
                server.deleteProject(id, function (err, project) {
                    if (!err) {
                        // TODO change to: prjName
                        cb && cb(null, project);
                        callController('projectDeleted', [project]);
                    } else {
                        cb && cb(err);
                    }
                });
            }
        },
        /**
         * Delete a project.
         * @param dirName
         * @param currentDirId
         * @param callback
         */
        deleteFolder: function deleteFolder(id, callback) {
            if (isConnected()) server.deleteFolder(id, function (err, dirId) {
                if (!err) {
                    callback && callback(null, dirId);
                    callController('folderDeleted', [dirId]);
                } else {
                    callback && callback(err);
                }
            });
        },
        /**
         * Search projects for given term
         * @param searchTerm
         * @param callback
         */
        searchTerm: function searchTerm(_searchTerm, callback) {
            if (isConnected()) server.searchTerm(_searchTerm, function (err, results) {
                if (!err) {
                    callback && callback(results);
                } else {
                    connectionLostUi.render('SEARCH_ERROR');
                }
            });
        },
        // Not really tested
        ready: function ready(cb) {
            if (server) {
                cb();
            } else {
                cbs.push(cb);
            }
        }
    };
}();

module.exports = trade;

},{"./events.js":19,"./uiModules/connectionLost/index.js":31,"canny":71,"dnode-weak-napi":83,"dom-opts":85,"shoe":137}],24:[function(require,module,exports){
"use strict";

var uiEvent = function () {
    var eventQueues = {
        activateLanguage: [],
        deActivateLanguage: [],
        addLanguage: [],
        showExportDialog: [],
        projectSelected: [],
        showOverviewPage: [],
        updateKey: [],
        anchorFocus: [],
        enableEditorMode: [],
        toggleWordCount: [],
        showFileUpload: [],
        showJMBFUploader: [],
        showJSONImport: [],
        JMBFFileUploaded: [],
        jsonImported: [],
        fileUploaded: []
    };
    return {
        addUiEventListener: function addUiEventListener(obj) {
            Object.keys(obj).forEach(function (key) {
                if (eventQueues.hasOwnProperty(key)) {
                    eventQueues[key].push(obj[key]);
                }
            });
        },
        callUievent: function callUievent(eventName, args) {
            var argsList = [].slice.call(arguments, 1, arguments.length);
            if (eventQueues.hasOwnProperty(eventName)) {
                eventQueues[eventName].forEach(function (fc) {
                    fc.apply(null, argsList);
                });
            }
        }
    };
}();

module.exports = uiEvent;

},{}],25:[function(require,module,exports){
'use strict';

/**
 * shows the uploader form to upload a image to the server
 */
var _onUpload = function onUpload() {},
    brain = {
    fileInput: {
        init: function init(node) {
            node.addEventListener('change', upload);
        }
    }
};

function upload() {
    console.log('c-upload:trigger upload');
    var file = this.files[0];
    if (file) {
        // send it direct after drop
        [].slice.call(this.files).forEach(function (file) {
            // TODO instead pass  directly a array of files - so we save POST calls
            _onUpload(file);
        });
        // cleanup value otherwise file with same name can't uploaded again
        this.value = null;
        return false;
    }
}
/**
 *
 * @returns {{add: Function, ready: Function}}
 */
module.exports = {
    onUpload: function onUpload(fc) {
        _onUpload = fc;
    },
    add: function add(node, attr) {
        if (brain.hasOwnProperty(attr)) {
            brain[attr].init(node);
        }
    }
};

},{}],26:[function(require,module,exports){
'use strict';

/**
 * shows the uploader form to upload a image to the server
 */
var _onUpload = function onUpload() {},
    brain = {
    fileInput: {
        init: function init(node) {
            node.addEventListener('change', upload);
        }
    }
};

function upload() {
    var file = this.files[0];
    if (file) {
        // send it direct after drop
        [].slice.call(this.files).forEach(function (file) {
            // TODO instead pass  directly a array of files - so we save POST calls
            _onUpload(file);
        });
        // cleanup value otherwise file with same name can't uploaded again
        this.value = null;
        return false;
    }
}
/**
 *
 * @returns {{add: Function, ready: Function}}
 */
module.exports = {
    onUpload: function onUpload(fc) {
        _onUpload = fc;
    },
    add: function add(node, attr) {
        if (brain.hasOwnProperty(attr)) {
            brain[attr].init(node);
        }
    }
};

},{}],27:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * anchorMenu
 *
 * TODO show the actual frame:
 *  * detect which dome categories in dom are in view and add a classes to the menu ul category.
 *      * the expected effect will be look like a frame which categories are in view
 *      * first-child border-top last-child border bottom and the rest border left and right will give a frame effect
 *
 *  do it for all c-anchorMenu-parent element which could be found in view
 *
 * The anchor menu shows all elements which have the class c-anchorMenu-parent as parent and searches for children
 * with class c-anchorMenu-child. It renders a ul li list and registered a click call to throw a click event with the id.
 *
 * @type {exports}
 */
var util = require('../util/url'),
    translationViewConfig = require('./translationView').config,
    rootNode,
    parentNodeList = [],
    _onSelect = function onSelect() {},
    shrinkOffsetForViewDetection = 100,
    highlightTopMostKey = function () {

    var highlightedItem;

    /**
     * check if node is aligned top most in the browser view
     * @param obj
     */
    return function () {

        var firstOpenCategory = rootNode.querySelector('li.c-inView'),
            currentMainViewCategoryNode,
            currentMainViewCategoryChildNodes,
            mainViewTopMostKeyNode;

        if (!firstOpenCategory) {
            return;
        }

        // Reset previous highlighted item
        if (highlightedItem) {
            highlightedItem.classList.remove('c-key-highlight');
        }

        // Highlight topmost item
        currentMainViewCategoryNode = document.body.querySelector('#' + translationViewConfig.rowPrefix + firstOpenCategory.attributes.data.nodeValue.replace('anchor_', ''));
        if (currentMainViewCategoryNode) {
            currentMainViewCategoryChildNodes = currentMainViewCategoryNode.querySelectorAll('.c-anchorMenu-child');
            mainViewTopMostKeyNode = getFirstElementInViewport(currentMainViewCategoryChildNodes);
        } else {
            console.error('anchorMenu:Can\'t find the category node with id', translationViewConfig.rowPrefix + firstOpenCategory.attributes.data.nodeValue.replace('anchor_', ''));
        }

        if (mainViewTopMostKeyNode) {
            highlightedItem = rootNode.querySelector('[data=anchor_' + mainViewTopMostKeyNode.id.replace(translationViewConfig.rowPrefix, '') + ']');
            if (highlightedItem) {
                highlightedItem.classList.add('c-key-highlight');
            }
        }
    };
}();

function _focusElement(id, elem) {
    var dom;
    // handle the active class from menu
    [].slice.call(rootNode.querySelectorAll('.c-active')).forEach(function (n) {
        n.classList.remove('c-active');
    });
    elem.classList.add('c-active');
    elem.parentNode.parentNode.classList.add('c-active');
    // handle the common dom active class
    [].slice.call(document.querySelectorAll('.c-anchorMenu-focus')).forEach(function (n) {
        n.classList.remove('c-anchorMenu-focus');
    });
    dom = document.getElementById(translationViewConfig.rowPrefix + id);
    if (dom) {
        dom.classList.add('c-anchorMenu-focus');
    } else {
        console.log('anchorMenu:focusElement can\'t find element for a anchor', id);
    }
}
/**
 *
 * @param items [{id : string, children : [string]}]
 */
function addItems(root, items) {
    var ul = document.createElement('ul'),
        anchor = util.getAnchor();
    root.appendChild(ul);
    items.forEach(function (catObj) {
        var li = document.createElement('li'),
            span = document.createElement('span');
        // TODO check with log
        if ((typeof catObj === 'undefined' ? 'undefined' : _typeof(catObj)) !== 'object') {
            console.error('anchorMenu:category needs to be an object', catObj);
        }
        span.appendChild(document.createTextNode(catObj.id));
        li.appendChild(span);
        li.setAttribute('data', 'anchor_' + catObj.id);
        span.addEventListener('click', function () {
            _onSelect(catObj.id);
            _focusElement(catObj.id, li);
        });

        if (catObj.children) {
            addItems(li, catObj.children);
        }
        ul.appendChild(li);
        if ('#' + catObj.id === anchor) {
            _focusElement(catObj.id, li);
        }
    });
}

/**
 * check is the node is in the view
 * @param node
 */
function isNodeInView(node) {
    var yOffset = window.scrollY || window.pageYOffset,
        w = {
        top: yOffset,
        bottom: yOffset + window.innerHeight
    },
        bodyRect = document.body.getBoundingClientRect(),
        elemRect = node.getBoundingClientRect(),
        offset = elemRect.top - bodyRect.top + shrinkOffsetForViewDetection,
        nodeHeight = offset + node.offsetHeight - shrinkOffsetForViewDetection * 2;
    return offset > w.top && offset < w.bottom || // is top frame in view
    nodeHeight > w.top && nodeHeight < w.bottom || // is bottom frame in view
    offset < w.top && nodeHeight > w.bottom; // is top frame above view and bottom frame below view
}

function cutCategories(val) {
    var split = val.split('_');
    if (split.length > 1) {
        split.splice(0, 1);
    }
    return {
        id: val,
        value: split.join('_')
    };
}

function expandCategoriesInView() {
    parentNodeList.forEach(function (obj) {
        var li = rootNode.querySelector('[data=anchor_' + obj.id + ']');
        if (isNodeInView(obj.node)) {
            li.classList.add('c-inView');
        } else {
            li.classList.remove('c-inView');
        }
    });
}

function getFirstElementInViewport(nodes) {
    var keyNode,
        pageScrollOffset = document.body.scrollTop || document.documentElement && document.documentElement.scrollTop,
        i = nodes.length,
        nodeMargin;

    while (i--) {
        keyNode = nodes[i];
        nodeMargin = parseInt(window.getComputedStyle(keyNode, null).marginBottom, 10);
        if (getPageOffsetForElement(keyNode) - nodeMargin * 2 <= pageScrollOffset) {
            return keyNode;
        }
    }

    // Return first key node for current active category
    return nodes[0];
}

function getPageOffsetForElement(elem) {
    var bodyRect = document.body.getBoundingClientRect(),
        elemRect = elem.getBoundingClientRect();
    return elemRect.top - bodyRect.top;
}

module.exports = {
    focusElement: function focusElement(id) {
        var li = rootNode.querySelector('[data=anchor_' + id + ']');
        if (li) {
            _focusElement(id, li);
        }
    },
    onSelect: function onSelect(fc) {
        _onSelect = fc;
    },
    renderMenu: function renderMenu() {
        var catObj = [];
        // clear parent node list
        parentNodeList = [];

        [].slice.call(document.querySelectorAll('.c-anchorMenu-parent')).forEach(function (parent) {
            var id = parent.getAttribute('id'),
                children = [];
            if (id) {
                id = id.replace(translationViewConfig.rowPrefix, '');
                // collect parents
                parentNodeList.push({ node: parent, id: id });

                [].slice.call(parent.querySelectorAll('.c-anchorMenu-child')).forEach(function (child) {
                    var id = child.getAttribute('id');
                    if (id) {
                        children.push(cutCategories(id.replace(translationViewConfig.rowPrefix, '')));
                    }
                });
                catObj.push({ id: id, children: children });
            }
        });
        [].slice.call(rootNode.children).forEach(function (child) {
            child.parentNode.removeChild(child);
        });
        addItems(rootNode, catObj);
        rootNode.children[0].style.height = window.innerHeight - 125 + 'px';

        // time delayed trigger the init view
        setTimeout(function () {
            expandCategoriesInView();
            highlightTopMostKey();
        }, 1000);
    },
    add: function add(node, attr) {
        rootNode = node;
    },
    ready: function ready() {
        window.addEventListener('scroll', function (e) {
            expandCategoriesInView();
            highlightTopMostKey();
        });
        window.addEventListener('resize', function () {
            if (rootNode.children[0]) {
                rootNode.children[0].style.height = window.innerHeight - 125 + 'px';
            }
        });
        // init the menu with a time delay
        setTimeout(function () {
            expandCategoriesInView();
            highlightTopMostKey();
        }, 1500);
    }
};

},{"../util/url":58,"./translationView":53}],28:[function(require,module,exports){
'use strict';

var _onLogout = function onLogout() {
    console.log('auth:onLogout is not handled');
},
    brain = {
    logoutButton: function logoutButton(node) {
        node.addEventListener('click', _onLogout);
    }
};

module.exports = {
    onLogout: function onLogout(fc) {
        _onLogout = fc;
    },
    add: function add(node, attr) {
        if (brain.hasOwnProperty(attr)) {
            brain[attr](node);
        }
    }
};

},{}],29:[function(require,module,exports){
'use strict';

var repeatFcPointer,
    _onClick = function onClick(item) {
    console.warn('breadcrumb:click handler not registered', item);
};

module.exports = {
    onClick: function onClick(fc) {
        _onClick = fc;
    },
    add: function add(node, attr) {},
    /**
     *
     * @param parentDirectories [String]
     */
    updateFolders: function updateFolders(parentDirectories) {
        repeatFcPointer(parentDirectories.map(function (item) {
            return { name: item.name, onClick: function onClick() {
                    _onClick(item.id);
                } };
        }));
    },
    /**
     * for canny repeat to get
     */
    registerCannyRepeat: function registerCannyRepeat(fc) {
        repeatFcPointer = fc;
    }
};

},{}],30:[function(require,module,exports){
module.exports = "<div class=\"connectionLost\">\n  <section>\n    <i class=\"octicon octicon-plug\"></i>\n    <h2>{{item.title}}</h2>\n    <div class=\"errorCode\"><p>Error code: <strong>{{item.errorCode}}</strong><span class=\"errorMessage\" wk-bind=\"item.errorMessage\"></span></p></div>\n    <div class=\"button-section\">\n      <button class=\"reconnect\" wk-bind=\"item.reconnect\" title=\"Try to reconnect your changes will be overwritten\">reconnect</button>\n      <button class=\"close\" wk-bind=\"item.close\" title=\"You can close this view to rescure you changes manually\">close</button>\n      <button class=\"reload\" wk-bind=\"item.reload\" title=\"If you do a page reload all your unsaved changes will be lost\">reload page</button>\n    </div>\n  </section>\n  <div class=\"progressUi\"></div>\n</div>";

},{}],31:[function(require,module,exports){
'use strict';

var whisker = require('canny/mod/whisker');
var template = require('./index.html');
var TEXTS = function TEXTS(code) {
    switch (code) {
        case 'EXCEPTION':
            return 'wow... not good - please report this problem to a developer';
        case 'FATAL':
            return 'dammed... this should not happen - please consult dev of trust';
        case 'AUTH':
            return 'Session timeout please login again';
        case 'RECONNECT_FAIL':
            return 'can\'t create a connection';
        case 'SEARCH_ERROR':
            return 'Search service unavailable';
        default:
            return 'whooops... server connection lost';
    }
};
/**
 *
 * @param onReload
 * @param onReconnect
 * @returns {{render: (function(string)), destroy: (function())}}
 */
module.exports = function (_ref) {
    var onReload = _ref.onReload,
        onReconnect = _ref.onReconnect,
        onClose = _ref.onClose;

    // saves the active node
    var ui = void 0;

    function _render(_ref2) {
        var errorCode = _ref2.errorCode,
            _errorMessage = _ref2.errorMessage;

        if (ui) ui.remove();
        var d = document.createElement('div');
        d.innerHTML = template;
        whisker.add(d.children[0], {
            reconnect: function reconnect(n) {
                if (errorCode === 'RECONNECT_FAIL' || errorCode === 'FATAL' || errorCode === 'AUTH' || errorCode === 'SERVER_DOWN' || errorCode === 'EXCEPTION' || errorCode === 'SEARCH_ERROR') return false;
                n.addEventListener('click', onReconnect);
            },
            close: function close(n) {
                return n.addEventListener('click', onClose);
            },
            reload: function reload(n) {
                return n.addEventListener('click', onReload);
            },
            errorCode: errorCode,
            title: TEXTS(errorCode),
            errorMessage: function errorMessage(n) {
                if (_errorMessage) {
                    n.innerHTML = ' ' + _errorMessage;
                } else return false;
            }
        });
        document.body.appendChild(ui = d.children[0]);
    }

    return {
        /**
         * Show the module
         * @param {string} err - error code to print on the view
         */
        render: function render(err, msg) {
            return _render({ errorCode: err, errorMessage: msg });
        },
        /**
         * Remove the module from ui
         */
        destroy: function destroy() {
            ui.remove();
            ui = undefined;
        },
        /**
         * indicates that the view is busy
         */
        showProgress: function showProgress() {
            ui.classList.add('progress');
        }
    };
};

},{"./index.html":30,"canny/mod/whisker":75}],32:[function(require,module,exports){
'use strict';

var _onCreateNewProject = function onCreateNewProject() {
    console.warn('createNewProject.onCreateNewProject not set');
},
    onCreateNewDirectory = function onCreateNewDirectory() {
    console.warn('createNewProject.onCreateNewDirectory not set');
};

var projectNameInputNode, directoryNameInputNode;

function noSpaces(node) {
    node.addEventListener('keypress', function (e) {
        var key = e.keyCode || e.which;
        if (key === 32) e.returnValue = false;
        return true;
    });
    return node;
}

function isValidProjectName(projectName) {
    return projectName.length > 0 && projectName.search('\\.|,| ') === -1 ? true : false;
}

function isValidDirectoryName(directoryName) {
    // TBD more forbidden characters?
    return directoryName.length > 0 && directoryName.search('/') === -1 ? true : false;
}

module.exports = {
    add: function add(node, attribute) {
        switch (attribute) {
            case 'createNewProjectInputProject':
                projectNameInputNode = node;
                break;
            case 'newDirectoryNameInput':
                directoryNameInputNode = noSpaces(node);
                break;
            case 'createNewProjectSubmit':
                node.addEventListener('click', function () {
                    var projectName = projectNameInputNode.value;
                    if (isValidProjectName(projectName)) {
                        _onCreateNewProject(projectName);
                    } else {
                        projectNameInputNode.classList.add('error');
                    }
                });
                break;
            case 'createNewDirectorySubmit':
                node.addEventListener('click', function () {
                    var directoryName = directoryNameInputNode.value;
                    if (isValidDirectoryName(directoryName)) {
                        onCreateNewDirectory(directoryName);
                    } else {
                        directoryNameInputNode.classList.add('error');
                    }
                });
                break;
            case 'cancel':
                node.addEventListener('click', function () {
                    canny.displayManager.hide(this.dataset.view);
                });
                break;
        }
    },
    /**
     * Pass in listener for execution of creating new project.
     * @param func
     */
    onCreateNewProject: function onCreateNewProject(func) {
        _onCreateNewProject = func;
    },
    /**
     * Pass in listener for execution of creating a new directory.
     * @param func
     */
    onCreateNewDirectoy: function onCreateNewDirectoy(func) {
        onCreateNewDirectory = func;
    }
};

},{}],33:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Overlay = require('./overlay'),
    displayManager = function displayManager() {

	var mainController = canny.flowControl,
	    overlayController = canny.flowControl.createNewInstance('overlays'),
	    children = {
		overlay: {
			ids: [],
			controller: overlayController,
			add: function add(node, id) {

				var overlay = new Overlay(node, id);
				overlay.onClick(function () {
					setDisplayStateById(id, false);
				});

				this.controller.add(overlay.node, {
					'view': overlay.id
				});
				this.ids.push(overlay.id);
			}
		},
		view: {
			ids: [],
			controller: mainController,
			add: function add(node, id) {
				this.controller.add(node, {
					'view': id
				});
				this.ids.push(id);
			}
		}
	};

	function setDisplayStateById(id, show) {
		Object.keys(children).map(function (type) {
			var pool = children[type],
			    ids = pool.ids,
			    currentId;

			for (var i = 0; i < ids.length; i++) {
				currentId = ids[i];
				if (id === currentId) {
					if (show) {
						pool.controller.show(currentId);
					} else if (pool.controller.mod[id]) {
						pool.controller.mod[id].forEach(function (obj) {
							obj.hide();
						});
					}
					break;
				}
			}
		});
	}

	return {
		add: function add(node, descriptor) {
			var keys, key;
			if ((typeof descriptor === 'undefined' ? 'undefined' : _typeof(descriptor)) === 'object') {
				keys = Object.keys(descriptor);
				for (var i = 0; i < keys.length; i++) {
					key = keys[i];
					if (children.hasOwnProperty(key)) {
						children[key].add(node, descriptor[key]);
					}
				}
			} else {
				console.warn('Parameter to add child to displayManager is not valid: ' + descriptor);
			}
		},
		show: function show(id) {
			setDisplayStateById(id, true);
		},
		hide: function hide(id) {
			setDisplayStateById(id, false);
		}

	};
};

module.exports = displayManager;

},{"./overlay":39}],34:[function(require,module,exports){
'use strict';

/**
 * handles all texts
 */
var domOpts = require('dom-opts'),
    flagMap = {
    da: 'dk',
    de: 'de',
    fr: 'fr',
    nl: 'nl',
    en: 'us',
    en_GB: 'gb',
    sv: 'se',
    es: 'es'
};

function getLang(lang) {
    var flagLang = lang;
    if (flagMap.hasOwnProperty(lang)) {
        flagLang = flagMap[lang];
    }
    return flagLang;
}

module.exports = {
    getFlag: function getFlag(lang) {
        return domOpts.createElement('span', null, 'flag-icon flag-icon-' + getLang(lang));
    },
    getFlagClasses: function getFlagClasses(lang) {
        return ['flag-icon', 'flag-icon-' + getLang(lang)];
    },
    getFlagMap: flagMap,
    getLang: getLang
};

},{"dom-opts":85}],35:[function(require,module,exports){
'use strict';

/*global ace */
/*jslint browser: true */
var events = require('../events.js');
var C = require('../CONST.js');

window.domOpts = window.domOpts || require('dom-opts');

var imageViewer = function () {
    "use strict";

    var nodeToAppend,
        init = false,
        config = {
        idPrefix: 'imageViewer_'
    },
        setupContainerCSS = function setupContainerCSS(node, css) {
        for (var prop in css) {
            node.style[prop] = css[prop];
        }
    },
        settings = {
        maxWidth: 300,
        maxHeight: 300
    },
        fc = {
        hideImageViewer: function hideImageViewer() {
            var pres = nodeToAppend.domChildTags('img');

            if (pres.length > 0) {
                // there are other open images
                pres.forEach(function (e) {
                    e.domAddClass('hidden');
                });
            }
        },
        showImage: function showImage(obj) {
            var img,
                id = config.idPrefix + obj.id,
                actualImg = document.getElementById(id);

            if (actualImg !== null) {
                actualImg.domRemoveClass('hidden');
            } else {
                img = new Image();
                img.onload = function () {
                    console.log('DONE IMAGE');
                };
                img.src = "data:image/png;base64," + obj.data;
                setupContainerCSS(img, {
                    maxWidth: '100%',
                    maxHeight: '100%'
                });
                img.setAttribute('id', id);
                img.domAppendTo(nodeToAppend);
            }
        }
    };

    events.addServerListener('sendFile', function (obj) {
        if (init) {
            fc.hideImageViewer();

            if (obj.fileType === C.FILE_MANAGER.FILE_TYPES.IMAGE) {
                fc.showImage(obj);
            }
        }
    });

    return {
        add: function add(node, attr) {
            init = true;
            nodeToAppend = node;
            nodeToAppend.setAttribute('id', 'imageViewer');

            setupContainerCSS(nodeToAppend, {
                width: settings.maxWidth + 'px',
                height: settings.maxHeight + 'px'
            });
        },
        setup: function setup(config) {
            var obj;
            for (obj in config) {
                settings[obj] = config[obj];
            }
        }
    };
}();

module.exports = imageViewer;

},{"../CONST.js":2,"../events.js":19,"dom-opts":85}],36:[function(require,module,exports){
'use strict';

function addEdit(node, fc) {
    var div = domOpts.createElement('div', null, 'inputEditManager-button edit octicon octicon-pencil');
    div.addEventListener('click', function (event) {
        node.classList.add('c-edit');
        fc(event);
    });
    div.setAttribute('title', 'edit');
    node.appendChild(div);
}
function addCancel(node, fc) {
    var div = domOpts.createElement('div', null, 'inputEditManager-button cancel octicon octicon-x');
    div.addEventListener('click', function (event) {
        node.classList.remove('c-edit');
        fc(event);
    });
    div.setAttribute('title', 'cancel');
    node.appendChild(div);
}

function addSave(node, fc) {
    var div = domOpts.createElement('div', null, 'inputEditManager-button save octicon octicon-check');
    div.addEventListener('click', function (event) {
        fc(event);
    });
    div.setAttribute('title', 'save changes');
    node.appendChild(div);
}

function addClone(node, fc) {
    var div = domOpts.createElement('div', null, 'inputEditManager-button save octicon octicon-file-symlink-file');
    div.addEventListener('click', function (event) {
        fc(event);
    });
    div.setAttribute('title', 'move key into other category');
    node.appendChild(div);
}

function addDelete(node, fc) {
    var div = domOpts.createElement('div', null, 'inputEditManager-button delete octicon octicon-trashcan');
    div.addEventListener('click', function (event) {
        fc(event);
    });
    div.setAttribute('title', 'remove this key');
    node.appendChild(div);
}

function closeEditorView(keyInputNode) {
    var editorPanelNode = keyInputNode.parentNode.querySelector('.inputEditManager.wrap');
    if (editorPanelNode) {
        editorPanelNode.classList.remove('c-edit');
    }
}

module.exports = {
    /**
     * each key input node hast
     * @param keyInputNode
     */
    closeEditView: function closeEditView(keyInputNode) {
        if (keyInputNode) {
            closeEditorView(keyInputNode);
        }
    },
    addEditorPanel: function addEditorPanel(keyNode, listeners) {
        var containerNode = domOpts.createElement('div', null, 'inputEditManager wrap');

        if (listeners.hasOwnProperty('onEdit')) {
            addEdit(containerNode, listeners.onEdit);
        }
        if (listeners.hasOwnProperty('onDelete')) {
            addDelete(containerNode, listeners.onDelete);
        }
        if (listeners.hasOwnProperty('onSave')) {
            addSave(containerNode, listeners.onSave);
        }
        if (listeners.hasOwnProperty('onClone')) {
            addClone(containerNode, listeners.onClone);
        }
        if (listeners.hasOwnProperty('onCancel')) {
            addCancel(containerNode, listeners.onCancel);
        }

        containerNode.domAppendTo(keyNode);

        return containerNode;
    },
    removePanel: function removePanel(node) {
        node.querySelector('.inputEditManager.wrap').domRemove();
    }
};

},{}],37:[function(require,module,exports){
'use strict';

module.exports = function () {
  var node = void 0;

  return {
    add: function add(n) {
      node = n;
    },
    show: function show() {
      node.classList.add('show');
    },
    hide: function hide() {
      node.classList.remove('show');
    }
  };
};

},{}],38:[function(require,module,exports){
'use strict';

var rootNode;

module.exports = {
    show: function show() {
        rootNode.classList.add('c-show');
    },
    hide: function hide() {
        rootNode.classList.remove('c-show');
    },
    add: function add(node, attr) {
        if (attr === 'button') {
            node.addEventListener('click', function () {
                if (rootNode.classList.contains('c-show')) {
                    rootNode.classList.remove('c-show');
                } else {
                    rootNode.classList.add('c-show');
                }
            });
        } else {
            rootNode = node;
        }
    }
};

},{}],39:[function(require,module,exports){
'use strict';

module.exports = function Overlay(node, id) {

	var id = id,
	    node = node,
	    clickHandler = function clickHandler() {
		console.warn('Click listener not attached for overlay with id: ' + id);
	};

	node.classList.add('displayManager-overlay');
	node.addEventListener('click', function (e) {
		if (node === e.target) {
			clickHandler();
		}
	});

	return {
		id: id,
		node: node,
		onClick: function onClick(cb) {
			clickHandler = cb;
		}
	};
};

},{}],40:[function(require,module,exports){
'use strict';

/*global */
/*jslint browser: true*/

var canny = require('canny'),
    flag = require('./flag'),
    texts = require('./texts');

/**
 * E.g.: canny-mod="flowControl" canny-var="{'view' : 'viewToShow'}"
 *
 * you can activate a initial view with a anchor in the URL e.g.: yourdomain.html#viewToShow
 * Or pass a comma separated module list for activate more module #viewToShow,otherView
 *
 * TODO made it possible to summarize views with one identifier.
 * Instead of call: gdom.flowControl.show('view1', 'view2', 'view3') call gdom.flowControl.show('view').
 */
var projectMainNavigation = function () {
    "use strict";

    var mainNode,
        selectLanguageQueue = [],
        onShowJSONQueue = [],
        onEnableEditorModeQueue = [],
        onToggleWordCountQueue = [],
        onShowJMBFQueue = [],
        onShowJMBFUploaderQueue = [],
        onShowJSONImportQueue = [],
        bundleName = window.domOpts.params.bundle,
        modViews = {
        main: function main(node) {
            mainNode = node;
        },
        menuToggleButton: function menuToggleButton(node) {
            new svgIcon(node, {
                hamburgerCross: {
                    url: '/dist/animatedSVG/svg/hamburger.svg',
                    animation: [{
                        el: 'path:nth-child(1)',
                        animProperties: {
                            from: { val: '{"path" : "m 5.0916789,20.818994 53.8166421,0"}' },
                            to: { val: '{"path" : "M 12.972944,50.936147 51.027056,12.882035"}' }
                        }
                    }, {
                        el: 'path:nth-child(2)',
                        animProperties: {
                            from: { val: '{"transform" : "s1 1", "opacity" : 1}', before: '{"transform" : "s0 0"}' },
                            to: { val: '{"opacity" : 0}' }
                        }
                    }, {
                        el: 'path:nth-child(3)',
                        animProperties: {
                            from: { val: '{"path" : "m 5.0916788,42.95698 53.8166422,0"}' },
                            to: { val: '{"path" : "M 12.972944,12.882035 51.027056,50.936147"}' }
                        }
                    }]
                }
            }, {
                easing: mina.elastic, speed: 1200, size: { w: '4em', h: '3em' }
            });
            node.addEventListener('click', function () {
                if (mainNode.classList.contains('c-open')) {
                    mainNode.classList.remove('c-open');
                } else {
                    mainNode.classList.add('c-open');
                }
            });
        },
        showResourceBundleEditor: function showResourceBundleEditor(node) {
            // reload the page because the files are not synced
            node.setAttribute('href', '#');
            node.addEventListener('click', function () {
                location.reload();
            });
        },
        showMessageBundleFormat: function showMessageBundleFormat(node) {
            node.addEventListener('click', function () {
                onShowJMBFQueue.forEach(function (fc) {
                    fc();
                });
            });
        },
        showJSONBundle: function showJSONBundle(node) {
            node.addEventListener('click', function () {
                onShowJSONQueue.forEach(function (fc) {
                    fc();
                });
            });
        },
        showJMBFUploader: function showJMBFUploader(node) {
            node.addEventListener('click', function () {
                onShowJMBFUploaderQueue.forEach(function (fc) {
                    fc();
                });
            });
        },
        showJSONImport: function showJSONImport(node) {
            node.addEventListener('click', function () {
                onShowJSONImportQueue.forEach(function (fc) {
                    fc();
                });
            });
        },
        enableEditorMode: function enableEditorMode(node) {
            node.addEventListener('click', function () {
                onEnableEditorModeQueue.forEach(function (fc) {
                    fc();
                });
            });
        },
        toggleWordCount: function toggleWordCount(node) {
            node.addEventListener('click', function () {
                onToggleWordCountQueue.forEach(function (fc) {
                    fc();
                });
            });
        },
        from: function from(node) {
            this.from.node = node;
        },
        to: function to(node) {
            this.to.node = node;
        }
    };

    /**
     *
     * @param locales []
     * @param node
     */
    function setLocale(locales, node) {
        var ul = node.querySelector('.languages'),
            li,
            languageNameNode,
            progressNode,
            flagIC;
        if (ul) {
            // remove all existing children first
            [].slice.call(ul.querySelectorAll('li')).forEach(function (elem) {
                ul.removeChild(elem);
            });
        } else {
            ul = window.domOpts.createElement('ul', null, 'navigationMenu languages');
        }
        locales.forEach(function (key) {
            var numOfTransKeys = window.domOpts.createElement('span', null, 'numOfTransKeys'),
                maxKeyNode = window.domOpts.createElement('span', null, 'maxKey');
            li = window.domOpts.createElement('li');
            languageNameNode = window.domOpts.createElement('span');
            progressNode = window.domOpts.createElement('span', null, 'progress');
            numOfTransKeys.appendChild(document.createTextNode('-'));
            numOfTransKeys.domAppendTo(progressNode);
            progressNode.appendChild(document.createTextNode('/'));
            maxKeyNode.appendChild(document.createTextNode('-'));
            maxKeyNode.domAppendTo(progressNode);

            li.classList.add('lang');
            li.classList.add(key);

            li.addEventListener('click', function () {
                var isInactive = true,
                    isActive = this.classList.contains('c-active');

                if (isActive) {
                    this.classList.toggle('c-inactive');
                    isInactive = this.classList.contains('c-inactive');
                } else {
                    // has no state
                }

                selectLanguageQueue.forEach(function (fc) {
                    fc({
                        isActive: isActive,
                        isInactive: isInactive,
                        project: bundleName,
                        language: key
                    });
                });
            });

            languageNameNode.innerHTML = texts.getLanguageNames(key);
            languageNameNode.className = 'langName';
            languageNameNode.domAppendTo(li);
            progressNode.domAppendTo(li);
            flagIC = flag.getFlag(key);
            flagIC.classList.add('icon', 'octicon', 'octicon-plus');
            flagIC.domAppendTo(li);
            li.domAppendTo(ul);
        });
        ul.domAppendTo(node);
    }

    /**
     * update all language max keys for all languages
     * @param keys
     * @param node
     */
    function updateMaxKeys(keys, node) {
        [].slice.call(node.querySelectorAll('.languages .lang')).forEach(function (langNode) {
            langNode.querySelector('.maxKey').innerHTML = keys;
        });
    }

    /**
     * update a specific language
     * @param key
     * @param lang
     * @param node
     */
    function updateNumberOfLangKeys(key, lang, node) {
        console.log('projectMainNavigation:updateNumberOfLangKeys', key, lang);
        node.querySelector('.languages .lang.' + lang + ' .numOfTransKeys').innerHTML = key;
    }

    return {
        setNumberOfTranslationMaxKeys: function setNumberOfTranslationMaxKeys(maxKeys) {
            updateMaxKeys(maxKeys, modViews.from.node);
        },
        setNumberOfTranslatedLanguageKey: function setNumberOfTranslatedLanguageKey(numberOfKeys, lang) {
            updateNumberOfLangKeys(numberOfKeys, lang, modViews.from.node);
        },
        onLanguageSelect: function onLanguageSelect(fc) {
            selectLanguageQueue.push(fc);
        },
        onShowJSON: function onShowJSON(fc) {
            onShowJSONQueue.push(fc);
        },
        onShowJMBF: function onShowJMBF(fc) {
            onShowJMBFQueue.push(fc);
        },
        onShowJMBFUploader: function onShowJMBFUploader(fc) {
            onShowJMBFUploaderQueue.push(fc);
        },
        onShowJSONImport: function onShowJSONImport(fc) {
            onShowJSONImportQueue.push(fc);
        },
        onEnableEditorMode: function onEnableEditorMode(fc) {
            onEnableEditorModeQueue.push(fc);
        },
        onToggleWordCount: function onToggleWordCount(fc) {
            onToggleWordCountQueue.push(fc);
        },
        activateLang: function activateLang(lang) {
            var node = mainNode.querySelector('li.' + lang);
            node.classList.remove('c-inactive');
            node.classList.add('c-active');
        },
        deActivateLang: function deActivateLang(lang) {
            var node = mainNode.querySelector('li.' + lang);
            node.classList.add('c-inactive');
        },
        /**
         * Apply the current project's number to the flags: activate flag where translations exist and show number of
         * translated keys.
         * @param keysTotal the total number of keys
         * @param translatedKeysPerLang the number of translated keys per language
         */
        setActivatedProjectLanguages: function setActivatedProjectLanguages(keysTotal, translatedKeysPerLang) {
            [].slice.call(mainNode.querySelectorAll('li')).forEach(function (node) {
                var progressNode = node.querySelector('.progress');
                node.classList.remove('c-active');
                if (progressNode) {
                    progressNode.children[0].innerHTML = "-";
                    progressNode.children[1].innerHTML = "-";
                }
            });

            Object.keys(translatedKeysPerLang).forEach(function (key) {
                [].slice.call(mainNode.querySelectorAll('li.' + key)).forEach(function (node) {
                    var progressNode = node.querySelector('.progress');
                    node.classList.add('c-active');
                    if (progressNode) {
                        progressNode.children[0].innerHTML = translatedKeysPerLang[key];
                        progressNode.children[1].innerHTML = keysTotal;
                    }
                });
            });
        },
        setAvailableLanguages: function setAvailableLanguages(languages) {
            setLocale(languages, modViews.from.node);
        },
        ready: function ready() {
            console.log('nav-controller ready event');
        },
        add: function add(node, attr) {
            // part of api
            if (modViews.hasOwnProperty(attr)) {
                modViews[attr](node);
            } else {
                console.log('LINK NOT IMPLEMENTED');
            }
        }
    };
}();

module.exports = projectMainNavigation;

},{"./flag":34,"./texts":52,"canny":71}],41:[function(require,module,exports){
'use strict';

var projectOverview = function () {
    'use strict';

    var componentRootNode,
        renderProjectsAndDirectoriesList,
        _onCreateProjectPressed = function onCreateProjectPressed() {
        console.warn('projectOverview.onCreateProjectPressed not set');
    },
        _onParentDirectorySelected = function onParentDirectorySelected() {
        console.warn('projectOverview.onParentDirectorySelected not set');
    },
        _onProjectSelected = function onProjectSelected() {
        console.warn('projectOverview.onProjectSelected not set');
    },
        _onDeleteProjectPressed = function onDeleteProjectPressed() {
        console.warn('projectOverview.onDeleteProjectPressed not set');
    },
        onMovedProjectPressed = function onMovedProjectPressed() {
        console.warn('projectOverview.onMovedProjectPressed not set');
    },
        _onDeleteFolderPressed = function onDeleteFolderPressed() {
        console.warn('projectOverview.onDeleteFolderPressed not set');
    },
        _onDirectorySelected = function onDirectorySelected() {
        console.warn('projectOverview.onDirectorySelected not set');
    },
        _onCreateDirectoryPressed = function onCreateDirectoryPressed() {
        console.warn('projectOverview.onCreateDirectoryPressed not set');
    },
        editModeEnabled = false;

    return {
        /**
         * Called from canny when registering components. The only component which we expect to be registered is
         * "projectOverviewContainer" (the root node of the component).
         * @param node
         * @param vars
         */
        add: function add(node, attr) {
            if (componentRootNode === undefined) {
                componentRootNode = node;
            } else {
                console.warn('projectOverview:add multiple views detected - it should be registered only ones in the DOM!');
            }
        },
        /**
         * Called from canny on documentReady event.
         */
        ready: function ready() {

            var createProjectButtonNode = componentRootNode.querySelector('.js-createProjectButton');
            if (!createProjectButtonNode) {
                console.error('No child node with class "createProjectButton found inside "projectOverviewContainer"');
            } else {
                createProjectButtonNode.addEventListener('click', function (event) {
                    _onCreateProjectPressed();
                });
            }

            var createFolderButtonNode = componentRootNode.querySelector('.js-createFolderButton');
            if (!createFolderButtonNode) {
                console.error('No child node with class "createFolderButton found inside "projectOverviewContainer"');
            } else {
                createFolderButtonNode.addEventListener('click', function (event) {
                    _onCreateDirectoryPressed();
                });
            }

            var toggleEditModeButtonNode = componentRootNode.querySelector('.js-toggleEditModeButton');
            if (!toggleEditModeButtonNode) {
                console.error('No child node with class "createFolderButton found inside "projectOverviewContainer"');
            } else {
                toggleEditModeButtonNode.addEventListener('click', function (event) {
                    editModeEnabled = !editModeEnabled;
                    componentRootNode.classList.toggle('editMode-enabled', editModeEnabled);
                    toggleEditModeButtonNode.classList.toggle('active', editModeEnabled);
                });
            }

            var selectParentDirectoryButton = componentRootNode.querySelector('.js-selectParentDirectoryButton');
            if (!selectParentDirectoryButton) {
                console.error('No child node with class "selectParentDirectoryButton" found inside "projectOverviewContainer"');
            } else {
                selectParentDirectoryButton.addEventListener('click', function (event) {
                    _onParentDirectorySelected();
                });
            }
        },
        /**
         * Inform the ui module about the new current set of directories and projects to list. This will also trigger
         * a new rendering of the projects list with the new content.
         * @param projectNames
         * @param directoryNames
         */
        setProjectsAndDirectories: function setProjectsAndDirectories(projectNames, directoryNames) {
            var projectsAndDirectories = [];

            if (!projectNames || !directoryNames) {
                return;
            } else if (!renderProjectsAndDirectoriesList) {
                console.error('renderProjectsAndDirectoriesList function has not been set, new list cannot be shown');
                return;
            }

            console.log('got projects', projectNames);
            console.log('got directories', directoryNames);

            projectNames.forEach(function (projectName) {
                projectsAndDirectories.push({
                    name: projectName,
                    dir: false,
                    openProjectListItem: function openProjectListItem() {
                        console.log('project selected:', projectName);
                        if (_onProjectSelected) {
                            _onProjectSelected(projectName);
                        }
                    },
                    deleteProjectListItem: function deleteProjectListItem() {
                        var deletionConfirmed = window.confirm('Really delete project ' + projectName + '?');
                        if (_onDeleteProjectPressed && deletionConfirmed) {
                            _onDeleteProjectPressed(projectName);
                        }
                    },
                    moveProject: function moveProject() {
                        onMovedProjectPressed(projectName);
                    }
                });
            });
            directoryNames.forEach(function (directoryName) {
                projectsAndDirectories.push({
                    name: directoryName,
                    dir: true,
                    openProjectListItem: function openProjectListItem() {
                        console.log('directory selected:', directoryName);
                        if (_onDirectorySelected) {
                            _onDirectorySelected(directoryName);
                        }
                    },
                    deleteProjectListItem: function deleteProjectListItem() {
                        var deletionConfirmed = window.confirm('Really delete folder ' + directoryName + '?');
                        if (_onDeleteFolderPressed && deletionConfirmed) {
                            _onDeleteFolderPressed(directoryName);
                        }
                    }
                });
            });

            renderProjectsAndDirectoriesList(projectsAndDirectories);
        },
        /**
         * For canny-repeat registered on the projects list, provide the function for rendering the list.
         * @param func a function which will set the list of projects and directories.
         */
        setRenderProjectsAndDirectoriesListFunction: function setRenderProjectsAndDirectoriesListFunction(func) {
            renderProjectsAndDirectoriesList = func;
        },
        deleteProjectListNode: function deleteProjectListNode(itemName) {
            var node = componentRootNode.querySelector('tr[data-listItem=' + itemName + ']');
            if (node && node.parentNode) {
                node.parentNode.removeChild(node);
            }
        },
        /**
         * Register a listener callback which will react to "to parent directory" event.
         * @param listener
         */
        onParentDirectorySelected: function onParentDirectorySelected(listener) {
            _onParentDirectorySelected = listener;
        },
        /**
         * Register a listener callback which will react to clicks on a project. The callback function should expect
         * one parameter which is the project name.
         * @param listener
         */
        onProjectSelected: function onProjectSelected(listener) {
            _onProjectSelected = listener;
        },
        /**
         * Register a listener callback which will react to clicks on a directory. The callback function should expect
         * one parameter which is the directory name.
         * @param listener
         */
        onDirectorySelected: function onDirectorySelected(listener) {
            _onDirectorySelected = listener;
        },
        onCreateProjectPressed: function onCreateProjectPressed(func) {
            _onCreateProjectPressed = func;
        },
        onDeleteProjectPressed: function onDeleteProjectPressed(func) {
            _onDeleteProjectPressed = func;
        },
        onDeleteFolderPressed: function onDeleteFolderPressed(func) {
            _onDeleteFolderPressed = func;
        },
        onCreateDirectoryPressed: function onCreateDirectoryPressed(func) {
            _onCreateDirectoryPressed = func;
        },
        onMoveDirectoryPressed: function onMoveDirectoryPressed(func) {
            onMovedProjectPressed = func;
        }
    };
}();

module.exports = projectOverview;

},{}],42:[function(require,module,exports){
'use strict';

var _onSearch = function onSearch() {
    console.log('search:onSearch is not handled');
},
    active = false,
    rootNode,
    inputNode,
    brain = {
    root: function root(node) {
        rootNode = node;
    },
    input: function input(node) {
        inputNode = node;
        node.addEventListener('keyup', function (event) {
            event.preventDefault();
            if (active && event.keyCode === 13) {
                _onSearch();
            }
        });
    },
    button: function button(node) {
        node.addEventListener('click', function (event) {
            if (active) {
                _onSearch();
            }
        });
    }
};

module.exports = {
    onSearch: function onSearch(fc) {
        _onSearch = fc;
    },
    get inputNode() {
        return inputNode;
    },
    add: function add(node, attr) {
        if (brain.hasOwnProperty(attr)) {
            brain[attr](node);
        }
    },
    show: function show() {
        rootNode.classList.add('show');
        active = true;
    },
    hide: function hide() {
        active = false;
        rootNode.classList.remove('show');
    }
};

},{}],43:[function(require,module,exports){
module.exports = "<div class=\"checkboxes\">\n    <label for=\"filter-casesensitive\">case-sensitive</label>\n    <input type=\"checkbox\" id=\"filter-casesensitive\" name=\"filter-casesensitive\">\n</div>";

},{}],44:[function(require,module,exports){
module.exports = "<h2>Found <span class=\"term\">{{item.title}}</span> in <span>{{item.resultsCounted}}</span> text items.</h2>";

},{}],45:[function(require,module,exports){
module.exports = "<li class=\"key-item\">\n    <div class=\"lang\"><span class=\"flag-icon flag-icon-{{item.lang}} icon octicon\"></span></div>\n    <div class=\"key\"><a href=\"{{item.url}}\">{{item.key}}</a></div>\n    <div class=\"text\">{{item.text}}</div>\n</li>";

},{}],46:[function(require,module,exports){
module.exports = "<div class=\"lang-button\" title=\"{{item.lang}}\">\n    <span class=\"flag-icon flag-icon-{{item.lang}} icon octicon\"></span>\n</div>";

},{}],47:[function(require,module,exports){
module.exports = "<li class=\"project-item\">\n  <h3>No matches found.</h3>\n</li>\n";

},{}],48:[function(require,module,exports){
module.exports = "<div class=\"page-button\">\n    {{item.pageNumber}}\n</div>";

},{}],49:[function(require,module,exports){
module.exports = "<li class=\"project-item\">\n    <h3>{{item.project_id}}</h3>\n    <ul class=\"key-list\">\n        <!-- KeyItem.html inserted dynmically -->\n    </ul>\n</li>";

},{}],50:[function(require,module,exports){
module.exports = "<div class=\"searchResults\">\n  <section>\n    <i class=\"octicon octicon-search\"></i>\n    <div class=\"headline\">\n      <!-- Headline.html -->\n    </div>\n    <div class=\"search-options\">\n      <div class=\"languages\">\n        <span>Search term was found in following languages:</span>\n        <div class=\"language-switch\">\n          <!-- LangButton.html inserted dynmically -->\n        </div>\n      </div>\n      <div class=\"filters\">\n        <!-- Filters.html inserted dynmically -->\n      </div>\n    </div>\n    <ul class=\"results-list\">\n      <!-- ProjectItem.html inserted dynmically -->\n    </ul>\n    <ul class=\"pagination\">\n      <!-- PageButton.html inserted dynmically -->\n    </ul>\n    <div class=\"button-section\">\n      <button class=\"close\" wk-bind=\"item.close\" title=\"Close modal\">close</button>\n    </div>\n  </section>\n</div>";

},{}],51:[function(require,module,exports){
"use strict";

var whisker = require("canny/mod/whisker");
var flags = require("../flag");
var template = require("./index.html");
var Headline = require("./Headline.html");
var Filters = require("./Filters.html");
var ProjectItem = require("./ProjectItem.html");
var KeyItem = require("./KeyItem.html");
var NoMatches = require("./NoMatches.html");
var LangButton = require("./LangButton.html");
var PageButton = require("./PageButton.html");

module.exports = function (_ref) {
  var onClose = _ref.onClose;

  var results = void 0;

  var node = document.createElement("div");
  node.innerHTML = template;

  var content = node.children[0];
  var headline = content.querySelector(".headline");
  var langSwitch = content.querySelector(".language-switch");
  var list = content.querySelector(".results-list");
  var filters = content.querySelector(".filters");
  filters.innerHTML = Filters;

  var checkboxCase = filters.querySelector("#filter-casesensitive");
  checkboxCase.addEventListener("change", function (event) {
    currentPage = 0;
    results && renderPage(results);
  });

  var pagination = content.querySelector(".pagination");
  var ENTRIES_PER_PAGE = 10;
  var currentPage = 0;

  function filterCaseSensitive(projects, searchTerm, isSensitive) {
    return projects.map(function (item) {
      item.results = item.results.filter(function (result) {
        return !isSensitive || isSensitive && result.text.indexOf(searchTerm) !== -1;
      });
      return item;
    }).filter(function (item) {
      return item.results.length > 0;
    });
  }

  function getMetaData(entries) {
    var resultsCounted = 0;
    var languages = [];
    entries.forEach(function (item) {
      item.results.forEach(function (result) {
        var lang = flags.getLang(result.lang);
        if (languages.indexOf(lang) === -1) {
          languages.push(lang);
        }
        resultsCounted++;
      });
    });
    return {
      resultsCounted: resultsCounted,
      languages: languages
    };
  }

  function renderHeader(data, htmlElement) {
    whisker.add(htmlElement, {
      title: data.searchTerm,
      resultsCounted: data.resultsCounted,
      close: function close(n) {
        return n.addEventListener("click", onClose);
      }
    });
  }

  function renderFlags(languages, htmlElement) {
    // Render flags on top of results-list
    languages.sort(function (a, b) {
      return a < b ? -1 : 1;
    }).forEach(function (lang) {
      lang = flags.getLang(lang);
      var langButton = document.createElement("div");
      langButton.innerHTML = LangButton;
      whisker.add(langButton, {
        lang: lang
      });
      htmlElement.appendChild(langButton.children[0]);
    });
  }

  function renderResults(items, rangeStart, rangeEnd, htmlList) {
    items.filter(function (item, index) {
      return index >= rangeStart && index < rangeEnd;
    }).forEach(function (item) {
      var htmlProject = document.createElement("div");
      htmlProject.innerHTML = ProjectItem;
      whisker.add(htmlProject, {
        project_id: item.project_id
      });

      var keyList = htmlProject.querySelector(".key-list");

      item.results.forEach(function (result) {
        var htmlKey = document.createElement("div");
        htmlKey.innerHTML = KeyItem;
        var lang = flags.getLang(result.lang);
        whisker.add(htmlKey, {
          key: result.key,
          url: result.url,
          lang: lang,
          text: result.text
        });
        keyList.appendChild(htmlKey.children[0]);
      });

      if (keyList.childElementCount > 0) {
        htmlList.appendChild(htmlProject.children[0]);
      }
    });
  }

  function renderPagination(numPages, htmlElement) {
    var _loop = function _loop(pageNumber) {
      var wrapper = document.createElement("div");
      wrapper.innerHTML = PageButton;

      var button = wrapper.children[0];

      whisker.add(button, {
        pageNumber: pageNumber + 1
      });

      button.addEventListener("click", function () {
        currentPage = pageNumber;
        results && renderPage(results);
      });

      if (currentPage === pageNumber) {
        button.classList.add("active");
      }

      htmlElement.appendChild(button);
    };

    for (var pageNumber = 0; pageNumber <= numPages; pageNumber++) {
      _loop(pageNumber);
    }
  }

  function renderPage(data) {
    results = data;

    var clonedData = JSON.parse(JSON.stringify(results));
    var projectEntries = clonedData.data;
    var searchTerm = clonedData.search_term;

    headline.innerHTML = Headline;
    langSwitch.innerHTML = "";
    list.innerHTML = "";
    pagination.innerHTML = "";

    if (projectEntries.length > 0) {
      var rangeStart = currentPage * ENTRIES_PER_PAGE;
      var rangeEnd = (currentPage + 1) * ENTRIES_PER_PAGE;

      projectEntries = filterCaseSensitive(clonedData.data, searchTerm, checkboxCase.checked);
      var metadata = getMetaData(projectEntries);

      renderHeader({ searchTerm: searchTerm, resultsCounted: metadata.resultsCounted }, content);
      renderFlags(metadata.languages, langSwitch);
      renderResults(projectEntries, rangeStart, rangeEnd, list);
      var numPages = Math.floor(projectEntries.length / ENTRIES_PER_PAGE);
      if (numPages > 0) {
        renderPagination(numPages, pagination);
      }
    } else {
      renderHeader({ searchTerm: searchTerm, resultsCounted: 0 }, content);
      var htmlProject = document.createElement("div");
      htmlProject.innerHTML = NoMatches;
      list.appendChild(htmlProject.children[0]);
    }

    document.body.appendChild(content);
  }

  return {
    /**
     * Show the module
     * @param {string} err - error code to print on the view
     */
    render: renderPage,
    /**
     * Remove the module from ui
     */
    destroy: function destroy() {
      pagination.innerHTML = "";
      document.body.removeChild(content);
      currentPage = 0;
    }
  };
};

},{"../flag":34,"./Filters.html":43,"./Headline.html":44,"./KeyItem.html":45,"./LangButton.html":46,"./NoMatches.html":47,"./PageButton.html":48,"./ProjectItem.html":49,"./index.html":50,"canny/mod/whisker":75}],52:[function(require,module,exports){
'use strict';

/**
 * handles all texts
 */
var texts = function () {
    'use strict';

    var node,
        languageNames = {
        da: 'Danmark',
        de: 'Deutschland',
        fr: 'France',
        nl: 'Nederland',
        en: 'United States (Default)',
        en_GB: 'United Kingdom',
        sv: 'Sverige',
        es: 'Espanol'
    },
        texts = {
        changeTexts: function changeTexts() {},
        data: {
            projectName: '',
            projectDescription: ''
        }
    };

    return {
        getLanguageNames: function getLanguageNames(key) {
            return languageNames[key];
        },
        setTexts: function setTexts(data) {
            texts.changeTexts('msg', data);
        },
        getTexts: function getTexts(fc) {
            console.log('texts:yes text is triggered');
            texts.changeTexts = fc;
            texts.changeTexts('msg', texts.data);
        },
        add: function add(elem, attr) {
            node = elem;
        },
        ready: function ready() {
            console.log('texts ready!');
        }
    };
}();

module.exports = texts;

},{}],53:[function(require,module,exports){
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var flag = require('./flag.js'),
    inputEditManager = require('./inputEditManager.js'),
    wordCounter = require('../util/wordCounter'),
    displayManager = require('canny').displayManager,
    conf = {
    rowPrefix: "tv_",
    inputPrefix: "keyValue_",
    inputTransPrefix: "trans_"
},
    catPrefix = 'tv_';
/**
 * Rename all DOM id attributes from old to new key
 * @param oldKey
 * @param newKey
 */
function renameDOMIds(oldKey, newKey, availableLanguages) {
    Object.keys(conf).forEach(function (prop) {
        var node;
        if (prop === 'inputTransPrefix') {
            availableLanguages.forEach(function (lang) {
                node = document.getElementById(getLanguageTextId(oldKey, lang));
                if (node) {
                    node.setAttribute('id', getLanguageTextId(newKey, lang));
                } else {
                    console.error('translationView:renameIds can not find dom node for id', getLanguageTextId(newKey, lang));
                }
            });
        } else {
            node = document.getElementById(conf[prop] + oldKey);
            if (node) {
                node.setAttribute('id', conf[prop] + newKey);
            } else {
                console.error('translationView:renameIds can not find dom node for id', conf[prop] + oldKey, 'property:', prop);
            }
        }
    });
}

function keyKeyPressListener(e) {
    var key = e.keyCode || e.which;
    if (key === 32) {
        e.returnValue = false;
    }
    return true;
}

function validateNewKey(string) {
    return string.length > 0 && string.search('\\.|,| ') === -1 ? true : false;
}

function getLanguageTextId(key, lang) {
    return conf.inputTransPrefix + [key, lang].join('_');
}

function getWordCountText(count) {
    return 'Words: ' + count;
}

/**
 * Counts the characters of the given parameter.
 *
 * Now counts:
 * punctuation, Whitespaces and Words/letters
 *
 * But does not count:
 * curly braces ( {0} ), html tags ( <br/> ) and numbers (3 eggs)
 * @param value
 */
function getCharacterCount(value) {
    while (/{.*?}/.test(value)) {
        //remove placeholders
        value = value.replace(/{.*?}/, '');
    }
    while (/<.*?>/.test(value)) {
        //remove html tags
        value = value.replace(/<.*?>/, '');
    }
    while (/\\!/.test(value)) {
        //remove leading slashes in front of !
        value = value.replace(/\\!/, '!');
    }
    return [].concat(_toConsumableArray(value)).filter(function (char) {
        return (/[\D]/.test(char)
        );
    }).length;
}

function getWordCountHeadline(category) {
    return 'Overall words in ' + category;
}

function createWordCountForLanguage(lang) {
    var countWrapper = domOpts.createElement('div', null, 'data js_' + lang),
        flagClass = flag.getFlagClasses(lang).pop(),
        wordCountLabel = domOpts.createElement('span', null, 'wordCountLabel '.concat(flagClass));
    wordCountLabel.innerHTML = getWordCountText(0);
    countWrapper.appendChild(wordCountLabel);
    return countWrapper;
}

/**
 * handle the translation overview
 * TODO refactor base.connection
 */
var translationView = function () {
    'use strict';

    /**
     * TODO remove project name - only the controller needs to know this
     *
     * @param {HTMLElement} node
     * @param {string} key - @deprecated
     * @param {string} lang
     * @param {string} text
     *
     * @class
     */

    function SaveOnLeave(node, key, lang, text) {
        var textList = [text],
            textIdx = 0;

        /**
         *
         * @param {HTMLElement} node
         * @returns {string} the key id
         */
        function getIdFromRow(node) {
            return node.parentNode.parentNode.parentNode.getAttribute('id').replace(conf.rowPrefix, '');
        }

        node.addEventListener('change', function (e) {
            console.log("Old: " + textList[textIdx]);
            var newValue = this.value;
            if (textList[textIdx] !== newValue) {
                textList.push(newValue);
                textIdx++;
            }
            console.log(textList);
            _onSaveKey && _onSaveKey(getIdFromRow(node), lang, newValue);
        });
    }

    /**
     * Clean up the attached event listeners and removes them from the node.
     * It removes the 'change' and 'keypress' event from all textArea's and input fields and
     * set it to "read only"
     *
     * @param {HTMLElement} rowNode
     */
    function removeEventListenersFromRow(rowNode) {
        [].slice.call(rowNode.querySelectorAll('textarea')).forEach(function (tarea) {
            tarea.removeEventListener('change', false);
            tarea.setAttribute('readonly', 'true');
        });

        [].slice.call(rowNode.querySelectorAll('input')).forEach(function (input) {
            input.removeEventListener('keypress', false);
            input.setAttribute('readonly', 'true');
        });
    }

    /**
     *
     * @param {HTMLElement} catNodeToInsert
     * @param {Array<HTMLElement>} catNodes
     */
    function insertCategory(catNodeToInsert, catNodes) {
        var catToAppendID = catNodeToInsert.id.toLowerCase(),
            shownCatNode,
            shownCatID;

        for (var i = 0; i < catNodes.length; i++) {
            shownCatNode = catNodes[i];
            shownCatID = catNodes[i].id.toLowerCase();
            if (catToAppendID < shownCatID) {
                rootNode.insertBefore(catNodeToInsert, shownCatNode);
                break;
            }
        }

        if (catNodes.length === 0 || catToAppendID > shownCatID) {
            rootNode.appendChild(catNodeToInsert);
        }
    }

    var rootNode,
        // main node all content are added to here
    renderTextFc,
        selectors = {
        root: "resourceBundleTable",
        debug: "debugIncomming",
        tpl: {
            tableBody: 'tableBody'
        }
    },

    // QUESTION: are these real queues?
    onQueues = {
        addNewKey: [],
        createNewProject: [],
        removeKey: [],
        renameKey: [],
        categoryClicked: [],
        removeCategory: [],
        renameCategory: []
    },
        ui = {
        css: {
            sendSuccess: 'sendSuccess',
            updateKey: 'updateKey'
        },
        /**
         *
         * @param key
         * @param inputPrefix
         */
        sendSuccess: function sendSuccess(key, inputPrefix) {
            var node1 = document.getElementById(conf.rowPrefix + key),
                node2 = document.getElementById(inputPrefix + key);
            if (node1) {
                ui.removeStateClasses(node1).classList.remove(ui.css.sendSuccess);
                setTimeout(function () {
                    ui.removeStateClasses(node1).classList.add(ui.css.sendSuccess);
                }, 100);
            }
            if (node2) {
                ui.removeStateClasses(node2).classList.remove(ui.css.sendSuccess);
                setTimeout(function () {
                    ui.removeStateClasses(node2).classList.add(ui.css.sendSuccess);
                }, 100);
            }
        },
        updateInputFields: function updateInputFields(key, inputPrefix) {
            console.error('translationView:updateInputFields', 'is this still in use????????????????????????????????????');
            debugger;
            var node = document.getElementById(inputPrefix + key);
            if (node) {
                ui.removeStateClasses(node).domAddClass(ui.css.updateKey);
            }
        },
        removeStateClasses: function removeStateClasses(node) {
            var cssState,
                classes = '';
            if (!node) {
                return;
            }
            // TODO refactor Object.keys()
            for (cssState in ui.css) {
                classes += cssState + ' ';
            }
            node.domRemoveClass(classes);
            return node;
        }
    },

    /**
     * Callback (registered from controller) to be called when changes to a key must be saved
     */
    _onSaveKey = function onSaveKey() {
        console.warn('translationView:onSaveKey not initialized');
    },
        _onCreateKey = function onCreateKey() {
        console.warn('translationView:onCreateKey not initialized');
    },
        _onCloneKey = function onCloneKey() {
        console.warn('translationView:onCloneKey not initialized');
    },
        brain = {
        cloneKeyOverlay: {
            init: function init(node) {
                this.node = node;
            },
            setData: function setData(data) {
                this.data = data;
                renderTextFc('cloneKeyOverlayText', {
                    keyName: data.keyName,
                    categoryName: data.contextName
                });
            },
            getData: function getData() {
                return this.data;
            }
        },
        cloneKeyInputCategory: {
            init: function init(node) {
                this.node = node;
            }
        },
        cloneKeyButtonSubmit: {
            init: function init(node) {
                node.addEventListener('click', function () {
                    if (brain.cloneKeyInputCategory.node.value.length === 0) {
                        brain.cloneKeyInputCategory.node.classList.add('error');
                        return;
                    }
                    var data = brain.cloneKeyOverlay.getData();
                    _onCloneKey(data.key, data.keyName, data.contextName, brain.cloneKeyInputCategory.node.value);
                });
            }
        },
        createNewProjectInputProject: {
            init: function init(node) {
                this.node = node;
            }
        },
        createNewProjectProjectDescription: {
            init: function init(node) {
                this.node = node;
            }
        },
        createNewProjectSubmit: function () {
            var node;
            return {
                init: function init(elem) {
                    node = elem;
                    node.addEventListener('click', function () {
                        var projectValue = brain.createNewProjectInputProject.node.value;

                        if (validateNewKey(projectValue)) {
                            // TODO read description field
                            onQueues.createNewProject.forEach(function (fc) {
                                fc(projectValue, {
                                    description: brain.createNewProjectProjectDescription.node.value
                                });
                            });
                            // TODO check if closed is needed?
                            displayManager.hide('createNewProjectView');
                        } else {
                            // TODO replace with classes
                            brain.createNewProjectInputProject.node.style.backgroundColor = '#ff4444';
                        }
                    });
                }
            };
        }(),
        projectShow: {
            init: function init(node) {
                node.addEventListener('click', function () {
                    displayManager.show('translationViewProjectCategoryKey');
                });
            }
        },
        projectInputCategory: {
            init: function init(node) {
                this.node = node;
            }
        },
        projectInputKey: {
            init: function init(node) {
                this.node = node;
            }
        },
        cancel: function () {
            return {
                init: function init(node) {
                    node.addEventListener('click', function () {
                        canny.displayManager.hide(this.dataset.view);
                    });
                }
            };
        }(),
        projectSubmit: function () {
            var node;
            return {
                init: function init(elem) {
                    node = elem;
                    node.addEventListener('click', function () {
                        var categoryKey = brain.projectInputCategory.node.value,
                            key = brain.projectInputKey.node.value,
                            newKey;

                        if (validateNewKey(categoryKey) && validateNewKey(key)) {
                            // TODO default language
                            newKey = categoryKey + '_' + key;
                            _onCreateKey(newKey);
                        } else {
                            // TODO replace with classes
                            brain.projectInputCategory.node.classList.add('error');
                            brain.projectInputKey.node.classList.add('error');
                        }
                    });
                }
            };
        }()
    },
        fc = {
        /**
         *
         * @returns {{rowPrefix: string, inputPrefix: string, inputTransPrefix: string}}
         */
        get config() {
            return conf;
        },
        enableEditorMode: function enableEditorMode(enable) {
            if (enable) {
                rootNode.classList.add('c-enableEditorMode');
            } else {
                rootNode.classList.remove('c-enableEditorMode');
            }
        },
        toggleWordCount: function toggleWordCount(enable) {
            rootNode.classList.toggle('c-wordCountEnabled', enable);
        },
        sendSuccess: ui.sendSuccess,
        add: function add(node, attr) {
            if (attr === 'main') {
                rootNode = node;
            } else if (brain.hasOwnProperty(attr)) {
                brain[attr].init(node);
            }
        },
        getViewKeyObject: function getViewKeyObject(obj) {
            var newKey,
                contextName = null,
                delimiter = '_';
            if (/\./.test(obj.key)) {
                delimiter = '.';
            }

            newKey = obj.key.split(delimiter);

            if (newKey.length > 1) {
                // use slice if we need the complete key in the view
                contextName = newKey.splice(0, 1)[0];
            }
            return {
                id: obj.key, // deprecated
                key: obj.key,
                contextName: contextName,
                keyName: newKey.join(delimiter),
                value: obj.value
            };
        },
        isBundleEqual: function isBundleEqual(bundle1, bundle2) {
            if (bundle1.bundle === bundle2.bundle && bundle1.locale === bundle2.locale) {
                return true;
            }
            return false;
        },
        getBundleNameFrom: function getBundleNameFrom() {

            return {
                bundle: domOpts.params.bundle || 'messages',
                locale: this.getFromParam()
            };
        },
        getFromParam: function getFromParam() {
            return domOpts.params.from || 'de';
        },
        getBundleNameTo: function getBundleNameTo() {

            return {
                bundle: domOpts.params.bundle || 'messages',
                locale: domOpts.params.to || null
            };
        },
        getBundleName: function getBundleName(locale) {
            var bundle = domOpts.params.bundle || 'messages';
            return bundle + '_' + locale;
        },
        /**
         * Render the i18n input field for keys from a single language. The row header (i.e. the actual key field) is
         * rendered, too if it does not exist yet.
         * @param bundles {key: string, data: string}
         * @param actualLanguage
         * @param availableProjectLanguages
         * @param projectName
         */
        printBundleTemplate: function printBundleTemplate(bundles, actualLanguage, availableProjectLanguages, cb) {
            var keyObj,
                projectNode,
                shownCategories = [].slice.call(rootNode.querySelectorAll('.categoryNode'));
            /**
             * Setup header and handle the category
             *
             * @param {string} contextName
             * @returns {HTMLElement}
             */
            function prepareCategoryNode(contextName, languages) {
                var categoryNode = document.getElementById(conf.rowPrefix + contextName);
                if (!categoryNode) {
                    categoryNode = document.querySelector('#templates .categoryNode').cloneNode(true);
                    categoryNode.classList.add('c-anchorMenu-parent');
                    var categoryName = contextName;
                    var categoryNodeId = categoryName;
                    categoryNode.setAttribute('id', conf.rowPrefix + categoryNodeId);
                    if (categoryName) {
                        var wrapper = categoryNode.querySelector('.headlineWrapper'),
                            h2 = categoryNode.querySelector('h2');
                        // TODO make a span for it
                        h2.appendChild(function () {
                            var span = document.createElement('span');
                            span.appendChild(document.createTextNode(categoryName));
                            span.className = 'keyName';
                            return span;
                        }());
                        h2.addEventListener('click', function (event) {
                            onQueues.categoryClicked.forEach(function (fc) {
                                fc(categoryNodeId);
                            });
                        });

                        var editPanel = inputEditManager.addEditorPanel(categoryNode, {
                            onEdit: function onEdit(event) {
                                event.stopImmediatePropagation();
                                keyInputNode.removeAttribute('disabled');
                                contextName = keyInputNode.value;
                                keyInputNode.focus();
                            },
                            onCancel: function onCancel(event) {
                                event.stopImmediatePropagation();
                                keyInputNode.setAttribute('disabled', 'true');
                                keyInputNode.value = contextName;
                            },
                            onSave: function onSave(event) {
                                event.stopImmediatePropagation();
                                onQueues.renameCategory.forEach(function (fc) {
                                    fc({
                                        oldName: contextName,
                                        newName: keyInputNode.value
                                    });
                                });
                            },
                            onDelete: function onDelete(event) {
                                event.stopImmediatePropagation();
                                var yes = window.confirm('Delete this category?\nAll keys within with will be lost.');
                                if (yes) {
                                    onQueues.removeCategory.forEach(function (fc) {
                                        fc({
                                            category: categoryName
                                        });
                                    });
                                }
                            }
                        });
                        wrapper.appendChild(editPanel);

                        var keyInputNode = domOpts.createElement('input', conf.rowPrefix + categoryName + '_input', 'categoryField');
                        keyInputNode.setAttribute('disabled', 'true');
                        keyInputNode.addEventListener('click', function (event) {
                            event.stopImmediatePropagation();
                        });
                        keyInputNode.addEventListener('keypress', keyKeyPressListener);
                        h2.appendChild(keyInputNode);
                        keyInputNode.value = categoryName;

                        // add the description functionality
                        var catDescNode = categoryNode.querySelector('.js-cat-description');
                        var span = document.createElement('span');
                        span.className = 'js-text';
                        catDescNode.appendChild(span);
                        if (catDescNode) {
                            canny.textEditor.add(catDescNode, {
                                id: categoryName,
                                placeholder: 'Add here the category description'
                            });
                            canny.translationViewImageUpload.add(categoryNode.querySelector('.js-imageUpload-editButton'), categoryName);
                        }
                        // add add key input field and button
                        var keyNameInput = categoryNode.querySelector('.addNewKeyrow input');
                        keyNameInput.setAttribute('category', categoryName);
                        keyNameInput.addEventListener('keypress', keyKeyPressListener);
                        categoryNode.querySelector('label').innerText = categoryName + "_";
                        var button = categoryNode.querySelector('button');
                        button.addEventListener('click', function () {
                            if (validateNewKey(keyNameInput.value)) {
                                var newKey = keyNameInput.getAttribute('category') + '_' + keyNameInput.value;
                                // TODO refactor this - server should add the key for all available languages - or pass default lang
                                _onCreateKey(newKey, actualLanguage);
                            } else {
                                button.style.color = '#ff0000';
                                keyNameInput.style.backgroundColor = "#ff4444";
                            }
                        });
                    }

                    // add overall word count for each language of a category
                    var overallWordsWrapper = categoryNode.querySelector('.overallWordCountWrapper'),
                        overallHeadline = overallWordsWrapper.querySelector('.overallWordsHeadline'),
                        countersWrapper = overallWordsWrapper.querySelector('.translationContainer');
                    overallHeadline.innerHTML = getWordCountHeadline(categoryName);
                    languages.forEach(function (lang) {
                        countersWrapper.appendChild(createWordCountForLanguage(lang));
                    });
                }
                return categoryNode;
            };

            bundles.forEach(function (data) {
                keyObj = fc.getViewKeyObject(data);
                // TODO which who calc the cate...
                projectNode = prepareCategoryNode(keyObj.contextName, availableProjectLanguages);
                insertCategory(projectNode, shownCategories);
                fc.addRowWithLanguages(projectNode, keyObj, actualLanguage, availableProjectLanguages);
                cb(projectNode.getAttribute('id').replace(conf.rowPrefix, ''));
                cb(keyObj.key);
            });
        },
        /**
         * Update the word count for a given category
         * @param data
         */
        updateCategoryWordCount: function updateCategoryWordCount(data) {
            var label = document.querySelector('#' + conf.rowPrefix + data.id + ' .overallWordCountWrapper .js_' + data.language + ' .wordCountLabel');
            if (label) {
                label.innerHTML = getWordCountText(data.words);
            }
        },
        /**
         * creates a key field
         *
         * @param node
         * @param data
         */
        addKeyField: function addKeyField(node, data) {
            var keyInputNode = document.getElementById(conf.inputPrefix + data.key),
                keyNode;
            if (!keyInputNode) {
                keyInputNode = domOpts.createElement('input', conf.inputPrefix + data.key, 'keyField');
                keyNode = domOpts.createElement('div', null, 'data key octicon octicon-key');
                keyInputNode.setAttribute('disabled', 'true');
                inputEditManager.addEditorPanel(keyNode, {
                    onDelete: function onDelete() {
                        var yes = window.confirm('Delete this key?\nThis key with all translations will removed.');
                        if (yes) {
                            onQueues.removeKey.forEach(function (fc) {
                                fc({
                                    key: data.key
                                });
                            });
                        }
                    },
                    onEdit: function onEdit() {
                        keyInputNode.removeAttribute('disabled');
                        // save actual key for restoring if cancel
                        data.keyName = keyInputNode.value;
                        // get the key: take id attribute and remove the value from it
                        data.key = keyInputNode.getAttribute('id').replace(conf.inputPrefix, '');
                        data.contextName = data.key.split('_')[0];
                        keyInputNode.focus();
                    },
                    onCancel: function onCancel() {
                        keyInputNode.setAttribute('disabled', 'true');
                        keyInputNode.value = data.keyName;
                    },
                    onSave: function onSave() {
                        console.log('translationView:addKeyField save new key');
                        var value = data.contextName ? data.contextName + '_' + keyInputNode.value : keyInputNode.value;
                        if (keyInputNode.value != '' && value != data.key) {
                            onQueues.renameKey.forEach(function (fc) {
                                fc({
                                    newKey: value,
                                    oldKey: data.key
                                });
                            });
                        }
                    },
                    onClone: function onClone() {
                        brain.cloneKeyOverlay.setData(data);
                        displayManager.show('translationViewCloneKey');
                    }
                });
                // register the input key listener to capture wrong character
                keyInputNode.addEventListener('keypress', keyKeyPressListener);
                keyNode.appendChild(function () {
                    var span = document.createElement('span');
                    span.appendChild(document.createTextNode(data.keyName));
                    span.className = 'keyName';
                    return span;
                }());

                keyNode.appendChild(keyInputNode);
                node.insertBefore(keyNode, node.children[0]);
                keyInputNode.value = data.keyName;
            }
        },
        /**
         * Call this to update/create a language field
         * @param node
         * @param key
         * @param value
         * @param lang
         * @param wordCount
         */
        addLanguageField: function addLanguageField(node, key, value, lang, wordCount, posIndex) {

            var textNode = document.getElementById(getLanguageTextId(key, lang)),
                dataNode,
                wordCountNode,
                charCountNode,
                nbspNode,
                textInformationNode;

            if (!textNode) {
                textNode = domOpts.createElement('textarea', getLanguageTextId(key, lang), 'textField');
                dataNode = domOpts.createElement('div', null, 'data tpl js_' + lang);
                textInformationNode = domOpts.createElement('div', null, 'textInformation');
                wordCountNode = domOpts.createElement('span', null, 'textInformation-wordCountLabel');
                charCountNode = domOpts.createElement('span', null, 'textInformation-charCountLabel');
                wordCountNode.innerHTML = getWordCountText(0);
                nbspNode = domOpts.createElement('div', null, 'textInformation-nbspSwitch octicon octicon-issue-opened');
                nbspNode.setAttribute('title', 'There is at least one non-breaking space in this translation. Click to highlight.');

                textInformationNode.appendChild(flag.getFlag(lang));
                textInformationNode.appendChild(wordCountNode);
                textInformationNode.appendChild(nbspNode);
                textInformationNode.appendChild(charCountNode);

                nbspNode.addEventListener('click', function () {
                    var start = textNode.value.indexOf('\xA0');
                    textNode.focus();
                    textNode.setSelectionRange(start, start + 1);
                    this.classList.add('active');
                });

                textNode.addEventListener('blur', function (event) {
                    nbspNode.classList.remove('active');
                });

                textNode.addEventListener('keyup', function () {
                    charCountNode.innerHTML = getCharacterCount(this.value);
                    wordCountNode.innerHTML = getWordCountText(wordCounter.countWordsInString(this.value));
                    if (checkOnNBSP(this.value)) {
                        // nbspNode.classList.add('show');
                        textNode.parentElement.classList.add('has-nbsp');
                    } else {
                        // nbspNode.classList.remove('show');
                        textNode.parentElement.classList.remove('has-nbsp');
                    }
                });

                textNode.setAttribute('type', 'text');

                new SaveOnLeave(textNode, key, lang, value);

                dataNode.appendChild(textNode);
                dataNode.appendChild(textInformationNode);

                node.insertBefore(dataNode, node.children[posIndex]);
            } else {
                wordCountNode = textNode.parentElement.querySelector('.textInformation-wordCountLabel');
                charCountNode = textNode.parentElement.querySelector('.textInformation-charCountLabel');
                nbspNode = textNode.parentElement.querySelector('.textInformation-nbspSwitch');
            }

            if (value || value === '') {
                textNode.value = value ? unicode.encode(value) : '';
                wordCountNode.innerHTML = getWordCountText(wordCounter.countWordsInString(value));
                charCountNode.innerHTML = getCharacterCount(value);
                checkOnNBSP(textNode.value) ? textNode.parentElement.classList.add('has-nbsp') : textNode.parentElement.classList.remove('has-nbsp');
            }

            function checkOnNBSP(text) {
                return (/\u00A0/.test(text)
                );
            }
        },
        /**
         * creates a row
         * @param {HTMLElement} node
         * @param {string} key
         * @returns {HTMLElement} the existing row or in case if not exists a new created row
         */
        getRow: function getRow(node, key) {
            // try to get the row
            var row = document.getElementById(conf.rowPrefix + key),
                translationContainer = row !== null ? row.querySelector('.translationContainer') : document.createElement('div');

            translationContainer.className = "translationContainer";

            // if there is a row but it is marked as removed than removed it
            if (row && row.classList.contains('c-removed')) {
                row.domRemove();
                row = undefined;
            }
            // create a row if the row is not exists
            if (!row) {
                row = domOpts.createElement('div', conf.rowPrefix + key, 'row c-row c-anchorMenu-child');
                // add the description functionality
                var catDescNode = document.createElement('div');
                var span = document.createElement('span');
                span.className = 'js-text';
                catDescNode.appendChild(span);
                catDescNode.className = 'js-row-description';
                row.appendChild(catDescNode);
                canny.textEditor.add(catDescNode, { id: key, placeholder: 'Add here the key description' });

                // add the translation area field container
                row.appendChild(translationContainer);
                node.querySelector('.keysWrapper').appendChild(row);
            }
            return row;
        },
        addRowWithLanguages: function addRowWithLanguages(node, data, actualLanguage, allProjectLanguages) {
            var row = fc.getRow(node, data.key);

            fc.addKeyField(row, data);

            allProjectLanguages.forEach(function (lang) {
                fc.addLanguageField(row.querySelector('.translationContainer'), data.key, actualLanguage === lang ? data.value : null, lang);
            });
        },
        addLanguage: function addLanguage(keys, lang, posIndex) {
            var row,
                categories = [],
                currentCategory;
            keys.forEach(function (key) {
                row = document.getElementById(conf.rowPrefix + key);
                if (row) {
                    fc.addLanguageField(row.querySelector(".translationContainer"), key, null, lang, 0, posIndex);

                    currentCategory = key.split('_')[0];
                    if (categories.indexOf(currentCategory) === -1) {
                        categories.push(currentCategory);
                    }
                } else {
                    console.log('translationView:addLanguage found key which is not available in view:', key);
                }
            });

            categories.forEach(function (category) {
                var overallWordCount = document.querySelector('#' + conf.rowPrefix + category + ' .overallWordCountWrapper .translationContainer');
                overallWordCount.appendChild(createWordCountForLanguage(lang));
            });
        },
        clearView: function clearView() {
            // just reset all for now
            // TODO do it better ;)
            [].slice.call(rootNode.children).forEach(function (child) {
                rootNode.removeChild(child);
            });
        },
        showLang: function showLang(lang) {
            // show the lang tab
            rootNode.classList.remove('c-hide_' + lang);
        },
        /**
         * remove a category
         * TODO it's not called if own user renames a category
         */
        renameCategory: function renameCategory(oldName, newName, availableProjectLanguages) {
            var categoryNode = document.getElementById(conf.rowPrefix + oldName),
                rows = categoryNode.querySelectorAll('.c-row'),
                headline = categoryNode.querySelector('h2'),
                addKeyNode = categoryNode.querySelector('.addNewKeyrow');

            categoryNode.id = conf.rowPrefix + newName;

            headline.querySelector('.keyName').childNodes[0].nodeValue = newName;

            addKeyNode.querySelector('label').innerHTML = newName + '_';
            addKeyNode.querySelector('input').setAttribute('category', newName);

            [].slice.call(rows).forEach(function (row) {
                var id = row.id.replace(conf.rowPrefix, ''),
                    splitName = id.split('_'),
                    newKeyName;

                splitName.shift();
                newKeyName = newName + '_' + splitName.join('_');
                if (id !== '') {
                    renameDOMIds(id, newKeyName, availableProjectLanguages);
                } else {
                    console.error('translationView:renameCategory should not hav an empty id', row);
                }
            });
            inputEditManager.closeEditView(headline);
            headline.querySelector('.categoryField').setAttribute('disabled', 'true');
        },
        /**
         * remove a category
         */
        removeCategory: function removeCategory(cat) {
            var row = document.getElementById(conf.rowPrefix + cat);
            if (row) {
                row.domRemove();
            }
        },
        /**
         * show a key as deleted
         * @param key
         */
        markKeyAsRemoved: function markKeyAsRemoved(key) {
            var row = document.getElementById(conf.rowPrefix + key),
                removeIc;
            if (row && !row.classList.contains('c-removed')) {
                row.classList.add('c-removed');
                removeIc = domOpts.createElement('div', null, 'remove-button octicon octicon-x');
                removeIc.addEventListener('click', function () {
                    row.domRemove();
                });
                removeIc.domAppendTo(row);
                removeEventListenersFromRow(row);
                inputEditManager.removePanel(row);
            } else {
                console.error('translationView:markkeyAsRemoved no node found for key', key, row);
            }
        },
        /**
         * remove a key
         */
        removeKey: function removeKey(key) {
            var row = document.getElementById(conf.rowPrefix + key);
            if (row) {
                row.domRemove();
            }
        },
        /**
         * rename a key
         *
         * @param oldKey
         * @param newKey
         * @param availableProjectLanguages []
         */
        renameKey: function renameKey(oldKey, newKey, availableProjectLanguages) {
            var keyInputNode = document.getElementById(conf.inputPrefix + oldKey),
                keyName;

            if (keyInputNode) {
                keyName = fc.getViewKeyObject({ key: newKey }).keyName;
                renameDOMIds(oldKey, newKey, availableProjectLanguages);
                keyInputNode.value = keyName;
                // close the edit view
                inputEditManager.closeEditView(keyInputNode);
                // disabled the input field
                keyInputNode.setAttribute('disabled', 'true');
                keyInputNode.parentNode.querySelector('.keyName').childNodes[0].nodeValue = keyName;
            }
        },
        removeImage: function removeImage(categoryName) {
            var imageBox = rootNode.querySelector('#' + conf.rowPrefix + categoryName + ' .imageUpload-imageBox');
            while (imageBox.firstChild) {
                imageBox.removeChild(imageBox.firstChild);
            }
            imageBox.classList.remove('c-show');
        },
        hideLang: function hideLang(lang) {
            rootNode.classList.add('c-hide_' + lang);
        },
        onCreateNewProject: function onCreateNewProject(cb) {
            onQueues.createNewProject.push(cb);
        },
        onCategoryClicked: function onCategoryClicked(cb) {
            onQueues.categoryClicked.push(cb);
        },
        onAddNewKey: function onAddNewKey(cb) {
            onQueues.addNewKey.push(cb);
        },
        onRenameKey: function onRenameKey(cb) {
            onQueues.renameKey.push(cb);
        },
        onRemoveKey: function onRemoveKey(cb) {
            onQueues.removeKey.push(cb);
        },
        onRemoveCategory: function onRemoveCategory(cb) {
            onQueues.removeCategory.push(cb);
        },
        onRenameCategory: function onRenameCategory(cb) {
            onQueues.renameCategory.push(cb);
        },
        /**
         * Set logic for handling saving changes to a key.
         * @param func
         */
        onSaveKey: function onSaveKey(func) {
            _onSaveKey = func;
        },
        /**
         * Set logic for handling saving changes to a key.
         * @param func
         */
        onCreateKey: function onCreateKey(func) {
            _onCreateKey = func;
        },
        onCloneKey: function onCloneKey(func) {
            _onCloneKey = func;
        },
        registerWhisker: function registerWhisker(fc) {
            renderTextFc = fc;
        }
    };
    return fc;
}();

module.exports = translationView;

},{"../util/wordCounter":59,"./flag.js":34,"./inputEditManager.js":36,"canny":71}],54:[function(require,module,exports){
'use strict';

var node;
module.exports = {
    add: function add(elem, attr) {
        node = elem;
    },
    addDescriptions: function addDescriptions(keyDescriptions) {
        Object.keys(keyDescriptions).forEach(function (key) {
            var parent = document.getElementById(key),
                child;
            if (parent) {
                child = parent.querySelector('.js-text');
                if (child) {
                    child.innerHTML = keyDescriptions[key];
                }
            }
        });
    }
};

},{}],55:[function(require,module,exports){
'use strict';

/**
 * is for the translation view to add the image upload button and show the images
 */
var rootNode,
    _onUploadButton = function onUploadButton() {
    console.warn('translationViewImageUpload::onUploadButton() not implemented.');
},
    _onDeleteButton = function onDeleteButton() {
    console.warn('translationViewImageUpload::onDeleteButton() not implemented.');
};

function uploadButton(id) {
    var node = document.createElement('div');
    node.className = 'upload-btn octicon octicon-cloud-upload';
    node.addEventListener('click', function () {
        _onUploadButton(id);
    });
    node.setAttribute('title', 'upload a image file');
    return node;
}

function editPanel(id) {
    var deleteBtn = document.createElement('div'),
        editBtn = document.createElement('div'),
        cancelBtn = document.createElement('div'),
        panelWrap = document.createElement('div');

    panelWrap.className = 'imageUpload-imageBox-editPanel';
    editBtn.className = 'edit-btn octicon octicon-pencil';
    editBtn.addEventListener('click', function () {
        panelWrap.classList.add('c-edit');
    });
    cancelBtn.className = 'cancel-btn octicon octicon-x';
    cancelBtn.addEventListener('click', function () {
        panelWrap.classList.remove('c-edit');
    });
    deleteBtn.className = 'delete-btn octicon octicon-trashcan';
    deleteBtn.addEventListener('click', function () {
        _onDeleteButton(id);
    });

    deleteBtn.setAttribute('title', 'remove image');
    cancelBtn.setAttribute('title', 'cancel');
    editBtn.setAttribute('title', 'edit');

    panelWrap.appendChild(editBtn);
    panelWrap.appendChild(cancelBtn);
    panelWrap.appendChild(deleteBtn);
    return panelWrap;
}

function getImage(file) {
    var img = new Image();
    img.src = file;
    img.addEventListener('click', function () {
        var win = window.open(file, '_blank');
        win.focus();
    });
    return img;
}

function addImageContent(id, img) {
    var node = document.createElement('div'),
        resizeAble = document.createElement('div');
    resizeAble.className = 'imageUpload-imageBox-resizeable';
    node.className = 'imageUpload-imageBox-content';
    resizeAble.appendChild(img);
    node.appendChild(resizeAble);
    node.appendChild(editPanel(id));
    return node;
}

module.exports = {
    onUploadButton: function onUploadButton(fc) {
        _onUploadButton = fc;
    },
    onDeleteButton: function onDeleteButton(fc) {
        _onDeleteButton = fc;
    },
    add: function add(node, attr) {
        node.appendChild(uploadButton(attr));
    },
    appendImage: function appendImage(id, url) {
        var dom = document.getElementById('tv_' + id),
            imgContainer;
        if (dom) {
            imgContainer = dom.querySelector('.js-imageUpload-box');
            if (imgContainer) {
                [].slice.call(imgContainer.children).forEach(function (n) {
                    n.remove();
                });
                imgContainer.classList.add('c-show');
                imgContainer.appendChild(addImageContent(id, getImage('/images' + url)));
            }
        }
    }
};

},{}],56:[function(require,module,exports){
'use strict';

/**
 * shows the uploader form to upload a image to the server
 */
var _onUpload = function onUpload() {},
    brain = {
    fileInput: {
        init: function init(node) {
            node.addEventListener('change', upload);
        }
    }
};

function upload() {
    console.log('c-upload:trigger upload');
    var file = this.files[0];
    if (file) {
        // send it direct after drop
        [].slice.call(this.files).forEach(function (file) {
            // TODO instead pass  directly a array of files - so we save POST calls
            _onUpload(file);
        });
        // cleanup value otherwise file with same name can't uploaded again
        this.value = null;
        return false;
    }
}
/**
 *
 * @returns {{add: Function, ready: Function}}
 */
module.exports = {
    onUpload: function onUpload(fc) {
        _onUpload = fc;
    },
    add: function add(node, attr) {
        if (brain.hasOwnProperty(attr)) {
            brain[attr].init(node);
        }
    }
};

},{}],57:[function(require,module,exports){
'use strict';

var unicode = function () {

    String.prototype.getEachChar = function (cb) {
        var newString = this;
        for (var i = 0; i < newString.length; i++) {
            newString[i] = cb(newString[i]);
        }
        return newString.toString();
    };
    var reg = new RegExp('\\\\u([0-9a-fA-F]{4})', "g");
    return {
        encode: function encode(string) {
            if (!string) {
                return '';
            }
            var newstring = string.replace(reg, function (match, submatch) {
                return String.fromCharCode(parseInt(submatch, 16));
            });
            return newstring;
        },
        decode: function decode(string) {
            return string.getEachChar(function (c) {
                for (var i = 0; i < table.length; i++) {
                    if (table[i] == c) {
                        console.log('found:' + table[i]);
                        return table[i];
                    }
                }
                return c;
            });
        }

    };
}();

module.exports = unicode;

var table = ['\xC0', '\xC1', '\xC2', '\xC3', '\xC4', '\xC5', '\xC6', '\xC7', '\xC8', '\xC9', '\xCA', '\xCB', '\xCC', '\xCD', '\xCE', '\xCF', '\xD0', '\xD1', '\xD2', '\xD3', '\xD4', '\xD5', '\xD6', '\xD8', '\xD9', '\xDA', '\xDB', '\xDC', '\xDD', '\xDE', '\xDF', '\xE0', '\xE1', '\xE2', '\xE3', '\xE4', '\xE5', '\xE6', '\xE7', '\xE8', '\xE9', '\xEA', '\xEB', '\xEC', '\xED', '\xEE', '\xEF', '\xF0', '\xF1', '\xF2', '\xF3', '\xF4', '\xF5', '\xF6', '\xF8', '\xF9', '\xFA', '\xFB', '\xFC', '\xFD', '\xFE', '\xFF'];

},{}],58:[function(require,module,exports){
'use strict';

function getAnchor() {
    var href = location.href;
    if (/#/.test(href)) {
        return '#' + location.href.replace(/.*#/, '');
    }
    return '';
}

module.exports = {
    getAnchor: getAnchor,
    hasAnchor: function hasAnchor() {
        return getAnchor() !== '';
    }
};

},{}],59:[function(require,module,exports){
'use strict';

var regExPunc = new RegExp(/([\.,\s!;?:\"]|\{(.*?)\})+/gi);

/**
 * Count amount of words in a given String
 * @param str
 * @returns Number
 */
module.exports.countWordsInString = function countWordsInString(str) {
    if (str) {
        return str.replace(regExPunc, ' ').trim().split(' ').length;
    }
    return 0;
};

},{}],60:[function(require,module,exports){
(function (global){(function (){
'use strict';

var objectAssign = require('object-assign');

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:
// NB: The URL to the CommonJS spec is kept just for tradition.
//     node-assert has evolved a lot since then, both in API and behavior.

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

// Expose a strict only variant of assert
function strict(value, message) {
  if (!value) fail(value, true, message, '==', strict);
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"object-assign":111,"util/":63}],61:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],62:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],63:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":62,"_process":116,"inherits":61}],64:[function(require,module,exports){
'use strict';
module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    if(a===b) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}

},{}],65:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],66:[function(require,module,exports){
var concatMap = require('concat-map');
var balanced = require('balanced-match');

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}


},{"balanced-match":64,"concat-map":76}],67:[function(require,module,exports){

},{}],68:[function(require,module,exports){
arguments[4][67][0].apply(exports,arguments)
},{"dup":67}],69:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    var copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        Buffer.from(buf).copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (var i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

}).call(this)}).call(this,require("buffer").Buffer)

},{"base64-js":65,"buffer":69,"ieee754":90}],70:[function(require,module,exports){
/*global base.cookieHandler, canny */

(function () {
    var DEFAULT_LIFETIME_AS_DAYS = 365 * 5,
        DEFAULT_PATH = '/';

    var cookieManager = {};

    /**
     * A cookie manager for handling cookies where the cookie value is a JSON-stringified object.
     *
     * For creating a session cookie (i.e. deleted when browser closes), add a null-valued domain property to
     * cookieAttributes.
     *
     * @param cookieName
     * @param cookieAttributes: an optional object where the properties are attributes of the cookie - expireDays,
     * domain, path (if any of those is left out defaults will be used).
     * @returns {{cookieName, store: store, storeAll: storeAll, getValue: getValue, getValues: getValues}}
     * @constructor
     */
    var CookieManager = function(cookieName, cookieAttributes) {

        var lifetimeAsDays = (function() {
            if (cookieAttributes && cookieAttributes.expireDays) {
                return cookieAttributes.expireDays;
            } else if (cookieAttributes && cookieAttributes.expireDays === null) {
                return null;
            } else {
                return DEFAULT_LIFETIME_AS_DAYS;
            }
        })();
        var domain = cookieAttributes && cookieAttributes.domain ?
            cookieAttributes.domain : cookieManager.computeCookieDomain(document.location.hostname, false);
        var path = cookieAttributes && cookieAttributes.path ?
            cookieAttributes.path : DEFAULT_PATH;

        function getCookieValues(cookieName) {
            var i, currentName, currentValue, decodedValue,
                allCookies = window.document.cookie.split(";"),
                cookieValue = {};
            for (i = 0; i < allCookies.length; i++) {
                currentName = allCookies[i].substr(0, allCookies[i].indexOf("="));
                currentName = currentName.replace(/^\s+|\s+$/g, "");
                if (currentName === cookieName) {
                    currentValue = allCookies[i].substr(allCookies[i].indexOf("=") + 1);
                    try {
                      cookieValue = JSON.parse(decodeURIComponent(currentValue));
                    } catch (err) {
                      cookieValue = decodeURIComponent(currentValue);
                    }

                }
            }
            return cookieValue;
        }

        function computeNewExpiryDateString() {
            var expiryDate = new Date();
            expiryDate.setDate(expiryDate.getDate() + lifetimeAsDays);
            return expiryDate.toUTCString();
        }

        /**
         * Update the *full* value of the cookie, incl. writing all other cookie attributes according to
         * configuration of cookie manager.
         * @param cookieValue an object where each own property is an entry in the cookie value.
         */
        function updateCookie(cookieValue) {
            var cookieParts = [
                cookieName + '=' + encodeURIComponent(JSON.stringify(cookieValue)),
                'path=' + path,
                'domain=' + domain
            ];
            if (lifetimeAsDays) {
                cookieParts.push('expires=' + computeNewExpiryDateString());
            }

            window.document.cookie = cookieParts.join(';');
        }

        /**
         * Merge new values into existing/old values.
         * @param newCookieValues an object holding all new cookie value entries (entries may already exist
         * in existingCookieValues)
         * @param existingCookieValues an object holding all existing cookie value entries.
         * @returns {*}
         */
        function mergeNewIntoOldValues(newCookieValues, existingCookieValues) {
            Object.keys(newCookieValues).forEach(function (key) {
                existingCookieValues[key] = newCookieValues[key];
            });
            return existingCookieValues;
        }

        function updateCookieValues(cookieValues) {
            var oldCookieValue = getCookieValues(cookieName);
            if (Object.keys(oldCookieValue).length === 0) {
                updateCookie(cookieValues);
            } else {
                updateCookie(mergeNewIntoOldValues(cookieValues, oldCookieValue));
            }
        }

        function isValidCookieValueEntries(entries) {
            return typeof entries === 'object' && Object.prototype.toString.call( entries ) !== '[object Array]';
        }

        return {
            get cookieName() { return cookieName; },
            /**
             *
             * @param key a key (String)
             * @param value a value, can be any type of object (incl. nested). value can be a JSON string but will
             *     *not*  be parsed.
             */
            store : function(key, value) {
                var newValue = {};
                newValue[key] = value;
                updateCookieValues(newValue);
            },
            /**
             *
             * @param entries an object where all own properties will be added to the cookie value (rules for values
             * from store function apply here as well). Existing entries will be overwritten. No object encoded as
             * Json string accepted, no Arrays either.
             */
            storeAll : function(entries) {
                if (!isValidCookieValueEntries(entries)) {
                    throw new TypeError('cookieManager.storeAll accepts only objects (incl. no arrays), parameter was "'
                        + entries + '"');
                }
                updateCookieValues(entries);
            },
            /**
             * Get the value of a single entry from the cookie.
             * @param key
             * @returns {*}
             */
            getValue : function(key) {
                return getCookieValues(cookieName)[key];
            },
            /**
             * Get all entries (as an object) from the cookie.
             * @returns {*}
             */
            getValues : function() {
                return getCookieValues(cookieName);
            }
            // if needed, add remove(key) and removeAll(keys) functions to the api
        };
    };

    /**
     * Factory function which produces a cookie manager for the given cookie name and config.
     * @param cookieName
     * @param cookieAttributes: see constructor documentation
     * @returns {CookieManager}
     */
    cookieManager.forCookie = function(cookieName, cookieAttributes) {
        return new CookieManager(cookieName, cookieAttributes);
    };

    /**
     *
     * @param cookieName the name of the cookie
     * @param cookieAttributes attributes of the cookie (but note that expires attributes cannot be overwritten, it will
     * be added to that object)
     * @returns {CookieManager}
     */
    cookieManager.forSessionCookie = function(cookieName, cookieAttributes) {
        cookieAttributes = cookieAttributes || {};
        cookieAttributes['expireDays'] = null;
        return new CookieManager(cookieName, cookieAttributes);
    };

    /**
     * Convenience factory function which produces a cookie manager for the standard GD cookie.
     * @param cookieAttributes: see constructor documentation
     * @returns {CookieManager}
     */
    cookieManager.forGDStandardCookie = function () {
        // TODO what is the name of the standard cookie?
        return new CookieManager('GD');
    };

    /**
     * Extracts the cookie domain from the given hostname.
     * @param hostname
     * @param includeSubDomains if true all subdomains will be omitted
     */
    cookieManager.computeCookieDomain = function(hostname, includeSubDomains) {
        if (hostname.indexOf('gameduell') !== -1 && !includeSubDomains) {
            var hostnameParts = hostname.split('.');
            for (var i = 0; i < hostnameParts.length; i++) {
                if (hostnameParts[i] === "gameduell") {
                    // some infos about the leading dot:
                    // http://stackoverflow.com/questions/9618217/what-does-the-dot-prefix-in-the-cookie-domain-mean
                    // tl;dr: an obsolete RFC defined that a domain with a leading dot would mean "allow for
                    // subdomains, too" IE8/9 are still affected. Others should just disregard the dot (as per newer
                    // RFC)
                    return '.' + hostnameParts.splice(i).join('.');
                }
            }
        }

        return hostname;
    };

    // export as module or bind to global
    if (typeof module !== 'undefined' && module.hasOwnProperty('exports')) {
        module.exports = cookieManager;
    } else {
        canny.add('cookieManager', cookieManager);
    }

}());

},{}],71:[function(require,module,exports){
/*global */
/*jslint browser: true*/
/**
 *
 * E.g.:
 *  canny-mod="moduleObj" canny-var="{'propertyKey':'value'}"
 *  canny-mod="moduleString" canny-var="button"
 *
 * Instead of canny-var you can use the module name to avoid conflicts like:
 * E.g.: canny-mod="mod1 mod2" canny-mod1={'foo':'123456', 'bar':'654321'} canny-mod2="mod2Property"
 *
 * ---------------------------------------------------------------------------- eightyfour
 */
(function (global) {
    "use strict";
    var canny = (function () {
        var readyQueue = [],
            readyQueueInit = false,
            moduleQueue = []; // save modules to call the ready method once

        /**
         * Find the single quotes and replace them with double quotes except string which
         * are part of the property string.
         *
         * @param string
         * @returns {string}
         */
        function escapeStringForJSON(string) {
            var s = string
                .replace(/\{\s*\'/g,'{"').replace(/\'\s*\}/g,'"}')
                .replace(/:\s*\'/g,':"').replace(/\'\s*:/g,'":')
                .replace(/,\s*\'/g,',"').replace(/\'\s*,/g,'",')
                .replace(/\[\s*\'/g,'["').replace(/\'\s*\]/g,'"]');
            return s;
        }

        function escapeStringForJSONArray(string) {
            var s = string
                .replace(/,\s*\'/g,',"').replace(/\'\s*,/g,'",')
                .replace(/\[\s*\'/g,'["').replace(/\'\s*\]/g,'"]');
            return s;
        }

        function callMethodQueue(queue) {
            (function reduce() {
                var fc = queue.pop();
                if (fc) {
                    fc();
                    reduce();
                } else {
                    queue = [];
                }
            }());
        }

        function parseNode(node, name, cb) {
            var that = this, gdModuleChildren = [].slice.call(node.querySelectorAll('[' + name + '-mod]')), prepareReadyQueue = {};

            gdModuleChildren.forEach(function (node) {
                var attribute = node.getAttribute(name + '-mod'), attr, viewPart, attributes, cannyVar;

                attributes = attribute.split(' ');

                attributes.forEach(function (moduleName) {
                    if (that[moduleName]) {
                        if (node.getAttribute(name + '-mod')) {
                            if (node.getAttribute(name + '-' + moduleName)) {
                                cannyVar = node.getAttribute(name + '-' + moduleName);
                            } else {
                                cannyVar = node.getAttribute(name + '-var');
                            }
                            if (cannyVar) {
                                // simple JSON test
                                if (/\{\s*\'|\".*:.*\}/.test(cannyVar)) {
                                    attr = escapeStringForJSON(cannyVar);
                                    // could be a JSON
                                    try {
                                        viewPart = JSON.parse(attr);
                                    } catch (ex) {
                                        console.error("canny can't parse passed JSON for module: " + moduleName, node);
                                    }
                                } else if (/\[\s*\'|\".*\'|\"\]/.test(cannyVar)) {
                                    attr = escapeStringForJSONArray(cannyVar);
                                    try {
                                        viewPart = JSON.parse(attr);
                                    } catch (ex) {
                                        console.error("canny can't parse passed JSON for module: " + moduleName, node);
                                    }
                                } else {
                                    viewPart = cannyVar;
                                }
                            }
                        }
                        // has module a ready function than save it for calling
                        if (that[moduleName].hasOwnProperty('ready')) {
                            // TODO or call it immediately?
                            prepareReadyQueue[moduleName] = that[moduleName].ready;
                        }
                        if (that.hasOwnProperty(moduleName)) {
                            that[moduleName].add(node, viewPart);
                        }
                    } else {
                        console.warn('canny parse: module with name ´' + moduleName + '´ is not registered');
                    }
                });
            });
            // add ready callback to moduleQueue
            Object.keys(prepareReadyQueue).forEach(function (name) {
                moduleQueue.push(prepareReadyQueue[name]);
            });
            cb && cb();
        }

        document.addEventListener('DOMContentLoaded', function cannyDomLoad() {
            document.removeEventListener('DOMContentLoaded', cannyDomLoad);

            parseNode.apply(canny, [document, 'canny']);

            callMethodQueue(moduleQueue);
            // call registered ready functions
            readyQueueInit = true;
            callMethodQueue(readyQueue);
        }, false);

        return {
            add : function (name, module) {
                var moduleApi = module;
                if (!this.hasOwnProperty(name)) {
                    if (typeof module === 'function') {
                        moduleApi = module(this); // initialize the module with the actual canny instance
                    }
                    this[name] = moduleApi;
                } else {
                    console.error('canny: Try to register module with name ' + name + ' twice');
                }
            },
            ready : function (fc) {
                if (!readyQueueInit) {
                    readyQueue.push(fc);
                } else {
                    fc();
                }
            },
            cannyParse : function (node, name, cb) {
                // TODO needs a callback
                if (typeof name === 'function') {
                    cb = name;
                    name = "canny";
                }
                parseNode.apply(this || canny, [node, name || 'canny', function () {
                    callMethodQueue(moduleQueue);
                    cb && cb();
                }]);
            }
        };
    }());
    // export as module or bind to global
    if (typeof module !== 'undefined' && module.hasOwnProperty('exports')) { module.exports = canny; } else {global.canny = canny; }
}(this));
},{}],72:[function(require,module,exports){
/*global canny */
/*jslint browser: true*/

/**
 * Required: 'canny' in global scope
 *
 * E.g.:
 * canny.async.load(URL, function (src) {
 *     node.innerHTML = src;
 *     // trigger canny parse to register canny on our new modules
 *     canny.cannyParse(node, function () {
 *         console.log('CANNY PARSE DONE');
 *     });
 * });
 *
 * Alternative you can just use loadHTML (scripts will automatically added and parsed by canny):
 * canny.async.loadHTML(node, {url : URL}, function () {
 *     console.log('kodos_load READY');
 * });
 *
 * Or directly as canny module:
 * <div canny-mod="async" canny-var="{'url':'/you/HTML/file.html'}"></div>
 *
 * TODO solve dependency problem to canny.
 *
 */
(function () {
    'use strict';
    var async = (function () {
        var filesToLoad = [],
            pushLoadCBs = [],
            ready = false;

        /**
         *
         * @param script
         * @param mediaURL
         * @param cb
         */
        function appendScript(script, mediaURL, cb) {
            var node = document.createElement('script'),
                src = script.getAttribute('src');
            // handle mediaURL and all relative script are loaded from the media URL string
            if (mediaURL && src[0] !== '/') {
                if (mediaURL[mediaURL.length - 1] !== '/') {
                    mediaURL += '/';
                }
                src = mediaURL + src;
            }
            node.type = "text/javascript";
            node.async = true;
            node.setAttribute('crossorigin', 'anonymous');
            node.setAttribute('src', src);
            node.addEventListener('load', cb, false);
            node.addEventListener('error', cb, true);
            document.head.appendChild(node);
        }

        /**
         *
         * @param scripts
         * @param mediaURL
         * @param cb
         */
        function appendScriptsToHead(scripts, mediaURL, cb) {
            var script, i, includesScripts = false,
                scriptCounter = (function () {
                    var count = 0;
                    return {
                        up : function () {count++; },
                        ready : function () {
                            count--;
                            if (count <= 0) {
                                cb();
                            }
                        }
                    };
                }());

            for (i = 0; i < scripts.length; i++) {
                script = scripts[i];
                if (script.getAttribute('src')) {
                    includesScripts = true;
                    scriptCounter.up();
                    appendScript(script, mediaURL, scriptCounter.ready);
                } else {
                    console.warn('async: found inline script tag!!!');
                }
            }

            if (scripts.length === 0 || includesScripts === false) {
                cb();
            }

        }

        /**
         * Parse the complete given DOM and prefix all relative href URL's with the given URL
         * All URL's are handled as relative if there starts not with a / or http:// or https://
         * TODO add support for URL's with a ./ or ../ and so on
         *
         * @param node parent element
         * @param mediaURL mediaPath to another server
         */
        function handleLinks(node, mediaURL) {
            Array.prototype.slice.call(node.querySelectorAll('link')).forEach(function (link) {
                var href = link.getAttribute('href');
                if (link.getAttribute('type') === 'text/css' && 
                        href !== undefined && 
                        href[0] !== '/' &&
                        !/^http:\/\/.*/.test(href) &&
                        !/^https:\/\/.*/.test(href)) {
                    if (mediaURL[mediaURL.length - 1] !== '/') {
                        mediaURL += '/';
                    }
                    href = mediaURL + href;
                    link.setAttribute('href', href);
                }
            })
        }

        /**
         *
         * @param node
         * @param attr {{url:string, mediaURL: string}}
         * @param cb
         */
        function loadHTML(node, attr, cb) {
            var template = document.createElement('template'),
                div = ('content' in template ? template : document.implementation.createHTMLDocument('main').body),
                body,
                scripts,
                // only parse if html and scripts are loaded (scripts has callbacks because there are needs to loaded asynchronous)
                handleCannyParse = (function (cb) {
                    var waitForScripts = true,
                        waitForHTML = true,
                        triggger = function () {
                            if (!waitForScripts && !waitForHTML) {
                                canny.cannyParse(node, cb); // init only canny own modules
                            }
                        };
                    return {
                        scriptReady : function () {
                            waitForScripts = false;
                            triggger();
                        },
                        htmlReady : function () {
                            waitForHTML = false;
                            triggger();
                        }
                    };
                }(function () {
                    cb(attr);
                }));

            load(attr.url, function (src) {
                var childs;
                if (src) {
                    div.innerHTML = src;
                    // if it is a template we need the content
                    body = 'content' in div ? div.content : div;
                    scripts = body.querySelectorAll('script');
                    childs = [].slice.call(body.childNodes);
                    appendScriptsToHead(scripts, attr.mediaURL, handleCannyParse.scriptReady);

                    if (attr.mediaURL) {
                        handleLinks(body, attr.mediaURL);
                    }
                    childs.forEach(function (child) {
                        if (!(child.tagName === 'SCRIPT' && child.getAttribute('src'))) {
                            node.appendChild(child);
                        }
                    });
                    handleCannyParse.htmlReady();
                } else {
                    console.warn('async: Loading async HTML failed');
                }
            });
        }
        /**
         * simple wrapper to load HTML files with GET
         * @param path
         * @param cb
         */
        function load(path, cb) {
            doAjax({
                method: 'GET',
                path: path,
                onSuccess: function (response) {
                    cb(response.responseText);
                }
            });
        }
        /**
         *
         * @param params {{
         *   noCache:boolean,
         *   method:string|POST(default),
         *   data:object|string,
         *   path:string,
         *   async:boolean|true(default),
         *   onRequest:function (will be called with the xmlHTTPRequest object quite close before the send method is called),
         *   onFailure:function,
         *   onSuccess:function,
         *   contentType:string|Content-Type(default),
         *   mimeType:string|text plain(default)
         * }}
         */
         function doAjax(params) {
            var call = new XMLHttpRequest();
            var url = params.path;
            if (params.method === 'GET' && typeof params.data === 'object') {
                for (var attr in params.data) {
                    url = url + ((/\?/).test(url) ? "&" : "?") + attr + "=" + params.data[attr];
                }
            }
            if (params.noCache) {
                url = url + ((/\?/).test(url) ? "&" : "?") + "ts=" + (new Date()).getTime();
            }
            params.method = params.method || 'POST';
            call.open(params.method, url, params.async !== false);

            if (params.onSuccess) {
                call.addEventListener("load", function (s) {
                    params.onSuccess(s.target);
                });
            }

            if (params.onFailure) {
                call.addEventListener("error", function (s) {
                    params.onFailure(s.target);
                });
            }

            call.setRequestHeader(params.contentType || "Content-Type", params.mimeType || "text/plain");

            // allow the caller to do some extra stuff on the request object
            if (params.onRequest && typeof params.onRequest === 'function') {
                params.onRequest(call);
            }

            if (params.method === 'POST') {
                call.send(params.data);
            } else {
                call.send(null);
            }
        }

        return {
            /**
             * add a callback. So you will be notified when files are loaded asynchronous.
             * You will be called only once except your return true then async will keep
             * your callback in the notifier list and you will be informed for each async request.
             *
             * The async module will call each callback with the actual attr. So you have the control
             * how often you will be notified.
             *
             * Might be changed in the future version of async:
             * Currently this is only executed for canny modules which are loaded from the DOM directly.
             *
             * @param fc
             */
            pushLoadCB : function (fc) {
                pushLoadCBs.push(fc);
            },
            /**
             * Do a simple ajax call.
             *
             * @param params {{
             *   noCache:boolean,
             *   method:string|POST(default),
             *   data:object,string,
             *   async:boolean|true(default),
             *   path:string,
             *   onRequest:function (will be called with the xmlHTTPRequest object quite close before the send method is called),
             *   onFailure:function,
             *   onSuccess:function,
             *   contentType:string|Content-Type(default),
             *   mimeType:string|text plain(default)
             * }}
             */
            doAjax: doAjax,
            /**
             *
             * @param node
             * @param attr {{
             *  url:string,
             *  mediaURL:string
             * }}
             * @param cb
             */
            loadHTML : loadHTML,
            /**
             * Deprecated: use loadHTML instead
             * @param path
             * @param cb
             */
            load: function () {
                console.warn('async:load function load is deprecated. Use loadHTML instead');
                load.apply(null, arguments);
            },
            /**
             * canny's add method
             *
             * @param node
             * @param attr
             */
            add: function (node, attr) {    // part of api
                // TODO implement logic for loading it directly from html
                if (attr.hasOwnProperty('url')) {
                    if (!ready) {
                        filesToLoad.push({
                            node: node,
                            attr: attr
                        });
                    } else {
                        loadHTML(node, attr);
                    }
                }
            },
            ready: function () {
                var obj, cbCount = filesToLoad.length;
                while (filesToLoad.length > 0) {
                    obj = filesToLoad.splice(0, 1)[0];
                    loadHTML(obj.node, obj.attr, function (attr) {
                        var keepPushCB = [], tmpCb;
                        cbCount--;
                        while (pushLoadCBs.length > 0) {
                            tmpCb = pushLoadCBs.splice(0, 1)[0];
                            if (tmpCb(attr) === true) {
                                keepPushCB.push(tmpCb);
                            }
                        }
                        pushLoadCBs = keepPushCB;
                    });
                }
            }
        };
    }());
    // export as module or bind to global
    if (typeof module !== 'undefined' && module.hasOwnProperty('exports')) {
        module.exports = async;
    } else {
        canny.add('async', async);
    }

}());
},{}],73:[function(require,module,exports){
/*global canny */
/*jslint browser: true*/

/**
 * E.g.: canny-mod="flowControl" canny-var="{'view' : 'viewName'}"
 *
 * you can activate a initial view with a anchor in the URL e.g.: yourdomain.html#viewToShow
 * Or pass a comma separated module list for activate more module #viewToShow,otherView.
 *
 * TODO made it possible to summarize views with one identifier.
 * Instead of call: canny.flowControl.show('view1', 'view2', 'view3') call canny.flowControl.show('view').
 *
 * TODO add a hide method that just hide the specific element.
 *
 * TODO handle the fade in and out via CSS classes - and use transitions for it
 */
(function () {
    "use strict";

    /**
     * wraps transitionend event vendor implementation
     */
    function onTransitionEndOnce(node, cb) {
        var event = (function () {
                if (node.style.webkitTransition !== undefined) {
                    return 'webkitTransitionEnd';
                } else if (node.style.transition !== undefined) {
                    return 'transitionend';
                }
            }()),
            listener = function(e) {
                e.target.removeEventListener(e.type, listener);
                cb(e);
            };
        if (event) {
            node.addEventListener(event, listener, false);
        } else {
            cb();
        }
    }

    var flowControlInstance = function (fcInstanceName) {
            var instanceName = fcInstanceName,
                // flag to save if the initial queue is already initialized or not
                showInitialViewComplete = false,
                onShowInitialViewComplete = [],
                modViews = {}, // saves module views
                getViewAnchor = function () {
                    var hash = location.hash || null,
                        rx = new RegExp('[^a-zA-Z-_,]', 'g'),
                        hashSub;

                    if (hash) {
                        hashSub = hash.substr(1);
                        if (hashSub.search(rx) > -1) {
                            hashSub = hashSub.substring(0, hashSub.search(rx));
                        }
                        return hashSub.split(',');
                    }

                    return hash;
                },
                getAllModuleChildrens = function (cNode) {
                    // TODO test selector if we have more than one module in canny-mod
                    var children = cNode.querySelectorAll('[canny-mod*=' + instanceName + ']'),
                        fc_childNodes = {};
//                            if (cNode.hasChildNodes()) {
//                                [].slice.call(cNode.children).forEach(findChildren);
//                            }
                    [].slice.call(children).forEach(function (mod) {
                        var attrValue, view;
                        // TODO read attributes should be a part of canny functionality
                        attrValue = mod.getAttribute('canny-var').split("\'").join('\"');
                        if (/:/.test(attrValue)) {
                            // could be a JSON
                            view = JSON.parse(attrValue).view;
                        } else {
                            view = attrValue;
                        }
                        fc_childNodes[view] = mod;
                    });
                    return fc_childNodes;
                },
                /**
                 * Each flowControl node will end up in a flowControlModule.
                 *
                 * @param node
                 * @param attr
                 * @returns {{hasChildrenWithName: hasChildrenWithName, getViewName: getViewName, show: show, hide: hide, fadeOut: fadeOut, getNode: getNode, fadeIn: fadeIn}}
                 */
                flowControlModule = function (node, attr) {
                    var flowControlChildNodes = {},
                        async = false,
                        parentViews = fc.getParentNode(attr.view);
                    // saves all children in a object
                    flowControlChildNodes = getAllModuleChildrens(node);
//                    console.log('flowControlChildNodes:', flowControlChildNodes);
                    return {
                        hasChildrenWithName : function (viewName) {
                            return flowControlChildNodes.hasOwnProperty(viewName);
                        },
                        getViewName : function () {
                            return attr.view;
                        },
                        display : function () {
                            // don't call parents
                            // don't fade in
                            node.style.display = '';
                        },
                        show : function (cb) {
                            if (parentViews) {
                                parentViews.forEach(function (fc_module) {
//                                console.log('parentViews', fc_module.getViewName());
                                    fc_module.display();
                                });
                            }
                            if (!async && attr.hasOwnProperty('async')) {
                                canny.async.loadHTML(node, {url : attr.async}, function () {
                                    if (attr.whisker) {
                                        if (canny.whisker !== undefined) {
                                            canny.whisker.add(node, attr.whisker);
                                        } else {
                                            console.error("flowControl:try execute whisker but no whisker module is registered on canny.")
                                        }
                                    }
                                    node.style.display = '';
                                    cb();
                                });
                                async = true;
                            } else {
                                node.style.display = '';
                                cb && cb();
                            }
                        },
                        hide : function () {
                            node.style.display = 'none';
                        },
                        fadeOut : function (cb) {
                            fc.fadeOut(node, cb || function () {});
                        },
                        getNode : function () {
                            return node;
                        },
                        fadeIn : function (cb) {
                            if (parentViews) {
                                parentViews.forEach(function (fc_module) {
//                                console.log('parentViews', fc_module.getViewName());
                                    fc_module.display();
                                });
                            }
                            if (!async && attr.hasOwnProperty('async')) {
                                canny.async.loadHTML(node, {url : attr.async}, function () {
                                    if (attr.whisker) {
                                        if (canny.whisker !== undefined) {
                                            canny.whisker.add(node, attr.whisker);
                                        } else {
                                            console.error("flowControl:try execute whisker but no whisker module is registered on canny.");
                                        }
                                    }
                                    fc.fadeIn(node,  cb || function () {});
                                });
                                async = true;
                            } else {
                                fc.fadeIn(node,  cb || function () {});
                            }
                        }
                    };

                },
                showInitialView = getViewAnchor(),
                fc = {
                    // get all parent modules from the given viewName
                    getParentNode : function (viewName) {
                        var queue = Object.keys(modViews), l, i, parents = [];
                        l = queue.length;
                        for (i = 0; i < l; i++) {
                            // TODO
                            if (viewName !== queue[i] && modViews[queue[i]][0].hasChildrenWithName(viewName)) {
                                parents.push(modViews[queue[i]][0]);
                            }
                        }
                        return parents.length === 0 ? null : parents;
                    },
                    // passes a view list and complete the list with all parent node names
                    addParents : function (views) {
                        var extViews = views, i, l, pNode,
                            pushExtViews = function (name) {
                                if (extViews.indexOf(name) === -1) {
                                    extViews.push(name);
                                }
                            },
                            addParentView = function (viewName) {
                                // TODO call ends always with null - viewName is top parent
                                var pViewName = fc.getParentNode(viewName);
//                            console.log('viewName: ' + viewName, 'pViewName ' + pViewName );
                                if (pViewName) {
                                    pViewName.forEach(function (fc_module) {
                                        // TODO while has parent add it to the extViews
                                        pushExtViews(fc_module.getViewName());
                                        addParentView(fc_module.getViewName());
                                    });
                                }
                            };
                        l = views.length;
                        for (i = 0; i < l; i++) {
                            pNode = fc.getParentNode(views[i]);
                            if (pNode) {
                                pNode.forEach(function (fc_module) {
                                    pushExtViews(fc_module.getViewName());
                                    // so far we have parents do it recursive
                                    // TODO not needed each parent will do it by own -
                                    addParentView(fc_module.getViewName());
                                });
                            }
                        }
                        return extViews;
                    },
                    fadeOut : function (node, cb) {

                        if(node.style.display === 'none') {
                            cb();
                        } else {
                            node.classList.add('c-flowControl');
                            node.classList.add('fade-out');

                            setTimeout(function () {
                                node.style.display = 'none';
                                node.classList.remove('c-flowControl');
                                node.classList.remove('fade-out');
                                cb();
                            }, 300);
                        }

                    },
                    fadeIn : function (node, cb) {
                        // TODO: fade in does not work properly
                        node.style.display = '';
                        node.classList.add('c-flowControl');
                        node.classList.add('fade-in');

                        setTimeout(function() {
                            node.classList.remove('c-flowControl');
                            node.classList.remove('fade-in');
                            cb();

                            // trigger reflow to fix the black boxes issue FTTWO-1249
                            // TODO: check if this can be avoided or
                            var box = document.querySelector('.t-centerBox-content');
                            if (box) {
                                box.style.opacity = 0.99;
                                setTimeout(function() {
                                    box.style.opacity = 1;
                                }, 50);
                            }
                        }, 300);
                    }
                },
                ext = {
                    /**
                     *
                     * @param node
                     * @param innerNode
                     * @returns {{remove: remove}}
                     */
                    progress : function (node, innerNode) {
                        var newNode = document.createElement('div'), centerNode = document.createElement('div'), txtNode;
                        node.style.position = 'relative';
                        newNode.style.opacity = '0.6';
                        newNode.style.backgroundColor = '#666';
                        newNode.style.position = 'absolute';
                        newNode.style.top = 0;
                        newNode.style.left = 0;
                        newNode.style.width = node.offsetWidth + 'px';
                        newNode.style.height = node.offsetHeight + 'px';
                        newNode.style.borderRadius = window.getComputedStyle(node, null).borderRadius;

                        centerNode.style.position = 'absolute';
                        centerNode.style.top = (node.offsetHeight / 2) - 30 + 'px';
                        centerNode.style.width = node.offsetWidth + 'px';
                        centerNode.style.textAlign = 'center';

                        if (innerNode) {
                            centerNode.appendChild(innerNode);
                        }
                        node.appendChild(newNode);
                        node.appendChild(centerNode);
                        return {
                            remove : function (delay, cb) {
                                setTimeout(function () {
                                    node.removeChild(newNode);
                                    node.removeChild(centerNode);
                                    cb && cb();
                                }, delay || 0);
                            },
                            fadeOut : function (delay, cb) {
                                setTimeout(function () {
                                    fc.fadeOut(newNode, function () {
                                        node.removeChild(newNode);
                                        node.removeChild(centerNode);
                                        cb && cb();
                                    });
                                }, delay || 0);
                            }
                        };
                    }
                },
                /**
                 *
                 * @type {{mod: {}, createNewInstance: createNewInstance, ready: ready, add: add, show: show, fadeIn: fadeIn, showImmediately: showImmediately, overlay: overlay}}
                 */
                api = {
                    mod : modViews, // part of api
                    /**
                     * this method could be used to create new instances of flowControl (only needed if you
                     * load this script directly without require)
                     * @param name (unique module name)
                     **/
                    createNewInstance : function (name) {
                        return flowControl(name);
                    },
                    ready : function () {
                        var modNames = Object.keys(modViews),
                            callInitialViewCompleteQueue = true,
                            l = modNames.length,
                            i;
                        if (showInitialView && l > 0) {
                            // check if showInitialView contains a registered module
                            for (i = 0; i < l; i++) {
                                // check for existing name in showInitialView
                                if (showInitialView.indexOf(modNames[i]) !== -1) {
                                    showInitialView.push(function () {
                                        onShowInitialViewComplete.forEach(function(fc) {
                                            showInitialViewComplete = true;
                                            fc();
                                        });
                                    });
                                    callInitialViewCompleteQueue = false;
                                    api.showImmediately.apply(null, showInitialView);
                                    break;
                                }
                            }
                        }

                        if (callInitialViewCompleteQueue) {
                            onShowInitialViewComplete.forEach(function(fc) {
                                showInitialViewComplete = true;
                                fc();
                            });
                        }
                    },
                    /**
                     * Calls the given function after loading all initial views.
                     *
                     * @param fc
                     */
                    onShowInitialViewComplete : function(fc) {
                        // make sure that the passed function will be called also after initialisation
                        if (!showInitialViewComplete) {
                            onShowInitialViewComplete.push(fc);
                        } else {
                            fc();
                        }
                    },
                    /**
                     *
                     * @param node
                     * @param attr {{view:(identifier),}}
                     */
                    add : function (node, attr) {    // part of api
                        if (!modViews[attr.view]) {
                            modViews[attr.view] = [];
                        }
                        modViews[attr.view].push(flowControlModule(node, attr));
                    },
                    /**
                     * @deprecated will handle showImmediately in near future
                     */
                    show : function () {
                        api.fadeIn.apply(this, arguments);
                    },
                    /**
                     * @param name (arguments list of views to show)
                     */
                    fadeIn : function (name) {
                        var showMods = [].slice.call(arguments),
                            queue = Object.keys(modViews),
                            queueCount = 0,// = queue.length,
                            fadeIn = function () {
                                showMods.forEach(function (module) {
                                    if (modViews.hasOwnProperty(module)) {
                                        modViews[module].forEach(function (obj) {
                                            obj.fadeIn(function () {
                                                // TODO remove
//                                                console.log('FADE IN DONE');
                                                // TODO count callbacks and handle it ?
                                            });
                                        });
                                    }
                                });
                                // if last param is function than handle it as callback
                                if (typeof showMods[showMods.length - 1] === 'function') {
                                    showMods[showMods.length - 1]();
                                }
                            };
                        showMods = fc.addParents(showMods);
                        queue.forEach(function (view) {
                            queueCount += modViews[view].length;
                        });
                        // iterate over all registered modules
                        queue.forEach(function (view) {
                            // iterate over all instances of the same view
                            modViews[view].forEach(function (obj) {
                                // hide all (except incoming and parents) TODO but only the parents of the module
                                if (showMods.indexOf(view) === -1) {
                                    obj.fadeOut(function () {
                                        queueCount--;
                                        if (queueCount <= 0) {
                                            fadeIn();
                                        }
                                    });
                                } else {
                                    queueCount--;
                                    if (queueCount <= 0) {
                                        fadeIn();
                                    }
                                }
                            });
                        });
                    },
                    /**
                     * @deprecated use show instead
                     * @param name
                     */
                    showImmediately : function () {    // module specific
                        var showMods = [].slice.call(arguments),
                            queue = Object.keys(modViews),
                            countCb = (function () {
                                var cb, length = 0;
                                // if last param is function than handle it as callback
                                if (typeof showMods[showMods.length - 1] === 'function') {
                                    cb = showMods[showMods.length - 1];
                                }
                                return {
                                    countUp : function (num) {
                                        length += num;
                                    },
                                    reduce : function () {
                                        length--;
                                        if (cb && length <= 0) {
                                            cb();
                                        }
                                    }
                                };
                            }()),
                            show = function () {
                                showMods.forEach(function (module) {
                                    if (modViews.hasOwnProperty(module)) {
                                        countCb.countUp(modViews[module].length);
                                        modViews[module].forEach(function (obj) {
                                            obj.show(countCb.reduce);
                                        });
                                    }
                                });
                            };
                        showMods = fc.addParents(showMods);
                        // hide all (except incoming)
                        queue.forEach(function (view) {
                            modViews[view].forEach(function (obj) {
                                if (showMods.indexOf(obj) === -1) {
                                    obj.hide();
                                }
                            });
                        });
                        show();
                    },
                    overlay : function (name) {
                        var node;
                        // it's own module?
                        if (modViews.hasOwnProperty(name)) {
                            node = modViews[name].getNode();
                        } else {
                            node = document.getElementById(name);
                        }

                        return {
                            by : function (name, text) {
                                return ext[name](node, text);
                            }
                        };
                    }
                };
            return api;
        },
        flowControl = (function () {
            var instances = {};
            return function (name) {
                var instance,
                    def = name || 'flowControl';
                if (instances.hasOwnProperty(def)) {
                    instance = instances[def];
                } else {
                    instances[def] = flowControlInstance(def);
                    instance = instances[def];
                }
                return instance;
            };
        }());
    // export as module or bind to global
    if (typeof module !== 'undefined' && module.hasOwnProperty('exports')) { module.exports = flowControl; } else {canny.add('flowControl', flowControl('flowControl')); }

}());
},{}],74:[function(require,module,exports){
/*global canny */
/*jslint browser: true*/

/**
 * repeat
 *
 * E.g.
 *  <div canny-mod="repeat" canny-var="{'for':'item', 'in':'path.to.list'}">
 *     <p>DATA: {{item}})</p>
 *  </div>
 *  or:
 *  <div canny-mod="repeat" canny-var="{'for':'objectItem', 'in':'path.to.object'}">
 *     <p>DATA FOO: {{objectItem.foo}})</p>
 *     <p>DATA BAR: {{objectItem.bar}})</p>
 *  </div>
 *
 * for:
 * is the name of the iterating item to have access from the DOM.
 *
 * in:
 * is the source where repeat can find the array.
 * It accepts functions, array, and objects pointer
 * - object: keep in mind that object has no specific sorting
 * - array:
 * - function: repeat will call it with the following parameter:
 *  * function which needs to be called with the object or list
 *  * ...
 *
 *  TODO: add example to get data direct from
 *   * a list of function
 *   * a object which contain functions
 *
 */
(function () {
    'use strict';

    var openChar = '{',
        endChar  = '}',
        ESCAPE_RE = /[-.*+?^${}()|[\]\/\\]/g,
        repeat = (function () {
            var BINDING_RE = getRegex();

            /**
             *  Parse a piece of text, return an array of tokens
             *  TODO refactor method
             *  @param text
             *  @return [{key:String, html:boolean}]
             */
            function parse(text) {
                if (!BINDING_RE.test(text)) {return null; }
                var m, i, token, match, tokens = [], orig = {text: text, idx : 0}, textObject;
                /* jshint boss: true */
                while (m = text.match(BINDING_RE)) {
                    i = m.index;
                    token = {concat : true};
                    if (i > 0) {
                        if (orig.idx === 0) {
                            textObject = {
                                concat : orig.text[orig.idx - 1] !== ' ',
                                value : text.slice(0, i),
                                text : true
                            };
                            orig.idx += i;
                        } else {
                            orig.idx += i;
                            textObject = {
                                concat : orig.text[orig.idx - 1] !== ' ',
                                value : text.slice(0, i),
                                text : true
                            };
                        }
                        tokens.push(textObject);
                    }
                    orig.idx += i;
                    token.key = m[1].trim();
                    match = m[0];
                    token.html =
                        match.charAt(2) === openChar &&
                        match.charAt(match.length - 3) === endChar;
                    tokens.push(token);
                    text = text.slice(i + m[0].length);
                }
                if (text.length) {
                    tokens.push({value : text, text : true, concat: true});
                }
                return tokens;
            }
            /**
             *
             * @param node
             * @param dataObj
             * @param itemName
             * @return tokens [{key:String, node:DOM node, html: boolean}]
             */
            function compileTextNode(node, dataObj, itemName) {
                var tokens = parse(node.nodeValue),
                    obj = dataObj,
                    el, token, i, l, tmp, tokenObjectProperty, val;
                if (!tokens || obj === undefined) {return; }

                for (i = 0, l = tokens.length; i < l; i++) {
                    token = tokens[i];
                    if (typeof token === 'object' && token.hasOwnProperty('key')) {
                        tmp = token.key.split('.');

                        if (tmp.length > 0 && tmp[0] === itemName) {

                            if (tmp[0] !== itemName) {
                                // TODO implement error handling if key doesn't match with itemName
                                console.error('repeat:compileTextNode hups something is wrong which needs to be fixed!!! Token with name', token.key, 'doesn\'t match with scope name: ', itemName , ' Repeat will continue but be carefully this "bug" will be removed in next version of repeat!!!');
                            }

                            tokenObjectProperty = tmp.slice(1).join('.');
                            if (typeof obj === 'object') {
                                val = getGlobalCall(tokenObjectProperty, obj);
                            } else {
                                val = obj;
                            }
                        } else {
                            // just a string?
                            val = obj;
                        }
                        if (typeof val === 'string' || typeof val === 'number') {
                            el = document.createTextNode(val);
                            node.parentNode.insertBefore(el, node);
                        } else if (typeof val === 'boolean') {
                            el = document.createTextNode(val.toString());
                            node.parentNode.insertBefore(el, node);
                        } else if (typeof val === 'function') {
                            el = document.createTextNode(val(node.parentNode));
                            node.parentNode.insertBefore(el, node);
                        } else if (tmp[0] === itemName) {
                            // property is not exists but it is the same scope
                            el = document.createTextNode('');
                            node.parentNode.insertBefore(el, node);
                        } else {
                            // restore the token... looks like is not mine
                            el = document.createTextNode('{{' + token.key + '}}');
                            node.parentNode.insertBefore(el, node);
                        }
                        token.node = el;
                    } else {
                        el = document.createTextNode(token.value);
                        // just normal string put back to view
                        node.parentNode.insertBefore(el, node);
                    }
                }
                node.parentNode.removeChild(node);
                return tokens;
            }
            /**
             *
             * @param node
             * @param dataObj
             * @param itemName
             */
            function compileElement (node, dataObj, itemName) {
                // recursively compile childNodes
                if (node.hasChildNodes()) {
                    [].slice.call(node.childNodes).forEach(function (child) {
                        compile(child, dataObj, itemName);
                    });
                }
            }
            /**
             * Compile a DOM node (recursive)
             * @param node
             * @param dataObj
             * @param itemName
             * @returns {*}
             */
            function compile(node, dataObj, itemName) {
                var nodeType = node.nodeType;
                if (nodeType === 1 && node.tagName !== 'SCRIPT') { // a normal node
                    compileElement(node, dataObj, itemName);
                } else if (nodeType === 3) {
                    compileTextNode(node, dataObj, itemName);
                }

                return node;
            }

            /**
             * helper function to do the read variable from string magic.
             * The cb will called with the property value - in case of undefined the variable does not exists
             * @param node
             * @param attributeName
             * @param cb
             */
            function getLoopValueFromAttribute(node, obj, itemName, attributeName, cb) {
                var tmp = node.getAttribute(attributeName).split('.'), tokenObjectProperty;
                if (tmp.length > 0 && tmp[0] === itemName) {
                    tokenObjectProperty = tmp.slice(1).join('.');
                    cb(getGlobalCall(tokenObjectProperty, obj));
                } else {
                    // TODO handle this correctly
                    console.error('repeat:getLoopValueFromAttribute has problems');
                }
            }

            /**
             * register click events
             * 
             * @deprecated use rp-bind attribute
             * 
             * @param clone
             * @param item
             * @param itemName
             */
            function handleEvents(clone, obj, itemName) {
                var onClick = 'on-click';
                // check children of clone
                [].slice.call(clone.querySelectorAll('[' + onClick + ']')).forEach(function (node) {
                    getLoopValueFromAttribute(node, obj, itemName, onClick, function (val) {
                        if (typeof val === 'function') {
                            node.addEventListener('click', val);
                        } else {
                            console.log('repeat:can not register click listener without a function', node);
                        }
                    });
                });
            }

            /**
             * register rp-bind handler
             * 
             * With help of this the if and if-not and onClick attribute is deprecated - you can just pass a function 
             * pointer to rp-bind and do all the required logic by your own.
             * 
             * If you return false then the node will be removed from the DOM
             *
             * @param clone
             * @param obj
             * @param itemName
             */
            function handleRPBindAttribute(clone, obj, itemName) {
                var attrName = 'rp-bind';
                // check children of clone
                [].slice.call(clone.querySelectorAll('[' + attrName + ']')).forEach(function (node) {
                    getLoopValueFromAttribute(node, obj, itemName, attrName, function (val) {
                        if (typeof val === 'function') {
                            if (val(node) === false) {
                                // remove node if function returns false
                               node.parentNode.removeChild(node); 
                            }
                        } else {
                            console.error('repeat:can not register control function without a function pointer', node);
                        }
                    });
                });
            }

            /**
             * Replaces expressions for all tag attributes
             *
             * @param clone
             * @param obj
             * @param itemName (currently not in used but needs to be checked)
             */
            function handleAttributes(containerNode, obj, itemName) {
                var returnTokens = [];
                (function searchForExpressions(children) {
                    [].slice.call(children).forEach(function (node) {
                        var i, attr, rTokens;
                        if (node.children.length > 0) {
                            // do it recursive for all children
                            searchForExpressions(node.children);
                        }
                        // loop through each attribute
                        for (i = 0; i < node.attributes.length; i++) {
                            attr = node.attributes[i];
                            if (/\{\{/.test(attr.textContent)) {
                                if (attr.name) {
                                    rTokens = (function () {
                                        var token = parse(attr.textContent),
                                            endData = [], tmpToken, j, tmpTokenSplit, value;
                                        for (j = 0; j < token.length; j++) {
                                            tmpToken = token[j];
                                            // if token not itemName skipp all
                                            if (tmpToken.key !== undefined && tmpToken.key.split('.')[0] === itemName) {
                                                // save the attribute
                                                tmpToken.attr = attr;
                                                if (/\./.test(tmpToken.key)) {
                                                    tmpTokenSplit = tmpToken.key.split('.').slice(1).join('.');
                                                } else {
                                                    tmpTokenSplit = tmpToken.key;
                                                }
                                                if (typeof obj === 'object') {
                                                    tmpToken.value = getGlobalCall(tmpTokenSplit, obj);
                                                    if (typeof tmpToken.value === 'function') {
                                                        value = tmpToken.value();
                                                    } else {
                                                        value = tmpToken.value;
                                                    }
                                                } else if (typeof obj === 'string') {
                                                    value = obj;
                                                } else if (typeof obj === 'function') {
                                                    value = obj(node);
                                                }

                                            } else if (tmpToken.hasOwnProperty('key')) {
                                                // restore the expression - might be another whisker instance will
                                                // needs this
                                                value = '{{' + tmpToken.key + '}}';
                                            } else {
                                                value = tmpToken.value;
                                            }
                                            endData.push({value : value, concat : tmpToken.concat});
                                        }
                                        attr.textContent = endData.map(function (d) {
                                            return d.concat ? d.value : ' ' + d.value;
                                        }).join('');
                                        return token;
                                    }());
                                    returnTokens = returnTokens.concat(rTokens);
                                }
                            }
                        }
                    });
                }(containerNode.children));
                return returnTokens;
            }

            /**
             * handle the if conditions if and if-not
             * 
             * @deprecated use rp-bind attribute
             * 
             * @param clone
             * @param obj
             * @param itemName
             */
            function handleIfCondition(clone, obj, itemName) {
                var attributeName_if = 'if',
                    attributeName_if_not = 'if-not';

                function checkIf(val, node) {
                    if (!val) {
                        node.parentNode.removeChild(node);
                    }
                }
                function checkIfNot(val, node) {
                    if (val) {
                        node.parentNode.removeChild(node);
                    }
                }
                // check children of clone
                [].slice.call(clone.querySelectorAll('[' +attributeName_if + ']')).forEach(function (node) {
                    getLoopValueFromAttribute(node, obj, itemName, attributeName_if, function (val) {checkIf(val, node);});
                });

                [].slice.call(clone.querySelectorAll('[' +attributeName_if_not + ']')).forEach(function (node) {
                    getLoopValueFromAttribute(node, obj, itemName, attributeName_if_not, function (val) {checkIfNot(val, node);});
                });
            }

            /**
             * Looped through the collection and do the logic for each clone instance.
             * Actually it supports only collection - no objects.
             * @param node
             * @param itemName
             * @param collection
             * @param template
             */
            function registerTemplate(node, itemName, collection, template) {
                var mainFrag;
                if (typeof collection === 'object') {
                    if (Object.prototype.toString.call(collection) === '[object Array]') {
                        // it is an array
                        mainFrag = document.createDocumentFragment();
                        collection.forEach(function (item) {
                            // item could be an object or just a property like a
                            // string (in case of it is direct a list of strings)
                            template.forEach(function (childTpl) {
                                // TODO works also with fragment but then the qunit test fails
                                // - there is a problem with the phantomjs
//                                var fragment = document.createDocumentFragment();
                                var fragment = document.createElement('div');
                                fragment.appendChild(childTpl.cloneNode(true));
                                
                                handleIfCondition(fragment, item, itemName);
                                // if conditions can remove elements from clone - it's important that this is executed first
                                if (fragment.children && fragment.children.length === 1) {
                                    handleRPBindAttribute(fragment, item, itemName);
                                }
                                // rp-bind attribute can also remove elements so need to check again if node exists
                                if (fragment.children && fragment.children.length === 1) {
                                    handleEvents(fragment, item, itemName);
                                    handleAttributes(fragment, item, itemName);
                                    // replace texts:
                                    mainFrag.appendChild(compile(fragment.children[0], item, itemName));
                                } else {
                                   // console.log('repeat:element has been removed from DOM');
                                }
                            });
                        });
                        node.appendChild(mainFrag);
                    } else {
                        // it is an object
                        console.error('repeat detect object but object currently not supported');
                        // what render? - property name or value? - Both?
                    }
                } else {
                    console.error('repeat:registerTemplate detect none acceptable data argument', collection);
                }
            }

            /**
             * Create a new repeat instance and do the "magic".
             * @param node
             * @param scopeName
             * @param data {[], function}
             */
            function execRepeat(node, scopeName, data) {
                var template = [];
                [].slice.call(node.children).forEach(function (child) {
                    template.push(node.removeChild(child));
                });

                if (typeof data === 'function') {
                    data(function (name, data) {
                        if (data) {
                            scopeName = name;
                        } else {
                            data = name;
                        }
                        // better would be a update children but this is much effort to detect
                        [].slice.call(node.children).forEach(function (child) {
                            node.removeChild(child);
                        });
                        registerTemplate(node, scopeName, data, template);
                    });
                } else {
                    registerTemplate(node, scopeName, data, template)
                }
            }

            return {
                /**
                 * the attribute requires:
                 *  for: name of the iterator
                 *  in: pointer to: function, array or object
                 *
                 * @param node
                 * @param attr {{for:string,in:string}}
                 */
                add : function (node, attr) {
                    var inPointer;
                    if (typeof attr === 'object' && attr.in && attr.for) {
                        if (typeof attr.in === 'string') {
                            // TODO replace window with this and also other instances could use the magic as closure
                            inPointer = getGlobalCall(attr.in, window);
                        } else {
                            inPointer = attr.in;
                        }
                        execRepeat(node, attr.for || 'item', inPointer);
                    } else if (Object.prototype.toString.call(attr) === '[object Array]') {
                        execRepeat(node, 'item', attr);
                    } else if (typeof attr === 'function') {
                        execRepeat(node, 'item', attr);
                    } else if (typeof attr === 'string') {
                        inPointer = getGlobalCall(attr, window);
                        execRepeat(node, 'item', inPointer);
                    } else {
                        console.warn('repeat:add none acceptable attributes', attr);
                    }
                }
            };
        }());

    function escapeRegex(str) {
        return str.replace(ESCAPE_RE, '\\$&');
    }

    function getRegex() {
        var open = escapeRegex(openChar),
            end  = escapeRegex(endChar);
        return new RegExp(open + open + open + '?(.+?)' + end + '?' + end + end);
    }

    /**
     * Read a property from a given string and object.
     * Returns the founded property pointer or undefined.
     * @param value
     * @param obj
     * @returns {*} or undefined
     */
    function getGlobalCall (value, obj) {
        var split = value.split('.'),
            rec = function (cur) {
                if (obj[cur] !== undefined) {
                    obj = obj[cur];
                    rec(split.shift());
                } else if (cur === value ) {
                    obj = undefined;
                }
            };
        rec(split.shift());
        return obj;
    }

    // export as module or bind to global
    if (typeof module !== 'undefined' && module.hasOwnProperty('exports')) {
        module.exports = repeat;
    } else {
        canny.add('repeat', repeat);
    }

}());

},{}],75:[function(require,module,exports){
/*global canny */
/*jslint browser: true*/
/**
 *
 * E.g. {{whisker}}:
 *  <div canny-mod="whisker" canny-var="{'bind':'scope','to':{'message':'My text'}}">
 *     <p>DATA: {{scope.message}})</p>
 *  </div>
 *  Or just pass the function pointer the default scope is 'scope'.
 *  <div canny-mod="whisker" canny-var="mymodule.functionPointer">
 *     <p>DATA: {{scope.message}})</p>
 *  </div>
 *
 */
(function () {
    "use strict";

    var openChar = '{',
        endChar  = '}',
        ESCAPE_RE = /[-.*+?^${}()|[\]\/\\]/g,
        whisker = (function () {
            var BINDING_RE = getRegex();
            /**
             *  Parse a piece of text, return an array of tokens
             *  TODO refactor method
             *  @param text
             *  @return [{key:String, html:boolean}]
             */
            function parse(text) {
                if (!BINDING_RE.test(text)) {return null; }
                var m, i, token, match, tokens = [], orig = {text: text, idx : 0}, textObject;
                /* jshint boss: true */
                while (m = text.match(BINDING_RE)) {
                    i = m.index;
                    token = {concat : true};
                    if (i > 0) {
                        if (orig.idx === 0) {
                            textObject = {
                                concat : orig.text[orig.idx - 1] !== ' ',
                                value : text.slice(0, i),
                                text : true
                            };
                            orig.idx += i;
                        } else {
                            orig.idx += i;
                            textObject = {
                                concat : orig.text[orig.idx - 1] !== ' ',
                                value : text.slice(0, i),
                                text : true
                            };
                        }
                        tokens.push(textObject);
                    }
                    orig.idx += i;
                    token.key = m[1].trim();
                    match = m[0];
                    token.html =
                        match.charAt(2) === openChar &&
                        match.charAt(match.length - 3) === endChar;
                    tokens.push(token);
                    text = text.slice(i + m[0].length);
                }
                if (text.length) {
                    tokens.push({value : text, text : true, concat: true});
                }
                return tokens;
            }
            /**
             *
             * @param node
             * @param dataObj
             * @param itemName
             * @return tokens [{key:String, node:DOM node, html: boolean}]
             */
            function compileTextNode(node, dataObj, itemName) {
                var tokens = parse(node.nodeValue),
                    obj = dataObj,
                    el, token, i, l, tmp, tokenObjectProperty, val, valUnknown;
                if (!tokens || obj === undefined || typeof obj === 'string') {return; }

                for (i = 0, l = tokens.length; i < l; i++) {
                    token = tokens[i];

                    if (typeof token === 'object' && token.hasOwnProperty('key')) {
                        tmp = token.key.split('.');
                        if (tmp.length > 0 && tmp[0] === itemName) {
                            tokenObjectProperty = tmp.slice(1).join('.');
                            if (typeof obj === 'object') {
                                valUnknown = getGlobalCall(tokenObjectProperty, obj);
                            } else {
                                valUnknown = obj;
                            }
                        } else {
                            // just a string?
                            valUnknown = obj;
                        }

                        if (typeof valUnknown === 'function') {
                            val = valUnknown(node);
                        } else {
                            val = valUnknown;
                        }

                        if (typeof val === 'string' || typeof val === 'number') {
                            el = document.createTextNode(val);
                            node.parentNode.insertBefore(el, node);
                        } else if (typeof val === 'boolean') {
                            el = document.createTextNode(val.toString());
                            node.parentNode.insertBefore(el, node);
                        } else if (val instanceof HTMLElement) {
                            el = val;
                            node.parentNode.insertBefore(el, node);
                        } else if (tmp[0] === itemName) {
                            // property is not exists but it is the same scope
                            el = document.createTextNode('');
                            node.parentNode.insertBefore(el, node);
                        } else {
                            // restore the token... looks like is not mine
                            el = document.createTextNode('{{' + token.key + '}}');
                            node.parentNode.insertBefore(el, node);
                        }
                        token.node = el;
                    } else {
                        el = document.createTextNode(token.value);
                        // just normal string put back to view
                        node.parentNode.insertBefore(el, node);
                    }
                }
                node.parentNode.removeChild(node);
                return tokens;
            }
            /**
             *
             * @param node
             * @param dataObj
             * @param itemName
             */
            function compileElement (node, dataObj, itemName) {
                var tokens = [],
                    token;
                // recursively compile childNodes
                if (node.hasChildNodes()) {
                    [].slice.call(node.childNodes).forEach(function (child) {
                        token = compile(child, dataObj, itemName);
                        if (token) {
                            tokens = tokens.concat(token);
                        }
                    });
                }
                return tokens.length > 0 ? tokens : undefined;
            }


            /**
             * helper function to do the read variable from string magic.
             * The cb will called with the property value - in case of undefined the variable does not exists
             * 
             * @param node
             * @param obj
             * @param itemName
             * @param attributeName
             * 
             * @return {function} | false if it is not a function or not available 
             */
            function getWkBindValue(node, obj, itemName, attributeName) {
                var tmp = node.getAttribute(attributeName).split('.'), tokenObjectProperty;
                if (tmp.length > 0 && tmp[0] === itemName) {
                    tokenObjectProperty = tmp.slice(1).join('.');
                    return getGlobalCall(tokenObjectProperty, obj) || false;
                }
                return false;
            }

            /**
             * register rp-bind handler
             *
             * With help of this the if and if-not and onClick attribute is deprecated - you can just pass a function pointer to rp-bind and
             * do all the required logic by your own.
             *
             * If you return false then the node will be removed from the DOM
             *
             * @param node
             * @param obj
             * @param scopeName
             */
            function handleWKBindAttribute(node, obj, scopeName) {

                function parseChildAttribute(child, data, scopeName) {
                    var attrName = 'wk-bind',
                        key = child.getAttribute('wk-bind'),
                        token,
                        fc = getWkBindValue(child, data, scopeName, attrName);
                    if (fc) {
                        (function (fc) {
                            var shadow,
                                hidden = false;
                            if (typeof fc === 'function') {
                                shadow = document.createElement('div');
                                shadow.style.display = 'none';
                                if (fc(child) === false) {
                                    // remove node if function returns false
                                    child = child.parentNode.replaceChild(shadow, child);
                                    hidden = true;
                                }
                                token = {
                                    hidden : hidden,
                                    node : child,
                                    shadowNode : shadow,
                                    isWkBindToken : true,
                                    // check if key is needed because it has the wkBind function pointer
                                    key : child.getAttribute('wk-bind')
                                }

                            } else {
                                console.error('whisker:can not register control function without a function pointer', child);
                            }
                        }(fc));
                    } else {
                        // valid in case of there is a different scope variable or
                    }
                    return token;
                }

                var attrName = 'wk-bind',
                    tokens = [];
                // check children of clone
                [].slice.call(node.querySelectorAll('[' + attrName + ']')).forEach(function (child) {
                    var tmpToken = parseChildAttribute(child, obj, scopeName);
                    if (tmpToken) {
                        tokens.push(tmpToken);
                    }
                });
                return tokens
            }

            /**
             *  Compile a DOM node (recursive)
             * @param node
             * @param dataObj
             * @param itemName
             * @returns {*}
             */
            function compile(node, dataObj, itemName) {
                var nodeType = node.nodeType,
                    tokens = [],
                    token;
                if (nodeType === 1 && node.tagName !== 'SCRIPT') { // a normal node
                    token = compileElement(node, dataObj, itemName);
                    if (token) {
                        tokens = tokens.concat(token);
                    }
                } else if (nodeType === 3) {
                    token = compileTextNode(node, dataObj, itemName);
                    if (token) {
                        tokens = tokens.concat(token);
                    }
                }
                return tokens.length > 0 ? tokens : undefined;
            }

            /**
             * Replaces expressions for all tag attributes
             *
             * loop though all children and check if a attribute has a expressions inside
             *
             * @param containerNode
             * @param obj
             * @param itemName
             * @return returnTokens [{key:String, attr: node attribute reference, html: boolean}]
             */
            function handleAttributes(containerNode, obj, itemName) {
                var returnTokens = [];
                (function searchForExpressions(children) {
                    [].slice.call(children).forEach(function (node) {
                        var i, attr, rTokens;
                        if (node.children.length > 0) {
                            // do it recursive for all children
                            searchForExpressions(node.children);
                        }
                        // loop through each attribute
                        for (i = 0; i < node.attributes.length; i++) {
                            attr = node.attributes[i];
                            if (/\{\{/.test(attr.textContent)) {
                                if (attr.name) {
                                    rTokens = (function () {
                                        var token = parse(attr.textContent),
                                            endData = [], tmpToken, j, tmpTokenSplit, value, tmpValue;
                                        for (j = 0; j < token.length; j++) {
                                            tmpToken = token[j];
                                            // if token not itemName skipp all
                                            if (tmpToken.key !== undefined && tmpToken.key.split('.')[0] === itemName) {
                                                // save the attribute
                                                tmpToken.attr = attr;
                                                if (/\./.test(tmpToken.key)) {
                                                    tmpTokenSplit = tmpToken.key.split('.').slice(1).join('.');
                                                } else {
                                                    tmpTokenSplit = tmpToken.key;
                                                }
                                                if (typeof obj === 'object') {
                                                    tmpValue = getGlobalCall(tmpTokenSplit, obj);
                                                    if (typeof tmpValue === 'function') {
                                                        tmpToken.value = tmpValue(node);
                                                        tmpToken.node = node;
                                                    } else {
                                                        tmpToken.value = tmpValue;
                                                    }
                                                    value = tmpToken.value;
                                                } else if (typeof obj === 'string') {
                                                    value = obj;
                                                } else if (typeof obj === 'function') {
                                                    value = obj(node);
                                                }

                                            } else if (tmpToken.hasOwnProperty('key')) {
                                                // restore the expression - might be another whisker instance will
                                                // needs this
                                                value = '{{' + tmpToken.key + '}}';
                                            } else {
                                                value = tmpToken.value;
                                            }
                                            endData.push({value : value, concat : tmpToken.concat});
                                        }
                                        attr.textContent = endData.map(function (d) {
                                            return d.concat ? d.value : ' ' + d.value;
                                        }).join('');
                                        return token;
                                    }());
                                    returnTokens = returnTokens.concat(rTokens);
                                }
                            }
                        }
                    });
                }(containerNode.children));
                return returnTokens;
            }

            /**
             * do the magic for attributes or text nodes
             * 
             * TODO: bug if property doesn't exists in first execution it want work anymore for attributes and wk-bind
             *  See: whiskerSpecs.js > dynamicallyChangeDataWithInitialMissingProperties
             *
             * @param node
             * @param scopeName
             * @param data
             */
            function fillData(node, scopeName, data) {
                var tokens = [];
                if (typeof data === 'object') {
                    // handleEvents(node, data, scopeName);
                    tokens = tokens.concat(handleAttributes(node, data, scopeName));
                    // make sure that the compiler also updates the hidden element
                    tokens = tokens.concat(compile(node, data, scopeName));

                    tokens = tokens.concat(handleWKBindAttribute(node, data, scopeName));

                    // replace texts:
                    return tokens;
                } else {
                    console.error('whisker:handleAttributes detect none acceptable data argument', data);
                }
            }

            /**
             * helper function for updateData to update the DOM Elements
             * @param token
             * @param domElement DOMElement
             */
            function updateDOMElement(token, domElement) {
                token.node.parentNode.insertBefore(domElement, token.node);
                token.node.parentNode.removeChild(token.node);
                token.node = domElement;
            }
            /**
             * helper function for updateData to update the text nodes
             * @param token
             * @param val
             */
            function updateText(token, val) {
                var textNode;
                if (token.node instanceof HTMLElement) {
                    // convert back to textNode
                    textNode = document.createTextNode('');
                    token.node.parentNode.insertBefore(textNode, token.node);
                    token.node.parentNode.removeChild(token.node);
                    token.node = textNode;
                }
                if (typeof val === 'string' || typeof val === 'number') {
                    token.node.nodeValue = val;
                } else if (typeof val === 'boolean') {
                    // TODO test
                    token.node.nodeValue = val.toString();
                }
            }

            /**
             * helper function for updateData to update the attributes for a node
             * @param token
             * @param value
             */
            function updateAttributes(token, value) {
                var val;
                if (typeof value === 'function') {
                    val = value(token.node);
                } else {
                    val = value;
                }
                if (typeof val === 'string' || typeof val === 'number') {
                    var replaceText = token.attr.textContent;
                    if (replaceText) {
                        token.attr.textContent = replaceText.replace(token.value, val);
                    } else {
                        token.attr.textContent = replaceText + val;
                    }
                    token.value = val;
                } else if (typeof val === 'boolean') {
                    // TODO test (makes no sense for an attribute but needs to be handled correctly (think about what to do in this case)
                    token.node.nodeValue = val.toString();
                }
            }
            /**
             *
             * Call this to update the existing data's
             *
             * TODO test also boolean and function
             *
             * @param tokenObjList [{key : "scopeName.property", node}]
             * @param scopeName
             * @param obj
             */
            function updateData(tokenObjList, scopeName, obj) {
                tokenObjList.forEach(function (token) {
                    if (token && token.hasOwnProperty('key')) {
                        var tmp = token.key.split('.'), tokenObjectProperty, val;
                        if (tmp.length > 0 && tmp[0] === scopeName) {
                            tokenObjectProperty = tmp.slice(1).join('.');
                            if (typeof obj === 'object') {
                                val = getGlobalCall(tokenObjectProperty, obj);
                            } else {
                                val = obj;
                            }

                            if (val !== undefined) {
                                if (token.hasOwnProperty('attr')) {
                                    // handle attribute
                                    updateAttributes(token, val);
                                } else if (token.isWkBindToken) {
                                    (function () {
                                        var removeMeIfImFalse;
                                        if (val) {
                                            removeMeIfImFalse = val(token.node);
                                        }
                                        if (removeMeIfImFalse === false && token.hidden === false) {
                                            // remove node
                                            token.hidden = true;
                                            token.node.parentNode.replaceChild(token.shadowNode, token.node);
                                        } else if (removeMeIfImFalse !== false && token.hidden) {
                                            token.hidden = false;
                                            token.shadowNode.parentNode.replaceChild(token.node, token.shadowNode);
                                            // restore node
                                        }
                                    }());
                                } else {
                                    (function () {
                                        // a return result could also be a HTMLElement
                                        var res = typeof val === 'function' ? val(token.node) : val;
                                        if (res instanceof HTMLElement) {
                                            updateDOMElement(token, res);
                                        } else {
                                            updateText(token, res);
                                        }
                                    }(val))
                                }
                            }
                        }
                    }
                });
            }

            /**
             * TODO description
             * Create a new whisker instance and do the "magic".
             * @param node
             * @param scopeName
             * @param data
             */
            function exec(node, data, scopeName) {
                var currentScope = scopeName || 'item',
                    keyValueholder = {};
                if (typeof data === 'function') {
                    data(function (scope, data) {
                        var renderScope;
                        if (data !== undefined) {
                            renderScope = currentScope = scope || currentScope;
                        } else {
                            data = scope;
                            // otherwise use the scope from the initialisation
                            renderScope = currentScope;
                        }
                        if (keyValueholder.hasOwnProperty(renderScope)) {
                            updateData(keyValueholder[renderScope], renderScope, data);
                        } else {
                            keyValueholder[renderScope] = fillData(node, renderScope, data);
                        }
                    });
                } else {
                    fillData(node, currentScope, data)
                }
            }

            return {
                add : function (node, attr) {
                    var inPointer;
                    if (typeof attr === 'object') {
                        if (attr.to && attr.bind) {
                            if (typeof attr.to === 'string') {
                                // TODO replace window with this and also other instances could use the magic as closure
                                inPointer = getGlobalCall(attr.to, window);
                            } else {
                                inPointer = attr.to;
                            }
                        } else {
                            inPointer = attr;
                        }
                        exec(node, inPointer, attr.bind || 'item');
                    } else if (typeof attr === 'string') {
                        inPointer = getGlobalCall(attr, window);
                        if (typeof inPointer === 'function') {
                            exec(node, inPointer);
                        } else {
                            console.warn('whisker:add none acceptable attributes', attr);
                        }
                    } else {
                        exec(node, attr);
                    }
                }
            };
        }());

    function escapeRegex(str) {
        return str.replace(ESCAPE_RE, '\\$&');
    }

    function getRegex() {
        var open = escapeRegex(openChar),
            end  = escapeRegex(endChar);
        return new RegExp(open + open + open + '?(.+?)' + end + '?' + end + end);
    }

    /**
     * Read a property from a given string and object.
     * Returns the founded property pointer or undefined.
     * @param value
     * @param obj
     * @returns {*} or undefined
     */
    function getGlobalCall (value, obj) {
        var split = value.split('.'),
            rec = function (cur) {
                if (obj[cur] !== undefined) {
                    obj = obj[cur];
                    rec(split.shift());
                } else if (cur === value ) {
                    obj = undefined;
                }
            };
        rec(split.shift());
        return obj;
    }

    // export as module or bind to global
    if (typeof module !== 'undefined' && module.hasOwnProperty('exports')) {
        module.exports = whisker;
    } else {
        canny.add('whisker', whisker);
    }

}());

},{}],76:[function(require,module,exports){
module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],77:[function(require,module,exports){
(function (Buffer){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":93}],78:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var scrubber = require('./lib/scrub');
var objectKeys = require('./lib/keys');
var forEach = require('./lib/foreach');
var isEnumerable = require('./lib/is_enum');

module.exports = function (cons, opts) {
    return new Proto(cons, opts);
};

(function () { // browsers bleh
    for (var key in EventEmitter.prototype) {
        Proto.prototype[key] = EventEmitter.prototype[key];
    }
})();

function Proto (cons, opts) {
    var self = this;
    EventEmitter.call(self);
    if (!opts) opts = {};
    
    self.remote = {};
    self.callbacks = { local : [], remote : [] };
    self.wrap = opts.wrap;
    self.unwrap = opts.unwrap;
    
    self.scrubber = scrubber(self.callbacks.local);
    
    if (typeof cons === 'function') {
        self.instance = new cons(self.remote, self);
    }
    else self.instance = cons || {};
}

Proto.prototype.start = function () {
    this.request('methods', [ this.instance ]);
};

Proto.prototype.cull = function (id) {
    delete this.callbacks.remote[id];
    this.emit('request', {
        method : 'cull',
        arguments : [ id ]
    });
};

Proto.prototype.request = function (method, args) {
    var scrub = this.scrubber.scrub(args);
    
    this.emit('request', {
        method : method,
        arguments : scrub.arguments,
        callbacks : scrub.callbacks,
        links : scrub.links
    });
};

Proto.prototype.handle = function (req) {
    var self = this;
    var args = self.scrubber.unscrub(req, function (id) {
        if (self.callbacks.remote[id] === undefined) {
            // create a new function only if one hasn't already been created
            // for a particular id
            var cb = function () {
                self.request(id, [].slice.apply(arguments));
            };
            self.callbacks.remote[id] = self.wrap ? self.wrap(cb, id) : cb;
            return cb;
        }
        return self.unwrap
            ? self.unwrap(self.callbacks.remote[id], id)
            : self.callbacks.remote[id]
        ;
    });
    
    if (req.method === 'methods') {
        self.handleMethods(args[0]);
    }
    else if (req.method === 'cull') {
        forEach(args, function (id) {
            delete self.callbacks.local[id];
        });
    }
    else if (typeof req.method === 'string') {
        if (isEnumerable(self.instance, req.method)) {
            self.apply(self.instance[req.method], args);
        }
        else {
            self.emit('fail', new Error(
                'request for non-enumerable method: ' + req.method
            ));
        }
    }
    else if (typeof req.method == 'number') {
        var fn = self.callbacks.local[req.method];
        if (!fn) {
            self.emit('fail', new Error('no such method'));
        }
        else self.apply(fn, args);
    }
};

Proto.prototype.handleMethods = function (methods) {
    var self = this;
    if (typeof methods != 'object') {
        methods = {};
    }
    
    // copy since assignment discards the previous refs
    forEach(objectKeys(self.remote), function (key) {
        delete self.remote[key];
    });
    
    forEach(objectKeys(methods), function (key) {
        self.remote[key] = methods[key];
    });
    
    self.emit('remote', self.remote);
    self.emit('ready');
};

Proto.prototype.apply = function (f, args) {
    try { f.apply(undefined, args) }
    catch (err) { this.emit('error', err) }
};

},{"./lib/foreach":79,"./lib/is_enum":80,"./lib/keys":81,"./lib/scrub":82,"events":86}],79:[function(require,module,exports){
module.exports = function forEach (xs, f) {
    if (xs.forEach) return xs.forEach(f)
    for (var i = 0; i < xs.length; i++) {
        f.call(xs, xs[i], i);
    }
}

},{}],80:[function(require,module,exports){
var objectKeys = require('./keys');

module.exports = function (obj, key) {
    if (Object.prototype.propertyIsEnumerable) {
        return Object.prototype.propertyIsEnumerable.call(obj, key);
    }
    var keys = objectKeys(obj);
    for (var i = 0; i < keys.length; i++) {
        if (key === keys[i]) return true;
    }
    return false;
};

},{"./keys":81}],81:[function(require,module,exports){
module.exports = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
};

},{}],82:[function(require,module,exports){
var traverse = require('traverse');
var objectKeys = require('./keys');
var forEach = require('./foreach');

function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) if (xs[i] === x) return i;
    return -1;
}

// scrub callbacks out of requests in order to call them again later
module.exports = function (callbacks) {
    return new Scrubber(callbacks);
};

function Scrubber (callbacks) {
    this.callbacks = callbacks;
}

// Take the functions out and note them for future use
Scrubber.prototype.scrub = function (obj) {
    var self = this;
    var paths = {};
    var links = [];
    
    var args = traverse(obj).map(function (node) {
        if (typeof node === 'function') {
            var i = indexOf(self.callbacks, node);
            if (i >= 0 && !(i in paths)) {
                // Keep previous function IDs only for the first function
                // found. This is somewhat suboptimal but the alternatives
                // are worse.
                paths[i] = this.path;
            }
            else {
                var id = self.callbacks.length;
                self.callbacks.push(node);
                paths[id] = this.path;
            }
            
            this.update('[Function]');
        }
        else if (this.circular) {
            links.push({ from : this.circular.path, to : this.path });
            this.update('[Circular]');
        }
    });
    
    return {
        arguments : args,
        callbacks : paths,
        links : links
    };
};
 
// Replace callbacks. The supplied function should take a callback id and
// return a callback of its own.
Scrubber.prototype.unscrub = function (msg, f) {
    var args = msg.arguments || [];
    forEach(objectKeys(msg.callbacks || {}), function (sid) {
        var id = parseInt(sid, 10);
        var path = msg.callbacks[id];
        traverse.set(args, path, f(id));
    });
    
    forEach(msg.links || [], function (link) {
        var value = traverse.get(args, link.from);
        traverse.set(args, link.to, value);
    });
    
    return args;
};

},{"./foreach":79,"./keys":81,"traverse":141}],83:[function(require,module,exports){
var dnode = require('./lib/dnode');

module.exports = function (cons, opts) {
    return new dnode(cons, opts);
};

},{"./lib/dnode":84}],84:[function(require,module,exports){
(function (process){(function (){
var protocol = require('dnode-protocol');
var Stream = require('stream');
var json = typeof JSON === 'object' ? JSON : require('jsonify');

module.exports = dnode;
dnode.prototype = {};
(function () { // browsers etc
    for (var key in Stream.prototype) {
        dnode.prototype[key] = Stream.prototype[key];
    }
})();

function dnode (cons, opts) {
    Stream.call(this);
    var self = this;
    
    self.opts = opts || {};
    
    self.cons = typeof cons === 'function'
        ? cons
        : function () { return cons || {} }
    ;
    
    self.readable = true;
    self.writable = true;
    
    process.nextTick(function () {
        if (self._ended) return;
        self.proto = self._createProto();
        self.proto.start();
        
        if (!self._handleQueue) return;
        for (var i = 0; i < self._handleQueue.length; i++) {
            self.handle(self._handleQueue[i]);
        }
    });
}

dnode.prototype._createProto = function () {
    var self = this;
    var proto = protocol(function (remote) {
        if (self._ended) return;
        
        var ref = self.cons.call(this, remote, self);
        if (typeof ref !== 'object') ref = this;
        
        self.emit('local', ref, self);
        
        return ref;
    }, self.opts.proto);
    
    proto.on('remote', function (remote) {
        self.emit('remote', remote, self);
        self.emit('ready'); // backwards compatability, deprecated
    });
    
    proto.on('request', function (req) {
        if (!self.readable) return;
        
        if (self.opts.emit === 'object') {
            self.emit('data', req);
        }
        else self.emit('data', json.stringify(req) + '\n');
    });
    
    proto.on('fail', function (err) {
        // errors that the remote end was responsible for
        self.emit('fail', err);
    });
    
    proto.on('error', function (err) {
        // errors that the local code was responsible for
        self.emit('error', err);
    });
    
    return proto;
};

dnode.prototype.write = function (buf) {
    if (this._ended) return;
    var self = this;
    var row;
    
    if (buf && typeof buf === 'object'
    && buf.constructor && buf.constructor.name === 'Buffer'
    && buf.length
    && typeof buf.slice === 'function') {
        // treat like a buffer
        if (!self._bufs) self._bufs = [];
        
        // treat like a buffer
        for (var i = 0, j = 0; i < buf.length; i++) {
            if (buf[i] === 0x0a) {
                self._bufs.push(buf.slice(j, i));
                
                var line = '';
                for (var k = 0; k < self._bufs.length; k++) {
                    line += String(self._bufs[k]);
                }
                
                try { row = json.parse(line) }
                catch (err) { return self.end() }
                
                j = i + 1;
                
                self.handle(row);
                self._bufs = [];
            }
        }
        
        if (j < buf.length) self._bufs.push(buf.slice(j, buf.length));
    }
    else if (buf && typeof buf === 'object') {
        // .isBuffer() without the Buffer
        // Use self to pipe JSONStream.parse() streams.
        self.handle(buf);
    }
    else {
        if (typeof buf !== 'string') buf = String(buf);
        if (!self._line) self._line = '';
        
        for (var i = 0; i < buf.length; i++) {
            if (buf.charCodeAt(i) === 0x0a) {
                try { row = json.parse(self._line) }
                catch (err) { return self.end() }
                
                self._line = '';
                self.handle(row);
            }
            else self._line += buf.charAt(i)
        }
    }
};

dnode.prototype.handle = function (row) {
    if (!this.proto) {
        if (!this._handleQueue) this._handleQueue = [];
        this._handleQueue.push(row);
    }
    else this.proto.handle(row);
};

dnode.prototype.end = function () {
    if (this._ended) return;
    this._ended = true;
    this.writable = false;
    this.readable = false;
    this.emit('end');
};

dnode.prototype.destroy = function () {
    this.end();
};

}).call(this)}).call(this,require('_process'))

},{"_process":116,"dnode-protocol":78,"jsonify":107,"stream":139}],85:[function(require,module,exports){
/*global HTMLElement */
/*jslint browser: true */

var domOpts = {};

domOpts.params = (function () {
    "use strict";
    var params = {}, i, nv, parts;
    if (location.search) {
        parts = location.search.substring(1).split('&');
        for (i = 0; i < parts.length; i++) {
            nv = parts[i].split('=');
            if (nv[0]) {
                params[nv[0]] = nv[1] || true;
            }
        }
    }
    return params;
}());

domOpts.createElement = function (tag, id, classes) {
    "use strict";
    var newNode = document.createElement(tag);
    if (id) {newNode.setAttribute('id', id); }
    if (classes) {newNode.setAttribute('class', classes); }
    return newNode;
};
module.exports =  domOpts;

// dom operations:
HTMLElement.prototype.domAddClass = function (addClasses) {
    "use strict";
    var attrClass = this.getAttribute('class'),
        addClassesList = addClasses.split(' '), newClasses = [], i;
    for (i = 0; i < addClassesList.length; i++) {
        if (!this.domHasClass(addClassesList[i])) {
            newClasses.push(addClassesList[i]);
        }
    }
    this.setAttribute('class', attrClass !== null ? attrClass + ' ' + newClasses.join(' ') : newClasses.join(' '));
    return this;
};
// TODO remove all classes with same name
HTMLElement.prototype.domRemoveClass = function (removeableClasses) {
    "use strict";
    var removeClasses = (removeableClasses && removeableClasses.split(' ')) || this.getAttribute('class').split(' '),
        attrClass = this.getAttribute('class'),
        currentClasses,
        i,
        idx;
    if (attrClass !== null) {
        currentClasses = attrClass.split(' ');
        for (i = 0; i < removeClasses.length; i++) {
            idx = currentClasses.indexOf(removeClasses[i]);
            if (idx >= 0) {
                currentClasses = currentClasses.slice(0, idx).concat(currentClasses.slice(idx + 1, currentClasses.length - 1));
            }
        }
        this.setAttribute('class', currentClasses.join(' '));
    }
    return this;
};

// dom operations:
HTMLElement.prototype.domHasClass = function (className) {
    "use strict";
    var classes = this.getAttribute('class'), currentClasses, i;
    if (classes !== null) {
        currentClasses = classes.split(' ');
        for (i = 0; i < currentClasses.length; i++) {
            if (currentClasses[i] === className) {return true; }
        }
    }
    return false;
};

HTMLElement.prototype.domRemove = function () {
    "use strict";
    this.parentNode.removeChild(this);
};
/**
 * remove all child elements from node
 */
HTMLElement.prototype.domEmpty = function () {
    "use strict";
    Array.prototype.slice.call(this.children).forEach(function (child) {
        child.domRemove(this);
    });
};

HTMLElement.prototype.domAppendTo = function (elem) {
    "use strict";
    var node = elem;
    if (typeof node === 'string') {
        node = document.getElementById(node);
    }
    node.appendChild(this);
    return this;
};

HTMLElement.prototype.domAppendChild = function (elem) {
    "use strict";
    var node = elem;
    if (typeof node === 'string') {
        node = document.getElementById(node);
    }
    this.appendChild(node);
    return this;
};

HTMLElement.prototype.domChildTags = function (tag) {
    "use strict";
    var tags = [];
    Array.prototype.slice.call(this.children).forEach(function (e) {
        if (e.tagName.toLowerCase() === tag.toLowerCase()) {
            tags.push(e);
        }
    });
    return tags;
};
},{}],86:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],87:[function(require,module,exports){
(function (process){(function (){
/*
 * exit
 * https://github.com/cowboy/node-exit
 *
 * Copyright (c) 2013 "Cowboy" Ben Alman
 * Licensed under the MIT license.
 */

'use strict';

module.exports = function exit(exitCode, streams) {
  if (!streams) { streams = [process.stdout, process.stderr]; }
  var drainCount = 0;
  // Actually exit if all streams are drained.
  function tryToExit() {
    if (drainCount === streams.length) {
      process.exit(exitCode);
    }
  }
  streams.forEach(function(stream) {
    // Count drained streams now, but monitor non-drained streams.
    if (stream.bufferSize === 0) {
      drainCount++;
    } else {
      stream.write('', 'utf-8', function() {
        drainCount++;
        tryToExit();
      });
    }
    // Prevent further writing.
    stream.write = function() {};
  });
  // If all streams were already drained, exit now.
  tryToExit();
  // In Windows, when run as a Node.js child process, a script utilizing
  // this library might just exit with a 0 exit code, regardless. This code,
  // despite the fact that it looks a bit crazy, appears to fix that.
  process.on('exit', function() {
    process.exit(exitCode);
  });
};

}).call(this)}).call(this,require('_process'))

},{"_process":116}],88:[function(require,module,exports){
(function (process){(function (){
module.exports = realpath
realpath.realpath = realpath
realpath.sync = realpathSync
realpath.realpathSync = realpathSync
realpath.monkeypatch = monkeypatch
realpath.unmonkeypatch = unmonkeypatch

var fs = require('fs')
var origRealpath = fs.realpath
var origRealpathSync = fs.realpathSync

var version = process.version
var ok = /^v[0-5]\./.test(version)
var old = require('./old.js')

function newError (er) {
  return er && er.syscall === 'realpath' && (
    er.code === 'ELOOP' ||
    er.code === 'ENOMEM' ||
    er.code === 'ENAMETOOLONG'
  )
}

function realpath (p, cache, cb) {
  if (ok) {
    return origRealpath(p, cache, cb)
  }

  if (typeof cache === 'function') {
    cb = cache
    cache = null
  }
  origRealpath(p, cache, function (er, result) {
    if (newError(er)) {
      old.realpath(p, cache, cb)
    } else {
      cb(er, result)
    }
  })
}

function realpathSync (p, cache) {
  if (ok) {
    return origRealpathSync(p, cache)
  }

  try {
    return origRealpathSync(p, cache)
  } catch (er) {
    if (newError(er)) {
      return old.realpathSync(p, cache)
    } else {
      throw er
    }
  }
}

function monkeypatch () {
  fs.realpath = realpath
  fs.realpathSync = realpathSync
}

function unmonkeypatch () {
  fs.realpath = origRealpath
  fs.realpathSync = origRealpathSync
}

}).call(this)}).call(this,require('_process'))

},{"./old.js":89,"_process":116,"fs":68}],89:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var pathModule = require('path');
var isWindows = process.platform === 'win32';
var fs = require('fs');

// JavaScript implementation of realpath, ported from node pre-v6

var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);

function rethrow() {
  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
  // is fairly slow to generate.
  var callback;
  if (DEBUG) {
    var backtrace = new Error;
    callback = debugCallback;
  } else
    callback = missingCallback;

  return callback;

  function debugCallback(err) {
    if (err) {
      backtrace.message = err.message;
      err = backtrace;
      missingCallback(err);
    }
  }

  function missingCallback(err) {
    if (err) {
      if (process.throwDeprecation)
        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs
      else if (!process.noDeprecation) {
        var msg = 'fs: missing callback ' + (err.stack || err.message);
        if (process.traceDeprecation)
          console.trace(msg);
        else
          console.error(msg);
      }
    }
  }
}

function maybeCallback(cb) {
  return typeof cb === 'function' ? cb : rethrow();
}

var normalize = pathModule.normalize;

// Regexp that finds the next partion of a (partial) path
// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
if (isWindows) {
  var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
} else {
  var nextPartRe = /(.*?)(?:[\/]+|$)/g;
}

// Regex to find the device root, including trailing slash. E.g. 'c:\\'.
if (isWindows) {
  var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
} else {
  var splitRootRe = /^[\/]*/;
}

exports.realpathSync = function realpathSync(p, cache) {
  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return cache[p];
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstatSync(base);
      knownHard[base] = true;
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  // NB: p.length changes.
  while (pos < p.length) {
    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      continue;
    }

    var resolvedLink;
    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // some known symbolic link.  no need to stat again.
      resolvedLink = cache[base];
    } else {
      var stat = fs.lstatSync(base);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache[base] = base;
        continue;
      }

      // read the link if it wasn't read before
      // dev/ino always return 0 on windows, so skip the check.
      var linkTarget = null;
      if (!isWindows) {
        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }
      if (linkTarget === null) {
        fs.statSync(base);
        linkTarget = fs.readlinkSync(base);
      }
      resolvedLink = pathModule.resolve(previous, linkTarget);
      // track this, if given a cache.
      if (cache) cache[base] = resolvedLink;
      if (!isWindows) seenLinks[id] = linkTarget;
    }

    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }

  if (cache) cache[original] = p;

  return p;
};


exports.realpath = function realpath(p, cache, cb) {
  if (typeof cb !== 'function') {
    cb = maybeCallback(cache);
    cache = null;
  }

  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return process.nextTick(cb.bind(null, null, cache[p]));
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstat(base, function(err) {
        if (err) return cb(err);
        knownHard[base] = true;
        LOOP();
      });
    } else {
      process.nextTick(LOOP);
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  function LOOP() {
    // stop if scanned past end of path
    if (pos >= p.length) {
      if (cache) cache[original] = p;
      return cb(null, p);
    }

    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      return process.nextTick(LOOP);
    }

    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // known symbolic link.  no need to stat again.
      return gotResolvedLink(cache[base]);
    }

    return fs.lstat(base, gotStat);
  }

  function gotStat(err, stat) {
    if (err) return cb(err);

    // if not a symlink, skip to the next path part
    if (!stat.isSymbolicLink()) {
      knownHard[base] = true;
      if (cache) cache[base] = base;
      return process.nextTick(LOOP);
    }

    // stat & read the link if not read before
    // call gotTarget as soon as the link target is known
    // dev/ino always return 0 on windows, so skip the check.
    if (!isWindows) {
      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
      if (seenLinks.hasOwnProperty(id)) {
        return gotTarget(null, seenLinks[id], base);
      }
    }
    fs.stat(base, function(err) {
      if (err) return cb(err);

      fs.readlink(base, function(err, target) {
        if (!isWindows) seenLinks[id] = target;
        gotTarget(err, target);
      });
    });
  }

  function gotTarget(err, target, base) {
    if (err) return cb(err);

    var resolvedLink = pathModule.resolve(previous, target);
    if (cache) cache[base] = resolvedLink;
    gotResolvedLink(resolvedLink);
  }

  function gotResolvedLink(resolvedLink) {
    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }
};

}).call(this)}).call(this,require('_process'))

},{"_process":116,"fs":68,"path":113}],90:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],91:[function(require,module,exports){
(function (process){(function (){
var wrappy = require('wrappy')
var reqs = Object.create(null)
var once = require('once')

module.exports = wrappy(inflight)

function inflight (key, cb) {
  if (reqs[key]) {
    reqs[key].push(cb)
    return null
  } else {
    reqs[key] = [cb]
    return makeres(key)
  }
}

function makeres (key) {
  return once(function RES () {
    var cbs = reqs[key]
    var len = cbs.length
    var args = slice(arguments)

    // XXX It's somewhat ambiguous whether a new callback added in this
    // pass should be queued for later execution if something in the
    // list of callbacks throws, or if it should just be discarded.
    // However, it's such an edge case that it hardly matters, and either
    // choice is likely as surprising as the other.
    // As it happens, we do go ahead and schedule it for later execution.
    try {
      for (var i = 0; i < len; i++) {
        cbs[i].apply(null, args)
      }
    } finally {
      if (cbs.length > len) {
        // added more in the interim.
        // de-zalgo, just in case, but don't call again.
        cbs.splice(0, len)
        process.nextTick(function () {
          RES.apply(null, args)
        })
      } else {
        delete reqs[key]
      }
    }
  })
}

function slice (args) {
  var length = args.length
  var array = []

  for (var i = 0; i < length; i++) array[i] = args[i]
  return array
}

}).call(this)}).call(this,require('_process'))

},{"_process":116,"once":112,"wrappy":147}],92:[function(require,module,exports){
arguments[4][61][0].apply(exports,arguments)
},{"dup":61}],93:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],94:[function(require,module,exports){
/*
Copyright (c) 2008-2018 Pivotal Labs

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
function getJasmineRequireObj() {
  if (typeof module !== 'undefined' && module.exports) {
    return exports;
  } else {
    window.jasmineRequire = window.jasmineRequire || {};
    return window.jasmineRequire;
  }
}

getJasmineRequireObj().console = function(jRequire, j$) {
  j$.ConsoleReporter = jRequire.ConsoleReporter();
};

getJasmineRequireObj().ConsoleReporter = function() {

  var noopTimer = {
    start: function(){},
    elapsed: function(){ return 0; }
  };

  function ConsoleReporter(options) {
    var print = options.print,
      showColors = options.showColors || false,
      onComplete = options.onComplete || function() {},
      timer = options.timer || noopTimer,
      specCount,
      failureCount,
      failedSpecs = [],
      pendingCount,
      ansi = {
        green: '\x1B[32m',
        red: '\x1B[31m',
        yellow: '\x1B[33m',
        none: '\x1B[0m'
      },
      failedSuites = [];

    print('ConsoleReporter is deprecated and will be removed in a future version.');

    this.jasmineStarted = function() {
      specCount = 0;
      failureCount = 0;
      pendingCount = 0;
      print('Started');
      printNewline();
      timer.start();
    };

    this.jasmineDone = function() {
      printNewline();
      for (var i = 0; i < failedSpecs.length; i++) {
        specFailureDetails(failedSpecs[i]);
      }

      if(specCount > 0) {
        printNewline();

        var specCounts = specCount + ' ' + plural('spec', specCount) + ', ' +
          failureCount + ' ' + plural('failure', failureCount);

        if (pendingCount) {
          specCounts += ', ' + pendingCount + ' pending ' + plural('spec', pendingCount);
        }

        print(specCounts);
      } else {
        print('No specs found');
      }

      printNewline();
      var seconds = timer.elapsed() / 1000;
      print('Finished in ' + seconds + ' ' + plural('second', seconds));
      printNewline();

      for(i = 0; i < failedSuites.length; i++) {
        suiteFailureDetails(failedSuites[i]);
      }

      onComplete(failureCount === 0);
    };

    this.specDone = function(result) {
      specCount++;

      if (result.status == 'pending') {
        pendingCount++;
        print(colored('yellow', '*'));
        return;
      }

      if (result.status == 'passed') {
        print(colored('green', '.'));
        return;
      }

      if (result.status == 'failed') {
        failureCount++;
        failedSpecs.push(result);
        print(colored('red', 'F'));
      }
    };

    this.suiteDone = function(result) {
      if (result.failedExpectations && result.failedExpectations.length > 0) {
        failureCount++;
        failedSuites.push(result);
      }
    };

    return this;

    function printNewline() {
      print('\n');
    }

    function colored(color, str) {
      return showColors ? (ansi[color] + str + ansi.none) : str;
    }

    function plural(str, count) {
      return count == 1 ? str : str + 's';
    }

    function repeat(thing, times) {
      var arr = [];
      for (var i = 0; i < times; i++) {
        arr.push(thing);
      }
      return arr;
    }

    function indent(str, spaces) {
      var lines = (str || '').split('\n');
      var newArr = [];
      for (var i = 0; i < lines.length; i++) {
        newArr.push(repeat(' ', spaces).join('') + lines[i]);
      }
      return newArr.join('\n');
    }

    function specFailureDetails(result) {
      printNewline();
      print(result.fullName);

      for (var i = 0; i < result.failedExpectations.length; i++) {
        var failedExpectation = result.failedExpectations[i];
        printNewline();
        print(indent(failedExpectation.message, 2));
        print(indent(failedExpectation.stack, 2));
      }

      printNewline();
    }

    function suiteFailureDetails(result) {
      for (var i = 0; i < result.failedExpectations.length; i++) {
        printNewline();
        print(colored('red', 'An error was thrown in an afterAll'));
        printNewline();
        print(colored('red', 'AfterAll ' + result.failedExpectations[i].message));

      }
      printNewline();
    }
  }

  return ConsoleReporter;
};

},{}],95:[function(require,module,exports){
(function (__dirname){(function (){
module.exports = require("./jasmine-core/jasmine.js");
module.exports.boot = require('./jasmine-core/node_boot.js');

var path = require('path'),
    fs = require('fs');

var rootPath = path.join(__dirname, "jasmine-core"),
    bootFiles = ['boot.js'],
    nodeBootFiles = ['node_boot.js'],
    cssFiles = [],
    jsFiles = [],
    jsFilesToSkip = ['jasmine.js'].concat(bootFiles, nodeBootFiles);

fs.readdirSync(rootPath).forEach(function(file) {
  if(fs.statSync(path.join(rootPath, file)).isFile()) {
    switch(path.extname(file)) {
      case '.css':
        cssFiles.push(file);
      break;
      case '.js':
        if (jsFilesToSkip.indexOf(file) < 0) {
        jsFiles.push(file);
      }
      break;
    }
  }
});

module.exports.files = {
  path: rootPath,
  bootDir: rootPath,
  bootFiles: bootFiles,
  nodeBootFiles: nodeBootFiles,
  cssFiles: cssFiles,
  jsFiles: ['jasmine.js'].concat(jsFiles),
  imagesDir: path.join(__dirname, '../images')
};

}).call(this)}).call(this,"/node_modules/jasmine-core/lib")

},{"./jasmine-core/jasmine.js":96,"./jasmine-core/node_boot.js":97,"fs":68,"path":113}],96:[function(require,module,exports){
(function (process,global){(function (){
/*
Copyright (c) 2008-2018 Pivotal Labs

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
var getJasmineRequireObj = (function (jasmineGlobal) {
  var jasmineRequire;

  if (typeof module !== 'undefined' && module.exports && typeof exports !== 'undefined') {
    if (typeof global !== 'undefined') {
      jasmineGlobal = global;
    } else {
      jasmineGlobal = {};
    }
    jasmineRequire = exports;
  } else {
    if (typeof window !== 'undefined' && typeof window.toString === 'function' && window.toString() === '[object GjsGlobal]') {
      jasmineGlobal = window;
    }
    jasmineRequire = jasmineGlobal.jasmineRequire = {};
  }

  function getJasmineRequire() {
    return jasmineRequire;
  }

  getJasmineRequire().core = function(jRequire) {
    var j$ = {};

    jRequire.base(j$, jasmineGlobal);
    j$.util = jRequire.util(j$);
    j$.errors = jRequire.errors();
    j$.formatErrorMsg = jRequire.formatErrorMsg();
    j$.Any = jRequire.Any(j$);
    j$.Anything = jRequire.Anything(j$);
    j$.CallTracker = jRequire.CallTracker(j$);
    j$.MockDate = jRequire.MockDate();
    j$.getClearStack = jRequire.clearStack(j$);
    j$.Clock = jRequire.Clock();
    j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler(j$);
    j$.Env = jRequire.Env(j$);
    j$.ExceptionFormatter = jRequire.ExceptionFormatter();
    j$.Expectation = jRequire.Expectation();
    j$.buildExpectationResult = jRequire.buildExpectationResult();
    j$.JsApiReporter = jRequire.JsApiReporter();
    j$.matchersUtil = jRequire.matchersUtil(j$);
    j$.ObjectContaining = jRequire.ObjectContaining(j$);
    j$.ArrayContaining = jRequire.ArrayContaining(j$);
    j$.ArrayWithExactContents = jRequire.ArrayWithExactContents(j$);
    j$.pp = jRequire.pp(j$);
    j$.QueueRunner = jRequire.QueueRunner(j$);
    j$.ReportDispatcher = jRequire.ReportDispatcher(j$);
    j$.Spec = jRequire.Spec(j$);
    j$.Spy = jRequire.Spy(j$);
    j$.SpyRegistry = jRequire.SpyRegistry(j$);
    j$.SpyStrategy = jRequire.SpyStrategy(j$);
    j$.StringMatching = jRequire.StringMatching(j$);
    j$.UserContext = jRequire.UserContext(j$);
    j$.Suite = jRequire.Suite(j$);
    j$.Timer = jRequire.Timer();
    j$.TreeProcessor = jRequire.TreeProcessor();
    j$.version = jRequire.version();
    j$.Order = jRequire.Order();
    j$.DiffBuilder = jRequire.DiffBuilder(j$);
    j$.NullDiffBuilder = jRequire.NullDiffBuilder(j$);
    j$.ObjectPath = jRequire.ObjectPath(j$);
    j$.GlobalErrors = jRequire.GlobalErrors(j$);

    j$.matchers = jRequire.requireMatchers(jRequire, j$);

    return j$;
  };

  return getJasmineRequire;
})(this);

getJasmineRequireObj().requireMatchers = function(jRequire, j$) {
  var availableMatchers = [
      'nothing',
      'toBe',
      'toBeCloseTo',
      'toBeDefined',
      'toBeFalsy',
      'toBeGreaterThan',
      'toBeGreaterThanOrEqual',
      'toBeLessThan',
      'toBeLessThanOrEqual',
      'toBeNaN',
      'toBeNegativeInfinity',
      'toBeNull',
      'toBePositiveInfinity',
      'toBeTruthy',
      'toBeUndefined',
      'toContain',
      'toEqual',
      'toHaveBeenCalled',
      'toHaveBeenCalledBefore',
      'toHaveBeenCalledTimes',
      'toHaveBeenCalledWith',
      'toMatch',
      'toThrow',
      'toThrowError'
    ],
    matchers = {};

  for (var i = 0; i < availableMatchers.length; i++) {
    var name = availableMatchers[i];
    matchers[name] = jRequire[name](j$);
  }

  return matchers;
};

getJasmineRequireObj().base = function(j$, jasmineGlobal) {
  j$.unimplementedMethod_ = function() {
    throw new Error('unimplemented method');
  };

  /**
   * Maximum object depth the pretty printer will print to.
   * Set this to a lower value to speed up pretty printing if you have large objects.
   * @name jasmine.MAX_PRETTY_PRINT_DEPTH
   */
  j$.MAX_PRETTY_PRINT_DEPTH = 8;
  /**
   * Maximum number of array elements to display when pretty printing objects.
   * This will also limit the number of keys and values displayed for an object.
   * Elements past this number will be ellipised.
   * @name jasmine.MAX_PRETTY_PRINT_ARRAY_LENGTH
   */
  j$.MAX_PRETTY_PRINT_ARRAY_LENGTH = 50;
  /**
   * Maximum number of charasters to display when pretty printing objects.
   * Characters past this number will be ellipised.
   * @name jasmine.MAX_PRETTY_PRINT_CHARS
   */
  j$.MAX_PRETTY_PRINT_CHARS = 1000;
  /**
   * Default number of milliseconds Jasmine will wait for an asynchronous spec to complete.
   * @name jasmine.DEFAULT_TIMEOUT_INTERVAL
   */
  j$.DEFAULT_TIMEOUT_INTERVAL = 5000;

  j$.getGlobal = function() {
    return jasmineGlobal;
  };

  /**
   * Get the currently booted Jasmine Environment.
   *
   * @name jasmine.getEnv
   * @function
   * @return {Env}
   */
  j$.getEnv = function(options) {
    var env = j$.currentEnv_ = j$.currentEnv_ || new j$.Env(options);
    //jasmine. singletons in here (setTimeout blah blah).
    return env;
  };

  j$.isArray_ = function(value) {
    return j$.isA_('Array', value);
  };

  j$.isObject_ = function(value) {
    return !j$.util.isUndefined(value) && value !== null && j$.isA_('Object', value);
  };

  j$.isString_ = function(value) {
    return j$.isA_('String', value);
  };

  j$.isNumber_ = function(value) {
    return j$.isA_('Number', value);
  };

  j$.isFunction_ = function(value) {
    return j$.isA_('Function', value);
  };

  j$.isAsyncFunction_ = function(value) {
    return j$.isA_('AsyncFunction', value);
  };

  j$.isTypedArray_ = function(value) {
    return j$.isA_('Float32Array', value) ||
      j$.isA_('Float64Array', value) ||
      j$.isA_('Int16Array', value) ||
      j$.isA_('Int32Array', value) ||
      j$.isA_('Int8Array', value) ||
      j$.isA_('Uint16Array', value) ||
      j$.isA_('Uint32Array', value) ||
      j$.isA_('Uint8Array', value) ||
      j$.isA_('Uint8ClampedArray', value);
  };

  j$.isA_ = function(typeName, value) {
    return j$.getType_(value) === '[object ' + typeName + ']';
  };

  j$.getType_ = function(value) {
    return Object.prototype.toString.apply(value);
  };

  j$.isDomNode = function(obj) {
    return obj.nodeType > 0;
  };

  j$.isMap = function(obj) {
    return typeof jasmineGlobal.Map !== 'undefined' && obj.constructor === jasmineGlobal.Map;
  };

  j$.isSet = function(obj) {
    return typeof jasmineGlobal.Set !== 'undefined' && obj.constructor === jasmineGlobal.Set;
  };

  j$.isPromise = function(obj) {
    return typeof jasmineGlobal.Promise !== 'undefined' && obj.constructor === jasmineGlobal.Promise;
  };

  j$.fnNameFor = function(func) {
    if (func.name) {
      return func.name;
    }

    var matches = func.toString().match(/^\s*function\s*(\w*)\s*\(/) ||
      func.toString().match(/^\s*\[object\s*(\w*)Constructor\]/);

    return matches ? matches[1] : '<anonymous>';
  };

  /**
   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared is an instance of the specified class/constructor.
   * @name jasmine.any
   * @function
   * @param {Constructor} clazz - The constructor to check against.
   */
  j$.any = function(clazz) {
    return new j$.Any(clazz);
  };

  /**
   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared is not `null` and not `undefined`.
   * @name jasmine.anything
   * @function
   */
  j$.anything = function() {
    return new j$.Anything();
  };

  /**
   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value being compared contains at least the keys and values.
   * @name jasmine.objectContaining
   * @function
   * @param {Object} sample - The subset of properties that _must_ be in the actual.
   */
  j$.objectContaining = function(sample) {
    return new j$.ObjectContaining(sample);
  };

  /**
   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value is a `String` that matches the `RegExp` or `String`.
   * @name jasmine.stringMatching
   * @function
   * @param {RegExp|String} expected
   */
  j$.stringMatching = function(expected) {
    return new j$.StringMatching(expected);
  };

  /**
   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value is an `Array` that contains at least the elements in the sample.
   * @name jasmine.arrayContaining
   * @function
   * @param {Array} sample
   */
  j$.arrayContaining = function(sample) {
    return new j$.ArrayContaining(sample);
  };

  /**
   * Get a matcher, usable in any {@link matchers|matcher} that uses Jasmine's equality (e.g. {@link matchers#toEqual|toEqual}, {@link matchers#toContain|toContain}, or {@link matchers#toHaveBeenCalledWith|toHaveBeenCalledWith}),
   * that will succeed if the actual value is an `Array` that contains all of the elements in the sample in any order.
   * @name jasmine.arrayWithExactContents
   * @function
   * @param {Array} sample
   */
  j$.arrayWithExactContents = function(sample) {
    return new j$.ArrayWithExactContents(sample);
  };

  /**
   * Create a bare {@link Spy} object. This won't be installed anywhere and will not have any implementation behind it.
   * @name jasmine.createSpy
   * @function
   * @param {String} [name] - Name to give the spy. This will be displayed in failure messages.
   * @param {Function} [originalFn] - Function to act as the real implementation.
   * @return {Spy}
   */
  j$.createSpy = function(name, originalFn) {
    return j$.Spy(name, originalFn);
  };

  j$.isSpy = function(putativeSpy) {
    if (!putativeSpy) {
      return false;
    }
    return putativeSpy.and instanceof j$.SpyStrategy &&
      putativeSpy.calls instanceof j$.CallTracker;
  };

  /**
   * Create an object with multiple {@link Spy}s as its members.
   * @name jasmine.createSpyObj
   * @function
   * @param {String} [baseName] - Base name for the spies in the object.
   * @param {String[]|Object} methodNames - Array of method names to create spies for, or Object whose keys will be method names and values the {@link Spy#and#returnValue|returnValue}.
   * @return {Object}
   */
  j$.createSpyObj = function(baseName, methodNames) {
    var baseNameIsCollection = j$.isObject_(baseName) || j$.isArray_(baseName);

    if (baseNameIsCollection && j$.util.isUndefined(methodNames)) {
      methodNames = baseName;
      baseName = 'unknown';
    }

    var obj = {};
    var spiesWereSet = false;

    if (j$.isArray_(methodNames)) {
      for (var i = 0; i < methodNames.length; i++) {
        obj[methodNames[i]] = j$.createSpy(baseName + '.' + methodNames[i]);
        spiesWereSet = true;
      }
    } else if (j$.isObject_(methodNames)) {
      for (var key in methodNames) {
        if (methodNames.hasOwnProperty(key)) {
          obj[key] = j$.createSpy(baseName + '.' + key);
          obj[key].and.returnValue(methodNames[key]);
          spiesWereSet = true;
        }
      }
    }

    if (!spiesWereSet) {
      throw 'createSpyObj requires a non-empty array or object of method names to create spies for';
    }

    return obj;
  };
};

getJasmineRequireObj().util = function(j$) {

  var util = {};

  util.inherit = function(childClass, parentClass) {
    var Subclass = function() {
    };
    Subclass.prototype = parentClass.prototype;
    childClass.prototype = new Subclass();
  };

  util.htmlEscape = function(str) {
    if (!str) {
      return str;
    }
    return str.replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
  };

  util.argsToArray = function(args) {
    var arrayOfArgs = [];
    for (var i = 0; i < args.length; i++) {
      arrayOfArgs.push(args[i]);
    }
    return arrayOfArgs;
  };

  util.isUndefined = function(obj) {
    return obj === void 0;
  };

  util.arrayContains = function(array, search) {
    var i = array.length;
    while (i--) {
      if (array[i] === search) {
        return true;
      }
    }
    return false;
  };

  util.clone = function(obj) {
    if (Object.prototype.toString.apply(obj) === '[object Array]') {
      return obj.slice();
    }

    var cloned = {};
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        cloned[prop] = obj[prop];
      }
    }

    return cloned;
  };

  util.cloneArgs = function(args) {
    var clonedArgs = [];
    var argsAsArray = j$.util.argsToArray(args);
    for(var i = 0; i < argsAsArray.length; i++) {
      var str = Object.prototype.toString.apply(argsAsArray[i]),
        primitives = /^\[object (Boolean|String|RegExp|Number)/;

      // All falsey values are either primitives, `null`, or `undefined.
      if (!argsAsArray[i] || str.match(primitives)) {
        clonedArgs.push(argsAsArray[i]);
      } else {
        clonedArgs.push(j$.util.clone(argsAsArray[i]));
      }
    }
    return clonedArgs;
  };

  util.getPropertyDescriptor = function(obj, methodName) {
    var descriptor,
      proto = obj;

    do {
      descriptor = Object.getOwnPropertyDescriptor(proto, methodName);
      proto = Object.getPrototypeOf(proto);
    } while (!descriptor && proto);

    return descriptor;
  };

  util.objectDifference = function(obj, toRemove) {
    var diff = {};

    for (var key in obj) {
      if (util.has(obj, key) && !util.has(toRemove, key)) {
        diff[key] = obj[key];
      }
    }

    return diff;
  };

  util.has = function(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  };

  return util;
};

getJasmineRequireObj().Spec = function(j$) {
  function Spec(attrs) {
    this.expectationFactory = attrs.expectationFactory;
    this.resultCallback = attrs.resultCallback || function() {};
    this.id = attrs.id;
    this.description = attrs.description || '';
    this.queueableFn = attrs.queueableFn;
    this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };
    this.userContext = attrs.userContext || function() { return {}; };
    this.onStart = attrs.onStart || function() {};
    this.getSpecName = attrs.getSpecName || function() { return ''; };
    this.expectationResultFactory = attrs.expectationResultFactory || function() { };
    this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};
    this.catchingExceptions = attrs.catchingExceptions || function() { return true; };
    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;

    if (!this.queueableFn.fn) {
      this.pend();
    }

    /**
     * @typedef SpecResult
     * @property {Int} id - The unique id of this spec.
     * @property {String} description - The description passed to the {@link it} that created this spec.
     * @property {String} fullName - The full description including all ancestors of this spec.
     * @property {Expectation[]} failedExpectations - The list of expectations that failed during execution of this spec.
     * @property {Expectation[]} passedExpectations - The list of expectations that passed during execution of this spec.
     * @property {Expectation[]} deprecationWarnings - The list of deprecation warnings that occurred during execution this spec.
     * @property {String} pendingReason - If the spec is {@link pending}, this will be the reason.
     * @property {String} status - Once the spec has completed, this string represents the pass/fail status of this spec.
     */
    this.result = {
      id: this.id,
      description: this.description,
      fullName: this.getFullName(),
      failedExpectations: [],
      passedExpectations: [],
      deprecationWarnings: [],
      pendingReason: ''
    };
  }

  Spec.prototype.addExpectationResult = function(passed, data, isError) {
    var expectationResult = this.expectationResultFactory(data);
    if (passed) {
      this.result.passedExpectations.push(expectationResult);
    } else {
      this.result.failedExpectations.push(expectationResult);

      if (this.throwOnExpectationFailure && !isError) {
        throw new j$.errors.ExpectationFailed();
      }
    }
  };

  Spec.prototype.expect = function(actual) {
    return this.expectationFactory(actual, this);
  };

  Spec.prototype.execute = function(onComplete, enabled) {
    var self = this;

    this.onStart(this);

    var fns = this.beforeAndAfterFns();
    var regularFns = fns.befores.concat(this.queueableFn);

    var runnerConfig = {
      isLeaf: true,
      queueableFns: regularFns,
      cleanupFns: fns.afters,
      onException: function() { self.onException.apply(self, arguments); },
      onComplete: complete,
      userContext: this.userContext()
    };

    if (!this.isExecutable() || this.markedPending || enabled === false) {
      runnerConfig.queueableFns = [];
      runnerConfig.cleanupFns = [];
      runnerConfig.onComplete = function() { complete(enabled); };
    }

    this.queueRunnerFactory(runnerConfig);

    function complete(enabledAgain) {
      self.result.status = self.status(enabledAgain);
      self.resultCallback(self.result);

      if (onComplete) {
        onComplete();
      }
    }
  };

  Spec.prototype.onException = function onException(e) {
    if (Spec.isPendingSpecException(e)) {
      this.pend(extractCustomPendingMessage(e));
      return;
    }

    if (e instanceof j$.errors.ExpectationFailed) {
      return;
    }

    this.addExpectationResult(false, {
      matcherName: '',
      passed: false,
      expected: '',
      actual: '',
      error: e
    }, true);
  };

  Spec.prototype.disable = function() {
    this.disabled = true;
  };

  Spec.prototype.pend = function(message) {
    this.markedPending = true;
    if (message) {
      this.result.pendingReason = message;
    }
  };

  Spec.prototype.getResult = function() {
    this.result.status = this.status();
    return this.result;
  };

  Spec.prototype.status = function(enabled) {
    if (this.disabled || enabled === false) {
      return 'disabled';
    }

    if (this.markedPending) {
      return 'pending';
    }

    if (this.result.failedExpectations.length > 0) {
      return 'failed';
    } else {
      return 'passed';
    }
  };

  Spec.prototype.isExecutable = function() {
    return !this.disabled;
  };

  Spec.prototype.getFullName = function() {
    return this.getSpecName(this);
  };

  Spec.prototype.addDeprecationWarning = function(msg) {
    this.result.deprecationWarnings.push(this.expectationResultFactory({ message: msg }));
  };

  var extractCustomPendingMessage = function(e) {
    var fullMessage = e.toString(),
        boilerplateStart = fullMessage.indexOf(Spec.pendingSpecExceptionMessage),
        boilerplateEnd = boilerplateStart + Spec.pendingSpecExceptionMessage.length;

    return fullMessage.substr(boilerplateEnd);
  };

  Spec.pendingSpecExceptionMessage = '=> marked Pending';

  Spec.isPendingSpecException = function(e) {
    return !!(e && e.toString && e.toString().indexOf(Spec.pendingSpecExceptionMessage) !== -1);
  };

  return Spec;
};

if (typeof window == void 0 && typeof exports == 'object') {
  exports.Spec = jasmineRequire.Spec;
}

/*jshint bitwise: false*/

getJasmineRequireObj().Order = function() {
  function Order(options) {
    this.random = 'random' in options ? options.random : true;
    var seed = this.seed = options.seed || generateSeed();
    this.sort = this.random ? randomOrder : naturalOrder;

    function naturalOrder(items) {
      return items;
    }

    function randomOrder(items) {
      var copy = items.slice();
      copy.sort(function(a, b) {
        return jenkinsHash(seed + a.id) - jenkinsHash(seed + b.id);
      });
      return copy;
    }

    function generateSeed() {
      return String(Math.random()).slice(-5);
    }

    // Bob Jenkins One-at-a-Time Hash algorithm is a non-cryptographic hash function
    // used to get a different output when the key changes slighly.
    // We use your return to sort the children randomly in a consistent way when
    // used in conjunction with a seed

    function jenkinsHash(key) {
      var hash, i;
      for(hash = i = 0; i < key.length; ++i) {
        hash += key.charCodeAt(i);
        hash += (hash << 10);
        hash ^= (hash >> 6);
      }
      hash += (hash << 3);
      hash ^= (hash >> 11);
      hash += (hash << 15);
      return hash;
    }

  }

  return Order;
};

getJasmineRequireObj().Env = function(j$) {
  /**
   * _Note:_ Do not construct this directly, Jasmine will make one during booting.
   * @name Env
   * @classdesc The Jasmine environment
   * @constructor
   */
  function Env(options) {
    options = options || {};

    var self = this;
    var global = options.global || j$.getGlobal();

    var hasExecuted = false;

    var totalSpecsDefined = 0;

    var catchExceptions = true;

    var realSetTimeout = j$.getGlobal().setTimeout;
    var realClearTimeout = j$.getGlobal().clearTimeout;
    var clearStack = j$.getClearStack(j$.getGlobal());
    this.clock = new j$.Clock(global, function () { return new j$.DelayedFunctionScheduler(); }, new j$.MockDate(global));

    var runnableResources = {};

    var currentSpec = null;
    var currentlyExecutingSuites = [];
    var currentDeclarationSuite = null;
    var throwOnExpectationFailure = false;
    var random = false;
    var seed = null;

    var currentSuite = function() {
      return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];
    };

    var currentRunnable = function() {
      return currentSpec || currentSuite();
    };

    /**
     * This represents the available reporter callback for an object passed to {@link Env#addReporter}.
     * @interface Reporter
     */
    var reporter = new j$.ReportDispatcher([
      /**
       * `jasmineStarted` is called after all of the specs have been loaded, but just before execution starts.
       * @function
       * @name Reporter#jasmineStarted
       * @param {JasmineStartedInfo} suiteInfo Information about the full Jasmine suite that is being run
       */
      'jasmineStarted',
      /**
       * When the entire suite has finished execution `jasmineDone` is called
       * @function
       * @name Reporter#jasmineDone
       * @param {JasmineDoneInfo} suiteInfo Information about the full Jasmine suite that just finished running.
       */
      'jasmineDone',
      /**
       * `suiteStarted` is invoked when a `describe` starts to run
       * @function
       * @name Reporter#suiteStarted
       * @param {SuiteResult} result Information about the individual {@link describe} being run
       */
      'suiteStarted',
      /**
       * `suiteDone` is invoked when all of the child specs and suites for a given suite have been run
       *
       * While jasmine doesn't require any specific functions, not defining a `suiteDone` will make it impossible for a reporter to know when a suite has failures in an `afterAll`.
       * @function
       * @name Reporter#suiteDone
       * @param {SuiteResult} result
       */
      'suiteDone',
      /**
       * `specStarted` is invoked when an `it` starts to run (including associated `beforeEach` functions)
       * @function
       * @name Reporter#specStarted
       * @param {SpecResult} result Information about the individual {@link it} being run
       */
      'specStarted',
      /**
       * `specDone` is invoked when an `it` and its associated `beforeEach` and `afterEach` functions have been run.
       *
       * While jasmine doesn't require any specific functions, not defining a `specDone` will make it impossible for a reporter to know when a spec has failed.
       * @function
       * @name Reporter#specDone
       * @param {SpecResult} result
       */
      'specDone'
    ]);

    var globalErrors = new j$.GlobalErrors();

    this.specFilter = function() {
      return true;
    };

    this.addCustomEqualityTester = function(tester) {
      if(!currentRunnable()) {
        throw new Error('Custom Equalities must be added in a before function or a spec');
      }
      runnableResources[currentRunnable().id].customEqualityTesters.push(tester);
    };

    this.addMatchers = function(matchersToAdd) {
      if(!currentRunnable()) {
        throw new Error('Matchers must be added in a before function or a spec');
      }
      var customMatchers = runnableResources[currentRunnable().id].customMatchers;
      for (var matcherName in matchersToAdd) {
        customMatchers[matcherName] = matchersToAdd[matcherName];
      }
    };

    j$.Expectation.addCoreMatchers(j$.matchers);

    var nextSpecId = 0;
    var getNextSpecId = function() {
      return 'spec' + nextSpecId++;
    };

    var nextSuiteId = 0;
    var getNextSuiteId = function() {
      return 'suite' + nextSuiteId++;
    };

    var expectationFactory = function(actual, spec) {
      return j$.Expectation.Factory({
        util: j$.matchersUtil,
        customEqualityTesters: runnableResources[spec.id].customEqualityTesters,
        customMatchers: runnableResources[spec.id].customMatchers,
        actual: actual,
        addExpectationResult: addExpectationResult
      });

      function addExpectationResult(passed, result) {
        return spec.addExpectationResult(passed, result);
      }
    };

    var defaultResourcesForRunnable = function(id, parentRunnableId) {
      var resources = {spies: [], customEqualityTesters: [], customMatchers: {}};

      if(runnableResources[parentRunnableId]){
        resources.customEqualityTesters = j$.util.clone(runnableResources[parentRunnableId].customEqualityTesters);
        resources.customMatchers = j$.util.clone(runnableResources[parentRunnableId].customMatchers);
      }

      runnableResources[id] = resources;
    };

    var clearResourcesForRunnable = function(id) {
        spyRegistry.clearSpies();
        delete runnableResources[id];
    };

    var beforeAndAfterFns = function(suite) {
      return function() {
        var befores = [],
          afters = [];

        while(suite) {
          befores = befores.concat(suite.beforeFns);
          afters = afters.concat(suite.afterFns);

          suite = suite.parentSuite;
        }

        return {
          befores: befores.reverse(),
          afters: afters
        };
      };
    };

    var getSpecName = function(spec, suite) {
      var fullName = [spec.description],
          suiteFullName = suite.getFullName();

      if (suiteFullName !== '') {
        fullName.unshift(suiteFullName);
      }
      return fullName.join(' ');
    };

    // TODO: we may just be able to pass in the fn instead of wrapping here
    var buildExpectationResult = j$.buildExpectationResult,
        exceptionFormatter = new j$.ExceptionFormatter(),
        expectationResultFactory = function(attrs) {
          attrs.messageFormatter = exceptionFormatter.message;
          attrs.stackFormatter = exceptionFormatter.stack;

          return buildExpectationResult(attrs);
        };

    // TODO: fix this naming, and here's where the value comes in
    this.catchExceptions = function(value) {
      catchExceptions = !!value;
      if (!catchExceptions) {
        this.deprecated('The catchExceptions option is deprecated and will be replaced with stopOnSpecFailure in Jasmine 3.0');
      }
      return catchExceptions;
    };

    this.catchingExceptions = function() {
      return catchExceptions;
    };

    var maximumSpecCallbackDepth = 20;
    var currentSpecCallbackDepth = 0;

    var catchException = function(e) {
      return j$.Spec.isPendingSpecException(e) || catchExceptions;
    };

    this.throwOnExpectationFailure = function(value) {
      throwOnExpectationFailure = !!value;
    };

    this.throwingExpectationFailures = function() {
      return throwOnExpectationFailure;
    };

    this.randomizeTests = function(value) {
      random = !!value;
    };

    this.randomTests = function() {
      return random;
    };

    this.seed = function(value) {
      if (value) {
        seed = value;
      }
      return seed;
    };

    this.deprecated = function(msg) {
      var runnable = currentRunnable() || topSuite;
      runnable.addDeprecationWarning(msg);
      if(typeof console !== 'undefined' && typeof console.warn !== 'undefined') {
        console.error('DEPRECATION: ' + msg);
      }
    };

    var queueRunnerFactory = function(options) {
      options.catchException = catchException;
      options.clearStack = options.clearStack || clearStack;
      options.timeout = {setTimeout: realSetTimeout, clearTimeout: realClearTimeout};
      options.fail = self.fail;
      options.globalErrors = globalErrors;
      options.completeOnFirstError = throwOnExpectationFailure && options.isLeaf;
      options.deprecated = self.deprecated;

      new j$.QueueRunner(options).execute();
    };

    var topSuite = new j$.Suite({
      env: this,
      id: getNextSuiteId(),
      description: 'Jasmine__TopLevel__Suite',
      expectationFactory: expectationFactory,
      expectationResultFactory: expectationResultFactory
    });
    defaultResourcesForRunnable(topSuite.id);
    currentDeclarationSuite = topSuite;

    this.topSuite = function() {
      return topSuite;
    };

    this.execute = function(runnablesToRun) {
      if (hasExecuted) {
        this.deprecated('Executing the same Jasmine multiple times will no longer work in Jasmine 3.0');
      }

      hasExecuted = true;

      if(!runnablesToRun) {
        if (focusedRunnables.length) {
          runnablesToRun = focusedRunnables;
        } else {
          runnablesToRun = [topSuite.id];
        }
      }

      var order = new j$.Order({
        random: random,
        seed: seed
      });

      var processor = new j$.TreeProcessor({
        tree: topSuite,
        runnableIds: runnablesToRun,
        queueRunnerFactory: queueRunnerFactory,
        nodeStart: function(suite) {
          currentlyExecutingSuites.push(suite);
          defaultResourcesForRunnable(suite.id, suite.parentSuite.id);
          reporter.suiteStarted(suite.result);
        },
        nodeComplete: function(suite, result) {
          if (suite !== currentSuite()) {
            throw new Error('Tried to complete the wrong suite');
          }

          if (!suite.markedPending) {
            clearResourcesForRunnable(suite.id);
          }
          currentlyExecutingSuites.pop();
          reporter.suiteDone(result);
        },
        orderChildren: function(node) {
          return order.sort(node.children);
        }
      });

      if(!processor.processTree().valid) {
        throw new Error('Invalid order: would cause a beforeAll or afterAll to be run multiple times');
      }

      /**
       * Information passed to the {@link Reporter#jasmineStarted} event.
       * @typedef JasmineStartedInfo
       * @property {Int} totalSpecsDefined - The total number of specs defined in this suite.
       * @property {Order} order - Information about the ordering (random or not) of this execution of the suite.
       */
      reporter.jasmineStarted({
        totalSpecsDefined: totalSpecsDefined,
        order: order
      });

      currentlyExecutingSuites.push(topSuite);

      globalErrors.install();
      processor.execute(function() {
        clearResourcesForRunnable(topSuite.id);
        currentlyExecutingSuites.pop();
        globalErrors.uninstall();

        /**
         * Information passed to the {@link Reporter#jasmineDone} event.
         * @typedef JasmineDoneInfo
         * @property {Order} order - Information about the ordering (random or not) of this execution of the suite.
         * @property {Expectation[]} failedExpectations - List of expectations that failed in an {@link afterAll} at the global level.
         * @property {Expectation[]} deprecationWarnings - List of deprecation warnings that occurred at the global level.
         */
        reporter.jasmineDone({
          order: order,
          failedExpectations: topSuite.result.failedExpectations,
          deprecationWarnings: topSuite.result.deprecationWarnings
        });
      });
    };

    /**
     * Add a custom reporter to the Jasmine environment.
     * @name Env#addReporter
     * @function
     * @param {Reporter} reporterToAdd The reporter to be added.
     * @see custom_reporter
     */
    this.addReporter = function(reporterToAdd) {
      reporter.addReporter(reporterToAdd);
    };

    this.provideFallbackReporter = function(reporterToAdd) {
      reporter.provideFallbackReporter(reporterToAdd);
    };

    this.clearReporters = function() {
      reporter.clearReporters();
    };

    var spyRegistry = new j$.SpyRegistry({currentSpies: function() {
      if(!currentRunnable()) {
        throw new Error('Spies must be created in a before function or a spec');
      }
      return runnableResources[currentRunnable().id].spies;
    }});

    this.allowRespy = function(allow){
      spyRegistry.allowRespy(allow);
    };

    this.spyOn = function() {
      return spyRegistry.spyOn.apply(spyRegistry, arguments);
    };

    this.spyOnProperty = function() {
      return spyRegistry.spyOnProperty.apply(spyRegistry, arguments);
    };

    var ensureIsFunction = function(fn, caller) {
      if (!j$.isFunction_(fn)) {
        throw new Error(caller + ' expects a function argument; received ' + j$.getType_(fn));
      }
    };

    var ensureIsFunctionOrAsync = function(fn, caller) {
      if (!j$.isFunction_(fn) && !j$.isAsyncFunction_(fn)) {
        throw new Error(caller + ' expects a function argument; received ' + j$.getType_(fn));
      }
    };

    function ensureIsNotNested(method) {
      var runnable = currentRunnable();
      if (runnable !== null && runnable !== undefined) {
        throw new Error('\'' + method + '\' should only be used in \'describe\' function');
      }
    }

    var suiteFactory = function(description) {
      var suite = new j$.Suite({
        env: self,
        id: getNextSuiteId(),
        description: description,
        parentSuite: currentDeclarationSuite,
        expectationFactory: expectationFactory,
        expectationResultFactory: expectationResultFactory,
        throwOnExpectationFailure: throwOnExpectationFailure
      });

      return suite;
    };

    this.describe = function(description, specDefinitions) {
      ensureIsNotNested('describe');
      ensureIsFunction(specDefinitions, 'describe');
      var suite = suiteFactory(description);
      if (specDefinitions.length > 0) {
        throw new Error('describe does not expect any arguments');
      }
      if (currentDeclarationSuite.markedPending) {
        suite.pend();
      }
      addSpecsToSuite(suite, specDefinitions);
      return suite;
    };

    this.xdescribe = function(description, specDefinitions) {
      ensureIsNotNested('xdescribe');
      ensureIsFunction(specDefinitions, 'xdescribe');
      var suite = suiteFactory(description);
      suite.pend();
      addSpecsToSuite(suite, specDefinitions);
      return suite;
    };

    var focusedRunnables = [];

    this.fdescribe = function(description, specDefinitions) {
      this.deprecated('fit and fdescribe will cause your suite to report an \'incomplete\' status in Jasmine 3.0');
      ensureIsNotNested('fdescribe');
      ensureIsFunction(specDefinitions, 'fdescribe');
      var suite = suiteFactory(description);
      suite.isFocused = true;

      focusedRunnables.push(suite.id);
      unfocusAncestor();
      addSpecsToSuite(suite, specDefinitions);

      return suite;
    };

    function addSpecsToSuite(suite, specDefinitions) {
      var parentSuite = currentDeclarationSuite;
      parentSuite.addChild(suite);
      currentDeclarationSuite = suite;

      var declarationError = null;
      try {
        specDefinitions.call(suite);
      } catch (e) {
        declarationError = e;
      }

      if (declarationError) {
        self.it('encountered a declaration exception', function() {
          throw declarationError;
        });
      }

      currentDeclarationSuite = parentSuite;
    }

    function findFocusedAncestor(suite) {
      while (suite) {
        if (suite.isFocused) {
          return suite.id;
        }
        suite = suite.parentSuite;
      }

      return null;
    }

    function unfocusAncestor() {
      var focusedAncestor = findFocusedAncestor(currentDeclarationSuite);
      if (focusedAncestor) {
        for (var i = 0; i < focusedRunnables.length; i++) {
          if (focusedRunnables[i] === focusedAncestor) {
            focusedRunnables.splice(i, 1);
            break;
          }
        }
      }
    }

    var specFactory = function(description, fn, suite, timeout) {
      totalSpecsDefined++;
      var spec = new j$.Spec({
        id: getNextSpecId(),
        beforeAndAfterFns: beforeAndAfterFns(suite),
        expectationFactory: expectationFactory,
        resultCallback: specResultCallback,
        getSpecName: function(spec) {
          return getSpecName(spec, suite);
        },
        onStart: specStarted,
        description: description,
        expectationResultFactory: expectationResultFactory,
        queueRunnerFactory: queueRunnerFactory,
        userContext: function() { return suite.clonedSharedUserContext(); },
        queueableFn: {
          fn: fn,
          timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }
        },
        throwOnExpectationFailure: throwOnExpectationFailure
      });

      if (!self.specFilter(spec)) {
        spec.disable();
      }

      return spec;

      function specResultCallback(result) {
        clearResourcesForRunnable(spec.id);
        currentSpec = null;
        reporter.specDone(result);
      }

      function specStarted(spec) {
        currentSpec = spec;
        defaultResourcesForRunnable(spec.id, suite.id);
        reporter.specStarted(spec.result);
      }
    };

    this.it = function(description, fn, timeout) {
      ensureIsNotNested('it');
      // it() sometimes doesn't have a fn argument, so only check the type if
      // it's given.
      if (arguments.length > 1 && typeof fn !== 'undefined') {
        ensureIsFunctionOrAsync(fn, 'it');
      }
      var spec = specFactory(description, fn, currentDeclarationSuite, timeout);
      if (currentDeclarationSuite.markedPending) {
        spec.pend();
      }
      currentDeclarationSuite.addChild(spec);
      return spec;
    };

    this.xit = function(description, fn, timeout) {
      ensureIsNotNested('xit');
      // xit(), like it(), doesn't always have a fn argument, so only check the
      // type when needed.
      if (arguments.length > 1 && typeof fn !== 'undefined') {
        ensureIsFunctionOrAsync(fn, 'xit');
      }
      var spec = this.it.apply(this, arguments);
      spec.pend('Temporarily disabled with xit');
      return spec;
    };

    this.fit = function(description, fn, timeout){
      this.deprecated('fit and fdescribe will cause your suite to report an \'incomplete\' status in Jasmine 3.0');
      ensureIsNotNested('fit');
      ensureIsFunctionOrAsync(fn, 'fit');
      var spec = specFactory(description, fn, currentDeclarationSuite, timeout);
      currentDeclarationSuite.addChild(spec);
      focusedRunnables.push(spec.id);
      unfocusAncestor();
      return spec;
    };

    this.expect = function(actual) {
      if (!currentRunnable()) {
        throw new Error('\'expect\' was used when there was no current spec, this could be because an asynchronous test timed out');
      }

      return currentRunnable().expect(actual);
    };

    this.beforeEach = function(beforeEachFunction, timeout) {
      ensureIsNotNested('beforeEach');
      ensureIsFunctionOrAsync(beforeEachFunction, 'beforeEach');
      currentDeclarationSuite.beforeEach({
        fn: beforeEachFunction,
        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }
      });
    };

    this.beforeAll = function(beforeAllFunction, timeout) {
      ensureIsNotNested('beforeAll');
      ensureIsFunctionOrAsync(beforeAllFunction, 'beforeAll');
      currentDeclarationSuite.beforeAll({
        fn: beforeAllFunction,
        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }
      });
    };

    this.afterEach = function(afterEachFunction, timeout) {
      ensureIsNotNested('afterEach');
      ensureIsFunctionOrAsync(afterEachFunction, 'afterEach');
      afterEachFunction.isCleanup = true;
      currentDeclarationSuite.afterEach({
        fn: afterEachFunction,
        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }
      });
    };

    this.afterAll = function(afterAllFunction, timeout) {
      ensureIsNotNested('afterAll');
      ensureIsFunctionOrAsync(afterAllFunction, 'afterAll');
      currentDeclarationSuite.afterAll({
        fn: afterAllFunction,
        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }
      });
    };

    this.pending = function(message) {
      var fullMessage = j$.Spec.pendingSpecExceptionMessage;
      if(message) {
        fullMessage += message;
      }
      throw fullMessage;
    };

    this.fail = function(error) {
      if (!currentRunnable()) {
        throw new Error('\'fail\' was used when there was no current spec, this could be because an asynchronous test timed out');
      }

      var message = 'Failed';
      if (error) {
        message += ': ';
        if (error.message) {
          message += error.message;
        } else if (jasmine.isString_(error)) {
          message += error;
        } else {
          // pretty print all kind of objects. This includes arrays.
          message += jasmine.pp(error);
        }
      }

      currentRunnable().addExpectationResult(false, {
        matcherName: '',
        passed: false,
        expected: '',
        actual: '',
        message: message,
        error: error && error.message ? error : null
      });

      if (self.throwingExpectationFailures()) {
        throw new Error(message);
      }
    };
  }

  return Env;
};

getJasmineRequireObj().JsApiReporter = function() {

  var noopTimer = {
    start: function(){},
    elapsed: function(){ return 0; }
  };

  /**
   * @name jsApiReporter
   * @classdesc {@link Reporter} added by default in `boot.js` to record results for retrieval in javascript code. An instance is made available as `jsApiReporter` on the global object.
   * @class
   * @hideconstructor
   */
  function JsApiReporter(options) {
    var timer = options.timer || noopTimer,
        status = 'loaded';

    this.started = false;
    this.finished = false;
    this.runDetails = {};

    this.jasmineStarted = function() {
      this.started = true;
      status = 'started';
      timer.start();
    };

    var executionTime;

    this.jasmineDone = function(runDetails) {
      this.finished = true;
      this.runDetails = runDetails;
      executionTime = timer.elapsed();
      status = 'done';
    };

    /**
     * Get the current status for the Jasmine environment.
     * @name jsApiReporter#status
     * @function
     * @return {String} - One of `loaded`, `started`, or `done`
     */
    this.status = function() {
      return status;
    };

    var suites = [],
      suites_hash = {};

    this.suiteStarted = function(result) {
      suites_hash[result.id] = result;
    };

    this.suiteDone = function(result) {
      storeSuite(result);
    };

    /**
     * Get the results for a set of suites.
     *
     * Retrievable in slices for easier serialization.
     * @name jsApiReporter#suiteResults
     * @function
     * @param {Number} index - The position in the suites list to start from.
     * @param {Number} length - Maximum number of suite results to return.
     * @return {SuiteResult[]}
     */
    this.suiteResults = function(index, length) {
      return suites.slice(index, index + length);
    };

    function storeSuite(result) {
      suites.push(result);
      suites_hash[result.id] = result;
    }

    /**
     * Get all of the suites in a single object, with their `id` as the key.
     * @name jsApiReporter#suites
     * @function
     * @return {Object} - Map of suite id to {@link SuiteResult}
     */
    this.suites = function() {
      return suites_hash;
    };

    var specs = [];

    this.specDone = function(result) {
      specs.push(result);
    };

    /**
     * Get the results for a set of specs.
     *
     * Retrievable in slices for easier serialization.
     * @name jsApiReporter#specResults
     * @function
     * @param {Number} index - The position in the specs list to start from.
     * @param {Number} length - Maximum number of specs results to return.
     * @return {SpecResult[]}
     */
    this.specResults = function(index, length) {
      return specs.slice(index, index + length);
    };

    /**
     * Get all spec results.
     * @name jsApiReporter#specs
     * @function
     * @return {SpecResult[]}
     */
    this.specs = function() {
      return specs;
    };

    /**
     * Get the number of milliseconds it took for the full Jasmine suite to run.
     * @name jsApiReporter#executionTime
     * @function
     * @return {Number}
     */
    this.executionTime = function() {
      return executionTime;
    };

  }

  return JsApiReporter;
};

getJasmineRequireObj().Any = function(j$) {

  function Any(expectedObject) {
    if (typeof expectedObject === 'undefined') {
      throw new TypeError(
        'jasmine.any() expects to be passed a constructor function. ' +
        'Please pass one or use jasmine.anything() to match any object.'
      );
    }
    this.expectedObject = expectedObject;
  }

  Any.prototype.asymmetricMatch = function(other) {
    if (this.expectedObject == String) {
      return typeof other == 'string' || other instanceof String;
    }

    if (this.expectedObject == Number) {
      return typeof other == 'number' || other instanceof Number;
    }

    if (this.expectedObject == Function) {
      return typeof other == 'function' || other instanceof Function;
    }

    if (this.expectedObject == Object) {
      if (other === null) {
        j$.getEnv().deprecated('jasmine.Any(Object) will no longer match null in Jasmine 3.0');
      }
      return typeof other == 'object';
    }

    if (this.expectedObject == Boolean) {
      return typeof other == 'boolean';
    }

    /* jshint -W122 */
    if (typeof Symbol != 'undefined' && this.expectedObject == Symbol) {
      return typeof other == 'symbol';
    }
    /* jshint +W122 */

    return other instanceof this.expectedObject;
  };

  Any.prototype.jasmineToString = function() {
    return '<jasmine.any(' + j$.fnNameFor(this.expectedObject) + ')>';
  };

  return Any;
};

getJasmineRequireObj().Anything = function(j$) {

  function Anything() {}

  Anything.prototype.asymmetricMatch = function(other) {
    return !j$.util.isUndefined(other) && other !== null;
  };

  Anything.prototype.jasmineToString = function() {
    return '<jasmine.anything>';
  };

  return Anything;
};

getJasmineRequireObj().ArrayContaining = function(j$) {
  function ArrayContaining(sample) {
    this.sample = sample;
  }

  ArrayContaining.prototype.asymmetricMatch = function(other, customTesters) {
    if (!j$.isArray_(this.sample)) {
      throw new Error('You must provide an array to arrayContaining, not ' + j$.pp(this.sample) + '.');
    }

    for (var i = 0; i < this.sample.length; i++) {
      var item = this.sample[i];
      if (!j$.matchersUtil.contains(other, item, customTesters)) {
        return false;
      }
    }

    return true;
  };

  ArrayContaining.prototype.jasmineToString = function () {
    return '<jasmine.arrayContaining(' + jasmine.pp(this.sample) +')>';
  };

  return ArrayContaining;
};

getJasmineRequireObj().ArrayWithExactContents = function(j$) {

  function ArrayWithExactContents(sample) {
    this.sample = sample;
  }

  ArrayWithExactContents.prototype.asymmetricMatch = function(other, customTesters) {
    if (!j$.isArray_(this.sample)) {
      throw new Error('You must provide an array to arrayWithExactContents, not ' + j$.pp(this.sample) + '.');
    }

    if (this.sample.length !== other.length) {
      return false;
    }

    for (var i = 0; i < this.sample.length; i++) {
      var item = this.sample[i];
      if (!j$.matchersUtil.contains(other, item, customTesters)) {
        return false;
      }
    }

    return true;
  };

  ArrayWithExactContents.prototype.jasmineToString = function() {
    return '<jasmine.arrayWithExactContents ' + j$.pp(this.sample) + '>';
  };

  return ArrayWithExactContents;
};

getJasmineRequireObj().ObjectContaining = function(j$) {

  function ObjectContaining(sample) {
    this.sample = sample;
  }

  function getPrototype(obj) {
    if (Object.getPrototypeOf) {
      return Object.getPrototypeOf(obj);
    }

    if (obj.constructor.prototype == obj) {
      return null;
    }

    return obj.constructor.prototype;
  }

  function hasProperty(obj, property) {
    if (!obj) {
      return false;
    }

    if (Object.prototype.hasOwnProperty.call(obj, property)) {
      return true;
    }

    return hasProperty(getPrototype(obj), property);
  }

  ObjectContaining.prototype.asymmetricMatch = function(other, customTesters) {
    if (typeof(this.sample) !== 'object') { throw new Error('You must provide an object to objectContaining, not \''+this.sample+'\'.'); }

    for (var property in this.sample) {
      if (!hasProperty(other, property) ||
          !j$.matchersUtil.equals(this.sample[property], other[property], customTesters)) {
        return false;
      }
    }

    return true;
  };

  ObjectContaining.prototype.jasmineToString = function() {
    return '<jasmine.objectContaining(' + j$.pp(this.sample) + ')>';
  };

  return ObjectContaining;
};

getJasmineRequireObj().StringMatching = function(j$) {

  function StringMatching(expected) {
    if (!j$.isString_(expected) && !j$.isA_('RegExp', expected)) {
      throw new Error('Expected is not a String or a RegExp');
    }

    this.regexp = new RegExp(expected);
  }

  StringMatching.prototype.asymmetricMatch = function(other) {
    return this.regexp.test(other);
  };

  StringMatching.prototype.jasmineToString = function() {
    return '<jasmine.stringMatching(' + this.regexp + ')>';
  };

  return StringMatching;
};

getJasmineRequireObj().CallTracker = function(j$) {

  /**
   * @namespace Spy#calls
   */
  function CallTracker() {
    var calls = [];
    var opts = {};

    this.track = function(context) {
      if(opts.cloneArgs) {
        context.args = j$.util.cloneArgs(context.args);
      }
      calls.push(context);
    };

    /**
     * Check whether this spy has been invoked.
     * @name Spy#calls#any
     * @function
     * @return {Boolean}
     */
    this.any = function() {
      return !!calls.length;
    };

    /**
     * Get the number of invocations of this spy.
     * @name Spy#calls#count
     * @function
     * @return {Integer}
     */
    this.count = function() {
      return calls.length;
    };

    /**
     * Get the arguments that were passed to a specific invocation of this spy.
     * @name Spy#calls#argsFor
     * @function
     * @param {Integer} index The 0-based invocation index.
     * @return {Array}
     */
    this.argsFor = function(index) {
      var call = calls[index];
      return call ? call.args : [];
    };

    /**
     * Get the raw calls array for this spy.
     * @name Spy#calls#all
     * @function
     * @return {Spy.callData[]}
     */
    this.all = function() {
      return calls;
    };

    /**
     * Get all of the arguments for each invocation of this spy in the order they were received.
     * @name Spy#calls#allArgs
     * @function
     * @return {Array}
     */
    this.allArgs = function() {
      var callArgs = [];
      for(var i = 0; i < calls.length; i++){
        callArgs.push(calls[i].args);
      }

      return callArgs;
    };

    /**
     * Get the first invocation of this spy.
     * @name Spy#calls#first
     * @function
     * @return {ObjecSpy.callData}
     */
    this.first = function() {
      return calls[0];
    };

    /**
     * Get the most recent invocation of this spy.
     * @name Spy#calls#mostRecent
     * @function
     * @return {ObjecSpy.callData}
     */
    this.mostRecent = function() {
      return calls[calls.length - 1];
    };

    /**
     * Reset this spy as if it has never been called.
     * @name Spy#calls#reset
     * @function
     */
    this.reset = function() {
      calls = [];
    };

    /**
     * Set this spy to do a shallow clone of arguments passed to each invocation.
     * @name Spy#calls#saveArgumentsByValue
     * @function
     */
    this.saveArgumentsByValue = function() {
      opts.cloneArgs = true;
    };

  }

  return CallTracker;
};

getJasmineRequireObj().clearStack = function(j$) {
  var maxInlineCallCount = 10;

  function messageChannelImpl(global, setTimeout) {
    var channel = new global.MessageChannel(),
        head = {},
        tail = head;

    var taskRunning = false;
    channel.port1.onmessage = function() {
      head = head.next;
      var task = head.task;
      delete head.task;

      if (taskRunning) {
        global.setTimeout(task, 0);
      } else {
        try {
          taskRunning = true;
          task();
        } finally {
          taskRunning = false;
        }
      }
    };

    var currentCallCount = 0;
    return function clearStack(fn) {
      currentCallCount++;

      if (currentCallCount < maxInlineCallCount) {
        tail = tail.next = { task: fn };
        channel.port2.postMessage(0);
      } else {
        currentCallCount = 0;
        setTimeout(fn);
      }
    };
  }

  function getClearStack(global) {
    var currentCallCount = 0;
    var realSetTimeout = global.setTimeout;
    var setTimeoutImpl = function clearStack(fn) {
        Function.prototype.apply.apply(realSetTimeout, [global, [fn, 0]]);
    };

    if (j$.isFunction_(global.setImmediate)) {
      var realSetImmediate = global.setImmediate;
      return function(fn) {
        currentCallCount++;

        if (currentCallCount < maxInlineCallCount) {
          realSetImmediate(fn);
        } else {
          currentCallCount = 0;

          setTimeoutImpl(fn);
        }
      };
    } else if (!j$.util.isUndefined(global.MessageChannel)) {
      return messageChannelImpl(global, setTimeoutImpl);
    } else {
      return setTimeoutImpl;
    }
  }

  return getClearStack;
};

getJasmineRequireObj().Clock = function() {

  var NODE_JS = typeof process !== 'undefined' && process.versions && typeof process.versions.node === 'string';

  /**
   * _Note:_ Do not construct this directly, Jasmine will make one during booting. You can get the current clock with {@link jasmine.clock}.
   * @class Clock
   * @classdesc Jasmine's mock clock is used when testing time dependent code.
   */
  function Clock(global, delayedFunctionSchedulerFactory, mockDate) {
    var self = this,
      realTimingFunctions = {
        setTimeout: global.setTimeout,
        clearTimeout: global.clearTimeout,
        setInterval: global.setInterval,
        clearInterval: global.clearInterval
      },
      fakeTimingFunctions = {
        setTimeout: setTimeout,
        clearTimeout: clearTimeout,
        setInterval: setInterval,
        clearInterval: clearInterval
      },
      installed = false,
      delayedFunctionScheduler,
      timer;

    self.FakeTimeout = FakeTimeout;

    /**
     * Install the mock clock over the built-in methods.
     * @name Clock#install
     * @function
     * @return {Clock}
     */
    self.install = function() {
      if(!originalTimingFunctionsIntact()) {
        throw new Error('Jasmine Clock was unable to install over custom global timer functions. Is the clock already installed?');
      }
      replace(global, fakeTimingFunctions);
      timer = fakeTimingFunctions;
      delayedFunctionScheduler = delayedFunctionSchedulerFactory();
      installed = true;

      return self;
    };

    /**
     * Uninstall the mock clock, returning the built-in methods to their places.
     * @name Clock#uninstall
     * @function
     */
    self.uninstall = function() {
      delayedFunctionScheduler = null;
      mockDate.uninstall();
      replace(global, realTimingFunctions);

      timer = realTimingFunctions;
      installed = false;
    };

    /**
     * Execute a function with a mocked Clock
     *
     * The clock will be {@link Clock#install|install}ed before the function is called and {@link Clock#uninstall|uninstall}ed in a `finally` after the function completes.
     * @name Clock#withMock
     * @function
     * @param {closure} Function The function to be called.
     */
    self.withMock = function(closure) {
      this.install();
      try {
        closure();
      } finally {
        this.uninstall();
      }
    };

    /**
     * Instruct the installed Clock to also mock the date returned by `new Date()`
     * @name Clock#mockDate
     * @function
     * @param {Date} [initialDate=now] The `Date` to provide.
     */
    self.mockDate = function(initialDate) {
      mockDate.install(initialDate);
    };

    self.setTimeout = function(fn, delay, params) {
      if (legacyIE()) {
        if (arguments.length > 2) {
          throw new Error('IE < 9 cannot support extra params to setTimeout without a polyfill');
        }
        return timer.setTimeout(fn, delay);
      }
      return Function.prototype.apply.apply(timer.setTimeout, [global, arguments]);
    };

    self.setInterval = function(fn, delay, params) {
      if (legacyIE()) {
        if (arguments.length > 2) {
          throw new Error('IE < 9 cannot support extra params to setInterval without a polyfill');
        }
        return timer.setInterval(fn, delay);
      }
      return Function.prototype.apply.apply(timer.setInterval, [global, arguments]);
    };

    self.clearTimeout = function(id) {
      return Function.prototype.call.apply(timer.clearTimeout, [global, id]);
    };

    self.clearInterval = function(id) {
      return Function.prototype.call.apply(timer.clearInterval, [global, id]);
    };

    /**
     * Tick the Clock forward, running any enqueued timeouts along the way
     * @name Clock#tick
     * @function
     * @param {int} millis The number of milliseconds to tick.
     */
    self.tick = function(millis) {
      if (installed) {
        delayedFunctionScheduler.tick(millis, function(millis) { mockDate.tick(millis); });
      } else {
        throw new Error('Mock clock is not installed, use jasmine.clock().install()');
      }
    };

    return self;

    function originalTimingFunctionsIntact() {
      return global.setTimeout === realTimingFunctions.setTimeout &&
        global.clearTimeout === realTimingFunctions.clearTimeout &&
        global.setInterval === realTimingFunctions.setInterval &&
        global.clearInterval === realTimingFunctions.clearInterval;
    }

    function legacyIE() {
      //if these methods are polyfilled, apply will be present
      return !(realTimingFunctions.setTimeout || realTimingFunctions.setInterval).apply;
    }

    function replace(dest, source) {
      for (var prop in source) {
        dest[prop] = source[prop];
      }
    }

    function setTimeout(fn, delay) {
      if (!NODE_JS) {
        return delayedFunctionScheduler.scheduleFunction(fn, delay, argSlice(arguments, 2));
      }

      var timeout = new FakeTimeout();

      delayedFunctionScheduler.scheduleFunction(fn, delay, argSlice(arguments, 2), false, timeout);

      return timeout;
    }

    function clearTimeout(id) {
      return delayedFunctionScheduler.removeFunctionWithId(id);
    }

    function setInterval(fn, interval) {
      if (!NODE_JS) {
        return delayedFunctionScheduler.scheduleFunction(fn, interval, argSlice(arguments, 2), true);
      }

      var timeout = new FakeTimeout();

      delayedFunctionScheduler.scheduleFunction(fn, interval, argSlice(arguments, 2), true, timeout);

      return timeout;
    }

    function clearInterval(id) {
      return delayedFunctionScheduler.removeFunctionWithId(id);
    }

    function argSlice(argsObj, n) {
      return Array.prototype.slice.call(argsObj, n);
    }
  }

  /**
   * Mocks Node.js Timeout class
   */
  function FakeTimeout() {}

  FakeTimeout.prototype.ref = function () {
    return this;
  };

  FakeTimeout.prototype.unref = function () {
    return this;
  };

  return Clock;
};

getJasmineRequireObj().DelayedFunctionScheduler = function(j$) {
  function DelayedFunctionScheduler() {
    var self = this;
    var scheduledLookup = [];
    var scheduledFunctions = {};
    var currentTime = 0;
    var delayedFnCount = 0;
    var deletedKeys = [];

    self.tick = function(millis, tickDate) {
      millis = millis || 0;
      var endTime = currentTime + millis;

      runScheduledFunctions(endTime, tickDate);
      currentTime = endTime;
    };

    self.scheduleFunction = function(funcToCall, millis, params, recurring, timeoutKey, runAtMillis) {
      var f;
      if (typeof(funcToCall) === 'string') {
        /* jshint evil: true */
        f = function() { return eval(funcToCall); };
        /* jshint evil: false */
      } else {
        f = funcToCall;
      }

      millis = millis || 0;
      timeoutKey = timeoutKey || ++delayedFnCount;
      runAtMillis = runAtMillis || (currentTime + millis);

      var funcToSchedule = {
        runAtMillis: runAtMillis,
        funcToCall: f,
        recurring: recurring,
        params: params,
        timeoutKey: timeoutKey,
        millis: millis
      };

      if (runAtMillis in scheduledFunctions) {
        scheduledFunctions[runAtMillis].push(funcToSchedule);
      } else {
        scheduledFunctions[runAtMillis] = [funcToSchedule];
        scheduledLookup.push(runAtMillis);
        scheduledLookup.sort(function (a, b) {
          return a - b;
        });
      }

      return timeoutKey;
    };

    self.removeFunctionWithId = function(timeoutKey) {
      deletedKeys.push(timeoutKey);

      for (var runAtMillis in scheduledFunctions) {
        var funcs = scheduledFunctions[runAtMillis];
        var i = indexOfFirstToPass(funcs, function (func) {
          return func.timeoutKey === timeoutKey;
        });

        if (i > -1) {
          if (funcs.length === 1) {
            delete scheduledFunctions[runAtMillis];
            deleteFromLookup(runAtMillis);
          } else {
            funcs.splice(i, 1);
          }

          // intervals get rescheduled when executed, so there's never more
          // than a single scheduled function with a given timeoutKey
          break;
        }
      }
    };

    return self;

    function indexOfFirstToPass(array, testFn) {
      var index = -1;

      for (var i = 0; i < array.length; ++i) {
        if (testFn(array[i])) {
          index = i;
          break;
        }
      }

      return index;
    }

    function deleteFromLookup(key) {
      var value = Number(key);
      var i = indexOfFirstToPass(scheduledLookup, function (millis) {
        return millis === value;
      });

      if (i > -1) {
        scheduledLookup.splice(i, 1);
      }
    }

    function reschedule(scheduledFn) {
      self.scheduleFunction(scheduledFn.funcToCall,
        scheduledFn.millis,
        scheduledFn.params,
        true,
        scheduledFn.timeoutKey,
        scheduledFn.runAtMillis + scheduledFn.millis);
    }

    function forEachFunction(funcsToRun, callback) {
      for (var i = 0; i < funcsToRun.length; ++i) {
        callback(funcsToRun[i]);
      }
    }

    function runScheduledFunctions(endTime, tickDate) {
      tickDate = tickDate || function() {};
      if (scheduledLookup.length === 0 || scheduledLookup[0] > endTime) {
        tickDate(endTime - currentTime);
        return;
      }

      do {
        deletedKeys = [];
        var newCurrentTime = scheduledLookup.shift();
        tickDate(newCurrentTime - currentTime);

        currentTime = newCurrentTime;

        var funcsToRun = scheduledFunctions[currentTime];

        delete scheduledFunctions[currentTime];

        forEachFunction(funcsToRun, function(funcToRun) {
          if (funcToRun.recurring) {
            reschedule(funcToRun);
          }
        });

        forEachFunction(funcsToRun, function(funcToRun) {
          if (j$.util.arrayContains(deletedKeys, funcToRun.timeoutKey)) {
            // skip a timeoutKey deleted whilst we were running
            return;
          }
          funcToRun.funcToCall.apply(null, funcToRun.params || []);
        });
      } while (scheduledLookup.length > 0 &&
              // checking first if we're out of time prevents setTimeout(0)
              // scheduled in a funcToRun from forcing an extra iteration
                 currentTime !== endTime  &&
                 scheduledLookup[0] <= endTime);

      // ran out of functions to call, but still time left on the clock
      if (currentTime !== endTime) {
        tickDate(endTime - currentTime);
      }
    }
  }

  return DelayedFunctionScheduler;
};

getJasmineRequireObj().errors = function() {
  function ExpectationFailed() {}

  ExpectationFailed.prototype = new Error();
  ExpectationFailed.prototype.constructor = ExpectationFailed;

  return {
    ExpectationFailed: ExpectationFailed
  };
};
getJasmineRequireObj().ExceptionFormatter = function() {
  function ExceptionFormatter() {
    this.message = function(error) {
      var message = '';

      if (error.name && error.message) {
        message += error.name + ': ' + error.message;
      } else {
        message += error.toString() + ' thrown';
      }

      if (error.fileName || error.sourceURL) {
        message += ' in ' + (error.fileName || error.sourceURL);
      }

      if (error.line || error.lineNumber) {
        message += ' (line ' + (error.line || error.lineNumber) + ')';
      }

      return message;
    };

    this.stack = function(error) {
      return error ? error.stack : null;
    };
  }

  return ExceptionFormatter;
};

getJasmineRequireObj().Expectation = function() {

  /**
   * Matchers that come with Jasmine out of the box.
   * @namespace matchers
   */
  function Expectation(options) {
    this.util = options.util || { buildFailureMessage: function() {} };
    this.customEqualityTesters = options.customEqualityTesters || [];
    this.actual = options.actual;
    this.addExpectationResult = options.addExpectationResult || function(){};
    this.isNot = options.isNot;

    var customMatchers = options.customMatchers || {};
    for (var matcherName in customMatchers) {
      this[matcherName] = Expectation.prototype.wrapCompare(matcherName, customMatchers[matcherName]);
    }
  }

  Expectation.prototype.wrapCompare = function(name, matcherFactory) {
    return function() {
      var args = Array.prototype.slice.call(arguments, 0),
        expected = args.slice(0),
        message = '';

      args.unshift(this.actual);

      var matcher = matcherFactory(this.util, this.customEqualityTesters),
          matcherCompare = matcher.compare;

      function defaultNegativeCompare() {
        var result = matcher.compare.apply(null, args);
        result.pass = !result.pass;
        return result;
      }

      if (this.isNot) {
        matcherCompare = matcher.negativeCompare || defaultNegativeCompare;
      }

      var result = matcherCompare.apply(null, args);

      if (!result.pass) {
        if (!result.message) {
          args.unshift(this.isNot);
          args.unshift(name);
          message = this.util.buildFailureMessage.apply(null, args);
        } else {
          if (Object.prototype.toString.apply(result.message) === '[object Function]') {
            message = result.message();
          } else {
            message = result.message;
          }
        }
      }

      if (expected.length == 1) {
        expected = expected[0];
      }

      // TODO: how many of these params are needed?
      this.addExpectationResult(
        result.pass,
        {
          matcherName: name,
          passed: result.pass,
          message: message,
          error: result.error,
          actual: this.actual,
          expected: expected // TODO: this may need to be arrayified/sliced
        }
      );
    };
  };

  Expectation.addCoreMatchers = function(matchers) {
    var prototype = Expectation.prototype;
    for (var matcherName in matchers) {
      var matcher = matchers[matcherName];
      prototype[matcherName] = prototype.wrapCompare(matcherName, matcher);
    }
  };

  Expectation.Factory = function(options) {
    options = options || {};

    var expect = new Expectation(options);

    // TODO: this would be nice as its own Object - NegativeExpectation
    // TODO: copy instead of mutate options
    options.isNot = true;
    expect.not = new Expectation(options);

    return expect;
  };

  return Expectation;
};

//TODO: expectation result may make more sense as a presentation of an expectation.
getJasmineRequireObj().buildExpectationResult = function() {
  function buildExpectationResult(options) {
    var messageFormatter = options.messageFormatter || function() {},
      stackFormatter = options.stackFormatter || function() {};

    /**
     * @typedef Expectation
     * @property {String} matcherName - The name of the matcher that was executed for this expectation.
     * @property {String} message - The failure message for the expectation.
     * @property {String} stack - The stack trace for the failure if available.
     * @property {Boolean} passed - Whether the expectation passed or failed.
     * @property {Object} expected - If the expectation failed, what was the expected value.
     * @property {Object} actual - If the expectation failed, what actual value was produced.
     */
    var result = {
      matcherName: options.matcherName,
      message: message(),
      stack: stack(),
      passed: options.passed
    };

    if(!result.passed) {
      result.expected = options.expected;
      result.actual = options.actual;
    }

    return result;

    function message() {
      if (options.passed) {
        return 'Passed.';
      } else if (options.message) {
        return options.message;
      } else if (options.error) {
        return messageFormatter(options.error);
      }
      return '';
    }

    function stack() {
      if (options.passed) {
        return '';
      }

      var error = options.error;
      if (!error) {
        try {
          throw new Error(message());
        } catch (e) {
          error = e;
        }
      }
      return stackFormatter(error);
    }
  }

  return buildExpectationResult;
};

getJasmineRequireObj().formatErrorMsg = function() {
  function generateErrorMsg(domain, usage) {
    var usageDefinition = usage ? '\nUsage: ' + usage : '';

    return function errorMsg(msg) {
      return domain + ' : ' + msg + usageDefinition;
    };
  }

  return generateErrorMsg;
};

getJasmineRequireObj().GlobalErrors = function(j$) {
  function GlobalErrors(global) {
    var handlers = [];
    global = global || j$.getGlobal();

    var onerror = function onerror() {
      var handler = handlers[handlers.length - 1];

      if (handler) {
        handler.apply(null, Array.prototype.slice.call(arguments, 0));
      } else {
        throw arguments[0];
      }
    };

    this.uninstall = function noop() {};

    this.install = function install() {
      if (global.process && global.process.listeners && j$.isFunction_(global.process.on)) {
        var originalHandlers = global.process.listeners('uncaughtException');
        global.process.removeAllListeners('uncaughtException');
        global.process.on('uncaughtException', onerror);

        this.uninstall = function uninstall() {
          global.process.removeListener('uncaughtException', onerror);
          for (var i = 0; i < originalHandlers.length; i++) {
            global.process.on('uncaughtException', originalHandlers[i]);
          }
        };
      } else {
        var originalHandler = global.onerror;
        global.onerror = onerror;

        this.uninstall = function uninstall() {
          global.onerror = originalHandler;
        };
      }
    };

    this.pushListener = function pushListener(listener) {
      handlers.push(listener);
    };

    this.popListener = function popListener() {
      handlers.pop();
    };
  }

  return GlobalErrors;
};

getJasmineRequireObj().DiffBuilder = function(j$) {
  return function DiffBuilder() {
    var path = new j$.ObjectPath(),
        mismatches = [];

    return {
      record: function (actual, expected, formatter) {
        formatter = formatter || defaultFormatter;
        mismatches.push(formatter(actual, expected, path));
      },

      getMessage: function () {
        return mismatches.join('\n');
      },

      withPath: function (pathComponent, block) {
        var oldPath = path;
        path = path.add(pathComponent);
        block();
        path = oldPath;
      }
    };

    function defaultFormatter (actual, expected, path) {
      return 'Expected ' +
        path + (path.depth() ? ' = ' : '') +
        j$.pp(actual) +
        ' to equal ' +
        j$.pp(expected) +
        '.';
    }
  };
};

getJasmineRequireObj().matchersUtil = function(j$) {
  // TODO: what to do about jasmine.pp not being inject? move to JSON.stringify? gut PrettyPrinter?

  return {
    equals: equals,

    contains: function(haystack, needle, customTesters) {
      customTesters = customTesters || [];

      if ((Object.prototype.toString.apply(haystack) === '[object Set]')) {
        return haystack.has(needle);
      }

      if ((Object.prototype.toString.apply(haystack) === '[object Array]') ||
        (!!haystack && !haystack.indexOf))
      {
        for (var i = 0; i < haystack.length; i++) {
          if (equals(haystack[i], needle, customTesters)) {
            return true;
          }
        }
        return false;
      }

      return !!haystack && haystack.indexOf(needle) >= 0;
    },

    buildFailureMessage: function() {
      var args = Array.prototype.slice.call(arguments, 0),
        matcherName = args[0],
        isNot = args[1],
        actual = args[2],
        expected = args.slice(3),
        englishyPredicate = matcherName.replace(/[A-Z]/g, function(s) { return ' ' + s.toLowerCase(); });

      var message = 'Expected ' +
        j$.pp(actual) +
        (isNot ? ' not ' : ' ') +
        englishyPredicate;

      if (expected.length > 0) {
        for (var i = 0; i < expected.length; i++) {
          if (i > 0) {
            message += ',';
          }
          message += ' ' + j$.pp(expected[i]);
        }
      }

      return message + '.';
    }
  };

  function isAsymmetric(obj) {
    return obj && j$.isA_('Function', obj.asymmetricMatch);
  }

  function asymmetricMatch(a, b, customTesters, diffBuilder) {
    var asymmetricA = isAsymmetric(a),
        asymmetricB = isAsymmetric(b),
        result;

    if (asymmetricA && asymmetricB) {
      return undefined;
    }

    if (asymmetricA) {
      result = a.asymmetricMatch(b, customTesters);
      if (!result) {
        diffBuilder.record(a, b);
      }
      return result;
    }

    if (asymmetricB) {
      result = b.asymmetricMatch(a, customTesters);
      if (!result) {
        diffBuilder.record(a, b);
      }
      return result;
    }
  }

  function equals(a, b, customTesters, diffBuilder) {
    customTesters = customTesters || [];
    diffBuilder = diffBuilder || j$.NullDiffBuilder();

    return eq(a, b, [], [], customTesters, diffBuilder);
  }

  // Equality function lovingly adapted from isEqual in
  //   [Underscore](http://underscorejs.org)
  function eq(a, b, aStack, bStack, customTesters, diffBuilder) {
    var result = true, i;

    var asymmetricResult = asymmetricMatch(a, b, customTesters, diffBuilder);
    if (!j$.util.isUndefined(asymmetricResult)) {
      return asymmetricResult;
    }

    for (i = 0; i < customTesters.length; i++) {
      var customTesterResult = customTesters[i](a, b);
      if (!j$.util.isUndefined(customTesterResult)) {
        if (!customTesterResult) {
          diffBuilder.record(a, b);
        }
        return customTesterResult;
      }
    }

    if (a instanceof Error && b instanceof Error) {
      result = a.message == b.message;
      if (!result) {
        diffBuilder.record(a, b);
      }
      return result;
    }

    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) {
      result = a !== 0 || 1 / a == 1 / b;
      if (!result) {
        diffBuilder.record(a, b);
      }
      return result;
    }
    // A strict comparison is necessary because `null == undefined`.
    if (a === null || b === null) {
      result = a === b;
      if (!result) {
        diffBuilder.record(a, b);
      }
      return result;
    }
    var className = Object.prototype.toString.call(a);
    if (className != Object.prototype.toString.call(b)) {
      diffBuilder.record(a, b);
      return false;
    }
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        result = a == String(b);
        if (!result) {
          diffBuilder.record(a, b);
        }
        return result;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        result = a != +a ? b != +b : (a === 0 ? 1 / a == 1 / b : a == +b);
        if (!result) {
          diffBuilder.record(a, b);
        }
        return result;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        result = +a == +b;
        if (!result) {
          diffBuilder.record(a, b);
        }
        return result;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
          a.global == b.global &&
          a.multiline == b.multiline &&
          a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') {
      diffBuilder.record(a, b);
      return false;
    }

    var aIsDomNode = j$.isDomNode(a);
    var bIsDomNode = j$.isDomNode(b);
    if (aIsDomNode && bIsDomNode) {
      // At first try to use DOM3 method isEqualNode
      if (a.isEqualNode) {
        result = a.isEqualNode(b);
        if (!result) {
          diffBuilder.record(a, b);
        }
        return result;
      }
      // IE8 doesn't support isEqualNode, try to use outerHTML && innerText
      var aIsElement = a instanceof Element;
      var bIsElement = b instanceof Element;
      if (aIsElement && bIsElement) {
        result = a.outerHTML == b.outerHTML;
        if (!result) {
          diffBuilder.record(a, b);
        }
        return result;
      }
      if (aIsElement || bIsElement) {
        diffBuilder.record(a, b);
        return false;
      }
      result = a.innerText == b.innerText && a.textContent == b.textContent;
      if (!result) {
        diffBuilder.record(a, b);
      }
      return result;
    }
    if (aIsDomNode || bIsDomNode) {
      diffBuilder.record(a, b);
      return false;
    }

    var aIsPromise = j$.isPromise(a);
    var bIsPromise = j$.isPromise(b);
    if (aIsPromise && bIsPromise) {
      return a === b;
    }

    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) { return bStack[length] == b; }
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0;
    // Recursively compare objects and arrays.
    // Compare array lengths to determine if a deep comparison is necessary.
    if (className == '[object Array]') {
      var aLength = a.length;
      var bLength = b.length;

      diffBuilder.withPath('length', function() {
        if (aLength !== bLength) {
          diffBuilder.record(aLength, bLength);
          result = false;
        }
      });

      for (i = 0; i < aLength || i < bLength; i++) {
        diffBuilder.withPath(i, function() {
          result = eq(i < aLength ? a[i] : void 0, i < bLength ? b[i] : void 0, aStack, bStack, customTesters, diffBuilder) && result;
        });
      }
      if (!result) {
        return false;
      }
    } else if (j$.isMap(a) && j$.isMap(b)) {
      if (a.size != b.size) {
        diffBuilder.record(a, b);
        return false;
      }

      var keysA = [];
      var keysB = [];
      a.forEach( function( valueA, keyA ) {
        keysA.push( keyA );
      });
      b.forEach( function( valueB, keyB ) {
        keysB.push( keyB );
      });

      // For both sets of keys, check they map to equal values in both maps.
      // Keep track of corresponding keys (in insertion order) in order to handle asymmetric obj keys.
      var mapKeys = [keysA, keysB];
      var cmpKeys = [keysB, keysA];
      var mapIter, mapKey, mapValueA, mapValueB;
      var cmpIter, cmpKey;
      for (i = 0; result && i < mapKeys.length; i++) {
        mapIter = mapKeys[i];
        cmpIter = cmpKeys[i];

        for (var j = 0; result && j < mapIter.length; j++) {
          mapKey = mapIter[j];
          cmpKey = cmpIter[j];
          mapValueA = a.get(mapKey);

          // Only use the cmpKey when one of the keys is asymmetric and the corresponding key matches,
          // otherwise explicitly look up the mapKey in the other Map since we want keys with unique
          // obj identity (that are otherwise equal) to not match.
          if (isAsymmetric(mapKey) || isAsymmetric(cmpKey) &&
              eq(mapKey, cmpKey, aStack, bStack, customTesters, j$.NullDiffBuilder())) {
            mapValueB = b.get(cmpKey);
          } else {
            mapValueB = b.get(mapKey);
          }
          result = eq(mapValueA, mapValueB, aStack, bStack, customTesters, j$.NullDiffBuilder());
        }
      }

      if (!result) {
        diffBuilder.record(a, b);
        return false;
      }
    } else if (j$.isSet(a) && j$.isSet(b)) {
      if (a.size != b.size) {
        diffBuilder.record(a, b);
        return false;
      }

      var valuesA = [];
      a.forEach( function( valueA ) {
        valuesA.push( valueA );
      });
      var valuesB = [];
      b.forEach( function( valueB ) {
        valuesB.push( valueB );
      });

      // For both sets, check they are all contained in the other set
      var setPairs = [[valuesA, valuesB], [valuesB, valuesA]];
      var stackPairs = [[aStack, bStack], [bStack, aStack]];
      var baseValues, baseValue, baseStack;
      var otherValues, otherValue, otherStack;
      var found;
      var prevStackSize;
      for (i = 0; result && i < setPairs.length; i++) {
        baseValues = setPairs[i][0];
        otherValues = setPairs[i][1];
        baseStack = stackPairs[i][0];
        otherStack = stackPairs[i][1];
        // For each value in the base set...
        for (var k = 0; result && k < baseValues.length; k++) {
          baseValue = baseValues[k];
          found = false;
          // ... test that it is present in the other set
          for (var l = 0; !found && l < otherValues.length; l++) {
            otherValue = otherValues[l];
            prevStackSize = baseStack.length;
            // compare by value equality
            found = eq(baseValue, otherValue, baseStack, otherStack, customTesters, j$.NullDiffBuilder());
            if (!found && prevStackSize !== baseStack.length) {
              baseStack.splice(prevStackSize);
              otherStack.splice(prevStackSize);
            }
          }
          result = result && found;
        }
      }

      if (!result) {
        diffBuilder.record(a, b);
        return false;
      }
    } else {

      // Objects with different constructors are not equivalent, but `Object`s
      // or `Array`s from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor &&
          isFunction(aCtor) && isFunction(bCtor) &&
          a instanceof aCtor && b instanceof bCtor &&
          !(aCtor instanceof aCtor && bCtor instanceof bCtor)) {

        diffBuilder.record(a, b, constructorsAreDifferentFormatter);
        return false;
      }
    }

    // Deep compare objects.
    var aKeys = keys(a, className == '[object Array]'), key;
    size = aKeys.length;

    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (keys(b, className == '[object Array]').length !== size) {
      diffBuilder.record(a, b, objectKeysAreDifferentFormatter);
      return false;
    }

    for (i = 0; i < size; i++) {
      key = aKeys[i];
      // Deep compare each member
      if (!j$.util.has(b, key)) {
        diffBuilder.record(a, b, objectKeysAreDifferentFormatter);
        result = false;
        continue;
      }

      diffBuilder.withPath(key, function() {
        if(!eq(a[key], b[key], aStack, bStack, customTesters, diffBuilder)) {
          result = false;
        }
      });
    }

    if (!result) {
      return false;
    }

    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();

    return result;
  }

  function keys(obj, isArray) {
    var allKeys = Object.keys ? Object.keys(obj) :
      (function(o) {
          var keys = [];
          for (var key in o) {
              if (j$.util.has(o, key)) {
                  keys.push(key);
              }
          }
          return keys;
      })(obj);

    if (!isArray) {
      return allKeys;
    }

    if (allKeys.length === 0) {
        return allKeys;
    }

    var extraKeys = [];
    for (var i = 0; i < allKeys.length; i++) {
      if (!/^[0-9]+$/.test(allKeys[i])) {
        extraKeys.push(allKeys[i]);
      }
    }

    return extraKeys;
  }

  function has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }

  function isFunction(obj) {
    return typeof obj === 'function';
  }

  function objectKeysAreDifferentFormatter(actual, expected, path) {
    var missingProperties = j$.util.objectDifference(expected, actual),
        extraProperties = j$.util.objectDifference(actual, expected),
        missingPropertiesMessage = formatKeyValuePairs(missingProperties),
        extraPropertiesMessage = formatKeyValuePairs(extraProperties),
        messages = [];

    if (!path.depth()) {
      path = 'object';
    }

    if (missingPropertiesMessage.length) {
      messages.push('Expected ' + path + ' to have properties' + missingPropertiesMessage);
    }

    if (extraPropertiesMessage.length) {
      messages.push('Expected ' + path + ' not to have properties' + extraPropertiesMessage);
    }

    return messages.join('\n');
  }

  function constructorsAreDifferentFormatter(actual, expected, path) {
    if (!path.depth()) {
      path = 'object';
    }

    return 'Expected ' +
      path + ' to be a kind of ' +
      j$.fnNameFor(expected.constructor) +
      ', but was ' + j$.pp(actual) + '.';
  }

  function formatKeyValuePairs(obj) {
    var formatted = '';
    for (var key in obj) {
      formatted += '\n    ' + key + ': ' + j$.pp(obj[key]);
    }
    return formatted;
  }
};

getJasmineRequireObj().nothing = function() {
  /**
   * {@link expect} nothing explicitly.
   * @function
   * @name matchers#nothing
   * @example
   * expect().nothing();
   */
  function nothing() {
    return {
      compare: function() {
        return {
          pass: true
        };
      }
    };
  }

  return nothing;
};

getJasmineRequireObj().NullDiffBuilder = function(j$) {
  return function() {
    return {
      withPath: function(_, block) {
        block();
      },
      record: function() {}
    };
  };
};

getJasmineRequireObj().ObjectPath = function(j$) {
  function ObjectPath(components) {
    this.components = components || [];
  }

  ObjectPath.prototype.toString = function() {
    if (this.components.length) {
      return '$' + map(this.components, formatPropertyAccess).join('');
    } else {
      return '';
    }
  };

  ObjectPath.prototype.add = function(component) {
    return new ObjectPath(this.components.concat([component]));
  };

  ObjectPath.prototype.depth = function() {
    return this.components.length;
  };

  function formatPropertyAccess(prop) {
    if (typeof prop === 'number') {
      return '[' + prop + ']';
    }

    if (isValidIdentifier(prop)) {
      return '.' + prop;
    }

    return '[\'' + prop + '\']';
  }

  function map(array, fn) {
    var results = [];
    for (var i = 0; i < array.length; i++) {
      results.push(fn(array[i]));
    }
    return results;
  }

  function isValidIdentifier(string) {
    return /^[A-Za-z\$_][A-Za-z0-9\$_]*$/.test(string);
  }

  return ObjectPath;
};

getJasmineRequireObj().toBe = function() {
  /**
   * {@link expect} the actual value to be `===` to the expected value.
   * @function
   * @name matchers#toBe
   * @param {Object} expected - The expected value to compare against.
   * @example
   * expect(thing).toBe(realThing);
   */
  function toBe() {
    return {
      compare: function(actual, expected) {
        return {
          pass: actual === expected
        };
      }
    };
  }

  return toBe;
};

getJasmineRequireObj().toBeCloseTo = function() {
  /**
   * {@link expect} the actual value to be within a specified precision of the expected value.
   * @function
   * @name matchers#toBeCloseTo
   * @param {Object} expected - The expected value to compare against.
   * @param {Number} [precision=2] - The number of decimal points to check.
   * @example
   * expect(number).toBeCloseTo(42.2, 3);
   */
  function toBeCloseTo() {
    return {
      compare: function(actual, expected, precision) {
        if (precision !== 0) {
          precision = precision || 2;
        }

        if (expected === null || actual === null) {
          throw new Error('Cannot use toBeCloseTo with null. Arguments evaluated to: ' +
            'expect(' + actual + ').toBeCloseTo(' + expected + ').'
          );
        }

        var pow = Math.pow(10, precision + 1);
        var delta = Math.abs(expected - actual);
        var maxDelta = Math.pow(10, -precision) / 2;

        return {
          pass: Math.round(delta * pow) / pow <= maxDelta
        };
      }
    };
  }

  return toBeCloseTo;
};

getJasmineRequireObj().toBeDefined = function() {
  /**
   * {@link expect} the actual value to be defined. (Not `undefined`)
   * @function
   * @name matchers#toBeDefined
   * @example
   * expect(result).toBeDefined();
   */
  function toBeDefined() {
    return {
      compare: function(actual) {
        return {
          pass: (void 0 !== actual)
        };
      }
    };
  }

  return toBeDefined;
};

getJasmineRequireObj().toBeFalsy = function() {
  /**
   * {@link expect} the actual value to be falsy
   * @function
   * @name matchers#toBeFalsy
   * @example
   * expect(result).toBeFalsy();
   */
  function toBeFalsy() {
    return {
      compare: function(actual) {
        return {
          pass: !!!actual
        };
      }
    };
  }

  return toBeFalsy;
};

getJasmineRequireObj().toBeGreaterThan = function() {
  /**
   * {@link expect} the actual value to be greater than the expected value.
   * @function
   * @name matchers#toBeGreaterThan
   * @param {Number} expected - The value to compare against.
   * @example
   * expect(result).toBeGreaterThan(3);
   */
  function toBeGreaterThan() {
    return {
      compare: function(actual, expected) {
        return {
          pass: actual > expected
        };
      }
    };
  }

  return toBeGreaterThan;
};


getJasmineRequireObj().toBeGreaterThanOrEqual = function() {
  /**
   * {@link expect} the actual value to be greater than or equal to the expected value.
   * @function
   * @name matchers#toBeGreaterThanOrEqual
   * @param {Number} expected - The expected value to compare against.
   * @example
   * expect(result).toBeGreaterThanOrEqual(25);
   */
  function toBeGreaterThanOrEqual() {
    return {
      compare: function(actual, expected) {
        return {
          pass: actual >= expected
        };
      }
    };
  }

  return toBeGreaterThanOrEqual;
};

getJasmineRequireObj().toBeLessThan = function() {
  /**
   * {@link expect} the actual value to be less than the expected value.
   * @function
   * @name matchers#toBeLessThan
   * @param {Number} expected - The expected value to compare against.
   * @example
   * expect(result).toBeLessThan(0);
   */
  function toBeLessThan() {
    return {

      compare: function(actual, expected) {
        return {
          pass: actual < expected
        };
      }
    };
  }

  return toBeLessThan;
};

getJasmineRequireObj().toBeLessThanOrEqual = function() {
  /**
   * {@link expect} the actual value to be less than or equal to the expected value.
   * @function
   * @name matchers#toBeLessThanOrEqual
   * @param {Number} expected - The expected value to compare against.
   * @example
   * expect(result).toBeLessThanOrEqual(123);
   */
  function toBeLessThanOrEqual() {
    return {

      compare: function(actual, expected) {
        return {
          pass: actual <= expected
        };
      }
    };
  }

  return toBeLessThanOrEqual;
};

getJasmineRequireObj().toBeNaN = function(j$) {
  /**
   * {@link expect} the actual value to be `NaN` (Not a Number).
   * @function
   * @name matchers#toBeNaN
   * @example
   * expect(thing).toBeNaN();
   */
  function toBeNaN() {
    return {
      compare: function(actual) {
        var result = {
          pass: (actual !== actual)
        };

        if (result.pass) {
          result.message = 'Expected actual not to be NaN.';
        } else {
          result.message = function() { return 'Expected ' + j$.pp(actual) + ' to be NaN.'; };
        }

        return result;
      }
    };
  }

  return toBeNaN;
};

getJasmineRequireObj().toBeNegativeInfinity = function(j$) {
  /**
   * {@link expect} the actual value to be `-Infinity` (-infinity).
   * @function
   * @name matchers#toBeNegativeInfinity
   * @example
   * expect(thing).toBeNegativeInfinity();
   */
  function toBeNegativeInfinity() {
    return {
      compare: function(actual) {
        var result = {
          pass: (actual === Number.NEGATIVE_INFINITY)
        };

        if (result.pass) {
          result.message = 'Expected actual to be -Infinity.';
        } else {
          result.message = function() { return 'Expected ' + j$.pp(actual) + ' not to be -Infinity.'; };
        }

        return result;
      }
    };
  }

  return toBeNegativeInfinity;
};

getJasmineRequireObj().toBeNull = function() {
  /**
   * {@link expect} the actual value to be `null`.
   * @function
   * @name matchers#toBeNull
   * @example
   * expect(result).toBeNull();
   */
  function toBeNull() {
    return {
      compare: function(actual) {
        return {
          pass: actual === null
        };
      }
    };
  }

  return toBeNull;
};

getJasmineRequireObj().toBePositiveInfinity = function(j$) {
  /**
   * {@link expect} the actual value to be `Infinity` (infinity).
   * @function
   * @name matchers#toBePositiveInfinity
   * @example
   * expect(thing).toBePositiveInfinity();
   */
  function toBePositiveInfinity() {
    return {
      compare: function(actual) {
        var result = {
          pass: (actual === Number.POSITIVE_INFINITY)
        };

        if (result.pass) {
          result.message = 'Expected actual to be Infinity.';
        } else {
          result.message = function() { return 'Expected ' + j$.pp(actual) + ' not to be Infinity.'; };
        }

        return result;
      }
    };
  }

  return toBePositiveInfinity;
};

getJasmineRequireObj().toBeTruthy = function() {
  /**
   * {@link expect} the actual value to be truthy.
   * @function
   * @name matchers#toBeTruthy
   * @example
   * expect(thing).toBeTruthy();
   */
  function toBeTruthy() {
    return {
      compare: function(actual) {
        return {
          pass: !!actual
        };
      }
    };
  }

  return toBeTruthy;
};

getJasmineRequireObj().toBeUndefined = function() {
  /**
   * {@link expect} the actual value to be `undefined`.
   * @function
   * @name matchers#toBeUndefined
   * @example
   * expect(result).toBeUndefined():
   */
  function toBeUndefined() {
    return {
      compare: function(actual) {
        return {
          pass: void 0 === actual
        };
      }
    };
  }

  return toBeUndefined;
};

getJasmineRequireObj().toContain = function() {
  /**
   * {@link expect} the actual value to contain a specific value.
   * @function
   * @name matchers#toContain
   * @param {Object} expected - The value to look for.
   * @example
   * expect(array).toContain(anElement);
   * expect(string).toContain(substring);
   */
  function toContain(util, customEqualityTesters) {
    customEqualityTesters = customEqualityTesters || [];

    return {
      compare: function(actual, expected) {

        return {
          pass: util.contains(actual, expected, customEqualityTesters)
        };
      }
    };
  }

  return toContain;
};

getJasmineRequireObj().toEqual = function(j$) {
  /**
   * {@link expect} the actual value to be equal to the expected, using deep equality comparison.
   * @function
   * @name matchers#toEqual
   * @param {Object} expected - Expected value
   * @example
   * expect(bigObject).toEqual({"foo": ['bar', 'baz']});
   */
  function toEqual(util, customEqualityTesters) {
    customEqualityTesters = customEqualityTesters || [];

    return {
      compare: function(actual, expected) {
        var result = {
            pass: false
          },
          diffBuilder = j$.DiffBuilder();

        result.pass = util.equals(actual, expected, customEqualityTesters, diffBuilder);

        // TODO: only set error message if test fails
        result.message = diffBuilder.getMessage();

        return result;
      }
    };
  }

  return toEqual;
};

getJasmineRequireObj().toHaveBeenCalled = function(j$) {

  var getErrorMsg = j$.formatErrorMsg('<toHaveBeenCalled>', 'expect(<spyObj>).toHaveBeenCalled()');

  /**
   * {@link expect} the actual (a {@link Spy}) to have been called.
   * @function
   * @name matchers#toHaveBeenCalled
   * @example
   * expect(mySpy).toHaveBeenCalled();
   * expect(mySpy).not.toHaveBeenCalled();
   */
  function toHaveBeenCalled() {
    return {
      compare: function(actual) {
        var result = {};

        if (!j$.isSpy(actual)) {
          throw new Error(getErrorMsg('Expected a spy, but got ' + j$.pp(actual) + '.'));
        }

        if (arguments.length > 1) {
          throw new Error(getErrorMsg('Does not take arguments, use toHaveBeenCalledWith'));
        }

        result.pass = actual.calls.any();

        result.message = result.pass ?
          'Expected spy ' + actual.and.identity() + ' not to have been called.' :
          'Expected spy ' + actual.and.identity() + ' to have been called.';

        return result;
      }
    };
  }

  return toHaveBeenCalled;
};

getJasmineRequireObj().toHaveBeenCalledBefore = function(j$) {

  var getErrorMsg = j$.formatErrorMsg('<toHaveBeenCalledBefore>', 'expect(<spyObj>).toHaveBeenCalledBefore(<spyObj>)');

  /**
   * {@link expect} the actual value (a {@link Spy}) to have been called before another {@link Spy}.
   * @function
   * @name matchers#toHaveBeenCalledBefore
   * @param {Spy} expected - {@link Spy} that should have been called after the `actual` {@link Spy}.
   * @example
   * expect(mySpy).toHaveBeenCalledBefore(otherSpy);
   */
  function toHaveBeenCalledBefore() {
    return {
      compare: function(firstSpy, latterSpy) {
        if (!j$.isSpy(firstSpy)) {
          throw new Error(getErrorMsg('Expected a spy, but got ' + j$.pp(firstSpy) + '.'));
        }
        if (!j$.isSpy(latterSpy)) {
          throw new Error(getErrorMsg('Expected a spy, but got ' + j$.pp(latterSpy) + '.'));
        }

        var result = { pass: false };

        if (!firstSpy.calls.count()) {
          result.message = 'Expected spy ' +  firstSpy.and.identity() + ' to have been called.';
          return result;
        }
        if (!latterSpy.calls.count()) {
          result.message = 'Expected spy ' +  latterSpy.and.identity() + ' to have been called.';
          return result;
        }

        var latest1stSpyCall = firstSpy.calls.mostRecent().invocationOrder;
        var first2ndSpyCall = latterSpy.calls.first().invocationOrder;

        result.pass = latest1stSpyCall < first2ndSpyCall;

        if (result.pass) {
          result.message = 'Expected spy ' + firstSpy.and.identity() + ' to not have been called before spy ' + latterSpy.and.identity() + ', but it was';
        } else {
          var first1stSpyCall = firstSpy.calls.first().invocationOrder;
          var latest2ndSpyCall = latterSpy.calls.mostRecent().invocationOrder;

          if(first1stSpyCall < first2ndSpyCall) {
            result.message = 'Expected latest call to spy ' + firstSpy.and.identity() + ' to have been called before first call to spy ' + latterSpy.and.identity() + ' (no interleaved calls)';
          } else if (latest2ndSpyCall > latest1stSpyCall) {
            result.message = 'Expected first call to spy ' + latterSpy.and.identity() + ' to have been called after latest call to spy ' + firstSpy.and.identity() + ' (no interleaved calls)';
          } else {
            result.message = 'Expected spy ' + firstSpy.and.identity() + ' to have been called before spy ' + latterSpy.and.identity();
          }
        }

        return result;
      }
    };
  }

  return toHaveBeenCalledBefore;
};

getJasmineRequireObj().toHaveBeenCalledTimes = function(j$) {

  var getErrorMsg = j$.formatErrorMsg('<toHaveBeenCalledTimes>', 'expect(<spyObj>).toHaveBeenCalledTimes(<Number>)');

  /**
   * {@link expect} the actual (a {@link Spy}) to have been called the specified number of times.
   * @function
   * @name matchers#toHaveBeenCalledTimes
   * @param {Number} expected - The number of invocations to look for.
   * @example
   * expect(mySpy).toHaveBeenCalledTimes(3);
   */
  function toHaveBeenCalledTimes() {
    return {
      compare: function(actual, expected) {
        if (!j$.isSpy(actual)) {
          throw new Error(getErrorMsg('Expected a spy, but got ' + j$.pp(actual) + '.'));
        }

        var args = Array.prototype.slice.call(arguments, 0),
          result = { pass: false };

        if (!j$.isNumber_(expected)){
          throw new Error(getErrorMsg('The expected times failed is a required argument and must be a number.'));
        }

        actual = args[0];
        var calls = actual.calls.count();
        var timesMessage = expected === 1 ? 'once' : expected + ' times';
        result.pass = calls === expected;
        result.message = result.pass ?
          'Expected spy ' + actual.and.identity() + ' not to have been called ' + timesMessage + '. It was called ' +  calls + ' times.' :
          'Expected spy ' + actual.and.identity() + ' to have been called ' + timesMessage + '. It was called ' +  calls + ' times.';
        return result;
      }
    };
  }

  return toHaveBeenCalledTimes;
};

getJasmineRequireObj().toHaveBeenCalledWith = function(j$) {

  var getErrorMsg = j$.formatErrorMsg('<toHaveBeenCalledWith>', 'expect(<spyObj>).toHaveBeenCalledWith(...arguments)');

  /**
   * {@link expect} the actual (a {@link Spy}) to have been called with particular arguments at least once.
   * @function
   * @name matchers#toHaveBeenCalledWith
   * @param {...Object} - The arguments to look for
   * @example
   * expect(mySpy).toHaveBeenCalledWith('foo', 'bar', 2);
   */
  function toHaveBeenCalledWith(util, customEqualityTesters) {
    return {
      compare: function() {
        var args = Array.prototype.slice.call(arguments, 0),
          actual = args[0],
          expectedArgs = args.slice(1),
          result = { pass: false };

        if (!j$.isSpy(actual)) {
          throw new Error(getErrorMsg('Expected a spy, but got ' + j$.pp(actual) + '.'));
        }

        if (!actual.calls.any()) {
          result.message = function() { return 'Expected spy ' + actual.and.identity() + ' to have been called with ' + j$.pp(expectedArgs) + ' but it was never called.'; };
          return result;
        }

        if (util.contains(actual.calls.allArgs(), expectedArgs, customEqualityTesters)) {
          result.pass = true;
          result.message = function() { return 'Expected spy ' + actual.and.identity() + ' not to have been called with ' + j$.pp(expectedArgs) + ' but it was.'; };
        } else {
          result.message = function() { return 'Expected spy ' + actual.and.identity() + ' to have been called with ' + j$.pp(expectedArgs) + ' but actual calls were ' + j$.pp(actual.calls.allArgs()).replace(/^\[ | \]$/g, '') + '.'; };
        }

        return result;
      }
    };
  }

  return toHaveBeenCalledWith;
};

getJasmineRequireObj().toMatch = function(j$) {

  var getErrorMsg = j$.formatErrorMsg('<toMatch>', 'expect(<expectation>).toMatch(<string> || <regexp>)');

  /**
   * {@link expect} the actual value to match a regular expression
   * @function
   * @name matchers#toMatch
   * @param {RegExp|String} expected - Value to look for in the string.
   * @example
   * expect("my string").toMatch(/string$/);
   * expect("other string").toMatch("her");
   */
  function toMatch() {
    return {
      compare: function(actual, expected) {
        if (!j$.isString_(expected) && !j$.isA_('RegExp', expected)) {
          throw new Error(getErrorMsg('Expected is not a String or a RegExp'));
        }

        var regexp = new RegExp(expected);

        return {
          pass: regexp.test(actual)
        };
      }
    };
  }

  return toMatch;
};

getJasmineRequireObj().toThrow = function(j$) {

  var getErrorMsg = j$.formatErrorMsg('<toThrow>', 'expect(function() {<expectation>}).toThrow()');

  /**
   * {@link expect} a function to `throw` something.
   * @function
   * @name matchers#toThrow
   * @param {Object} [expected] - Value that should be thrown. If not provided, simply the fact that something was thrown will be checked.
   * @example
   * expect(function() { return 'things'; }).toThrow('foo');
   * expect(function() { return 'stuff'; }).toThrow();
   */
  function toThrow(util) {
    return {
      compare: function(actual, expected) {
        var result = { pass: false },
          threw = false,
          thrown;

        if (typeof actual != 'function') {
          throw new Error(getErrorMsg('Actual is not a Function'));
        }

        try {
          actual();
        } catch (e) {
          threw = true;
          thrown = e;
        }

        if (!threw) {
          result.message = 'Expected function to throw an exception.';
          return result;
        }

        if (arguments.length == 1) {
          result.pass = true;
          result.message = function() { return 'Expected function not to throw, but it threw ' + j$.pp(thrown) + '.'; };

          return result;
        }

        if (util.equals(thrown, expected)) {
          result.pass = true;
          result.message = function() { return 'Expected function not to throw ' + j$.pp(expected) + '.'; };
        } else {
          result.message = function() { return 'Expected function to throw ' + j$.pp(expected) + ', but it threw ' +  j$.pp(thrown) + '.'; };
        }

        return result;
      }
    };
  }

  return toThrow;
};

getJasmineRequireObj().toThrowError = function(j$) {

  var getErrorMsg =  j$.formatErrorMsg('<toThrowError>', 'expect(function() {<expectation>}).toThrowError(<ErrorConstructor>, <message>)');

  /**
   * {@link expect} a function to `throw` an `Error`.
   * @function
   * @name matchers#toThrowError
   * @param {Error} [expected] - `Error` constructor the object that was thrown needs to be an instance of. If not provided, `Error` will be used.
   * @param {RegExp|String} [message] - The message that should be set on the thrown `Error`
   * @example
   * expect(function() { return 'things'; }).toThrowError(MyCustomError, 'message');
   * expect(function() { return 'things'; }).toThrowError(MyCustomError, /bar/);
   * expect(function() { return 'stuff'; }).toThrowError(MyCustomError);
   * expect(function() { return 'other'; }).toThrowError(/foo/);
   * expect(function() { return 'other'; }).toThrowError();
   */
  function toThrowError () {
    return {
      compare: function(actual) {
        var threw = false,
          pass = {pass: true},
          fail = {pass: false},
          thrown;

        if (typeof actual != 'function') {
          throw new Error(getErrorMsg('Actual is not a Function'));
        }

        var errorMatcher = getMatcher.apply(null, arguments);

        try {
          actual();
        } catch (e) {
          threw = true;
          thrown = e;
        }

        if (!threw) {
          fail.message = 'Expected function to throw an Error.';
          return fail;
        }

        // Get Error constructor of thrown
        if (!isErrorObject(thrown)) {
          fail.message = function() { return 'Expected function to throw an Error, but it threw ' + j$.pp(thrown) + '.'; };
          return fail;
        }

        if (errorMatcher.hasNoSpecifics()) {
          pass.message = 'Expected function not to throw an Error, but it threw ' + j$.fnNameFor(thrown) + '.';
          return pass;
        }

        if (errorMatcher.matches(thrown)) {
          pass.message = function() {
            return 'Expected function not to throw ' + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() + '.';
          };
          return pass;
        } else {
          fail.message = function() {
            return 'Expected function to throw ' + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() +
              ', but it threw ' + errorMatcher.thrownDescription(thrown) + '.';
          };
          return fail;
        }
      }
    };

    function getMatcher() {
      var expected = null,
          errorType = null;

      if (arguments.length == 2) {
        expected = arguments[1];
        if (isAnErrorType(expected)) {
          errorType = expected;
          expected = null;
        }
      } else if (arguments.length > 2) {
        errorType = arguments[1];
        expected = arguments[2];
        if (!isAnErrorType(errorType)) {
          throw new Error(getErrorMsg('Expected error type is not an Error.'));
        }
      }

      if (expected && !isStringOrRegExp(expected)) {
        if (errorType) {
          throw new Error(getErrorMsg('Expected error message is not a string or RegExp.'));
        } else {
          throw new Error(getErrorMsg('Expected is not an Error, string, or RegExp.'));
        }
      }

      function messageMatch(message) {
        if (typeof expected == 'string') {
          return expected == message;
        } else {
          return expected.test(message);
        }
      }

      return {
        errorTypeDescription: errorType ? j$.fnNameFor(errorType) : 'an exception',
        thrownDescription: function(thrown) {
          var thrownName = errorType ? j$.fnNameFor(thrown.constructor) : 'an exception',
              thrownMessage = '';

          if (expected) {
            thrownMessage = ' with message ' + j$.pp(thrown.message);
          }

          return thrownName + thrownMessage;
        },
        messageDescription: function() {
          if (expected === null) {
            return '';
          } else if (expected instanceof RegExp) {
            return ' with a message matching ' + j$.pp(expected);
          } else {
            return ' with message ' + j$.pp(expected);
          }
        },
        hasNoSpecifics: function() {
          return expected === null && errorType === null;
        },
        matches: function(error) {
          return (errorType === null || error instanceof errorType) &&
            (expected === null || messageMatch(error.message));
        }
      };
    }

    function isStringOrRegExp(potential) {
      return potential instanceof RegExp || (typeof potential == 'string');
    }

    function isAnErrorType(type) {
      if (typeof type !== 'function') {
        return false;
      }

      var Surrogate = function() {};
      Surrogate.prototype = type.prototype;
      return isErrorObject(new Surrogate());
    }

    function isErrorObject(thrown) {
      if (thrown instanceof Error) {
        return true;
      }
      if (thrown && thrown.constructor && thrown.constructor.constructor &&
          (thrown instanceof (thrown.constructor.constructor('return this')()).Error)) {
        return true;
      }
      return false;
    }
  }

  return toThrowError;
};

getJasmineRequireObj().MockDate = function() {
  function MockDate(global) {
    var self = this;
    var currentTime = 0;

    if (!global || !global.Date) {
      self.install = function() {};
      self.tick = function() {};
      self.uninstall = function() {};
      return self;
    }

    var GlobalDate = global.Date;

    self.install = function(mockDate) {
      if (mockDate instanceof GlobalDate) {
        currentTime = mockDate.getTime();
      } else {
        currentTime = new GlobalDate().getTime();
      }

      global.Date = FakeDate;
    };

    self.tick = function(millis) {
      millis = millis || 0;
      currentTime = currentTime + millis;
    };

    self.uninstall = function() {
      currentTime = 0;
      global.Date = GlobalDate;
    };

    createDateProperties();

    return self;

    function FakeDate() {
      switch(arguments.length) {
        case 0:
          return new GlobalDate(currentTime);
        case 1:
          return new GlobalDate(arguments[0]);
        case 2:
          return new GlobalDate(arguments[0], arguments[1]);
        case 3:
          return new GlobalDate(arguments[0], arguments[1], arguments[2]);
        case 4:
          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3]);
        case 5:
          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],
                                arguments[4]);
        case 6:
          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],
                                arguments[4], arguments[5]);
        default:
          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],
                                arguments[4], arguments[5], arguments[6]);
      }
    }

    function createDateProperties() {
      FakeDate.prototype = GlobalDate.prototype;

      FakeDate.now = function() {
        if (GlobalDate.now) {
          return currentTime;
        } else {
          throw new Error('Browser does not support Date.now()');
        }
      };

      FakeDate.toSource = GlobalDate.toSource;
      FakeDate.toString = GlobalDate.toString;
      FakeDate.parse = GlobalDate.parse;
      FakeDate.UTC = GlobalDate.UTC;
    }
	}

  return MockDate;
};

getJasmineRequireObj().pp = function(j$) {

  function PrettyPrinter() {
    this.ppNestLevel_ = 0;
    this.seen = [];
    this.length = 0;
    this.stringParts = [];
  }

  function hasCustomToString(value) {
    // value.toString !== Object.prototype.toString if value has no custom toString but is from another context (e.g.
    // iframe, web worker)
    return j$.isFunction_(value.toString) && value.toString !== Object.prototype.toString && (value.toString() !== Object.prototype.toString.call(value));
  }

  PrettyPrinter.prototype.format = function(value) {
    this.ppNestLevel_++;
    try {
      if (j$.util.isUndefined(value)) {
        this.emitScalar('undefined');
      } else if (value === null) {
        this.emitScalar('null');
      } else if (value === 0 && 1/value === -Infinity) {
        this.emitScalar('-0');
      } else if (value === j$.getGlobal()) {
        this.emitScalar('<global>');
      } else if (value.jasmineToString) {
        this.emitScalar(value.jasmineToString());
      } else if (typeof value === 'string') {
        this.emitString(value);
      } else if (j$.isSpy(value)) {
        this.emitScalar('spy on ' + value.and.identity());
      } else if (value instanceof RegExp) {
        this.emitScalar(value.toString());
      } else if (typeof value === 'function') {
        this.emitScalar('Function');
      } else if (typeof value.nodeType === 'number') {
        this.emitScalar('HTMLNode');
      } else if (value instanceof Date) {
        this.emitScalar('Date(' + value + ')');
      } else if (j$.isSet(value)) {
        this.emitSet(value);
      } else if (j$.isMap(value)) {
        this.emitMap(value);
      } else if (j$.isTypedArray_(value)) {
        this.emitTypedArray(value);
      } else if (value.toString && typeof value === 'object' && !j$.isArray_(value) && hasCustomToString(value)) {
        this.emitScalar(value.toString());
      } else if (j$.util.arrayContains(this.seen, value)) {
        this.emitScalar('<circular reference: ' + (j$.isArray_(value) ? 'Array' : 'Object') + '>');
      } else if (j$.isArray_(value) || j$.isA_('Object', value)) {
        this.seen.push(value);
        if (j$.isArray_(value)) {
          this.emitArray(value);
        } else {
          this.emitObject(value);
        }
        this.seen.pop();
      } else {
        this.emitScalar(value.toString());
      }
    } catch (e) {
      if (this.ppNestLevel_ > 1 || !(e instanceof MaxCharsReachedError)) {
        throw e;
      }
    } finally {
      this.ppNestLevel_--;
    }
  };

  PrettyPrinter.prototype.iterateObject = function(obj, fn) {
    var objKeys = keys(obj, j$.isArray_(obj));
    var isGetter = function isGetter(prop) {};

    if (obj.__lookupGetter__) {
      isGetter = function isGetter(prop) {
        var getter = obj.__lookupGetter__(prop);
        return !j$.util.isUndefined(getter) && getter !== null;
      };

    }
    var length = Math.min(objKeys.length, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);
    for (var i = 0; i < length; i++) {
      var property = objKeys[i];
      fn(property, isGetter(property));
    }

    return objKeys.length > length;
  };

  PrettyPrinter.prototype.emitScalar = function(value) {
    this.append(value);
  };

  PrettyPrinter.prototype.emitString = function(value) {
    this.append('\'' + value + '\'');
  };

  PrettyPrinter.prototype.emitArray = function(array) {
    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {
      this.append('Array');
      return;
    }
    var length = Math.min(array.length, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);
    this.append('[ ');
    for (var i = 0; i < length; i++) {
      if (i > 0) {
        this.append(', ');
      }
      this.format(array[i]);
    }
    if(array.length > length){
      this.append(', ...');
    }

    var self = this;
    var first = array.length === 0;
    var truncated = this.iterateObject(array, function(property, isGetter) {
      if (first) {
        first = false;
      } else {
        self.append(', ');
      }

      self.formatProperty(array, property, isGetter);
    });

    if (truncated) { this.append(', ...'); }

    this.append(' ]');
  };

  PrettyPrinter.prototype.emitSet = function(set) {
    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {
      this.append('Set');
      return;
    }
    this.append('Set( ');
    var size = Math.min(set.size, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);
    var i = 0;
    set.forEach( function( value, key ) {
      if (i >= size) {
        return;
      }
      if (i > 0) {
        this.append(', ');
      }
      this.format(value);

      i++;
    }, this );
    if (set.size > size){
      this.append(', ...');
    }
    this.append(' )');
  };

  PrettyPrinter.prototype.emitMap = function(map) {
    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {
      this.append('Map');
      return;
    }
    this.append('Map( ');
    var size = Math.min(map.size, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);
    var i = 0;
    map.forEach( function( value, key ) {
      if (i >= size) {
        return;
      }
      if (i > 0) {
        this.append(', ');
      }
      this.format([key,value]);

      i++;
    }, this );
    if (map.size > size){
      this.append(', ...');
    }
    this.append(' )');
  };

  PrettyPrinter.prototype.emitObject = function(obj) {
    var ctor = obj.constructor,
        constructorName;

    constructorName = typeof ctor === 'function' && obj instanceof ctor ?
      j$.fnNameFor(obj.constructor) :
      'null';

    this.append(constructorName);

    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {
      return;
    }

    var self = this;
    this.append('({ ');
    var first = true;

    var truncated = this.iterateObject(obj, function(property, isGetter) {
      if (first) {
        first = false;
      } else {
        self.append(', ');
      }

      self.formatProperty(obj, property, isGetter);
    });

    if (truncated) { this.append(', ...'); }

    this.append(' })');
  };

  PrettyPrinter.prototype.emitTypedArray = function(arr) {
    var constructorName = j$.fnNameFor(arr.constructor),
      limitedArray = Array.prototype.slice.call(arr, 0, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH),
      itemsString = Array.prototype.join.call(limitedArray, ', ');

    if (limitedArray.length !== arr.length) {
      itemsString += ', ...';
    }

    this.append(constructorName + ' [ ' + itemsString + ' ]');
  };

  PrettyPrinter.prototype.formatProperty = function(obj, property, isGetter) {
      this.append(property);
      this.append(': ');
      if (isGetter) {
        this.append('<getter>');
      } else {
        this.format(obj[property]);
      }
  };

  PrettyPrinter.prototype.append = function(value) {
    var result = truncate(value, j$.MAX_PRETTY_PRINT_CHARS - this.length);
    this.length += result.value.length;
    this.stringParts.push(result.value);

    if (result.truncated) {
      throw new MaxCharsReachedError();
    }
  };


  function truncate(s, maxlen) {
    if (s.length <= maxlen) {
      return { value: s, truncated: false };
    }

    s = s.substring(0, maxlen - 4) + ' ...';
    return { value: s, truncated: true };
  }

  function MaxCharsReachedError() {
    this.message = 'Exceeded ' + j$.MAX_PRETTY_PRINT_CHARS +
      ' characters while pretty-printing a value';
  }

  MaxCharsReachedError.prototype = new Error();

  function keys(obj, isArray) {
    var allKeys = Object.keys ? Object.keys(obj) :
      (function(o) {
          var keys = [];
          for (var key in o) {
              if (j$.util.has(o, key)) {
                  keys.push(key);
              }
          }
          return keys;
      })(obj);

    if (!isArray) {
      return allKeys;
    }

    if (allKeys.length === 0) {
        return allKeys;
    }

    var extraKeys = [];
    for (var i = 0; i < allKeys.length; i++) {
      if (!/^[0-9]+$/.test(allKeys[i])) {
        extraKeys.push(allKeys[i]);
      }
    }

    return extraKeys;
  }
  return function(value) {
    var prettyPrinter = new PrettyPrinter();
    prettyPrinter.format(value);
    return prettyPrinter.stringParts.join('');
  };
};

getJasmineRequireObj().QueueRunner = function(j$) {

  function once(fn) {
    var called = false;
    return function() {
      if (!called) {
        called = true;
        fn.apply(null, arguments);
      }
      return null;
    };
  }

  function QueueRunner(attrs) {
    var queueableFns = attrs.queueableFns || [];
    this.queueableFns = queueableFns.concat(attrs.cleanupFns || []);
    this.firstCleanupIx = queueableFns.length;
    this.onComplete = attrs.onComplete || function() {};
    this.clearStack = attrs.clearStack || function(fn) {fn();};
    this.onException = attrs.onException || function() {};
    this.catchException = attrs.catchException || function() { return true; };
    this.userContext = attrs.userContext || new j$.UserContext();
    this.timeout = attrs.timeout || {setTimeout: setTimeout, clearTimeout: clearTimeout};
    this.fail = attrs.fail || function() {};
    this.globalErrors = attrs.globalErrors || { pushListener: function() {}, popListener: function() {} };
    this.completeOnFirstError = !!attrs.completeOnFirstError;
    this.deprecated = attrs.deprecated;
  }

  QueueRunner.prototype.execute = function() {
    var self = this;
    this.handleFinalError = function(error) {
      self.onException(error);
    };
    this.globalErrors.pushListener(this.handleFinalError);
    this.run(0);
  };

  QueueRunner.prototype.skipToCleanup = function(lastRanIndex) {
    if (lastRanIndex < this.firstCleanupIx) {
      this.run(this.firstCleanupIx);
    } else {
      this.run(lastRanIndex + 1);
    }
  };

  QueueRunner.prototype.run = function(recursiveIndex) {
    var length = this.queueableFns.length,
      self = this,
      iterativeIndex;


    for(iterativeIndex = recursiveIndex; iterativeIndex < length; iterativeIndex++) {
      var result = attempt(iterativeIndex);

      if (!result.completedSynchronously) {
        return;
      }

      if (this.completeOnFirstError && result.errored) {
        this.skipToCleanup(iterativeIndex);
        return;
      }
    }

    this.clearStack(function() {
      self.globalErrors.popListener(self.handleFinalError);
      self.onComplete();
    });

    function attempt() {
      var clearTimeout = function () {
          Function.prototype.apply.apply(self.timeout.clearTimeout, [j$.getGlobal(), [timeoutId]]);
        },
        setTimeout = function(delayedFn, delay) {
          return Function.prototype.apply.apply(self.timeout.setTimeout, [j$.getGlobal(), [delayedFn, delay]]);
        },
        completedSynchronously = true,
        handleError = function(error) {
          onException(error);
          next();
        },
        cleanup = once(function() {
          clearTimeout(timeoutId);
          self.globalErrors.popListener(handleError);
        }),
        next = once(function (err) {
          cleanup();

          if (err instanceof Error) {
            self.deprecated('done callback received an Error object. Jasmine 3.0 will treat this as a failure');
          }

          function runNext() {
            if (self.completeOnFirstError && errored) {
              self.skipToCleanup(iterativeIndex);
            } else {
              self.run(iterativeIndex + 1);
            }
          }

          if (completedSynchronously) {
            setTimeout(runNext);
          } else {
            runNext();
          }
        }),
        errored = false,
        queueableFn = self.queueableFns[iterativeIndex],
        timeoutId;

      next.fail = function() {
        self.fail.apply(null, arguments);
        errored = true;
        next();
      };

      self.globalErrors.pushListener(handleError);

      if (queueableFn.timeout) {
        timeoutId = setTimeout(function() {
          var error = new Error('Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.');
          onException(error);
          next();
        }, queueableFn.timeout());
      }

      try {
        if (queueableFn.fn.length === 0) {
          var maybeThenable = queueableFn.fn.call(self.userContext);

          if (maybeThenable && j$.isFunction_(maybeThenable.then)) {
            maybeThenable.then(next, onPromiseRejection);
            completedSynchronously = false;
            return { completedSynchronously: false };
          }
        } else {
          queueableFn.fn.call(self.userContext, next);
          completedSynchronously = false;
          return { completedSynchronously: false };
        }
      } catch (e) {
        handleException(e, queueableFn);
        errored = true;
      }

      cleanup();
      return { completedSynchronously: true, errored: errored };

      function onException(e) {
        self.onException(e);
        errored = true;
      }

      function onPromiseRejection(e) {
        onException(e);
        next();
      }

      function handleException(e, queueableFn) {
        onException(e);
        if (!self.catchException(e)) {
          //TODO: set a var when we catch an exception and
          //use a finally block to close the loop in a nice way..
          throw e;
        }
      }
    }
  };

  return QueueRunner;
};

getJasmineRequireObj().ReportDispatcher = function(j$) {
  function ReportDispatcher(methods) {

    var dispatchedMethods = methods || [];

    for (var i = 0; i < dispatchedMethods.length; i++) {
      var method = dispatchedMethods[i];
      this[method] = (function(m) {
        return function() {
          dispatch(m, arguments);
        };
      }(method));
    }

    var reporters = [];
    var fallbackReporter = null;

    this.addReporter = function(reporter) {
      reporters.push(reporter);
    };

    this.provideFallbackReporter = function(reporter) {
      fallbackReporter = reporter;
    };

    this.clearReporters = function() {
      reporters = [];
    };

    return this;

    function dispatch(method, args) {
      if (reporters.length === 0 && fallbackReporter !== null) {
          reporters.push(fallbackReporter);
      }
      for (var i = 0; i < reporters.length; i++) {
        var reporter = reporters[i];
        if (reporter[method]) {
          reporter[method].apply(reporter, j$.util.cloneArgs(args));
        }
      }
    }
  }

  return ReportDispatcher;
};


getJasmineRequireObj().interface = function(jasmine, env) {
  var jasmineInterface = {
    /**
     * Callback passed to parts of the Jasmine base interface.
     *
     * By default Jasmine assumes this function completes synchronously.
     * If you have code that you need to test asynchronously, you can declare that you receive a `done` callback, return a Promise, or use the `async` keyword if it is supported in your environment.
     * @callback implementationCallback
     * @param {Function} [done] Used to specify to Jasmine that this callback is asynchronous and Jasmine should wait until it has been called before moving on.
     * @returns {} Optionally return a Promise instead of using `done` to cause Jasmine to wait for completion.
     */

    /**
     * Create a group of specs (often called a suite).
     *
     * Calls to `describe` can be nested within other calls to compose your suite as a tree.
     * @name describe
     * @function
     * @global
     * @param {String} description Textual description of the group
     * @param {Function} specDefinitions Function for Jasmine to invoke that will define inner suites and specs
     */
    describe: function(description, specDefinitions) {
      return env.describe(description, specDefinitions);
    },

    /**
     * A temporarily disabled [`describe`]{@link describe}
     *
     * Specs within an `xdescribe` will be marked pending and not executed
     * @name xdescribe
     * @function
     * @global
     * @param {String} description Textual description of the group
     * @param {Function} specDefinitions Function for Jasmine to invoke that will define inner suites and specs
     */
    xdescribe: function(description, specDefinitions) {
      return env.xdescribe(description, specDefinitions);
    },

    /**
     * A focused [`describe`]{@link describe}
     *
     * If suites or specs are focused, only those that are focused will be executed
     * @see fit
     * @name fdescribe
     * @function
     * @global
     * @param {String} description Textual description of the group
     * @param {Function} specDefinitions Function for Jasmine to invoke that will define inner suites and specs
     */
    fdescribe: function(description, specDefinitions) {
      return env.fdescribe(description, specDefinitions);
    },

    /**
     * Define a single spec. A spec should contain one or more {@link expect|expectations} that test the state of the code.
     *
     * A spec whose expectations all succeed will be passing and a spec with any failures will fail.
     * @name it
     * @function
     * @global
     * @param {String} description Textual description of what this spec is checking
     * @param {implementationCallback} [testFunction] Function that contains the code of your test. If not provided the test will be `pending`.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async spec.
     */
    it: function() {
      return env.it.apply(env, arguments);
    },

    /**
     * A temporarily disabled [`it`]{@link it}
     *
     * The spec will report as `pending` and will not be executed.
     * @name xit
     * @function
     * @global
     * @param {String} description Textual description of what this spec is checking.
     * @param {implementationCallback} [testFunction] Function that contains the code of your test. Will not be executed.
     */
    xit: function() {
      return env.xit.apply(env, arguments);
    },

    /**
     * A focused [`it`]{@link it}
     *
     * If suites or specs are focused, only those that are focused will be executed.
     * @name fit
     * @function
     * @global
     * @param {String} description Textual description of what this spec is checking.
     * @param {implementationCallback} testFunction Function that contains the code of your test.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async spec.
     */
    fit: function() {
      return env.fit.apply(env, arguments);
    },

    /**
     * Run some shared setup before each of the specs in the {@link describe} in which it is called.
     * @name beforeEach
     * @function
     * @global
     * @param {implementationCallback} [function] Function that contains the code to setup your specs.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async beforeEach.
     */
    beforeEach: function() {
      return env.beforeEach.apply(env, arguments);
    },

    /**
     * Run some shared teardown after each of the specs in the {@link describe} in which it is called.
     * @name afterEach
     * @function
     * @global
     * @param {implementationCallback} [function] Function that contains the code to teardown your specs.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async afterEach.
     */
    afterEach: function() {
      return env.afterEach.apply(env, arguments);
    },

    /**
     * Run some shared setup once before all of the specs in the {@link describe} are run.
     *
     * _Note:_ Be careful, sharing the setup from a beforeAll makes it easy to accidentally leak state between your specs so that they erroneously pass or fail.
     * @name beforeAll
     * @function
     * @global
     * @param {implementationCallback} [function] Function that contains the code to setup your specs.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async beforeAll.
     */
    beforeAll: function() {
      return env.beforeAll.apply(env, arguments);
    },

    /**
     * Run some shared teardown once after all of the specs in the {@link describe} are run.
     *
     * _Note:_ Be careful, sharing the teardown from a afterAll makes it easy to accidentally leak state between your specs so that they erroneously pass or fail.
     * @name afterAll
     * @function
     * @global
     * @param {implementationCallback} [function] Function that contains the code to teardown your specs.
     * @param {Int} [timeout={@link jasmine.DEFAULT_TIMEOUT_INTERVAL}] Custom timeout for an async afterAll.
     */
    afterAll: function() {
      return env.afterAll.apply(env, arguments);
    },

    /**
     * Create an expectation for a spec.
     * @name expect
     * @function
     * @global
     * @param {Object} actual - Actual computed value to test expectations against.
     * @return {matchers}
     */
    expect: function(actual) {
      return env.expect(actual);
    },

    /**
     * Mark a spec as pending, expectation results will be ignored.
     * @name pending
     * @function
     * @global
     * @param {String} [message] - Reason the spec is pending.
     */
    pending: function() {
      return env.pending.apply(env, arguments);
    },

    /**
     * Explicitly mark a spec as failed.
     * @name fail
     * @function
     * @global
     * @param {String|Error} [error] - Reason for the failure.
    */
    fail: function() {
      return env.fail.apply(env, arguments);
    },

    /**
     * Install a spy onto an existing object.
     * @name spyOn
     * @function
     * @global
     * @param {Object} obj - The object upon which to install the {@link Spy}.
     * @param {String} methodName - The name of the method to replace with a {@link Spy}.
     * @returns {Spy}
     */
    spyOn: function(obj, methodName) {
      return env.spyOn(obj, methodName);
    },

    /**
     * Install a spy on a property installed with `Object.defineProperty` onto an existing object.
     * @name spyOnProperty
     * @function
     * @global
     * @param {Object} obj - The object upon which to install the {@link Spy}
     * @param {String} propertyName - The name of the property to replace with a {@link Spy}.
     * @param {String} [accessType=get] - The access type (get|set) of the property to {@link Spy} on.
     * @returns {Spy}
     */
    spyOnProperty: function(obj, methodName, accessType) {
      return env.spyOnProperty(obj, methodName, accessType);
    },

    jsApiReporter: new jasmine.JsApiReporter({
      timer: new jasmine.Timer()
    }),

    /**
     * @namespace jasmine
     */
    jasmine: jasmine
  };

  /**
   * Add a custom equality tester for the current scope of specs.
   *
   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.
   * @name jasmine.addCustomEqualityTester
   * @function
   * @param {Function} tester - A function which takes two arguments to compare and returns a `true` or `false` comparison result if it knows how to compare them, and `undefined` otherwise.
   * @see custom_equality
   */
  jasmine.addCustomEqualityTester = function(tester) {
    env.addCustomEqualityTester(tester);
  };

  /**
   * Add custom matchers for the current scope of specs.
   *
   * _Note:_ This is only callable from within a {@link beforeEach}, {@link it}, or {@link beforeAll}.
   * @name jasmine.addMatchers
   * @function
   * @param {Object} matchers - Keys from this object will be the new matcher names.
   * @see custom_matcher
   */
  jasmine.addMatchers = function(matchers) {
    return env.addMatchers(matchers);
  };

  /**
   * Get the currently booted mock {Clock} for this Jasmine environment.
   * @name jasmine.clock
   * @function
   * @returns {Clock}
   */
  jasmine.clock = function() {
    return env.clock;
  };

  return jasmineInterface;
};

getJasmineRequireObj().Spy = function (j$) {

  var nextOrder = (function() {
    var order = 0;

    return function() {
      return order++;
    };
  })();

  /**
   * _Note:_ Do not construct this directly, use {@link spyOn}, {@link spyOnProperty}, {@link jasmine.createSpy}, or {@link jasmine.createSpyObj}
   * @constructor
   * @name Spy
   */
  function Spy(name, originalFn) {
    var numArgs = (typeof originalFn === 'function' ? originalFn.length : 0),
      wrapper = makeFunc(numArgs, function () {
        return spy.apply(this, Array.prototype.slice.call(arguments));
      }),
      spyStrategy = new j$.SpyStrategy({
        name: name,
        fn: originalFn,
        getSpy: function () {
          return wrapper;
        }
      }),
      callTracker = new j$.CallTracker(),
      spy = function () {
        /**
         * @name Spy.callData
         * @property {object} object - `this` context for the invocation.
         * @property {number} invocationOrder - Order of the invocation.
         * @property {Array} args - The arguments passed for this invocation.
         */
        var callData = {
          object: this,
          invocationOrder: nextOrder(),
          args: Array.prototype.slice.apply(arguments)
        };

        callTracker.track(callData);
        var returnValue = spyStrategy.exec.apply(this, arguments);
        callData.returnValue = returnValue;

        return returnValue;
      };

    function makeFunc(length, fn) {
      switch (length) {
        case 1 : return function (a) { return fn.apply(this, arguments); };
        case 2 : return function (a,b) { return fn.apply(this, arguments); };
        case 3 : return function (a,b,c) { return fn.apply(this, arguments); };
        case 4 : return function (a,b,c,d) { return fn.apply(this, arguments); };
        case 5 : return function (a,b,c,d,e) { return fn.apply(this, arguments); };
        case 6 : return function (a,b,c,d,e,f) { return fn.apply(this, arguments); };
        case 7 : return function (a,b,c,d,e,f,g) { return fn.apply(this, arguments); };
        case 8 : return function (a,b,c,d,e,f,g,h) { return fn.apply(this, arguments); };
        case 9 : return function (a,b,c,d,e,f,g,h,i) { return fn.apply(this, arguments); };
        default : return function () { return fn.apply(this, arguments); };
      }
    }

    for (var prop in originalFn) {
      if (prop === 'and' || prop === 'calls') {
        throw new Error('Jasmine spies would overwrite the \'and\' and \'calls\' properties on the object being spied upon');
      }

      wrapper[prop] = originalFn[prop];
    }

    wrapper.and = spyStrategy;
    wrapper.calls = callTracker;

    return wrapper;
  }

  return Spy;
};

getJasmineRequireObj().SpyRegistry = function(j$) {

  var getErrorMsg = j$.formatErrorMsg('<spyOn>', 'spyOn(<object>, <methodName>)');

  function SpyRegistry(options) {
    options = options || {};
    var global = options.global || j$.getGlobal();
    var currentSpies = options.currentSpies || function() { return []; };

    this.allowRespy = function(allow){
      this.respy = allow;
    };

    this.spyOn = function(obj, methodName) {

      if (j$.util.isUndefined(obj) || obj === null) {
        throw new Error(getErrorMsg('could not find an object to spy upon for ' + methodName + '()'));
      }

      if (j$.util.isUndefined(methodName) || methodName === null) {
        throw new Error(getErrorMsg('No method name supplied'));
      }

      if (j$.util.isUndefined(obj[methodName])) {
        throw new Error(getErrorMsg(methodName + '() method does not exist'));
      }

      if (obj[methodName] && j$.isSpy(obj[methodName])  ) {
        if ( !!this.respy ){
          return obj[methodName];
        }else {
          throw new Error(getErrorMsg(methodName + ' has already been spied upon'));
        }
      }

      var descriptor;
      try {
        descriptor = Object.getOwnPropertyDescriptor(obj, methodName);
      } catch(e) {
        // IE 8 doesn't support `definePropery` on non-DOM nodes
      }

      if (descriptor && !(descriptor.writable || descriptor.set)) {
        throw new Error(getErrorMsg(methodName + ' is not declared writable or has no setter'));
      }

      var originalMethod = obj[methodName],
        spiedMethod = j$.createSpy(methodName, originalMethod),
        restoreStrategy;

      if (Object.prototype.hasOwnProperty.call(obj, methodName) || (obj === global && methodName === 'onerror')) {
        restoreStrategy = function() {
          obj[methodName] = originalMethod;
        };
      } else {
        restoreStrategy = function() {
          if (!delete obj[methodName]) {
            obj[methodName] = originalMethod;
          }
        };
      }

      currentSpies().push({
        restoreObjectToOriginalState: restoreStrategy
      });

      obj[methodName] = spiedMethod;

      return spiedMethod;
    };

    this.spyOnProperty = function (obj, propertyName, accessType) {
      accessType = accessType || 'get';

      if (j$.util.isUndefined(obj)) {
        throw new Error('spyOn could not find an object to spy upon for ' + propertyName + '');
      }

      if (j$.util.isUndefined(propertyName)) {
        throw new Error('No property name supplied');
      }

      var descriptor;
      try {
        descriptor = j$.util.getPropertyDescriptor(obj, propertyName);
      } catch(e) {
        // IE 8 doesn't support `definePropery` on non-DOM nodes
      }

      if (!descriptor) {
        throw new Error(propertyName + ' property does not exist');
      }

      if (!descriptor.configurable) {
        throw new Error(propertyName + ' is not declared configurable');
      }

      if(!descriptor[accessType]) {
        throw new Error('Property ' + propertyName + ' does not have access type ' + accessType);
      }

      if (j$.isSpy(descriptor[accessType])) {
        //TODO?: should this return the current spy? Downside: may cause user confusion about spy state
        throw new Error(propertyName + ' has already been spied upon');
      }

      var originalDescriptor = j$.util.clone(descriptor),
        spy = j$.createSpy(propertyName, descriptor[accessType]),
        restoreStrategy;

      if (Object.prototype.hasOwnProperty.call(obj, propertyName)) {
        restoreStrategy = function() {
          Object.defineProperty(obj, propertyName, originalDescriptor);
        };
      } else {
        restoreStrategy = function() {
          delete obj[propertyName];
        };
      }

      currentSpies().push({
        restoreObjectToOriginalState: restoreStrategy
      });

      descriptor[accessType] = spy;

      Object.defineProperty(obj, propertyName, descriptor);

      return spy;
    };

    this.clearSpies = function() {
      var spies = currentSpies();
      for (var i = spies.length - 1; i >= 0; i--) {
        var spyEntry = spies[i];
        spyEntry.restoreObjectToOriginalState();
      }
    };
  }

  return SpyRegistry;
};

getJasmineRequireObj().SpyStrategy = function(j$) {

  /**
   * @namespace Spy#and
   */
  function SpyStrategy(options) {
    options = options || {};

    var identity = options.name || 'unknown',
        originalFn = options.fn || function() {},
        getSpy = options.getSpy || function() {},
        plan = function() {};

    /**
     * Return the identifying information for the spy.
     * @name Spy#and#identity
     * @function
     * @returns {String}
     */
    this.identity = function() {
      return identity;
    };

    /**
     * Execute the current spy strategy.
     * @name Spy#and#exec
     * @function
     */
    this.exec = function() {
      return plan.apply(this, arguments);
    };

    /**
     * Tell the spy to call through to the real implementation when invoked.
     * @name Spy#and#callThrough
     * @function
     */
    this.callThrough = function() {
      plan = originalFn;
      return getSpy();
    };

    /**
     * Tell the spy to return the value when invoked.
     * @name Spy#and#returnValue
     * @function
     * @param {*} value The value to return.
     */
    this.returnValue = function(value) {
      plan = function() {
        return value;
      };
      return getSpy();
    };

    /**
     * Tell the spy to return one of the specified values (sequentially) each time the spy is invoked.
     * @name Spy#and#returnValues
     * @function
     * @param {...*} values - Values to be returned on subsequent calls to the spy.
     */
    this.returnValues = function() {
      var values = Array.prototype.slice.call(arguments);
      plan = function () {
        return values.shift();
      };
      return getSpy();
    };

    /**
     * Tell the spy to throw an error when invoked.
     * @name Spy#and#throwError
     * @function
     * @param {Error|String} something Thing to throw
     */
    this.throwError = function(something) {
      var error = (something instanceof Error) ? something : new Error(something);
      plan = function() {
        throw error;
      };
      return getSpy();
    };

    /**
     * Tell the spy to call a fake implementation when invoked.
     * @name Spy#and#callFake
     * @function
     * @param {Function} fn The function to invoke with the passed parameters.
     */
    this.callFake = function(fn) {
      if(!(j$.isFunction_(fn) || j$.isAsyncFunction_(fn))) {
        throw new Error('Argument passed to callFake should be a function, got ' + fn);
      }
      plan = fn;
      return getSpy();
    };

    /**
     * Tell the spy to do nothing when invoked. This is the default.
     * @name Spy#and#stub
     * @function
     */
    this.stub = function(fn) {
      plan = function() {};
      return getSpy();
    };
  }

  return SpyStrategy;
};

getJasmineRequireObj().Suite = function(j$) {
  function Suite(attrs) {
    this.env = attrs.env;
    this.id = attrs.id;
    this.parentSuite = attrs.parentSuite;
    this.description = attrs.description;
    this.expectationFactory = attrs.expectationFactory;
    this.expectationResultFactory = attrs.expectationResultFactory;
    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;

    this.beforeFns = [];
    this.afterFns = [];
    this.beforeAllFns = [];
    this.afterAllFns = [];

    this.children = [];

    /**
     * @typedef SuiteResult
     * @property {Int} id - The unique id of this suite.
     * @property {String} description - The description text passed to the {@link describe} that made this suite.
     * @property {String} fullName - The full description including all ancestors of this suite.
     * @property {Expectation[]} failedExpectations - The list of expectations that failed in an {@link afterAll} for this suite.
     * @property {Expectation[]} deprecationWarnings - The list of deprecation warnings that occurred on this suite.
     * @property {String} status - Once the suite has completed, this string represents the pass/fail status of this suite.
     */
    this.result = {
      id: this.id,
      description: this.description,
      fullName: this.getFullName(),
      failedExpectations: [],
      deprecationWarnings: []
    };
  }

  Suite.prototype.expect = function(actual) {
    return this.expectationFactory(actual, this);
  };

  Suite.prototype.getFullName = function() {
    var fullName = [];
    for (var parentSuite = this; parentSuite; parentSuite = parentSuite.parentSuite) {
      if (parentSuite.parentSuite) {
        fullName.unshift(parentSuite.description);
      }
    }
    return fullName.join(' ');
  };

  Suite.prototype.pend = function() {
    this.markedPending = true;
  };

  Suite.prototype.beforeEach = function(fn) {
    this.beforeFns.unshift(fn);
  };

  Suite.prototype.beforeAll = function(fn) {
    this.beforeAllFns.push(fn);
  };

  Suite.prototype.afterEach = function(fn) {
    this.afterFns.unshift(fn);
  };

  Suite.prototype.afterAll = function(fn) {
    this.afterAllFns.unshift(fn);
  };

  Suite.prototype.addChild = function(child) {
    this.children.push(child);
  };

  Suite.prototype.status = function() {
    if (this.markedPending) {
      return 'pending';
    }

    if (this.result.failedExpectations.length > 0) {
      return 'failed';
    } else {
      return 'finished';
    }
  };

  Suite.prototype.isExecutable = function() {
    return !this.markedPending;
  };

  Suite.prototype.canBeReentered = function() {
    return this.beforeAllFns.length === 0 && this.afterAllFns.length === 0;
  };

  Suite.prototype.getResult = function() {
    this.result.status = this.status();
    return this.result;
  };

  Suite.prototype.sharedUserContext = function() {
    if (!this.sharedContext) {
      this.sharedContext = this.parentSuite ? this.parentSuite.clonedSharedUserContext() : new j$.UserContext();
    }

    return this.sharedContext;
  };

  Suite.prototype.clonedSharedUserContext = function() {
    return j$.UserContext.fromExisting(this.sharedUserContext());
  };

  Suite.prototype.onException = function() {
    if (arguments[0] instanceof j$.errors.ExpectationFailed) {
      return;
    }

    if(isAfterAll(this.children)) {
      var data = {
        matcherName: '',
        passed: false,
        expected: '',
        actual: '',
        error: arguments[0]
      };
      this.result.failedExpectations.push(this.expectationResultFactory(data));
    } else {
      for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i];
        child.onException.apply(child, arguments);
      }
    }
  };

  Suite.prototype.addExpectationResult = function () {
    if(isAfterAll(this.children) && isFailure(arguments)){
      var data = arguments[1];
      this.result.failedExpectations.push(this.expectationResultFactory(data));
      if(this.throwOnExpectationFailure) {
        throw new j$.errors.ExpectationFailed();
      }
    } else {
      for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i];
        try {
          child.addExpectationResult.apply(child, arguments);
        } catch(e) {
          // keep going
        }
      }
    }
  };

  Suite.prototype.addDeprecationWarning = function(msg) {
    this.result.deprecationWarnings.push(this.expectationResultFactory({ message: msg }));
  };

  function isAfterAll(children) {
    return children && children[0].result.status;
  }

  function isFailure(args) {
    return !args[0];
  }

  return Suite;
};

if (typeof window == void 0 && typeof exports == 'object') {
  exports.Suite = jasmineRequire.Suite;
}

getJasmineRequireObj().Timer = function() {
  var defaultNow = (function(Date) {
    return function() { return new Date().getTime(); };
  })(Date);

  function Timer(options) {
    options = options || {};

    var now = options.now || defaultNow,
      startTime;

    this.start = function() {
      startTime = now();
    };

    this.elapsed = function() {
      return now() - startTime;
    };
  }

  return Timer;
};

getJasmineRequireObj().TreeProcessor = function() {
  function TreeProcessor(attrs) {
    var tree = attrs.tree,
        runnableIds = attrs.runnableIds,
        queueRunnerFactory = attrs.queueRunnerFactory,
        nodeStart = attrs.nodeStart || function() {},
        nodeComplete = attrs.nodeComplete || function() {},
        orderChildren = attrs.orderChildren || function(node) { return node.children; },
        stats = { valid: true },
        processed = false,
        defaultMin = Infinity,
        defaultMax = 1 - Infinity;

    this.processTree = function() {
      processNode(tree, false);
      processed = true;
      return stats;
    };

    this.execute = function(done) {
      if (!processed) {
        this.processTree();
      }

      if (!stats.valid) {
        throw 'invalid order';
      }

      var childFns = wrapChildren(tree, 0);

      queueRunnerFactory({
        queueableFns: childFns,
        userContext: tree.sharedUserContext(),
        onException: function() {
          tree.onException.apply(tree, arguments);
        },
        onComplete: done
      });
    };

    function runnableIndex(id) {
      for (var i = 0; i < runnableIds.length; i++) {
        if (runnableIds[i] === id) {
          return i;
        }
      }
    }

    function processNode(node, parentEnabled) {
      var executableIndex = runnableIndex(node.id);

      if (executableIndex !== undefined) {
        parentEnabled = true;
      }

      parentEnabled = parentEnabled && node.isExecutable();

      if (!node.children) {
        stats[node.id] = {
          executable: parentEnabled && node.isExecutable(),
          segments: [{
            index: 0,
            owner: node,
            nodes: [node],
            min: startingMin(executableIndex),
            max: startingMax(executableIndex)
          }]
        };
      } else {
        var hasExecutableChild = false;

        var orderedChildren = orderChildren(node);

        for (var i = 0; i < orderedChildren.length; i++) {
          var child = orderedChildren[i];

          processNode(child, parentEnabled);

          if (!stats.valid) {
            return;
          }

          var childStats = stats[child.id];

          hasExecutableChild = hasExecutableChild || childStats.executable;
        }

        stats[node.id] = {
          executable: hasExecutableChild
        };

        segmentChildren(node, orderedChildren, stats[node.id], executableIndex);

        if (!node.canBeReentered() && stats[node.id].segments.length > 1) {
          stats = { valid: false };
        }
      }
    }

    function startingMin(executableIndex) {
      return executableIndex === undefined ? defaultMin : executableIndex;
    }

    function startingMax(executableIndex) {
      return executableIndex === undefined ? defaultMax : executableIndex;
    }

    function segmentChildren(node, orderedChildren, nodeStats, executableIndex) {
      var currentSegment = { index: 0, owner: node, nodes: [], min: startingMin(executableIndex), max: startingMax(executableIndex) },
          result = [currentSegment],
          lastMax = defaultMax,
          orderedChildSegments = orderChildSegments(orderedChildren);

      function isSegmentBoundary(minIndex) {
        return lastMax !== defaultMax && minIndex !== defaultMin && lastMax < minIndex - 1;
      }

      for (var i = 0; i < orderedChildSegments.length; i++) {
        var childSegment = orderedChildSegments[i],
          maxIndex = childSegment.max,
          minIndex = childSegment.min;

        if (isSegmentBoundary(minIndex)) {
          currentSegment = {index: result.length, owner: node, nodes: [], min: defaultMin, max: defaultMax};
          result.push(currentSegment);
        }

        currentSegment.nodes.push(childSegment);
        currentSegment.min = Math.min(currentSegment.min, minIndex);
        currentSegment.max = Math.max(currentSegment.max, maxIndex);
        lastMax = maxIndex;
      }

      nodeStats.segments = result;
    }

    function orderChildSegments(children) {
      var specifiedOrder = [],
          unspecifiedOrder = [];

      for (var i = 0; i < children.length; i++) {
        var child = children[i],
            segments = stats[child.id].segments;

        for (var j = 0; j < segments.length; j++) {
          var seg = segments[j];

          if (seg.min === defaultMin) {
            unspecifiedOrder.push(seg);
          } else {
            specifiedOrder.push(seg);
          }
        }
      }

      specifiedOrder.sort(function(a, b) {
        return a.min - b.min;
      });

      return specifiedOrder.concat(unspecifiedOrder);
    }

    function executeNode(node, segmentNumber) {
      if (node.children) {
        return {
          fn: function(done) {
            nodeStart(node);

            queueRunnerFactory({
              onComplete: function() {
                nodeComplete(node, node.getResult());
                done();
              },
              queueableFns: wrapChildren(node, segmentNumber),
              userContext: node.sharedUserContext(),
              onException: function() {
                node.onException.apply(node, arguments);
              }
            });
          }
        };
      } else {
        return {
          fn: function(done) { node.execute(done, stats[node.id].executable); }
        };
      }
    }

    function wrapChildren(node, segmentNumber) {
      var result = [],
          segmentChildren = stats[node.id].segments[segmentNumber].nodes;

      for (var i = 0; i < segmentChildren.length; i++) {
        result.push(executeNode(segmentChildren[i].owner, segmentChildren[i].index));
      }

      if (!stats[node.id].executable) {
        return result;
      }

      return node.beforeAllFns.concat(result).concat(node.afterAllFns);
    }
  }

  return TreeProcessor;
};

getJasmineRequireObj().UserContext = function(j$) {
  function UserContext() {
  }

  UserContext.fromExisting = function(oldContext) {
    var context = new UserContext();

    for (var prop in oldContext) {
      if (oldContext.hasOwnProperty(prop)) {
        context[prop] = oldContext[prop];
      }
    }

    return context;
  };

  return  UserContext;
};

getJasmineRequireObj().version = function() {
  return '2.99.0';
};

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":116}],97:[function(require,module,exports){
(function (global){(function (){
/*
Copyright (c) 2008-2018 Pivotal Labs

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
module.exports = function(jasmineRequire) {
  var jasmine = jasmineRequire.core(jasmineRequire);

  var consoleFns = require('../console/console.js');
  consoleFns.console(consoleFns, jasmine);

  var env = jasmine.getEnv();

  var jasmineInterface = jasmineRequire.interface(jasmine, env);

  extend(global, jasmineInterface);

  function extend(destination, source) {
    for (var property in source) destination[property] = source[property];
    return destination;
  }

  return jasmine;
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../console/console.js":94}],98:[function(require,module,exports){
module.exports = function(exitCode, platform, nodeVersion, exit, nodeExit) {
  if(isWindows(platform) && olderThan12(nodeVersion)) {
    nodeExit(exitCode);
  }
  else {
    exit(exitCode);
  }
};

function isWindows(platform) {
  return /^win/.test(platform);
}

function olderThan12(nodeVersion) {
  var version = nodeVersion.split('.');
  return parseInt(version[0].substr(1), 10) <= 0 && parseInt(version[1], 10) < 12;
}
},{}],99:[function(require,module,exports){
module.exports = exports = ConsoleSpecFilter;

function ConsoleSpecFilter(options) {
  var filterString = options && options.filterString;
  var filterPattern = new RegExp(filterString);

  this.matches = function(specName) {
    return filterPattern.test(specName);
  };
}

},{}],100:[function(require,module,exports){
(function (process){(function (){
var path = require('path'),
    util = require('util'),
    glob = require('glob'),
    exit = require('./exit'),
    CompletionReporter = require('./reporters/completion_reporter'),
    ConsoleSpecFilter = require('./filters/console_spec_filter');

module.exports = Jasmine;
module.exports.ConsoleReporter = require('./reporters/console_reporter');

function Jasmine(options) {
  options = options || {};
  var jasmineCore = options.jasmineCore || require('jasmine-core');
  this.jasmineCorePath = path.join(jasmineCore.files.path, 'jasmine.js');
  this.jasmine = jasmineCore.boot(jasmineCore);
  this.projectBaseDir = options.projectBaseDir || path.resolve();
  this.printDeprecation = options.printDeprecation || require('./printDeprecation');
  this.specDir = '';
  this.specFiles = [];
  this.helperFiles = [];
  this.env = this.jasmine.getEnv();
  this.reportersCount = 0;
  this.completionReporter = new CompletionReporter();
  this.onCompleteCallbackAdded = false;
  this.exit = exit;
  this.showingColors = true;
  this.reporter = new module.exports.ConsoleReporter();
  this.addReporter(this.reporter);
  this.defaultReporterConfigured = false;

  var jasmineRunner = this;
  this.completionReporter.onComplete(function(passed) {
    jasmineRunner.exitCodeCompletion(passed);
  });
  this.checkExit = checkExit(this);

  this.coreVersion = function() {
    return jasmineCore.version();
  };
}

Jasmine.prototype.randomizeTests = function(value) {
  this.env.randomizeTests(value);
};

Jasmine.prototype.seed = function(value) {
  this.env.seed(value);
};

Jasmine.prototype.showColors = function(value) {
  this.showingColors = value;
};

Jasmine.prototype.addSpecFile = function(filePath) {
  this.specFiles.push(filePath);
};

Jasmine.prototype.addReporter = function(reporter) {
  this.env.addReporter(reporter);
  this.reportersCount++;
};

Jasmine.prototype.clearReporters = function() {
  this.env.clearReporters();
  this.reportersCount = 0;
};

Jasmine.prototype.provideFallbackReporter = function(reporter) {
  this.env.provideFallbackReporter(reporter);
};

Jasmine.prototype.configureDefaultReporter = function(options) {
  options.timer = options.timer || new this.jasmine.Timer();
  options.print = options.print || function() {
    process.stdout.write(util.format.apply(this, arguments));
  };
  options.showColors = options.hasOwnProperty('showColors') ? options.showColors : true;
  options.jasmineCorePath = options.jasmineCorePath || this.jasmineCorePath;

  if(options.onComplete) {
    this.printDeprecation('Passing in an onComplete function to configureDefaultReporter is deprecated.');
  }
  this.reporter.setOptions(options);
  this.defaultReporterConfigured = true;
};

Jasmine.prototype.addMatchers = function(matchers) {
  this.env.addMatchers(matchers);
};

Jasmine.prototype.loadSpecs = function() {
  this.specFiles.forEach(function(file) {
    require(file);
  });
};

Jasmine.prototype.loadHelpers = function() {
  this.helperFiles.forEach(function(file) {
    require(file);
  });
};

Jasmine.prototype.loadConfigFile = function(configFilePath) {
  try {
    var absoluteConfigFilePath = path.resolve(this.projectBaseDir, configFilePath || 'spec/support/jasmine.json');
    var config = require(absoluteConfigFilePath);
    this.loadConfig(config);
  } catch (e) {
    if(configFilePath || e.code != 'MODULE_NOT_FOUND') { throw e; }
  }
};

Jasmine.prototype.loadConfig = function(config) {
  this.specDir = config.spec_dir || this.specDir;
  this.env.throwOnExpectationFailure(config.stopSpecOnExpectationFailure);
  this.env.randomizeTests(config.random);

  if(config.helpers) {
    this.addHelperFiles(config.helpers);
  }

  if(config.spec_files) {
    this.addSpecFiles(config.spec_files);
  }
};

Jasmine.prototype.addHelperFiles = addFiles('helperFiles');
Jasmine.prototype.addSpecFiles = addFiles('specFiles');

function addFiles(kind) {
  return function (files) {
    var jasmineRunner = this;
    var fileArr = this[kind];

    files.forEach(function(file) {
      if(!(path.isAbsolute && path.isAbsolute(file))) {
        file = path.join(jasmineRunner.projectBaseDir, jasmineRunner.specDir, file);
      }
      var filePaths = glob.sync(file);
      filePaths.forEach(function(filePath) {
        if(fileArr.indexOf(filePath) === -1) {
          fileArr.push(filePath);
        }
      });
    });
  };
}

Jasmine.prototype.onComplete = function(onCompleteCallback) {
  this.completionReporter.onComplete(onCompleteCallback);
};

Jasmine.prototype.stopSpecOnExpectationFailure = function(value) {
  this.env.throwOnExpectationFailure(value);
};

Jasmine.prototype.exitCodeCompletion = function(passed) {
  if(passed) {
    this.exit(0, process.platform, process.version, process.exit, require('exit'));
  }
  else {
    this.exit(1, process.platform, process.version, process.exit, require('exit'));
  }
};

var checkExit = function(jasmineRunner) {
  return function() {
    if (!jasmineRunner.completionReporter.isComplete()) {
      process.exitCode = 4;
    }
  };
};

Jasmine.prototype.execute = function(files, filterString) {
  process.on('exit', this.checkExit);

  this.loadHelpers();
  if (!this.defaultReporterConfigured) {
    this.configureDefaultReporter({ showColors: this.showingColors });
  }

  if(filterString) {
    var specFilter = new ConsoleSpecFilter({
      filterString: filterString
    });
    this.env.specFilter = function(spec) {
      return specFilter.matches(spec.getFullName());
    };
  }

  if (files && files.length > 0) {
    this.specDir = '';
    this.specFiles = [];
    this.addSpecFiles(files);
  }

  this.loadSpecs();

  this.addReporter(this.completionReporter);
  this.env.execute();
};

}).call(this)}).call(this,require('_process'))

},{"./exit":98,"./filters/console_spec_filter":99,"./printDeprecation":101,"./reporters/completion_reporter":102,"./reporters/console_reporter":103,"_process":116,"exit":87,"glob":105,"jasmine-core":95,"path":113,"util":146}],101:[function(require,module,exports){
module.exports = function(message) {
  console.warn('Deprecation warning: ' + message);
};
},{}],102:[function(require,module,exports){
module.exports = function() {
  var results = true;
  var onCompleteCallback = function() {};
  var completed = false;

  this.onComplete = function(callback) {
    onCompleteCallback = callback;
  };

  this.jasmineDone = function(result) {
    completed = true;
    if (result && result.failedExpectations && result.failedExpectations.length > 0) {
      results = false;
    }
    onCompleteCallback(results);
  };

  this.isComplete = function() {
    return completed;
  };

  this.specDone = function(result) {
    if(result.status === 'failed') {
      results = false;
    }
  };

  this.suiteDone = function(result) {
    if (result.failedExpectations && result.failedExpectations.length > 0) {
      results = false;
    }
  };
};

},{}],103:[function(require,module,exports){
module.exports = exports = ConsoleReporter;

var noopTimer = {
  start: function(){},
  elapsed: function(){ return 0; }
};

function ConsoleReporter() {
  var print = function() {},
    showColors = false,
    timer = noopTimer,
    jasmineCorePath = null,
    printDeprecation = function() {},
    specCount,
    executableSpecCount,
    failureCount,
    failedSpecs = [],
    pendingSpecs = [],
    ansi = {
      green: '\x1B[32m',
      red: '\x1B[31m',
      yellow: '\x1B[33m',
      none: '\x1B[0m'
    },
    failedSuites = [],
    stackFilter = defaultStackFilter,
    onComplete = function() {};

  this.setOptions = function(options) {
    if (options.print) {
      print = options.print;
    }
    showColors = options.showColors || false;
    if (options.timer) {
      timer = options.timer;
    }
    if (options.jasmineCorePath) {
      jasmineCorePath = options.jasmineCorePath;
    }
    if (options.printDeprecation) {
      printDeprecation = options.printDeprecation;
    }
    if (options.stackFilter) {
      stackFilter = options.stackFilter;
    }

    if(options.onComplete) {
      printDeprecation('Passing in an onComplete function to the ConsoleReporter is deprecated.');
      onComplete = options.onComplete;
    }
  };

  this.jasmineStarted = function(options) {
    specCount = 0;
    executableSpecCount = 0;
    failureCount = 0;
    if (options && options.order && options.order.random) {
      print('Randomized with seed ' + options.order.seed);
      printNewline();
    }
    print('Started');
    printNewline();
    timer.start();
  };

  this.jasmineDone = function(result) {
    printNewline();
    printNewline();
    if(failedSpecs.length > 0) {
      print('Failures:');
    }
    for (var i = 0; i < failedSpecs.length; i++) {
      specFailureDetails(failedSpecs[i], i + 1);
    }

    if (pendingSpecs.length > 0) {
      print("Pending:");
    }
    for(i = 0; i < pendingSpecs.length; i++) {
      pendingSpecDetails(pendingSpecs[i], i + 1);
    }

    if(specCount > 0) {
      printNewline();

      if(executableSpecCount !== specCount) {
        print('Ran ' + executableSpecCount + ' of ' + specCount + plural(' spec', specCount));
        printNewline();
      }
      var specCounts = executableSpecCount + ' ' + plural('spec', executableSpecCount) + ', ' +
        failureCount + ' ' + plural('failure', failureCount);

      if (pendingSpecs.length) {
        specCounts += ', ' + pendingSpecs.length + ' pending ' + plural('spec', pendingSpecs.length);
      }

      print(specCounts);
    } else {
      print('No specs found');
    }

    printNewline();
    var seconds = timer.elapsed() / 1000;
    print('Finished in ' + seconds + ' ' + plural('second', seconds));
    printNewline();

    for(i = 0; i < failedSuites.length; i++) {
      suiteFailureDetails(failedSuites[i]);
    }

    if (result && result.failedExpectations) {
      suiteFailureDetails(result);
    }

    if (result && result.order && result.order.random) {
      print('Randomized with seed ' + result.order.seed);
      printNewline();
    }

    onComplete(failureCount === 0);
  };

  this.specDone = function(result) {
    specCount++;

    if (result.status == 'pending') {
      pendingSpecs.push(result);
      executableSpecCount++;
      print(colored('yellow', '*'));
      return;
    }

    if (result.status == 'passed') {
      executableSpecCount++;
      print(colored('green', '.'));
      return;
    }

    if (result.status == 'failed') {
      failureCount++;
      failedSpecs.push(result);
      executableSpecCount++;
      print(colored('red', 'F'));
    }
  };

  this.suiteDone = function(result) {
    if (result.failedExpectations && result.failedExpectations.length > 0) {
      failureCount++;
      failedSuites.push(result);
    }
  };

  return this;

  function printNewline() {
    print('\n');
  }

  function colored(color, str) {
    return showColors ? (ansi[color] + str + ansi.none) : str;
  }

  function plural(str, count) {
    return count == 1 ? str : str + 's';
  }

  function repeat(thing, times) {
    var arr = [];
    for (var i = 0; i < times; i++) {
      arr.push(thing);
    }
    return arr;
  }

  function indent(str, spaces) {
    var lines = (str || '').split('\n');
    var newArr = [];
    for (var i = 0; i < lines.length; i++) {
      newArr.push(repeat(' ', spaces).join('') + lines[i]);
    }
    return newArr.join('\n');
  }

  function defaultStackFilter(stack) {
    if (!stack) {
      return '';
    }

    var filteredStack = stack.split('\n').filter(function(stackLine) {
      return stackLine.indexOf(jasmineCorePath) === -1;
    }).join('\n');
    return filteredStack;
  }

  function specFailureDetails(result, failedSpecNumber) {
    printNewline();
    print(failedSpecNumber + ') ');
    print(result.fullName);

    for (var i = 0; i < result.failedExpectations.length; i++) {
      var failedExpectation = result.failedExpectations[i];
      printNewline();
      print(indent('Message:', 2));
      printNewline();
      print(colored('red', indent(failedExpectation.message, 4)));
      printNewline();
      print(indent('Stack:', 2));
      printNewline();
      print(indent(stackFilter(failedExpectation.stack), 4));
    }

    printNewline();
  }

  function suiteFailureDetails(result) {
    for (var i = 0; i < result.failedExpectations.length; i++) {
      printNewline();
      print(colored('red', 'An error was thrown in an afterAll'));
      printNewline();
      print(colored('red', 'AfterAll ' + result.failedExpectations[i].message));

    }
    printNewline();
  }

  function pendingSpecDetails(result, pendingSpecNumber) {
    printNewline();
    printNewline();
    print(pendingSpecNumber + ') ');
    print(result.fullName);
    printNewline();
    var pendingReason = "No reason given";
    if (result.pendingReason && result.pendingReason !== '') {
      pendingReason = result.pendingReason;
    }
    print(indent(colored('yellow', pendingReason), 2));
    printNewline();
  }
}

},{}],104:[function(require,module,exports){
(function (process){(function (){
exports.setopts = setopts
exports.ownProp = ownProp
exports.makeAbs = makeAbs
exports.finish = finish
exports.mark = mark
exports.isIgnored = isIgnored
exports.childrenIgnored = childrenIgnored

function ownProp (obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field)
}

var path = require("path")
var minimatch = require("minimatch")
var isAbsolute = require("path-is-absolute")
var Minimatch = minimatch.Minimatch

function alphasort (a, b) {
  return a.localeCompare(b, 'en')
}

function setupIgnores (self, options) {
  self.ignore = options.ignore || []

  if (!Array.isArray(self.ignore))
    self.ignore = [self.ignore]

  if (self.ignore.length) {
    self.ignore = self.ignore.map(ignoreMap)
  }
}

// ignore patterns are always in dot:true mode.
function ignoreMap (pattern) {
  var gmatcher = null
  if (pattern.slice(-3) === '/**') {
    var gpattern = pattern.replace(/(\/\*\*)+$/, '')
    gmatcher = new Minimatch(gpattern, { dot: true })
  }

  return {
    matcher: new Minimatch(pattern, { dot: true }),
    gmatcher: gmatcher
  }
}

function setopts (self, pattern, options) {
  if (!options)
    options = {}

  // base-matching: just use globstar for that.
  if (options.matchBase && -1 === pattern.indexOf("/")) {
    if (options.noglobstar) {
      throw new Error("base matching requires globstar")
    }
    pattern = "**/" + pattern
  }

  self.silent = !!options.silent
  self.pattern = pattern
  self.strict = options.strict !== false
  self.realpath = !!options.realpath
  self.realpathCache = options.realpathCache || Object.create(null)
  self.follow = !!options.follow
  self.dot = !!options.dot
  self.mark = !!options.mark
  self.nodir = !!options.nodir
  if (self.nodir)
    self.mark = true
  self.sync = !!options.sync
  self.nounique = !!options.nounique
  self.nonull = !!options.nonull
  self.nosort = !!options.nosort
  self.nocase = !!options.nocase
  self.stat = !!options.stat
  self.noprocess = !!options.noprocess
  self.absolute = !!options.absolute

  self.maxLength = options.maxLength || Infinity
  self.cache = options.cache || Object.create(null)
  self.statCache = options.statCache || Object.create(null)
  self.symlinks = options.symlinks || Object.create(null)

  setupIgnores(self, options)

  self.changedCwd = false
  var cwd = process.cwd()
  if (!ownProp(options, "cwd"))
    self.cwd = cwd
  else {
    self.cwd = path.resolve(options.cwd)
    self.changedCwd = self.cwd !== cwd
  }

  self.root = options.root || path.resolve(self.cwd, "/")
  self.root = path.resolve(self.root)
  if (process.platform === "win32")
    self.root = self.root.replace(/\\/g, "/")

  // TODO: is an absolute `cwd` supposed to be resolved against `root`?
  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')
  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)
  if (process.platform === "win32")
    self.cwdAbs = self.cwdAbs.replace(/\\/g, "/")
  self.nomount = !!options.nomount

  // disable comments and negation in Minimatch.
  // Note that they are not supported in Glob itself anyway.
  options.nonegate = true
  options.nocomment = true

  self.minimatch = new Minimatch(pattern, options)
  self.options = self.minimatch.options
}

function finish (self) {
  var nou = self.nounique
  var all = nou ? [] : Object.create(null)

  for (var i = 0, l = self.matches.length; i < l; i ++) {
    var matches = self.matches[i]
    if (!matches || Object.keys(matches).length === 0) {
      if (self.nonull) {
        // do like the shell, and spit out the literal glob
        var literal = self.minimatch.globSet[i]
        if (nou)
          all.push(literal)
        else
          all[literal] = true
      }
    } else {
      // had matches
      var m = Object.keys(matches)
      if (nou)
        all.push.apply(all, m)
      else
        m.forEach(function (m) {
          all[m] = true
        })
    }
  }

  if (!nou)
    all = Object.keys(all)

  if (!self.nosort)
    all = all.sort(alphasort)

  // at *some* point we statted all of these
  if (self.mark) {
    for (var i = 0; i < all.length; i++) {
      all[i] = self._mark(all[i])
    }
    if (self.nodir) {
      all = all.filter(function (e) {
        var notDir = !(/\/$/.test(e))
        var c = self.cache[e] || self.cache[makeAbs(self, e)]
        if (notDir && c)
          notDir = c !== 'DIR' && !Array.isArray(c)
        return notDir
      })
    }
  }

  if (self.ignore.length)
    all = all.filter(function(m) {
      return !isIgnored(self, m)
    })

  self.found = all
}

function mark (self, p) {
  var abs = makeAbs(self, p)
  var c = self.cache[abs]
  var m = p
  if (c) {
    var isDir = c === 'DIR' || Array.isArray(c)
    var slash = p.slice(-1) === '/'

    if (isDir && !slash)
      m += '/'
    else if (!isDir && slash)
      m = m.slice(0, -1)

    if (m !== p) {
      var mabs = makeAbs(self, m)
      self.statCache[mabs] = self.statCache[abs]
      self.cache[mabs] = self.cache[abs]
    }
  }

  return m
}

// lotta situps...
function makeAbs (self, f) {
  var abs = f
  if (f.charAt(0) === '/') {
    abs = path.join(self.root, f)
  } else if (isAbsolute(f) || f === '') {
    abs = f
  } else if (self.changedCwd) {
    abs = path.resolve(self.cwd, f)
  } else {
    abs = path.resolve(f)
  }

  if (process.platform === 'win32')
    abs = abs.replace(/\\/g, '/')

  return abs
}


// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
function isIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
  })
}

function childrenIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return !!(item.gmatcher && item.gmatcher.match(path))
  })
}

}).call(this)}).call(this,require('_process'))

},{"_process":116,"minimatch":110,"path":113,"path-is-absolute":114}],105:[function(require,module,exports){
(function (process){(function (){
// Approach:
//
// 1. Get the minimatch set
// 2. For each pattern in the set, PROCESS(pattern, false)
// 3. Store matches per-set, then uniq them
//
// PROCESS(pattern, inGlobStar)
// Get the first [n] items from pattern that are all strings
// Join these together.  This is PREFIX.
//   If there is no more remaining, then stat(PREFIX) and
//   add to matches if it succeeds.  END.
//
// If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = []
// else readdir(PREFIX) as ENTRIES
//   If fail, END
//
// with ENTRIES
//   If pattern[n] is GLOBSTAR
//     // handle the case where the globstar match is empty
//     // by pruning it out, and testing the resulting pattern
//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
//     // handle other cases.
//     for ENTRY in ENTRIES (not dotfiles)
//       // attach globstar + tail onto the entry
//       // Mark that this entry is a globstar match
//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
//
//   else // not globstar
//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
//       Test ENTRY against pattern[n]
//       If fails, continue
//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
//
// Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   `true` for files, and [children,...] for directories, or `false` for
//   things that don't exist.

module.exports = glob

var fs = require('fs')
var rp = require('fs.realpath')
var minimatch = require('minimatch')
var Minimatch = minimatch.Minimatch
var inherits = require('inherits')
var EE = require('events').EventEmitter
var path = require('path')
var assert = require('assert')
var isAbsolute = require('path-is-absolute')
var globSync = require('./sync.js')
var common = require('./common.js')
var setopts = common.setopts
var ownProp = common.ownProp
var inflight = require('inflight')
var util = require('util')
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

var once = require('once')

function glob (pattern, options, cb) {
  if (typeof options === 'function') cb = options, options = {}
  if (!options) options = {}

  if (options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return globSync(pattern, options)
  }

  return new Glob(pattern, options, cb)
}

glob.sync = globSync
var GlobSync = glob.GlobSync = globSync.GlobSync

// old api surface
glob.glob = glob

function extend (origin, add) {
  if (add === null || typeof add !== 'object') {
    return origin
  }

  var keys = Object.keys(add)
  var i = keys.length
  while (i--) {
    origin[keys[i]] = add[keys[i]]
  }
  return origin
}

glob.hasMagic = function (pattern, options_) {
  var options = extend({}, options_)
  options.noprocess = true

  var g = new Glob(pattern, options)
  var set = g.minimatch.set

  if (!pattern)
    return false

  if (set.length > 1)
    return true

  for (var j = 0; j < set[0].length; j++) {
    if (typeof set[0][j] !== 'string')
      return true
  }

  return false
}

glob.Glob = Glob
inherits(Glob, EE)
function Glob (pattern, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = null
  }

  if (options && options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return new GlobSync(pattern, options)
  }

  if (!(this instanceof Glob))
    return new Glob(pattern, options, cb)

  setopts(this, pattern, options)
  this._didRealPath = false

  // process each pattern in the minimatch set
  var n = this.minimatch.set.length

  // The matches are stored as {<filename>: true,...} so that
  // duplicates are automagically pruned.
  // Later, we do an Object.keys() on these.
  // Keep them as a list so we can fill in when nonull is set.
  this.matches = new Array(n)

  if (typeof cb === 'function') {
    cb = once(cb)
    this.on('error', cb)
    this.on('end', function (matches) {
      cb(null, matches)
    })
  }

  var self = this
  this._processing = 0

  this._emitQueue = []
  this._processQueue = []
  this.paused = false

  if (this.noprocess)
    return this

  if (n === 0)
    return done()

  var sync = true
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false, done)
  }
  sync = false

  function done () {
    --self._processing
    if (self._processing <= 0) {
      if (sync) {
        process.nextTick(function () {
          self._finish()
        })
      } else {
        self._finish()
      }
    }
  }
}

Glob.prototype._finish = function () {
  assert(this instanceof Glob)
  if (this.aborted)
    return

  if (this.realpath && !this._didRealpath)
    return this._realpath()

  common.finish(this)
  this.emit('end', this.found)
}

Glob.prototype._realpath = function () {
  if (this._didRealpath)
    return

  this._didRealpath = true

  var n = this.matches.length
  if (n === 0)
    return this._finish()

  var self = this
  for (var i = 0; i < this.matches.length; i++)
    this._realpathSet(i, next)

  function next () {
    if (--n === 0)
      self._finish()
  }
}

Glob.prototype._realpathSet = function (index, cb) {
  var matchset = this.matches[index]
  if (!matchset)
    return cb()

  var found = Object.keys(matchset)
  var self = this
  var n = found.length

  if (n === 0)
    return cb()

  var set = this.matches[index] = Object.create(null)
  found.forEach(function (p, i) {
    // If there's a problem with the stat, then it means that
    // one or more of the links in the realpath couldn't be
    // resolved.  just return the abs value in that case.
    p = self._makeAbs(p)
    rp.realpath(p, self.realpathCache, function (er, real) {
      if (!er)
        set[real] = true
      else if (er.syscall === 'stat')
        set[p] = true
      else
        self.emit('error', er) // srsly wtf right here

      if (--n === 0) {
        self.matches[index] = set
        cb()
      }
    })
  })
}

Glob.prototype._mark = function (p) {
  return common.mark(this, p)
}

Glob.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}

Glob.prototype.abort = function () {
  this.aborted = true
  this.emit('abort')
}

Glob.prototype.pause = function () {
  if (!this.paused) {
    this.paused = true
    this.emit('pause')
  }
}

Glob.prototype.resume = function () {
  if (this.paused) {
    this.emit('resume')
    this.paused = false
    if (this._emitQueue.length) {
      var eq = this._emitQueue.slice(0)
      this._emitQueue.length = 0
      for (var i = 0; i < eq.length; i ++) {
        var e = eq[i]
        this._emitMatch(e[0], e[1])
      }
    }
    if (this._processQueue.length) {
      var pq = this._processQueue.slice(0)
      this._processQueue.length = 0
      for (var i = 0; i < pq.length; i ++) {
        var p = pq[i]
        this._processing--
        this._process(p[0], p[1], p[2], p[3])
      }
    }
  }
}

Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
  assert(this instanceof Glob)
  assert(typeof cb === 'function')

  if (this.aborted)
    return

  this._processing++
  if (this.paused) {
    this._processQueue.push([pattern, index, inGlobStar, cb])
    return
  }

  //console.error('PROCESS %d', this._processing, pattern)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // see if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index, cb)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip _processing
  if (childrenIgnored(this, read))
    return cb()

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
}

Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}

Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return cb()

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return cb()

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return cb()
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix) {
      if (prefix !== '/')
        e = prefix + '/' + e
      else
        e = prefix + e
    }
    this._process([e].concat(remain), index, inGlobStar, cb)
  }
  cb()
}

Glob.prototype._emitMatch = function (index, e) {
  if (this.aborted)
    return

  if (isIgnored(this, e))
    return

  if (this.paused) {
    this._emitQueue.push([index, e])
    return
  }

  var abs = isAbsolute(e) ? e : this._makeAbs(e)

  if (this.mark)
    e = this._mark(e)

  if (this.absolute)
    e = abs

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true

  var st = this.statCache[abs]
  if (st)
    this.emit('stat', e, st)

  this.emit('match', e)
}

Glob.prototype._readdirInGlobStar = function (abs, cb) {
  if (this.aborted)
    return

  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false, cb)

  var lstatkey = 'lstat\0' + abs
  var self = this
  var lstatcb = inflight(lstatkey, lstatcb_)

  if (lstatcb)
    fs.lstat(abs, lstatcb)

  function lstatcb_ (er, lstat) {
    if (er && er.code === 'ENOENT')
      return cb()

    var isSym = lstat && lstat.isSymbolicLink()
    self.symlinks[abs] = isSym

    // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.
    if (!isSym && lstat && !lstat.isDirectory()) {
      self.cache[abs] = 'FILE'
      cb()
    } else
      self._readdir(abs, false, cb)
  }
}

Glob.prototype._readdir = function (abs, inGlobStar, cb) {
  if (this.aborted)
    return

  cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
  if (!cb)
    return

  //console.error('RD %j %j', +inGlobStar, abs)
  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs, cb)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return cb()

    if (Array.isArray(c))
      return cb(null, c)
  }

  var self = this
  fs.readdir(abs, readdirCb(this, abs, cb))
}

function readdirCb (self, abs, cb) {
  return function (er, entries) {
    if (er)
      self._readdirError(abs, er, cb)
    else
      self._readdirEntries(abs, entries, cb)
  }
}

Glob.prototype._readdirEntries = function (abs, entries, cb) {
  if (this.aborted)
    return

  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries
  return cb(null, entries)
}

Glob.prototype._readdirError = function (f, er, cb) {
  if (this.aborted)
    return

  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        this.emit('error', error)
        this.abort()
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict) {
        this.emit('error', er)
        // If the error is handled, then we abort
        // if not, we threw out of here
        this.abort()
      }
      if (!this.silent)
        console.error('glob error', er)
      break
  }

  return cb()
}

Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}


Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  //console.error('pgs2', prefix, remain[0], entries)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return cb()

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false, cb)

  var isSym = this.symlinks[abs]
  var len = entries.length

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return cb()

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true, cb)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true, cb)
  }

  cb()
}

Glob.prototype._processSimple = function (prefix, index, cb) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var self = this
  this._stat(prefix, function (er, exists) {
    self._processSimple2(prefix, index, er, exists, cb)
  })
}
Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

  //console.error('ps2', prefix, exists)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return cb()

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
  cb()
}

// Returns either 'DIR', 'FILE', or false
Glob.prototype._stat = function (f, cb) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return cb()

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return cb(null, c)

    if (needDir && c === 'FILE')
      return cb()

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (stat !== undefined) {
    if (stat === false)
      return cb(null, stat)
    else {
      var type = stat.isDirectory() ? 'DIR' : 'FILE'
      if (needDir && type === 'FILE')
        return cb()
      else
        return cb(null, type, stat)
    }
  }

  var self = this
  var statcb = inflight('stat\0' + abs, lstatcb_)
  if (statcb)
    fs.lstat(abs, statcb)

  function lstatcb_ (er, lstat) {
    if (lstat && lstat.isSymbolicLink()) {
      // If it's a symlink, then treat it as the target, unless
      // the target does not exist, then treat it as a file.
      return fs.stat(abs, function (er, stat) {
        if (er)
          self._stat2(f, abs, null, lstat, cb)
        else
          self._stat2(f, abs, er, stat, cb)
      })
    } else {
      self._stat2(f, abs, er, lstat, cb)
    }
  }
}

Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
    this.statCache[abs] = false
    return cb()
  }

  var needDir = f.slice(-1) === '/'
  this.statCache[abs] = stat

  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())
    return cb(null, false, stat)

  var c = true
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE'
  this.cache[abs] = this.cache[abs] || c

  if (needDir && c === 'FILE')
    return cb()

  return cb(null, c, stat)
}

}).call(this)}).call(this,require('_process'))

},{"./common.js":104,"./sync.js":106,"_process":116,"assert":60,"events":86,"fs":68,"fs.realpath":88,"inflight":91,"inherits":92,"minimatch":110,"once":112,"path":113,"path-is-absolute":114,"util":146}],106:[function(require,module,exports){
(function (process){(function (){
module.exports = globSync
globSync.GlobSync = GlobSync

var fs = require('fs')
var rp = require('fs.realpath')
var minimatch = require('minimatch')
var Minimatch = minimatch.Minimatch
var Glob = require('./glob.js').Glob
var util = require('util')
var path = require('path')
var assert = require('assert')
var isAbsolute = require('path-is-absolute')
var common = require('./common.js')
var setopts = common.setopts
var ownProp = common.ownProp
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

function globSync (pattern, options) {
  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  return new GlobSync(pattern, options).found
}

function GlobSync (pattern, options) {
  if (!pattern)
    throw new Error('must provide pattern')

  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  if (!(this instanceof GlobSync))
    return new GlobSync(pattern, options)

  setopts(this, pattern, options)

  if (this.noprocess)
    return this

  var n = this.minimatch.set.length
  this.matches = new Array(n)
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false)
  }
  this._finish()
}

GlobSync.prototype._finish = function () {
  assert(this instanceof GlobSync)
  if (this.realpath) {
    var self = this
    this.matches.forEach(function (matchset, index) {
      var set = self.matches[index] = Object.create(null)
      for (var p in matchset) {
        try {
          p = self._makeAbs(p)
          var real = rp.realpathSync(p, self.realpathCache)
          set[real] = true
        } catch (er) {
          if (er.syscall === 'stat')
            set[self._makeAbs(p)] = true
          else
            throw er
        }
      }
    })
  }
  common.finish(this)
}


GlobSync.prototype._process = function (pattern, index, inGlobStar) {
  assert(this instanceof GlobSync)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // See if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip processing
  if (childrenIgnored(this, read))
    return

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
}


GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
  var entries = this._readdir(abs, inGlobStar)

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix.slice(-1) !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix)
      newPattern = [prefix, e]
    else
      newPattern = [e]
    this._process(newPattern.concat(remain), index, inGlobStar)
  }
}


GlobSync.prototype._emitMatch = function (index, e) {
  if (isIgnored(this, e))
    return

  var abs = this._makeAbs(e)

  if (this.mark)
    e = this._mark(e)

  if (this.absolute) {
    e = abs
  }

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true

  if (this.stat)
    this._stat(e)
}


GlobSync.prototype._readdirInGlobStar = function (abs) {
  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false)

  var entries
  var lstat
  var stat
  try {
    lstat = fs.lstatSync(abs)
  } catch (er) {
    if (er.code === 'ENOENT') {
      // lstat failed, doesn't exist
      return null
    }
  }

  var isSym = lstat && lstat.isSymbolicLink()
  this.symlinks[abs] = isSym

  // If it's not a symlink or a dir, then it's definitely a regular file.
  // don't bother doing a readdir in that case.
  if (!isSym && lstat && !lstat.isDirectory())
    this.cache[abs] = 'FILE'
  else
    entries = this._readdir(abs, false)

  return entries
}

GlobSync.prototype._readdir = function (abs, inGlobStar) {
  var entries

  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return null

    if (Array.isArray(c))
      return c
  }

  try {
    return this._readdirEntries(abs, fs.readdirSync(abs))
  } catch (er) {
    this._readdirError(abs, er)
    return null
  }
}

GlobSync.prototype._readdirEntries = function (abs, entries) {
  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries

  // mark and cache dir-ness
  return entries
}

GlobSync.prototype._readdirError = function (f, er) {
  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        throw error
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict)
        throw er
      if (!this.silent)
        console.error('glob error', er)
      break
  }
}

GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

  var entries = this._readdir(abs, inGlobStar)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false)

  var len = entries.length
  var isSym = this.symlinks[abs]

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true)
  }
}

GlobSync.prototype._processSimple = function (prefix, index) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var exists = this._stat(prefix)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
}

// Returns either 'DIR', 'FILE', or false
GlobSync.prototype._stat = function (f) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return false

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return c

    if (needDir && c === 'FILE')
      return false

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (!stat) {
    var lstat
    try {
      lstat = fs.lstatSync(abs)
    } catch (er) {
      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
        this.statCache[abs] = false
        return false
      }
    }

    if (lstat && lstat.isSymbolicLink()) {
      try {
        stat = fs.statSync(abs)
      } catch (er) {
        stat = lstat
      }
    } else {
      stat = lstat
    }
  }

  this.statCache[abs] = stat

  var c = true
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE'

  this.cache[abs] = this.cache[abs] || c

  if (needDir && c === 'FILE')
    return false

  return c
}

GlobSync.prototype._mark = function (p) {
  return common.mark(this, p)
}

GlobSync.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}

}).call(this)}).call(this,require('_process'))

},{"./common.js":104,"./glob.js":105,"_process":116,"assert":60,"fs":68,"fs.realpath":88,"minimatch":110,"path":113,"path-is-absolute":114,"util":146}],107:[function(require,module,exports){
exports.parse = require('./lib/parse');
exports.stringify = require('./lib/stringify');

},{"./lib/parse":108,"./lib/stringify":109}],108:[function(require,module,exports){
var at, // The index of the current character
    ch, // The current character
    escapee = {
        '"':  '"',
        '\\': '\\',
        '/':  '/',
        b:    '\b',
        f:    '\f',
        n:    '\n',
        r:    '\r',
        t:    '\t'
    },
    text,

    error = function (m) {
        // Call error when something is wrong.
        throw {
            name:    'SyntaxError',
            message: m,
            at:      at,
            text:    text
        };
    },
    
    next = function (c) {
        // If a c parameter is provided, verify that it matches the current character.
        if (c && c !== ch) {
            error("Expected '" + c + "' instead of '" + ch + "'");
        }
        
        // Get the next character. When there are no more characters,
        // return the empty string.
        
        ch = text.charAt(at);
        at += 1;
        return ch;
    },
    
    number = function () {
        // Parse a number value.
        var number,
            string = '';
        
        if (ch === '-') {
            string = '-';
            next('-');
        }
        while (ch >= '0' && ch <= '9') {
            string += ch;
            next();
        }
        if (ch === '.') {
            string += '.';
            while (next() && ch >= '0' && ch <= '9') {
                string += ch;
            }
        }
        if (ch === 'e' || ch === 'E') {
            string += ch;
            next();
            if (ch === '-' || ch === '+') {
                string += ch;
                next();
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
        }
        number = +string;
        if (!isFinite(number)) {
            error("Bad number");
        } else {
            return number;
        }
    },
    
    string = function () {
        // Parse a string value.
        var hex,
            i,
            string = '',
            uffff;
        
        // When parsing for string values, we must look for " and \ characters.
        if (ch === '"') {
            while (next()) {
                if (ch === '"') {
                    next();
                    return string;
                } else if (ch === '\\') {
                    next();
                    if (ch === 'u') {
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            uffff = uffff * 16 + hex;
                        }
                        string += String.fromCharCode(uffff);
                    } else if (typeof escapee[ch] === 'string') {
                        string += escapee[ch];
                    } else {
                        break;
                    }
                } else {
                    string += ch;
                }
            }
        }
        error("Bad string");
    },

    white = function () {

// Skip whitespace.

        while (ch && ch <= ' ') {
            next();
        }
    },

    word = function () {

// true, false, or null.

        switch (ch) {
        case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;
        case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;
        case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;
        }
        error("Unexpected '" + ch + "'");
    },

    value,  // Place holder for the value function.

    array = function () {

// Parse an array value.

        var array = [];

        if (ch === '[') {
            next('[');
            white();
            if (ch === ']') {
                next(']');
                return array;   // empty array
            }
            while (ch) {
                array.push(value());
                white();
                if (ch === ']') {
                    next(']');
                    return array;
                }
                next(',');
                white();
            }
        }
        error("Bad array");
    },

    object = function () {

// Parse an object value.

        var key,
            object = {};

        if (ch === '{') {
            next('{');
            white();
            if (ch === '}') {
                next('}');
                return object;   // empty object
            }
            while (ch) {
                key = string();
                white();
                next(':');
                if (Object.hasOwnProperty.call(object, key)) {
                    error('Duplicate key "' + key + '"');
                }
                object[key] = value();
                white();
                if (ch === '}') {
                    next('}');
                    return object;
                }
                next(',');
                white();
            }
        }
        error("Bad object");
    };

value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

    white();
    switch (ch) {
    case '{':
        return object();
    case '[':
        return array();
    case '"':
        return string();
    case '-':
        return number();
    default:
        return ch >= '0' && ch <= '9' ? number() : word();
    }
};

// Return the json_parse function. It will have access to all of the above
// functions and variables.

module.exports = function (source, reviver) {
    var result;
    
    text = source;
    at = 0;
    ch = ' ';
    result = value();
    white();
    if (ch) {
        error("Syntax error");
    }

    // If there is a reviver function, we recursively walk the new structure,
    // passing each name/value pair to the reviver function for possible
    // transformation, starting with a temporary root object that holds the result
    // in an empty key. If there is not a reviver function, we simply return the
    // result.

    return typeof reviver === 'function' ? (function walk(holder, key) {
        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
            for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                    v = walk(value, k);
                    if (v !== undefined) {
                        value[k] = v;
                    } else {
                        delete value[k];
                    }
                }
            }
        }
        return reviver.call(holder, key, value);
    }({'': result}, '')) : result;
};

},{}],109:[function(require,module,exports){
var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {    // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    },
    rep;

function quote(string) {
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.
    
    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
        var c = meta[a];
        return typeof c === 'string' ? c :
            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
}

function str(key, holder) {
    // Produce a string from holder[key].
    var i,          // The loop counter.
        k,          // The member key.
        v,          // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key];
    
    // If the value has a toJSON method, call it to obtain a replacement value.
    if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
        value = value.toJSON(key);
    }
    
    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.
    if (typeof rep === 'function') {
        value = rep.call(holder, key, value);
    }
    
    // What happens next depends on the value's type.
    switch (typeof value) {
        case 'string':
            return quote(value);
        
        case 'number':
            // JSON numbers must be finite. Encode non-finite numbers as null.
            return isFinite(value) ? String(value) : 'null';
        
        case 'boolean':
        case 'null':
            // If the value is a boolean or null, convert it to a string. Note:
            // typeof null does not produce 'null'. The case is included here in
            // the remote chance that this gets fixed someday.
            return String(value);
            
        case 'object':
            if (!value) return 'null';
            gap += indent;
            partial = [];
            
            // Array.isArray
            if (Object.prototype.toString.apply(value) === '[object Array]') {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }
                
                // Join all of the elements together, separated with commas, and
                // wrap them in brackets.
                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }
            
            // If the replacer is an array, use it to select the members to be
            // stringified.
            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            else {
                // Otherwise, iterate through all of the keys in the object.
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            
        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0 ? '{}' : gap ?
            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
            '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
}

module.exports = function (value, replacer, space) {
    var i;
    gap = '';
    indent = '';
    
    // If the space parameter is a number, make an indent string containing that
    // many spaces.
    if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
            indent += ' ';
        }
    }
    // If the space parameter is a string, it will be used as the indent string.
    else if (typeof space === 'string') {
        indent = space;
    }

    // If there is a replacer, it must be a function or an array.
    // Otherwise, throw an error.
    rep = replacer;
    if (replacer && typeof replacer !== 'function'
    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
    }
    
    // Make a fake root object containing our value under the key of ''.
    // Return the result of stringifying the value.
    return str('', {'': value});
};

},{}],110:[function(require,module,exports){
module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = { sep: '/' }
try {
  path = require('path')
} catch (er) {}

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = require('brace-expansion')

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  a = a || {}
  b = b || {}
  var t = {}
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return minimatch

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig.minimatch(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return Minimatch
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  // "" only matches ""
  if (pattern.trim() === '') return p === ''

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}
  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  // don't do it more than once.
  if (this._made) return

  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = console.error

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  if (typeof pattern === 'undefined') {
    throw new TypeError('undefined pattern')
  }

  if (options.nobrace ||
    !pattern.match(/\{.*\}/)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  if (pattern.length > 1024 * 64) {
    throw new TypeError('pattern is too long')
  }

  var options = this.options

  // shortcuts
  if (!options.noglobstar && pattern === '**') return GLOBSTAR
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      case '/':
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        if (inClass) {
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          var cs = pattern.substring(classStart + 1, i)
          try {
            RegExp('[' + cs + ']')
          } catch (er) {
            // not a valid class!
            var sp = this.parse(cs, SUBPARSE)
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
            hasMagic = hasMagic || sp[1]
            inClass = false
            continue
          }
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '.':
    case '[':
    case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (er) {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = match
function match (f, partial) {
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase()
      } else {
        hit = f === p
      }
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
    return emptyFileEnd
  }

  // should be unreachable.
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}

},{"brace-expansion":66,"path":113}],111:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],112:[function(require,module,exports){
var wrappy = require('wrappy')
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}

},{"wrappy":147}],113:[function(require,module,exports){
(function (process){(function (){
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this)}).call(this,require('_process'))

},{"_process":116}],114:[function(require,module,exports){
(function (process){(function (){
'use strict';

function posix(path) {
	return path.charAt(0) === '/';
}

function win32(path) {
	// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
	var result = splitDeviceRe.exec(path);
	var device = result[1] || '';
	var isUnc = Boolean(device && device.charAt(1) !== ':');

	// UNC paths are always absolute
	return Boolean(result[2] || isUnc);
}

module.exports = process.platform === 'win32' ? win32 : posix;
module.exports.posix = posix;
module.exports.win32 = win32;

}).call(this)}).call(this,require('_process'))

},{"_process":116}],115:[function(require,module,exports){
(function (process){(function (){
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this)}).call(this,require('_process'))

},{"_process":116}],116:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],117:[function(require,module,exports){
(function (global){(function (){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],118:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],119:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],120:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":118,"./encode":119}],121:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":122}],122:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":124,"./_stream_writable":126,"core-util-is":77,"inherits":92,"process-nextick-args":115}],123:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":125,"core-util-is":77,"inherits":92}],124:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":122,"./internal/streams/BufferList":127,"./internal/streams/destroy":128,"./internal/streams/stream":129,"_process":116,"core-util-is":77,"events":86,"inherits":92,"isarray":130,"process-nextick-args":115,"safe-buffer":136,"string_decoder/":131,"util":67}],125:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":122,"core-util-is":77,"inherits":92}],126:[function(require,module,exports){
(function (process,global,setImmediate){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)

},{"./_stream_duplex":122,"./internal/streams/destroy":128,"./internal/streams/stream":129,"_process":116,"core-util-is":77,"inherits":92,"process-nextick-args":115,"safe-buffer":136,"timers":140,"util-deprecate":144}],127:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":136,"util":67}],128:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":115}],129:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":86}],130:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],131:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":136}],132:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":133}],133:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":122,"./lib/_stream_passthrough.js":123,"./lib/_stream_readable.js":124,"./lib/_stream_transform.js":125,"./lib/_stream_writable.js":126}],134:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":133}],135:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":126}],136:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":69}],137:[function(require,module,exports){
var Stream = require('stream');
var sockjs = require('sockjs-client');
var resolve = require('url').resolve;
var parse = require('url').parse;

module.exports = function (u, cb) {
    var uri = parse(u).protocol ? u : resolve(window.location.href, u);
    
    var stream = new Stream;
    stream.readable = true;
    stream.writable = true;
    
    var ready = false;
    var buffer = [];
    
    var sock = sockjs(uri);
    stream.sock = sock;
    
    stream.write = function (msg) {
        if (!ready || buffer.length) buffer.push(msg)
        else sock.send(msg)
    };
    
    stream.end = function (msg) {
        if (msg !== undefined) stream.write(msg);
        if (!ready) {
            stream._ended = true;
            return;
        }
        stream.writable = false;
        sock.close();
    };
    
    stream.destroy = function () {
        stream._ended = true;
        stream.writable = stream.readable = false;
        buffer.length = 0
        sock.close();
    };
    
    sock.onopen = function () {
        if (typeof cb === 'function') cb();
        ready = true;
        for (var i = 0; i < buffer.length; i++) {
            sock.send(buffer[i]);
        }
        buffer = [];
        stream.emit('connect');
        if (stream._ended) stream.end();
    };
    
    sock.onmessage = function (e) {
        stream.emit('data', e.data);
    };
    
    sock.onclose = function () {
        stream.emit('end');
        stream.writable = false;
        stream.readable = false;
    };
    
    return stream;
};

},{"sockjs-client":138,"stream":139,"url":142}],138:[function(require,module,exports){
/* SockJS client, version 0.3.1.7.ga67f.dirty, http://sockjs.org, MIT License

Copyright (c) 2011-2012 VMware, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

// JSON2 by Douglas Crockford (minified).
var JSON;JSON||(JSON={}),function(){function str(a,b){var c,d,e,f,g=gap,h,i=b[a];i&&typeof i=="object"&&typeof i.toJSON=="function"&&(i=i.toJSON(a)),typeof rep=="function"&&(i=rep.call(b,a,i));switch(typeof i){case"string":return quote(i);case"number":return isFinite(i)?String(i):"null";case"boolean":case"null":return String(i);case"object":if(!i)return"null";gap+=indent,h=[];if(Object.prototype.toString.apply(i)==="[object Array]"){f=i.length;for(c=0;c<f;c+=1)h[c]=str(c,i)||"null";e=h.length===0?"[]":gap?"[\n"+gap+h.join(",\n"+gap)+"\n"+g+"]":"["+h.join(",")+"]",gap=g;return e}if(rep&&typeof rep=="object"){f=rep.length;for(c=0;c<f;c+=1)typeof rep[c]=="string"&&(d=rep[c],e=str(d,i),e&&h.push(quote(d)+(gap?": ":":")+e))}else for(d in i)Object.prototype.hasOwnProperty.call(i,d)&&(e=str(d,i),e&&h.push(quote(d)+(gap?": ":":")+e));e=h.length===0?"{}":gap?"{\n"+gap+h.join(",\n"+gap)+"\n"+g+"}":"{"+h.join(",")+"}",gap=g;return e}}function quote(a){escapable.lastIndex=0;return escapable.test(a)?'"'+a.replace(escapable,function(a){var b=meta[a];return typeof b=="string"?b:"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)})+'"':'"'+a+'"'}function f(a){return a<10?"0"+a:a}"use strict",typeof Date.prototype.toJSON!="function"&&(Date.prototype.toJSON=function(a){return isFinite(this.valueOf())?this.getUTCFullYear()+"-"+f(this.getUTCMonth()+1)+"-"+f(this.getUTCDate())+"T"+f(this.getUTCHours())+":"+f(this.getUTCMinutes())+":"+f(this.getUTCSeconds())+"Z":null},String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(a){return this.valueOf()});var cx=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,escapable=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,gap,indent,meta={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"},rep;typeof JSON.stringify!="function"&&(JSON.stringify=function(a,b,c){var d;gap="",indent="";if(typeof c=="number")for(d=0;d<c;d+=1)indent+=" ";else typeof c=="string"&&(indent=c);rep=b;if(!b||typeof b=="function"||typeof b=="object"&&typeof b.length=="number")return str("",{"":a});throw new Error("JSON.stringify")}),typeof JSON.parse!="function"&&(JSON.parse=function(text,reviver){function walk(a,b){var c,d,e=a[b];if(e&&typeof e=="object")for(c in e)Object.prototype.hasOwnProperty.call(e,c)&&(d=walk(e,c),d!==undefined?e[c]=d:delete e[c]);return reviver.call(a,b,e)}var j;text=String(text),cx.lastIndex=0,cx.test(text)&&(text=text.replace(cx,function(a){return"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)}));if(/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,"@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:\s*\[)+/g,""))){j=eval("("+text+")");return typeof reviver=="function"?walk({"":j},""):j}throw new SyntaxError("JSON.parse")})}()


//     [*] Including lib/index.js
// Public object
var SockJS = (function(){
              var _document = document;
              var _window = window;
              var utils = {};


//         [*] Including lib/reventtarget.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

/* Simplified implementation of DOM2 EventTarget.
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
 */
var REventTarget = function() {};
REventTarget.prototype.addEventListener = function (eventType, listener) {
    if(!this._listeners) {
         this._listeners = {};
    }
    if(!(eventType in this._listeners)) {
        this._listeners[eventType] = [];
    }
    var arr = this._listeners[eventType];
    if(utils.arrIndexOf(arr, listener) === -1) {
        arr.push(listener);
    }
    return;
};

REventTarget.prototype.removeEventListener = function (eventType, listener) {
    if(!(this._listeners && (eventType in this._listeners))) {
        return;
    }
    var arr = this._listeners[eventType];
    var idx = utils.arrIndexOf(arr, listener);
    if (idx !== -1) {
        if(arr.length > 1) {
            this._listeners[eventType] = arr.slice(0, idx).concat( arr.slice(idx+1) );
        } else {
            delete this._listeners[eventType];
        }
        return;
    }
    return;
};

REventTarget.prototype.dispatchEvent = function (event) {
    var t = event.type;
    var args = Array.prototype.slice.call(arguments, 0);
    if (this['on'+t]) {
        this['on'+t].apply(this, args);
    }
    if (this._listeners && t in this._listeners) {
        for(var i=0; i < this._listeners[t].length; i++) {
            this._listeners[t][i].apply(this, args);
        }
    }
};
//         [*] End of lib/reventtarget.js


//         [*] Including lib/simpleevent.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var SimpleEvent = function(type, obj) {
    this.type = type;
    if (typeof obj !== 'undefined') {
        for(var k in obj) {
            if (!obj.hasOwnProperty(k)) continue;
            this[k] = obj[k];
        }
    }
};

SimpleEvent.prototype.toString = function() {
    var r = [];
    for(var k in this) {
        if (!this.hasOwnProperty(k)) continue;
        var v = this[k];
        if (typeof v === 'function') v = '[function]';
        r.push(k + '=' + v);
    }
    return 'SimpleEvent(' + r.join(', ') + ')';
};
//         [*] End of lib/simpleevent.js


//         [*] Including lib/eventemitter.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var EventEmitter = function(events) {
    this.events = events || [];
};
EventEmitter.prototype.emit = function(type) {
    var that = this;
    var args = Array.prototype.slice.call(arguments, 1);
    if (!that.nuked && that['on'+type]) {
        that['on'+type].apply(that, args);
    }
    if (utils.arrIndexOf(that.events, type) === -1) {
        utils.log('Event ' + JSON.stringify(type) +
                  ' not listed ' + JSON.stringify(that.events) +
                  ' in ' + that);
    }
};

EventEmitter.prototype.nuke = function(type) {
    var that = this;
    that.nuked = true;
    for(var i=0; i<that.events.length; i++) {
        delete that[that.events[i]];
    }
};
//         [*] End of lib/eventemitter.js


//         [*] Including lib/utils.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var random_string_chars = 'abcdefghijklmnopqrstuvwxyz0123456789_';
utils.random_string = function(length, max) {
    max = max || random_string_chars.length;
    var i, ret = [];
    for(i=0; i < length; i++) {
        ret.push( random_string_chars.substr(Math.floor(Math.random() * max),1) );
    }
    return ret.join('');
};
utils.random_number = function(max) {
    return Math.floor(Math.random() * max);
};
utils.random_number_string = function(max) {
    var t = (''+(max - 1)).length;
    var p = Array(t+1).join('0');
    return (p + utils.random_number(max)).slice(-t);
};

// Assuming that url looks like: http://asdasd:111/asd
utils.getOrigin = function(url) {
    url += '/';
    var parts = url.split('/').slice(0, 3);
    return parts.join('/');
};

utils.isSameOriginUrl = function(url_a, url_b) {
    // location.origin would do, but it's not always available.
    if (!url_b) url_b = _window.location.href;

    return (url_a.split('/').slice(0,3).join('/')
                ===
            url_b.split('/').slice(0,3).join('/'));
};

utils.getParentDomain = function(url) {
    // ipv4 ip address
    if (/^[0-9.]*$/.test(url)) return url;
    // ipv6 ip address
    if (/^\[/.test(url)) return url;
    // no dots
    if (!(/[.]/.test(url))) return url;

    var parts = url.split('.').slice(1);
    return parts.join('.');
};

utils.objectExtend = function(dst, src) {
    for(var k in src) {
        if (src.hasOwnProperty(k)) {
            dst[k] = src[k];
        }
    }
    return dst;
};

var WPrefix = '_jp';

utils.polluteGlobalNamespace = function() {
    if (!(WPrefix in _window)) {
        _window[WPrefix] = {};
    }
};

utils.closeFrame = function (code, reason) {
    return 'c'+JSON.stringify([code, reason]);
};

utils.userSetCode = function (code) {
    return code === 1000 || (code >= 3000 && code <= 4999);
};

// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
// and RFC 2988.
utils.countRTO = function (rtt) {
    var rto;
    if (rtt > 100) {
        rto = 3 * rtt; // rto > 300msec
    } else {
        rto = rtt + 200; // 200msec < rto <= 300msec
    }
    return rto;
}

utils.log = function() {
    if (_window.console && console.log && console.log.apply) {
        console.log.apply(console, arguments);
    }
};

utils.bind = function(fun, that) {
    if (fun.bind) {
        return fun.bind(that);
    } else {
        return function() {
            return fun.apply(that, arguments);
        };
    }
};

utils.flatUrl = function(url) {
    return url.indexOf('?') === -1 && url.indexOf('#') === -1;
};

utils.amendUrl = function(url) {
    var dl = _document.location;
    if (!url) {
        throw new Error('Wrong url for SockJS');
    }
    if (!utils.flatUrl(url)) {
        throw new Error('Only basic urls are supported in SockJS');
    }

    //  '//abc' --> 'http://abc'
    if (url.indexOf('//') === 0) {
        url = dl.protocol + url;
    }
    // '/abc' --> 'http://localhost:80/abc'
    if (url.indexOf('/') === 0) {
        url = dl.protocol + '//' + dl.host + url;
    }
    // strip trailing slashes
    url = url.replace(/[/]+$/,'');
    return url;
};

// IE doesn't support [].indexOf.
utils.arrIndexOf = function(arr, obj){
    for(var i=0; i < arr.length; i++){
        if(arr[i] === obj){
            return i;
        }
    }
    return -1;
};

utils.arrSkip = function(arr, obj) {
    var idx = utils.arrIndexOf(arr, obj);
    if (idx === -1) {
        return arr.slice();
    } else {
        var dst = arr.slice(0, idx);
        return dst.concat(arr.slice(idx+1));
    }
};

// Via: https://gist.github.com/1133122/2121c601c5549155483f50be3da5305e83b8c5df
utils.isArray = Array.isArray || function(value) {
    return {}.toString.call(value).indexOf('Array') >= 0
};

utils.delay = function(t, fun) {
    if(typeof t === 'function') {
        fun = t;
        t = 0;
    }
    return setTimeout(fun, t);
};


// Chars worth escaping, as defined by Douglas Crockford:
//   https://github.com/douglascrockford/JSON-js/blob/47a9882cddeb1e8529e07af9736218075372b8ac/json2.js#L196
var json_escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    json_lookup = {
"\u0000":"\\u0000","\u0001":"\\u0001","\u0002":"\\u0002","\u0003":"\\u0003",
"\u0004":"\\u0004","\u0005":"\\u0005","\u0006":"\\u0006","\u0007":"\\u0007",
"\b":"\\b","\t":"\\t","\n":"\\n","\u000b":"\\u000b","\f":"\\f","\r":"\\r",
"\u000e":"\\u000e","\u000f":"\\u000f","\u0010":"\\u0010","\u0011":"\\u0011",
"\u0012":"\\u0012","\u0013":"\\u0013","\u0014":"\\u0014","\u0015":"\\u0015",
"\u0016":"\\u0016","\u0017":"\\u0017","\u0018":"\\u0018","\u0019":"\\u0019",
"\u001a":"\\u001a","\u001b":"\\u001b","\u001c":"\\u001c","\u001d":"\\u001d",
"\u001e":"\\u001e","\u001f":"\\u001f","\"":"\\\"","\\":"\\\\",
"\u007f":"\\u007f","\u0080":"\\u0080","\u0081":"\\u0081","\u0082":"\\u0082",
"\u0083":"\\u0083","\u0084":"\\u0084","\u0085":"\\u0085","\u0086":"\\u0086",
"\u0087":"\\u0087","\u0088":"\\u0088","\u0089":"\\u0089","\u008a":"\\u008a",
"\u008b":"\\u008b","\u008c":"\\u008c","\u008d":"\\u008d","\u008e":"\\u008e",
"\u008f":"\\u008f","\u0090":"\\u0090","\u0091":"\\u0091","\u0092":"\\u0092",
"\u0093":"\\u0093","\u0094":"\\u0094","\u0095":"\\u0095","\u0096":"\\u0096",
"\u0097":"\\u0097","\u0098":"\\u0098","\u0099":"\\u0099","\u009a":"\\u009a",
"\u009b":"\\u009b","\u009c":"\\u009c","\u009d":"\\u009d","\u009e":"\\u009e",
"\u009f":"\\u009f","\u00ad":"\\u00ad","\u0600":"\\u0600","\u0601":"\\u0601",
"\u0602":"\\u0602","\u0603":"\\u0603","\u0604":"\\u0604","\u070f":"\\u070f",
"\u17b4":"\\u17b4","\u17b5":"\\u17b5","\u200c":"\\u200c","\u200d":"\\u200d",
"\u200e":"\\u200e","\u200f":"\\u200f","\u2028":"\\u2028","\u2029":"\\u2029",
"\u202a":"\\u202a","\u202b":"\\u202b","\u202c":"\\u202c","\u202d":"\\u202d",
"\u202e":"\\u202e","\u202f":"\\u202f","\u2060":"\\u2060","\u2061":"\\u2061",
"\u2062":"\\u2062","\u2063":"\\u2063","\u2064":"\\u2064","\u2065":"\\u2065",
"\u2066":"\\u2066","\u2067":"\\u2067","\u2068":"\\u2068","\u2069":"\\u2069",
"\u206a":"\\u206a","\u206b":"\\u206b","\u206c":"\\u206c","\u206d":"\\u206d",
"\u206e":"\\u206e","\u206f":"\\u206f","\ufeff":"\\ufeff","\ufff0":"\\ufff0",
"\ufff1":"\\ufff1","\ufff2":"\\ufff2","\ufff3":"\\ufff3","\ufff4":"\\ufff4",
"\ufff5":"\\ufff5","\ufff6":"\\ufff6","\ufff7":"\\ufff7","\ufff8":"\\ufff8",
"\ufff9":"\\ufff9","\ufffa":"\\ufffa","\ufffb":"\\ufffb","\ufffc":"\\ufffc",
"\ufffd":"\\ufffd","\ufffe":"\\ufffe","\uffff":"\\uffff"};

// Some extra characters that Chrome gets wrong, and substitutes with
// something else on the wire.
var extra_escapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g,
    extra_lookup;

// JSON Quote string. Use native implementation when possible.
var JSONQuote = (JSON && JSON.stringify) || function(string) {
    json_escapable.lastIndex = 0;
    if (json_escapable.test(string)) {
        string = string.replace(json_escapable, function(a) {
            return json_lookup[a];
        });
    }
    return '"' + string + '"';
};

// This may be quite slow, so let's delay until user actually uses bad
// characters.
var unroll_lookup = function(escapable) {
    var i;
    var unrolled = {}
    var c = []
    for(i=0; i<65536; i++) {
        c.push( String.fromCharCode(i) );
    }
    escapable.lastIndex = 0;
    c.join('').replace(escapable, function (a) {
        unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        return '';
    });
    escapable.lastIndex = 0;
    return unrolled;
};

// Quote string, also taking care of unicode characters that browsers
// often break. Especially, take care of unicode surrogates:
//    http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
utils.quote = function(string) {
    var quoted = JSONQuote(string);

    // In most cases this should be very fast and good enough.
    extra_escapable.lastIndex = 0;
    if(!extra_escapable.test(quoted)) {
        return quoted;
    }

    if(!extra_lookup) extra_lookup = unroll_lookup(extra_escapable);

    return quoted.replace(extra_escapable, function(a) {
        return extra_lookup[a];
    });
}

var _all_protocols = ['websocket',
                      'xdr-streaming',
                      'xhr-streaming',
                      'iframe-eventsource',
                      'iframe-htmlfile',
                      'xdr-polling',
                      'xhr-polling',
                      'iframe-xhr-polling',
                      'jsonp-polling'];

utils.probeProtocols = function() {
    var probed = {};
    for(var i=0; i<_all_protocols.length; i++) {
        var protocol = _all_protocols[i];
        // User can have a typo in protocol name.
        probed[protocol] = SockJS[protocol] &&
                           SockJS[protocol].enabled();
    }
    return probed;
};

utils.detectProtocols = function(probed, protocols_whitelist, info) {
    var pe = {},
        protocols = [];
    if (!protocols_whitelist) protocols_whitelist = _all_protocols;
    for(var i=0; i<protocols_whitelist.length; i++) {
        var protocol = protocols_whitelist[i];
        pe[protocol] = probed[protocol];
    }
    var maybe_push = function(protos) {
        var proto = protos.shift();
        if (pe[proto]) {
            protocols.push(proto);
        } else {
            if (protos.length > 0) {
                maybe_push(protos);
            }
        }
    }

    // 1. Websocket
    if (info.websocket !== false) {
        maybe_push(['websocket']);
    }

    // 2. Streaming
    if (pe['xhr-streaming'] && !info.null_origin) {
        protocols.push('xhr-streaming');
    } else {
        if (pe['xdr-streaming'] && !info.cookie_needed && !info.null_origin) {
            protocols.push('xdr-streaming');
        } else {
            maybe_push(['iframe-eventsource',
                        'iframe-htmlfile']);
        }
    }

    // 3. Polling
    if (pe['xhr-polling'] && !info.null_origin) {
        protocols.push('xhr-polling');
    } else {
        if (pe['xdr-polling'] && !info.cookie_needed && !info.null_origin) {
            protocols.push('xdr-polling');
        } else {
            maybe_push(['iframe-xhr-polling',
                        'jsonp-polling']);
        }
    }
    return protocols;
}
//         [*] End of lib/utils.js


//         [*] Including lib/dom.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// May be used by htmlfile jsonp and transports.
var MPrefix = '_sockjs_global';
utils.createHook = function() {
    var window_id = 'a' + utils.random_string(8);
    if (!(MPrefix in _window)) {
        var map = {};
        _window[MPrefix] = function(window_id) {
            if (!(window_id in map)) {
                map[window_id] = {
                    id: window_id,
                    del: function() {delete map[window_id];}
                };
            }
            return map[window_id];
        }
    }
    return _window[MPrefix](window_id);
};



utils.attachMessage = function(listener) {
    utils.attachEvent('message', listener);
};
utils.attachEvent = function(event, listener) {
    if (typeof _window.addEventListener !== 'undefined') {
        _window.addEventListener(event, listener, false);
    } else {
        // IE quirks.
        // According to: http://stevesouders.com/misc/test-postmessage.php
        // the message gets delivered only to 'document', not 'window'.
        _document.attachEvent("on" + event, listener);
        // I get 'window' for ie8.
        _window.attachEvent("on" + event, listener);
    }
};

utils.detachMessage = function(listener) {
    utils.detachEvent('message', listener);
};
utils.detachEvent = function(event, listener) {
    if (typeof _window.addEventListener !== 'undefined') {
        _window.removeEventListener(event, listener, false);
    } else {
        _document.detachEvent("on" + event, listener);
        _window.detachEvent("on" + event, listener);
    }
};


var on_unload = {};
// Things registered after beforeunload are to be called immediately.
var after_unload = false;

var trigger_unload_callbacks = function() {
    for(var ref in on_unload) {
        on_unload[ref]();
        delete on_unload[ref];
    };
};

var unload_triggered = function() {
    if(after_unload) return;
    after_unload = true;
    trigger_unload_callbacks();
};

// Onbeforeunload alone is not reliable. We could use only 'unload'
// but it's not working in opera within an iframe. Let's use both.
utils.attachEvent('beforeunload', unload_triggered);
utils.attachEvent('unload', unload_triggered);

utils.unload_add = function(listener) {
    var ref = utils.random_string(8);
    on_unload[ref] = listener;
    if (after_unload) {
        utils.delay(trigger_unload_callbacks);
    }
    return ref;
};
utils.unload_del = function(ref) {
    if (ref in on_unload)
        delete on_unload[ref];
};


utils.createIframe = function (iframe_url, error_callback) {
    var iframe = _document.createElement('iframe');
    var tref, unload_ref;
    var unattach = function() {
        clearTimeout(tref);
        // Explorer had problems with that.
        try {iframe.onload = null;} catch (x) {}
        iframe.onerror = null;
    };
    var cleanup = function() {
        if (iframe) {
            unattach();
            // This timeout makes chrome fire onbeforeunload event
            // within iframe. Without the timeout it goes straight to
            // onunload.
            setTimeout(function() {
                if(iframe) {
                    iframe.parentNode.removeChild(iframe);
                }
                iframe = null;
            }, 0);
            utils.unload_del(unload_ref);
        }
    };
    var onerror = function(r) {
        if (iframe) {
            cleanup();
            error_callback(r);
        }
    };
    var post = function(msg, origin) {
        try {
            // When the iframe is not loaded, IE raises an exception
            // on 'contentWindow'.
            if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage(msg, origin);
            }
        } catch (x) {};
    };

    iframe.src = iframe_url;
    iframe.style.display = 'none';
    iframe.style.position = 'absolute';
    iframe.onerror = function(){onerror('onerror');};
    iframe.onload = function() {
        // `onload` is triggered before scripts on the iframe are
        // executed. Give it few seconds to actually load stuff.
        clearTimeout(tref);
        tref = setTimeout(function(){onerror('onload timeout');}, 2000);
    };
    _document.body.appendChild(iframe);
    tref = setTimeout(function(){onerror('timeout');}, 15000);
    unload_ref = utils.unload_add(cleanup);
    return {
        post: post,
        cleanup: cleanup,
        loaded: unattach
    };
};

utils.createHtmlfile = function (iframe_url, error_callback) {
    var doc = new ActiveXObject('htmlfile');
    var tref, unload_ref;
    var iframe;
    var unattach = function() {
        clearTimeout(tref);
    };
    var cleanup = function() {
        if (doc) {
            unattach();
            utils.unload_del(unload_ref);
            iframe.parentNode.removeChild(iframe);
            iframe = doc = null;
            CollectGarbage();
        }
    };
    var onerror = function(r)  {
        if (doc) {
            cleanup();
            error_callback(r);
        }
    };
    var post = function(msg, origin) {
        try {
            // When the iframe is not loaded, IE raises an exception
            // on 'contentWindow'.
            if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage(msg, origin);
            }
        } catch (x) {};
    };

    doc.open();
    doc.write('<html><s' + 'cript>' +
              'document.domain="' + document.domain + '";' +
              '</s' + 'cript></html>');
    doc.close();
    doc.parentWindow[WPrefix] = _window[WPrefix];
    var c = doc.createElement('div');
    doc.body.appendChild(c);
    iframe = doc.createElement('iframe');
    c.appendChild(iframe);
    iframe.src = iframe_url;
    tref = setTimeout(function(){onerror('timeout');}, 15000);
    unload_ref = utils.unload_add(cleanup);
    return {
        post: post,
        cleanup: cleanup,
        loaded: unattach
    };
};
//         [*] End of lib/dom.js


//         [*] Including lib/dom2.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var AbstractXHRObject = function(){};
AbstractXHRObject.prototype = new EventEmitter(['chunk', 'finish']);

AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
    var that = this;

    try {
        that.xhr = new XMLHttpRequest();
    } catch(x) {};

    if (!that.xhr) {
        try {
            that.xhr = new _window.ActiveXObject('Microsoft.XMLHTTP');
        } catch(x) {};
    }
    if (_window.ActiveXObject || _window.XDomainRequest) {
        // IE8 caches even POSTs
        url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);
    }

    // Explorer tends to keep connection open, even after the
    // tab gets closed: http://bugs.jquery.com/ticket/5280
    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});
    try {
        that.xhr.open(method, url, true);
    } catch(e) {
        // IE raises an exception on wrong port.
        that.emit('finish', 0, '');
        that._cleanup();
        return;
    };

    if (!opts || !opts.no_credentials) {
        // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
        // "This never affects same-site requests."
        that.xhr.withCredentials = 'true';
    }
    if (opts && opts.headers) {
        for(var key in opts.headers) {
            that.xhr.setRequestHeader(key, opts.headers[key]);
        }
    }

    that.xhr.onreadystatechange = function() {
        if (that.xhr) {
            var x = that.xhr;
            switch (x.readyState) {
            case 3:
                // IE doesn't like peeking into responseText or status
                // on Microsoft.XMLHTTP and readystate=3
                try {
                    var status = x.status;
                    var text = x.responseText;
                } catch (x) {};
                // IE does return readystate == 3 for 404 answers.
                if (text && text.length > 0) {
                    that.emit('chunk', status, text);
                }
                break;
            case 4:
                that.emit('finish', x.status, x.responseText);
                that._cleanup(false);
                break;
            }
        }
    };
    that.xhr.send(payload);
};

AbstractXHRObject.prototype._cleanup = function(abort) {
    var that = this;
    if (!that.xhr) return;
    utils.unload_del(that.unload_ref);

    // IE needs this field to be a function
    that.xhr.onreadystatechange = function(){};

    if (abort) {
        try {
            that.xhr.abort();
        } catch(x) {};
    }
    that.unload_ref = that.xhr = null;
};

AbstractXHRObject.prototype.close = function() {
    var that = this;
    that.nuke();
    that._cleanup(true);
};

var XHRCorsObject = utils.XHRCorsObject = function() {
    var that = this, args = arguments;
    utils.delay(function(){that._start.apply(that, args);});
};
XHRCorsObject.prototype = new AbstractXHRObject();

var XHRLocalObject = utils.XHRLocalObject = function(method, url, payload) {
    var that = this;
    utils.delay(function(){
        that._start(method, url, payload, {
            no_credentials: true
        });
    });
};
XHRLocalObject.prototype = new AbstractXHRObject();



// References:
//   http://ajaxian.com/archives/100-line-ajax-wrapper
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx
var XDRObject = utils.XDRObject = function(method, url, payload) {
    var that = this;
    utils.delay(function(){that._start(method, url, payload);});
};
XDRObject.prototype = new EventEmitter(['chunk', 'finish']);
XDRObject.prototype._start = function(method, url, payload) {
    var that = this;
    var xdr = new XDomainRequest();
    // IE caches even POSTs
    url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);

    var onerror = xdr.ontimeout = xdr.onerror = function() {
        that.emit('finish', 0, '');
        that._cleanup(false);
    };
    xdr.onprogress = function() {
        that.emit('chunk', 200, xdr.responseText);
    };
    xdr.onload = function() {
        that.emit('finish', 200, xdr.responseText);
        that._cleanup(false);
    };
    that.xdr = xdr;
    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});
    try {
        // Fails with AccessDenied if port number is bogus
        that.xdr.open(method, url);
        that.xdr.send(payload);
    } catch(x) {
        onerror();
    }
};

XDRObject.prototype._cleanup = function(abort) {
    var that = this;
    if (!that.xdr) return;
    utils.unload_del(that.unload_ref);

    that.xdr.ontimeout = that.xdr.onerror = that.xdr.onprogress =
        that.xdr.onload = null;
    if (abort) {
        try {
            that.xdr.abort();
        } catch(x) {};
    }
    that.unload_ref = that.xdr = null;
};

XDRObject.prototype.close = function() {
    var that = this;
    that.nuke();
    that._cleanup(true);
};

// 1. Is natively via XHR
// 2. Is natively via XDR
// 3. Nope, but postMessage is there so it should work via the Iframe.
// 4. Nope, sorry.
utils.isXHRCorsCapable = function() {
    if (_window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest()) {
        return 1;
    }
    // XDomainRequest doesn't work if page is served from file://
    if (_window.XDomainRequest && _document.domain) {
        return 2;
    }
    if (IframeTransport.enabled()) {
        return 3;
    }
    return 4;
};
//         [*] End of lib/dom2.js


//         [*] Including lib/sockjs.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var SockJS = function(url, dep_protocols_whitelist, options) {
    if (this === window) {
        // makes `new` optional
        return new SockJS(url, dep_protocols_whitelist, options);
    }
    
    var that = this, protocols_whitelist;
    that._options = {devel: false, debug: false, protocols_whitelist: [],
                     info: undefined, rtt: undefined};
    if (options) {
        utils.objectExtend(that._options, options);
    }
    that._base_url = utils.amendUrl(url);
    that._server = that._options.server || utils.random_number_string(1000);
    if (that._options.protocols_whitelist &&
        that._options.protocols_whitelist.length) {
        protocols_whitelist = that._options.protocols_whitelist;
    } else {
        // Deprecated API
        if (typeof dep_protocols_whitelist === 'string' &&
            dep_protocols_whitelist.length > 0) {
            protocols_whitelist = [dep_protocols_whitelist];
        } else if (utils.isArray(dep_protocols_whitelist)) {
            protocols_whitelist = dep_protocols_whitelist
        } else {
            protocols_whitelist = null;
        }
        if (protocols_whitelist) {
            that._debug('Deprecated API: Use "protocols_whitelist" option ' +
                        'instead of supplying protocol list as a second ' +
                        'parameter to SockJS constructor.');
        }
    }
    that._protocols = [];
    that.protocol = null;
    that.readyState = SockJS.CONNECTING;
    that._ir = createInfoReceiver(that._base_url);
    that._ir.onfinish = function(info, rtt) {
        that._ir = null;
        if (info) {
            if (that._options.info) {
                // Override if user supplies the option
                info = utils.objectExtend(info, that._options.info);
            }
            if (that._options.rtt) {
                rtt = that._options.rtt;
            }
            that._applyInfo(info, rtt, protocols_whitelist);
            that._didClose();
        } else {
            that._didClose(1002, 'Can\'t connect to server', true);
        }
    };
};
// Inheritance
SockJS.prototype = new REventTarget();

SockJS.version = "0.3.1.7.ga67f.dirty";

SockJS.CONNECTING = 0;
SockJS.OPEN = 1;
SockJS.CLOSING = 2;
SockJS.CLOSED = 3;

SockJS.prototype._debug = function() {
    if (this._options.debug)
        utils.log.apply(utils, arguments);
};

SockJS.prototype._dispatchOpen = function() {
    var that = this;
    if (that.readyState === SockJS.CONNECTING) {
        if (that._transport_tref) {
            clearTimeout(that._transport_tref);
            that._transport_tref = null;
        }
        that.readyState = SockJS.OPEN;
        that.dispatchEvent(new SimpleEvent("open"));
    } else {
        // The server might have been restarted, and lost track of our
        // connection.
        that._didClose(1006, "Server lost session");
    }
};

SockJS.prototype._dispatchMessage = function(data) {
    var that = this;
    if (that.readyState !== SockJS.OPEN)
            return;
    that.dispatchEvent(new SimpleEvent("message", {data: data}));
};

SockJS.prototype._dispatchHeartbeat = function(data) {
    var that = this;
    if (that.readyState !== SockJS.OPEN)
        return;
    that.dispatchEvent(new SimpleEvent('heartbeat', {}));
};

SockJS.prototype._didClose = function(code, reason, force) {
    var that = this;
    if (that.readyState !== SockJS.CONNECTING &&
        that.readyState !== SockJS.OPEN &&
        that.readyState !== SockJS.CLOSING)
            throw new Error('INVALID_STATE_ERR');
    if (that._ir) {
        that._ir.nuke();
        that._ir = null;
    }

    if (that._transport) {
        that._transport.doCleanup();
        that._transport = null;
    }

    var close_event = new SimpleEvent("close", {
        code: code,
        reason: reason,
        wasClean: utils.userSetCode(code)});

    if (!utils.userSetCode(code) &&
        that.readyState === SockJS.CONNECTING && !force) {
        if (that._try_next_protocol(close_event)) {
            return;
        }
        close_event = new SimpleEvent("close", {code: 2000,
                                                reason: "All transports failed",
                                                wasClean: false,
                                                last_event: close_event});
    }
    that.readyState = SockJS.CLOSED;

    utils.delay(function() {
                   that.dispatchEvent(close_event);
                });
};

SockJS.prototype._didMessage = function(data) {
    var that = this;
    var type = data.slice(0, 1);
    switch(type) {
    case 'o':
        that._dispatchOpen();
        break;
    case 'a':
        var payload = JSON.parse(data.slice(1) || '[]');
        for(var i=0; i < payload.length; i++){
            that._dispatchMessage(payload[i]);
        }
        break;
    case 'm':
        var payload = JSON.parse(data.slice(1) || 'null');
        that._dispatchMessage(payload);
        break;
    case 'c':
        var payload = JSON.parse(data.slice(1) || '[]');
        that._didClose(payload[0], payload[1]);
        break;
    case 'h':
        that._dispatchHeartbeat();
        break;
    }
};

SockJS.prototype._try_next_protocol = function(close_event) {
    var that = this;
    if (that.protocol) {
        that._debug('Closed transport:', that.protocol, ''+close_event);
        that.protocol = null;
    }
    if (that._transport_tref) {
        clearTimeout(that._transport_tref);
        that._transport_tref = null;
    }

    while(1) {
        var protocol = that.protocol = that._protocols.shift();
        if (!protocol) {
            return false;
        }
        // Some protocols require access to `body`, what if were in
        // the `head`?
        if (SockJS[protocol] &&
            SockJS[protocol].need_body === true &&
            (!_document.body ||
             (typeof _document.readyState !== 'undefined'
              && _document.readyState !== 'complete'))) {
            that._protocols.unshift(protocol);
            that.protocol = 'waiting-for-load';
            utils.attachEvent('load', function(){
                that._try_next_protocol();
            });
            return true;
        }

        if (!SockJS[protocol] ||
              !SockJS[protocol].enabled(that._options)) {
            that._debug('Skipping transport:', protocol);
        } else {
            var roundTrips = SockJS[protocol].roundTrips || 1;
            var to = ((that._options.rto || 0) * roundTrips) || 5000;
            that._transport_tref = utils.delay(to, function() {
                if (that.readyState === SockJS.CONNECTING) {
                    // I can't understand how it is possible to run
                    // this timer, when the state is CLOSED, but
                    // apparently in IE everythin is possible.
                    that._didClose(2007, "Transport timeouted");
                }
            });

            var connid = utils.random_string(8);
            var trans_url = that._base_url + '/' + that._server + '/' + connid;
            that._debug('Opening transport:', protocol, ' url:'+trans_url,
                        ' RTO:'+that._options.rto);
            that._transport = new SockJS[protocol](that, trans_url,
                                                   that._base_url);
            return true;
        }
    }
};

SockJS.prototype.close = function(code, reason) {
    var that = this;
    if (code && !utils.userSetCode(code))
        throw new Error("INVALID_ACCESS_ERR");
    if(that.readyState !== SockJS.CONNECTING &&
       that.readyState !== SockJS.OPEN) {
        return false;
    }
    that.readyState = SockJS.CLOSING;
    that._didClose(code || 1000, reason || "Normal closure");
    return true;
};

SockJS.prototype.send = function(data) {
    var that = this;
    if (that.readyState === SockJS.CONNECTING)
        throw new Error('INVALID_STATE_ERR');
    if (that.readyState === SockJS.OPEN) {
        that._transport.doSend(utils.quote('' + data));
    }
    return true;
};

SockJS.prototype._applyInfo = function(info, rtt, protocols_whitelist) {
    var that = this;
    that._options.info = info;
    that._options.rtt = rtt;
    that._options.rto = utils.countRTO(rtt);
    that._options.info.null_origin = !_document.domain;
    var probed = utils.probeProtocols();
    that._protocols = utils.detectProtocols(probed, protocols_whitelist, info);
};
//         [*] End of lib/sockjs.js


//         [*] Including lib/trans-websocket.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var WebSocketTransport = SockJS.websocket = function(ri, trans_url) {
    var that = this;
    var url = trans_url + '/websocket';
    if (url.slice(0, 5) === 'https') {
        url = 'wss' + url.slice(5);
    } else {
        url = 'ws' + url.slice(4);
    }
    that.ri = ri;
    that.url = url;
    var Constructor = _window.WebSocket || _window.MozWebSocket;

    that.ws = new Constructor(that.url);
    that.ws.onmessage = function(e) {
        that.ri._didMessage(e.data);
    };
    // Firefox has an interesting bug. If a websocket connection is
    // created after onbeforeunload, it stays alive even when user
    // navigates away from the page. In such situation let's lie -
    // let's not open the ws connection at all. See:
    // https://github.com/sockjs/sockjs-client/issues/28
    // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
    that.unload_ref = utils.unload_add(function(){that.ws.close()});
    that.ws.onclose = function() {
        that.ri._didMessage(utils.closeFrame(1006, "WebSocket connection broken"));
    };
};

WebSocketTransport.prototype.doSend = function(data) {
    this.ws.send('[' + data + ']');
};

WebSocketTransport.prototype.doCleanup = function() {
    var that = this;
    var ws = that.ws;
    if (ws) {
        ws.onmessage = ws.onclose = null;
        ws.close();
        utils.unload_del(that.unload_ref);
        that.unload_ref = that.ri = that.ws = null;
    }
};

WebSocketTransport.enabled = function() {
    return !!(_window.WebSocket || _window.MozWebSocket);
};

// In theory, ws should require 1 round trip. But in chrome, this is
// not very stable over SSL. Most likely a ws connection requires a
// separate SSL connection, in which case 2 round trips are an
// absolute minumum.
WebSocketTransport.roundTrips = 2;
//         [*] End of lib/trans-websocket.js


//         [*] Including lib/trans-sender.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var BufferedSender = function() {};
BufferedSender.prototype.send_constructor = function(sender) {
    var that = this;
    that.send_buffer = [];
    that.sender = sender;
};
BufferedSender.prototype.doSend = function(message) {
    var that = this;
    that.send_buffer.push(message);
    if (!that.send_stop) {
        that.send_schedule();
    }
};

// For polling transports in a situation when in the message callback,
// new message is being send. If the sending connection was started
// before receiving one, it is possible to saturate the network and
// timeout due to the lack of receiving socket. To avoid that we delay
// sending messages by some small time, in order to let receiving
// connection be started beforehand. This is only a halfmeasure and
// does not fix the big problem, but it does make the tests go more
// stable on slow networks.
BufferedSender.prototype.send_schedule_wait = function() {
    var that = this;
    var tref;
    that.send_stop = function() {
        that.send_stop = null;
        clearTimeout(tref);
    };
    tref = utils.delay(25, function() {
        that.send_stop = null;
        that.send_schedule();
    });
};

BufferedSender.prototype.send_schedule = function() {
    var that = this;
    if (that.send_buffer.length > 0) {
        var payload = '[' + that.send_buffer.join(',') + ']';
        that.send_stop = that.sender(that.trans_url,
                                     payload,
                                     function() {
                                         that.send_stop = null;
                                         that.send_schedule_wait();
                                     });
        that.send_buffer = [];
    }
};

BufferedSender.prototype.send_destructor = function() {
    var that = this;
    if (that._send_stop) {
        that._send_stop();
    }
    that._send_stop = null;
};

var jsonPGenericSender = function(url, payload, callback) {
    var that = this;

    if (!('_send_form' in that)) {
        var form = that._send_form = _document.createElement('form');
        var area = that._send_area = _document.createElement('textarea');
        area.name = 'd';
        form.style.display = 'none';
        form.style.position = 'absolute';
        form.method = 'POST';
        form.enctype = 'application/x-www-form-urlencoded';
        form.acceptCharset = "UTF-8";
        form.appendChild(area);
        _document.body.appendChild(form);
    }
    var form = that._send_form;
    var area = that._send_area;
    var id = 'a' + utils.random_string(8);
    form.target = id;
    form.action = url + '/jsonp_send?i=' + id;

    var iframe;
    try {
        // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
        iframe = _document.createElement('<iframe name="'+ id +'">');
    } catch(x) {
        iframe = _document.createElement('iframe');
        iframe.name = id;
    }
    iframe.id = id;
    form.appendChild(iframe);
    iframe.style.display = 'none';

    try {
        area.value = payload;
    } catch(e) {
        utils.log('Your browser is seriously broken. Go home! ' + e.message);
    }
    form.submit();

    var completed = function(e) {
        if (!iframe.onerror) return;
        iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
        // Opera mini doesn't like if we GC iframe
        // immediately, thus this timeout.
        utils.delay(500, function() {
                       iframe.parentNode.removeChild(iframe);
                       iframe = null;
                   });
        area.value = '';
        callback();
    };
    iframe.onerror = iframe.onload = completed;
    iframe.onreadystatechange = function(e) {
        if (iframe.readyState == 'complete') completed();
    };
    return completed;
};

var createAjaxSender = function(AjaxObject) {
    return function(url, payload, callback) {
        var xo = new AjaxObject('POST', url + '/xhr_send', payload);
        xo.onfinish = function(status, text) {
            callback(status);
        };
        return function(abort_reason) {
            callback(0, abort_reason);
        };
    };
};
//         [*] End of lib/trans-sender.js


//         [*] Including lib/trans-jsonp-receiver.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// Parts derived from Socket.io:
//    https://github.com/LearnBoost/socket.io/blob/0.6.17/lib/socket.io/transports/jsonp-polling.js
// and jQuery-JSONP:
//    https://code.google.com/p/jquery-jsonp/source/browse/trunk/core/jquery.jsonp.js
var jsonPGenericReceiver = function(url, callback) {
    var tref;
    var script = _document.createElement('script');
    var script2;  // Opera synchronous load trick.
    var close_script = function(frame) {
        if (script2) {
            script2.parentNode.removeChild(script2);
            script2 = null;
        }
        if (script) {
            clearTimeout(tref);
            script.parentNode.removeChild(script);
            script.onreadystatechange = script.onerror =
                script.onload = script.onclick = null;
            script = null;
            callback(frame);
            callback = null;
        }
    };

    // IE9 fires 'error' event after orsc or before, in random order.
    var loaded_okay = false;
    var error_timer = null;

    script.id = 'a' + utils.random_string(8);
    script.src = url;
    script.type = 'text/javascript';
    script.charset = 'UTF-8';
    script.onerror = function(e) {
        if (!error_timer) {
            // Delay firing close_script.
            error_timer = setTimeout(function() {
                if (!loaded_okay) {
                    close_script(utils.closeFrame(
                        1006,
                        "JSONP script loaded abnormally (onerror)"));
                }
            }, 1000);
        }
    };
    script.onload = function(e) {
        close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (onload)"));
    };

    script.onreadystatechange = function(e) {
        if (/loaded|closed/.test(script.readyState)) {
            if (script && script.htmlFor && script.onclick) {
                loaded_okay = true;
                try {
                    // In IE, actually execute the script.
                    script.onclick();
                } catch (x) {}
            }
            if (script) {
                close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (onreadystatechange)"));
            }
        }
    };
    // IE: event/htmlFor/onclick trick.
    // One can't rely on proper order for onreadystatechange. In order to
    // make sure, set a 'htmlFor' and 'event' properties, so that
    // script code will be installed as 'onclick' handler for the
    // script object. Later, onreadystatechange, manually execute this
    // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
    // set. For reference see:
    //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
    // Also, read on that about script ordering:
    //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
    if (typeof script.async === 'undefined' && _document.attachEvent) {
        // According to mozilla docs, in recent browsers script.async defaults
        // to 'true', so we may use it to detect a good browser:
        // https://developer.mozilla.org/en/HTML/Element/script
        if (!/opera/i.test(navigator.userAgent)) {
            // Naively assume we're in IE
            try {
                script.htmlFor = script.id;
                script.event = "onclick";
            } catch (x) {}
            script.async = true;
        } else {
            // Opera, second sync script hack
            script2 = _document.createElement('script');
            script2.text = "try{var a = document.getElementById('"+script.id+"'); if(a)a.onerror();}catch(x){};";
            script.async = script2.async = false;
        }
    }
    if (typeof script.async !== 'undefined') {
        script.async = true;
    }

    // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
    tref = setTimeout(function() {
                          close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (timeout)"));
                      }, 35000);

    var head = _document.getElementsByTagName('head')[0];
    head.insertBefore(script, head.firstChild);
    if (script2) {
        head.insertBefore(script2, head.firstChild);
    }
    return close_script;
};
//         [*] End of lib/trans-jsonp-receiver.js


//         [*] Including lib/trans-jsonp-polling.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// The simplest and most robust transport, using the well-know cross
// domain hack - JSONP. This transport is quite inefficient - one
// mssage could use up to one http request. But at least it works almost
// everywhere.
// Known limitations:
//   o you will get a spinning cursor
//   o for Konqueror a dumb timer is needed to detect errors


var JsonPTransport = SockJS['jsonp-polling'] = function(ri, trans_url) {
    utils.polluteGlobalNamespace();
    var that = this;
    that.ri = ri;
    that.trans_url = trans_url;
    that.send_constructor(jsonPGenericSender);
    that._schedule_recv();
};

// Inheritnace
JsonPTransport.prototype = new BufferedSender();

JsonPTransport.prototype._schedule_recv = function() {
    var that = this;
    var callback = function(data) {
        that._recv_stop = null;
        if (data) {
            // no data - heartbeat;
            if (!that._is_closing) {
                that.ri._didMessage(data);
            }
        }
        // The message can be a close message, and change is_closing state.
        if (!that._is_closing) {
            that._schedule_recv();
        }
    };
    that._recv_stop = jsonPReceiverWrapper(that.trans_url + '/jsonp',
                                           jsonPGenericReceiver, callback);
};

JsonPTransport.enabled = function() {
    return true;
};

JsonPTransport.need_body = true;


JsonPTransport.prototype.doCleanup = function() {
    var that = this;
    that._is_closing = true;
    if (that._recv_stop) {
        that._recv_stop();
    }
    that.ri = that._recv_stop = null;
    that.send_destructor();
};


// Abstract away code that handles global namespace pollution.
var jsonPReceiverWrapper = function(url, constructReceiver, user_callback) {
    var id = 'a' + utils.random_string(6);
    var url_id = url + '?c=' + escape(WPrefix + '.' + id);
    // Callback will be called exactly once.
    var callback = function(frame) {
        delete _window[WPrefix][id];
        user_callback(frame);
    };

    var close_script = constructReceiver(url_id, callback);
    _window[WPrefix][id] = close_script;
    var stop = function() {
        if (_window[WPrefix][id]) {
            _window[WPrefix][id](utils.closeFrame(1000, "JSONP user aborted read"));
        }
    };
    return stop;
};
//         [*] End of lib/trans-jsonp-polling.js


//         [*] Including lib/trans-xhr.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var AjaxBasedTransport = function() {};
AjaxBasedTransport.prototype = new BufferedSender();

AjaxBasedTransport.prototype.run = function(ri, trans_url,
                                            url_suffix, Receiver, AjaxObject) {
    var that = this;
    that.ri = ri;
    that.trans_url = trans_url;
    that.send_constructor(createAjaxSender(AjaxObject));
    that.poll = new Polling(ri, Receiver,
                            trans_url + url_suffix, AjaxObject);
};

AjaxBasedTransport.prototype.doCleanup = function() {
    var that = this;
    if (that.poll) {
        that.poll.abort();
        that.poll = null;
    }
};

// xhr-streaming
var XhrStreamingTransport = SockJS['xhr-streaming'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XHRCorsObject);
};

XhrStreamingTransport.prototype = new AjaxBasedTransport();

XhrStreamingTransport.enabled = function() {
    // Support for CORS Ajax aka Ajax2? Opera 12 claims CORS but
    // doesn't do streaming.
    return (_window.XMLHttpRequest &&
            'withCredentials' in new XMLHttpRequest() &&
            (!/opera/i.test(navigator.userAgent)));
};
XhrStreamingTransport.roundTrips = 2; // preflight, ajax

// Safari gets confused when a streaming ajax request is started
// before onload. This causes the load indicator to spin indefinetely.
XhrStreamingTransport.need_body = true;


// According to:
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/


// xdr-streaming
var XdrStreamingTransport = SockJS['xdr-streaming'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XDRObject);
};

XdrStreamingTransport.prototype = new AjaxBasedTransport();

XdrStreamingTransport.enabled = function() {
    return !!_window.XDomainRequest;
};
XdrStreamingTransport.roundTrips = 2; // preflight, ajax



// xhr-polling
var XhrPollingTransport = SockJS['xhr-polling'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRCorsObject);
};

XhrPollingTransport.prototype = new AjaxBasedTransport();

XhrPollingTransport.enabled = XhrStreamingTransport.enabled;
XhrPollingTransport.roundTrips = 2; // preflight, ajax


// xdr-polling
var XdrPollingTransport = SockJS['xdr-polling'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XDRObject);
};

XdrPollingTransport.prototype = new AjaxBasedTransport();

XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
XdrPollingTransport.roundTrips = 2; // preflight, ajax
//         [*] End of lib/trans-xhr.js


//         [*] Including lib/trans-iframe.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// Few cool transports do work only for same-origin. In order to make
// them working cross-domain we shall use iframe, served form the
// remote domain. New browsers, have capabilities to communicate with
// cross domain iframe, using postMessage(). In IE it was implemented
// from IE 8+, but of course, IE got some details wrong:
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
//    http://stevesouders.com/misc/test-postmessage.php

var IframeTransport = function() {};

IframeTransport.prototype.i_constructor = function(ri, trans_url, base_url) {
    var that = this;
    that.ri = ri;
    that.origin = utils.getOrigin(base_url);
    that.base_url = base_url;
    that.trans_url = trans_url;

    var iframe_url = base_url + '/iframe.html';
    if (that.ri._options.devel) {
        iframe_url += '?t=' + (+new Date);
    }
    that.window_id = utils.random_string(8);
    iframe_url += '#' + that.window_id;

    that.iframeObj = utils.createIframe(iframe_url, function(r) {
                                            that.ri._didClose(1006, "Unable to load an iframe (" + r + ")");
                                        });

    that.onmessage_cb = utils.bind(that.onmessage, that);
    utils.attachMessage(that.onmessage_cb);
};

IframeTransport.prototype.doCleanup = function() {
    var that = this;
    if (that.iframeObj) {
        utils.detachMessage(that.onmessage_cb);
        try {
            // When the iframe is not loaded, IE raises an exception
            // on 'contentWindow'.
            if (that.iframeObj.iframe.contentWindow) {
                that.postMessage('c');
            }
        } catch (x) {}
        that.iframeObj.cleanup();
        that.iframeObj = null;
        that.onmessage_cb = that.iframeObj = null;
    }
};

IframeTransport.prototype.onmessage = function(e) {
    var that = this;
    if (e.origin !== that.origin) return;
    var window_id = e.data.slice(0, 8);
    var type = e.data.slice(8, 9);
    var data = e.data.slice(9);

    if (window_id !== that.window_id) return;

    switch(type) {
    case 's':
        that.iframeObj.loaded();
        that.postMessage('s', JSON.stringify([SockJS.version, that.protocol, that.trans_url, that.base_url]));
        break;
    case 't':
        that.ri._didMessage(data);
        break;
    }
};

IframeTransport.prototype.postMessage = function(type, data) {
    var that = this;
    that.iframeObj.post(that.window_id + type + (data || ''), that.origin);
};

IframeTransport.prototype.doSend = function (message) {
    this.postMessage('m', message);
};

IframeTransport.enabled = function() {
    // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
    // huge delay, or not at all.
    var konqueror = navigator && navigator.userAgent && navigator.userAgent.indexOf('Konqueror') !== -1;
    return ((typeof _window.postMessage === 'function' ||
            typeof _window.postMessage === 'object') && (!konqueror));
};
//         [*] End of lib/trans-iframe.js


//         [*] Including lib/trans-iframe-within.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var curr_window_id;

var postMessage = function (type, data) {
    if(parent !== _window) {
        parent.postMessage(curr_window_id + type + (data || ''), '*');
    } else {
        utils.log("Can't postMessage, no parent window.", type, data);
    }
};

var FacadeJS = function() {};
FacadeJS.prototype._didClose = function (code, reason) {
    postMessage('t', utils.closeFrame(code, reason));
};
FacadeJS.prototype._didMessage = function (frame) {
    postMessage('t', frame);
};
FacadeJS.prototype._doSend = function (data) {
    this._transport.doSend(data);
};
FacadeJS.prototype._doCleanup = function () {
    this._transport.doCleanup();
};

utils.parent_origin = undefined;

SockJS.bootstrap_iframe = function() {
    var facade;
    curr_window_id = _document.location.hash.slice(1);
    var onMessage = function(e) {
        if(e.source !== parent) return;
        if(typeof utils.parent_origin === 'undefined')
            utils.parent_origin = e.origin;
        if (e.origin !== utils.parent_origin) return;

        var window_id = e.data.slice(0, 8);
        var type = e.data.slice(8, 9);
        var data = e.data.slice(9);
        if (window_id !== curr_window_id) return;
        switch(type) {
        case 's':
            var p = JSON.parse(data);
            var version = p[0];
            var protocol = p[1];
            var trans_url = p[2];
            var base_url = p[3];
            if (version !== SockJS.version) {
                utils.log("Incompatibile SockJS! Main site uses:" +
                          " \"" + version + "\", the iframe:" +
                          " \"" + SockJS.version + "\".");
            }
            if (!utils.flatUrl(trans_url) || !utils.flatUrl(base_url)) {
                utils.log("Only basic urls are supported in SockJS");
                return;
            }

            if (!utils.isSameOriginUrl(trans_url) ||
                !utils.isSameOriginUrl(base_url)) {
                utils.log("Can't connect to different domain from within an " +
                          "iframe. (" + JSON.stringify([_window.location.href, trans_url, base_url]) +
                          ")");
                return;
            }
            facade = new FacadeJS();
            facade._transport = new FacadeJS[protocol](facade, trans_url, base_url);
            break;
        case 'm':
            facade._doSend(data);
            break;
        case 'c':
            if (facade)
                facade._doCleanup();
            facade = null;
            break;
        }
    };

    // alert('test ticker');
    // facade = new FacadeJS();
    // facade._transport = new FacadeJS['w-iframe-xhr-polling'](facade, 'http://host.com:9999/ticker/12/basd');

    utils.attachMessage(onMessage);

    // Start
    postMessage('s');
};
//         [*] End of lib/trans-iframe-within.js


//         [*] Including lib/info.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var InfoReceiver = function(base_url, AjaxObject) {
    var that = this;
    utils.delay(function(){that.doXhr(base_url, AjaxObject);});
};

InfoReceiver.prototype = new EventEmitter(['finish']);

InfoReceiver.prototype.doXhr = function(base_url, AjaxObject) {
    var that = this;
    var t0 = (new Date()).getTime();
    var xo = new AjaxObject('GET', base_url + '/info');

    var tref = utils.delay(8000,
                           function(){xo.ontimeout();});

    xo.onfinish = function(status, text) {
        clearTimeout(tref);
        tref = null;
        if (status === 200) {
            var rtt = (new Date()).getTime() - t0;
            var info = JSON.parse(text);
            if (typeof info !== 'object') info = {};
            that.emit('finish', info, rtt);
        } else {
            that.emit('finish');
        }
    };
    xo.ontimeout = function() {
        xo.close();
        that.emit('finish');
    };
};

var InfoReceiverIframe = function(base_url) {
    var that = this;
    var go = function() {
        var ifr = new IframeTransport();
        ifr.protocol = 'w-iframe-info-receiver';
        var fun = function(r) {
            if (typeof r === 'string' && r.substr(0,1) === 'm') {
                var d = JSON.parse(r.substr(1));
                var info = d[0], rtt = d[1];
                that.emit('finish', info, rtt);
            } else {
                that.emit('finish');
            }
            ifr.doCleanup();
            ifr = null;
        };
        var mock_ri = {
            _options: {},
            _didClose: fun,
            _didMessage: fun
        };
        ifr.i_constructor(mock_ri, base_url, base_url);
    }
    if(!_document.body) {
        utils.attachEvent('load', go);
    } else {
        go();
    }
};
InfoReceiverIframe.prototype = new EventEmitter(['finish']);


var InfoReceiverFake = function() {
    // It may not be possible to do cross domain AJAX to get the info
    // data, for example for IE7. But we want to run JSONP, so let's
    // fake the response, with rtt=2s (rto=6s).
    var that = this;
    utils.delay(function() {
        that.emit('finish', {}, 2000);
    });
};
InfoReceiverFake.prototype = new EventEmitter(['finish']);

var createInfoReceiver = function(base_url) {
    if (utils.isSameOriginUrl(base_url)) {
        // If, for some reason, we have SockJS locally - there's no
        // need to start up the complex machinery. Just use ajax.
        return new InfoReceiver(base_url, utils.XHRLocalObject);
    }
    switch (utils.isXHRCorsCapable()) {
    case 1:
        return new InfoReceiver(base_url, utils.XHRCorsObject);
    case 2:
        return new InfoReceiver(base_url, utils.XDRObject);
    case 3:
        // Opera
        return new InfoReceiverIframe(base_url);
    default:
        // IE 7
        return new InfoReceiverFake();
    };
};


var WInfoReceiverIframe = FacadeJS['w-iframe-info-receiver'] = function(ri, _trans_url, base_url) {
    var ir = new InfoReceiver(base_url, utils.XHRLocalObject);
    ir.onfinish = function(info, rtt) {
        ri._didMessage('m'+JSON.stringify([info, rtt]));
        ri._didClose();
    }
};
WInfoReceiverIframe.prototype.doCleanup = function() {};
//         [*] End of lib/info.js


//         [*] Including lib/trans-iframe-eventsource.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var EventSourceIframeTransport = SockJS['iframe-eventsource'] = function () {
    var that = this;
    that.protocol = 'w-iframe-eventsource';
    that.i_constructor.apply(that, arguments);
};

EventSourceIframeTransport.prototype = new IframeTransport();

EventSourceIframeTransport.enabled = function () {
    return ('EventSource' in _window) && IframeTransport.enabled();
};

EventSourceIframeTransport.need_body = true;
EventSourceIframeTransport.roundTrips = 3; // html, javascript, eventsource


// w-iframe-eventsource
var EventSourceTransport = FacadeJS['w-iframe-eventsource'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/eventsource', EventSourceReceiver, utils.XHRLocalObject);
}
EventSourceTransport.prototype = new AjaxBasedTransport();
//         [*] End of lib/trans-iframe-eventsource.js


//         [*] Including lib/trans-iframe-xhr-polling.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var XhrPollingIframeTransport = SockJS['iframe-xhr-polling'] = function () {
    var that = this;
    that.protocol = 'w-iframe-xhr-polling';
    that.i_constructor.apply(that, arguments);
};

XhrPollingIframeTransport.prototype = new IframeTransport();

XhrPollingIframeTransport.enabled = function () {
    return _window.XMLHttpRequest && IframeTransport.enabled();
};

XhrPollingIframeTransport.need_body = true;
XhrPollingIframeTransport.roundTrips = 3; // html, javascript, xhr


// w-iframe-xhr-polling
var XhrPollingITransport = FacadeJS['w-iframe-xhr-polling'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRLocalObject);
};

XhrPollingITransport.prototype = new AjaxBasedTransport();
//         [*] End of lib/trans-iframe-xhr-polling.js


//         [*] Including lib/trans-iframe-htmlfile.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// This transport generally works in any browser, but will cause a
// spinning cursor to appear in any browser other than IE.
// We may test this transport in all browsers - why not, but in
// production it should be only run in IE.

var HtmlFileIframeTransport = SockJS['iframe-htmlfile'] = function () {
    var that = this;
    that.protocol = 'w-iframe-htmlfile';
    that.i_constructor.apply(that, arguments);
};

// Inheritance.
HtmlFileIframeTransport.prototype = new IframeTransport();

HtmlFileIframeTransport.enabled = function() {
    return IframeTransport.enabled();
};

HtmlFileIframeTransport.need_body = true;
HtmlFileIframeTransport.roundTrips = 3; // html, javascript, htmlfile


// w-iframe-htmlfile
var HtmlFileTransport = FacadeJS['w-iframe-htmlfile'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/htmlfile', HtmlfileReceiver, utils.XHRLocalObject);
};
HtmlFileTransport.prototype = new AjaxBasedTransport();
//         [*] End of lib/trans-iframe-htmlfile.js


//         [*] Including lib/trans-polling.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var Polling = function(ri, Receiver, recv_url, AjaxObject) {
    var that = this;
    that.ri = ri;
    that.Receiver = Receiver;
    that.recv_url = recv_url;
    that.AjaxObject = AjaxObject;
    that._scheduleRecv();
};

Polling.prototype._scheduleRecv = function() {
    var that = this;
    var poll = that.poll = new that.Receiver(that.recv_url, that.AjaxObject);
    var msg_counter = 0;
    poll.onmessage = function(e) {
        msg_counter += 1;
        that.ri._didMessage(e.data);
    };
    poll.onclose = function(e) {
        that.poll = poll = poll.onmessage = poll.onclose = null;
        if (!that.poll_is_closing) {
            if (e.reason === 'permanent') {
                that.ri._didClose(1006, 'Polling error (' + e.reason + ')');
            } else {
                that._scheduleRecv();
            }
        }
    };
};

Polling.prototype.abort = function() {
    var that = this;
    that.poll_is_closing = true;
    if (that.poll) {
        that.poll.abort();
    }
};
//         [*] End of lib/trans-polling.js


//         [*] Including lib/trans-receiver-eventsource.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var EventSourceReceiver = function(url) {
    var that = this;
    var es = new EventSource(url);
    es.onmessage = function(e) {
        that.dispatchEvent(new SimpleEvent('message',
                                           {'data': unescape(e.data)}));
    };
    that.es_close = es.onerror = function(e, abort_reason) {
        // ES on reconnection has readyState = 0 or 1.
        // on network error it's CLOSED = 2
        var reason = abort_reason ? 'user' :
            (es.readyState !== 2 ? 'network' : 'permanent');
        that.es_close = es.onmessage = es.onerror = null;
        // EventSource reconnects automatically.
        es.close();
        es = null;
        // Safari and chrome < 15 crash if we close window before
        // waiting for ES cleanup. See:
        //   https://code.google.com/p/chromium/issues/detail?id=89155
        utils.delay(200, function() {
                        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));
                    });
    };
};

EventSourceReceiver.prototype = new REventTarget();

EventSourceReceiver.prototype.abort = function() {
    var that = this;
    if (that.es_close) {
        that.es_close({}, true);
    }
};
//         [*] End of lib/trans-receiver-eventsource.js


//         [*] Including lib/trans-receiver-htmlfile.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var _is_ie_htmlfile_capable;
var isIeHtmlfileCapable = function() {
    if (_is_ie_htmlfile_capable === undefined) {
        if ('ActiveXObject' in _window) {
            try {
                _is_ie_htmlfile_capable = !!new ActiveXObject('htmlfile');
            } catch (x) {}
        } else {
            _is_ie_htmlfile_capable = false;
        }
    }
    return _is_ie_htmlfile_capable;
};


var HtmlfileReceiver = function(url) {
    var that = this;
    utils.polluteGlobalNamespace();

    that.id = 'a' + utils.random_string(6, 26);
    url += ((url.indexOf('?') === -1) ? '?' : '&') +
        'c=' + escape(WPrefix + '.' + that.id);

    var constructor = isIeHtmlfileCapable() ?
        utils.createHtmlfile : utils.createIframe;

    var iframeObj;
    _window[WPrefix][that.id] = {
        start: function () {
            iframeObj.loaded();
        },
        message: function (data) {
            that.dispatchEvent(new SimpleEvent('message', {'data': data}));
        },
        stop: function () {
            that.iframe_close({}, 'network');
        }
    };
    that.iframe_close = function(e, abort_reason) {
        iframeObj.cleanup();
        that.iframe_close = iframeObj = null;
        delete _window[WPrefix][that.id];
        that.dispatchEvent(new SimpleEvent('close', {reason: abort_reason}));
    };
    iframeObj = constructor(url, function(e) {
                                that.iframe_close({}, 'permanent');
                            });
};

HtmlfileReceiver.prototype = new REventTarget();

HtmlfileReceiver.prototype.abort = function() {
    var that = this;
    if (that.iframe_close) {
        that.iframe_close({}, 'user');
    }
};
//         [*] End of lib/trans-receiver-htmlfile.js


//         [*] Including lib/trans-receiver-xhr.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var XhrReceiver = function(url, AjaxObject) {
    var that = this;
    var buf_pos = 0;

    that.xo = new AjaxObject('POST', url, null);
    that.xo.onchunk = function(status, text) {
        if (status !== 200) return;
        while (1) {
            var buf = text.slice(buf_pos);
            var p = buf.indexOf('\n');
            if (p === -1) break;
            buf_pos += p+1;
            var msg = buf.slice(0, p);
            that.dispatchEvent(new SimpleEvent('message', {data: msg}));
        }
    };
    that.xo.onfinish = function(status, text) {
        that.xo.onchunk(status, text);
        that.xo = null;
        var reason = status === 200 ? 'network' : 'permanent';
        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));
    }
};

XhrReceiver.prototype = new REventTarget();

XhrReceiver.prototype.abort = function() {
    var that = this;
    if (that.xo) {
        that.xo.close();
        that.dispatchEvent(new SimpleEvent('close', {reason: 'user'}));
        that.xo = null;
    }
};
//         [*] End of lib/trans-receiver-xhr.js


//         [*] Including lib/test-hooks.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// For testing
SockJS.getUtils = function(){
    return utils;
};

SockJS.getIframeTransport = function(){
    return IframeTransport;
};
//         [*] End of lib/test-hooks.js

                  return SockJS;
          })();
if ('_sockjs_onload' in window) setTimeout(_sockjs_onload, 1);

// AMD compliance
if (typeof define === 'function' && define.amd) {
    define('sockjs', [], function(){return SockJS;});
}

if (typeof module === 'object' && module && module.exports) {
    module.exports = SockJS;
}
//     [*] End of lib/index.js

// [*] End of lib/all.js


},{}],139:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":86,"inherits":92,"readable-stream/duplex.js":121,"readable-stream/passthrough.js":132,"readable-stream/readable.js":133,"readable-stream/transform.js":134,"readable-stream/writable.js":135}],140:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":116,"timers":140}],141:[function(require,module,exports){
var traverse = module.exports = function (obj) {
    return new Traverse(obj);
};

function Traverse (obj) {
    this.value = obj;
}

Traverse.prototype.get = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            node = undefined;
            break;
        }
        node = node[key];
    }
    return node;
};

Traverse.prototype.has = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            return false;
        }
        node = node[key];
    }
    return true;
};

Traverse.prototype.set = function (ps, value) {
    var node = this.value;
    for (var i = 0; i < ps.length - 1; i ++) {
        var key = ps[i];
        if (!hasOwnProperty.call(node, key)) node[key] = {};
        node = node[key];
    }
    node[ps[i]] = value;
    return value;
};

Traverse.prototype.map = function (cb) {
    return walk(this.value, cb, true);
};

Traverse.prototype.forEach = function (cb) {
    this.value = walk(this.value, cb, false);
    return this.value;
};

Traverse.prototype.reduce = function (cb, init) {
    var skip = arguments.length === 1;
    var acc = skip ? this.value : init;
    this.forEach(function (x) {
        if (!this.isRoot || !skip) {
            acc = cb.call(this, acc, x);
        }
    });
    return acc;
};

Traverse.prototype.paths = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.path); 
    });
    return acc;
};

Traverse.prototype.nodes = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.node);
    });
    return acc;
};

Traverse.prototype.clone = function () {
    var parents = [], nodes = [];
    
    return (function clone (src) {
        for (var i = 0; i < parents.length; i++) {
            if (parents[i] === src) {
                return nodes[i];
            }
        }
        
        if (typeof src === 'object' && src !== null) {
            var dst = copy(src);
            
            parents.push(src);
            nodes.push(dst);
            
            forEach(objectKeys(src), function (key) {
                dst[key] = clone(src[key]);
            });
            
            parents.pop();
            nodes.pop();
            return dst;
        }
        else {
            return src;
        }
    })(this.value);
};

function walk (root, cb, immutable) {
    var path = [];
    var parents = [];
    var alive = true;
    
    return (function walker (node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        
        var keepGoing = true;
        
        var state = {
            node : node,
            node_ : node_,
            path : [].concat(path),
            parent : parents[parents.length - 1],
            parents : parents,
            key : path.slice(-1)[0],
            isRoot : path.length === 0,
            level : path.length,
            circular : null,
            update : function (x, stopHere) {
                if (!state.isRoot) {
                    state.parent.node[state.key] = x;
                }
                state.node = x;
                if (stopHere) keepGoing = false;
            },
            'delete' : function (stopHere) {
                delete state.parent.node[state.key];
                if (stopHere) keepGoing = false;
            },
            remove : function (stopHere) {
                if (isArray(state.parent.node)) {
                    state.parent.node.splice(state.key, 1);
                }
                else {
                    delete state.parent.node[state.key];
                }
                if (stopHere) keepGoing = false;
            },
            keys : null,
            before : function (f) { modifiers.before = f },
            after : function (f) { modifiers.after = f },
            pre : function (f) { modifiers.pre = f },
            post : function (f) { modifiers.post = f },
            stop : function () { alive = false },
            block : function () { keepGoing = false }
        };
        
        if (!alive) return state;
        
        function updateState() {
            if (typeof state.node === 'object' && state.node !== null) {
                if (!state.keys || state.node_ !== state.node) {
                    state.keys = objectKeys(state.node)
                }
                
                state.isLeaf = state.keys.length == 0;
                
                for (var i = 0; i < parents.length; i++) {
                    if (parents[i].node_ === node_) {
                        state.circular = parents[i];
                        break;
                    }
                }
            }
            else {
                state.isLeaf = true;
                state.keys = null;
            }
            
            state.notLeaf = !state.isLeaf;
            state.notRoot = !state.isRoot;
        }
        
        updateState();
        
        // use return values to update if defined
        var ret = cb.call(state, state.node);
        if (ret !== undefined && state.update) state.update(ret);
        
        if (modifiers.before) modifiers.before.call(state, state.node);
        
        if (!keepGoing) return state;
        
        if (typeof state.node == 'object'
        && state.node !== null && !state.circular) {
            parents.push(state);
            
            updateState();
            
            forEach(state.keys, function (key, i) {
                path.push(key);
                
                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
                
                var child = walker(state.node[key]);
                if (immutable && hasOwnProperty.call(state.node, key)) {
                    state.node[key] = child.node;
                }
                
                child.isLast = i == state.keys.length - 1;
                child.isFirst = i == 0;
                
                if (modifiers.post) modifiers.post.call(state, child);
                
                path.pop();
            });
            parents.pop();
        }
        
        if (modifiers.after) modifiers.after.call(state, state.node);
        
        return state;
    })(root).node;
}

function copy (src) {
    if (typeof src === 'object' && src !== null) {
        var dst;
        
        if (isArray(src)) {
            dst = [];
        }
        else if (isDate(src)) {
            dst = new Date(src.getTime ? src.getTime() : src);
        }
        else if (isRegExp(src)) {
            dst = new RegExp(src);
        }
        else if (isError(src)) {
            dst = { message: src.message };
        }
        else if (isBoolean(src)) {
            dst = new Boolean(src);
        }
        else if (isNumber(src)) {
            dst = new Number(src);
        }
        else if (isString(src)) {
            dst = new String(src);
        }
        else if (Object.create && Object.getPrototypeOf) {
            dst = Object.create(Object.getPrototypeOf(src));
        }
        else if (src.constructor === Object) {
            dst = {};
        }
        else {
            var proto =
                (src.constructor && src.constructor.prototype)
                || src.__proto__
                || {}
            ;
            var T = function () {};
            T.prototype = proto;
            dst = new T;
        }
        
        forEach(objectKeys(src), function (key) {
            dst[key] = src[key];
        });
        return dst;
    }
    else return src;
}

var objectKeys = Object.keys || function keys (obj) {
    var res = [];
    for (var key in obj) res.push(key)
    return res;
};

function toS (obj) { return Object.prototype.toString.call(obj) }
function isDate (obj) { return toS(obj) === '[object Date]' }
function isRegExp (obj) { return toS(obj) === '[object RegExp]' }
function isError (obj) { return toS(obj) === '[object Error]' }
function isBoolean (obj) { return toS(obj) === '[object Boolean]' }
function isNumber (obj) { return toS(obj) === '[object Number]' }
function isString (obj) { return toS(obj) === '[object String]' }

var isArray = Array.isArray || function isArray (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

forEach(objectKeys(Traverse.prototype), function (key) {
    traverse[key] = function (obj) {
        var args = [].slice.call(arguments, 1);
        var t = new Traverse(obj);
        return t[key].apply(t, args);
    };
});

var hasOwnProperty = Object.hasOwnProperty || function (obj, key) {
    return key in obj;
};

},{}],142:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":143,"punycode":117,"querystring":120}],143:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],144:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],145:[function(require,module,exports){
arguments[4][62][0].apply(exports,arguments)
},{"dup":62}],146:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":145,"_process":116,"inherits":92}],147:[function(require,module,exports){
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}

},{}]},{},[21])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIvRVJST1JTLmpzIiwibGliL2NsaWVudC9qcy9DT05TVC5qcyIsImxpYi9jbGllbnQvanMvVG9hc3QuanMiLCJsaWIvY2xpZW50L2pzL2NvbnRyb2xsZXIvSk1CRlVwbG9hZGVyQ29udHJvbGxlci5qcyIsImxpYi9jbGllbnQvanMvY29udHJvbGxlci9Kc29uSW1wb3J0Q29udHJvbGxlci5qcyIsImxpYi9jbGllbnQvanMvY29udHJvbGxlci9hdXRoQ29udHJvbGxlci5qcyIsImxpYi9jbGllbnQvanMvY29udHJvbGxlci9icmVhZGNydW1iQ29udHJvbGxlci5qcyIsImxpYi9jbGllbnQvanMvY29udHJvbGxlci9jcmVhdGVOZXdQcm9qZWN0Q29udHJvbGxlci5qcyIsImxpYi9jbGllbnQvanMvY29udHJvbGxlci9tZW51UmlnaHRDb250cm9sbGVyLmpzIiwibGliL2NsaWVudC9qcy9jb250cm9sbGVyL21vdmVQcm9qZWN0Q29tcG9uZW50LmpzIiwibGliL2NsaWVudC9qcy9jb250cm9sbGVyL3BhZ2VIZWFkZXJDb250cm9sbGVyLmpzIiwibGliL2NsaWVudC9qcy9jb250cm9sbGVyL3Byb2plY3RNYWluTmF2aWdhdGlvbkNvbnRyb2xsZXIuanMiLCJsaWIvY2xpZW50L2pzL2NvbnRyb2xsZXIvcHJvamVjdE92ZXJ2aWV3Q29udHJvbGxlci5qcyIsImxpYi9jbGllbnQvanMvY29udHJvbGxlci9zZWFyY2hDb250cm9sbGVyLmpzIiwibGliL2NsaWVudC9qcy9jb250cm9sbGVyL3RleHRFZGl0b3JDb250cm9sbGVyLmpzIiwibGliL2NsaWVudC9qcy9jb250cm9sbGVyL3RyYW5zbGF0aW9uVmlld0NvbnRyb2xsZXIuanMiLCJsaWIvY2xpZW50L2pzL2NvbnRyb2xsZXIvdXBsb2FkQ29udHJvbGxlci5qcyIsImxpYi9jbGllbnQvanMvY29udHJvbGxlci91cmxNYW5pcHVsYXRvci5qcyIsImxpYi9jbGllbnQvanMvZXZlbnRzLmpzIiwibGliL2NsaWVudC9qcy9oYW5kbGVTZXNzaW9uVGltZU91dC5qcyIsImxpYi9jbGllbnQvanMvbWFpbi5qcyIsImxpYi9jbGllbnQvanMvdGV4dEVkaXRvci5qcyIsImxpYi9jbGllbnQvanMvdHJhZGUuanMiLCJsaWIvY2xpZW50L2pzL3VpRXZlbnRNYW5hZ2VyLmpzIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvSk1CRlVwbG9hZGVyLmpzIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvSnNvbkltcG9ydC5qcyIsImxpYi9jbGllbnQvanMvdWlNb2R1bGVzL2FuY2hvck1lbnUuanMiLCJsaWIvY2xpZW50L2pzL3VpTW9kdWxlcy9hdXRoLmpzIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvYnJlYWRjcnVtYi5qcyIsImxpYi9jbGllbnQvanMvdWlNb2R1bGVzL2Nvbm5lY3Rpb25Mb3N0L2luZGV4Lmh0bWwiLCJsaWIvY2xpZW50L2pzL3VpTW9kdWxlcy9jb25uZWN0aW9uTG9zdC9pbmRleC5qcyIsImxpYi9jbGllbnQvanMvdWlNb2R1bGVzL2NyZWF0ZU5ld1Byb2plY3QuanMiLCJsaWIvY2xpZW50L2pzL3VpTW9kdWxlcy9kaXNwbGF5TWFuYWdlci5qcyIsImxpYi9jbGllbnQvanMvdWlNb2R1bGVzL2ZsYWcuanMiLCJsaWIvY2xpZW50L2pzL3VpTW9kdWxlcy9pbWFnZVZpZXdlci5qcyIsImxpYi9jbGllbnQvanMvdWlNb2R1bGVzL2lucHV0RWRpdE1hbmFnZXIuanMiLCJsaWIvY2xpZW50L2pzL3VpTW9kdWxlcy9sb2FkaW5nTW9kYWwvaW5kZXguanMiLCJsaWIvY2xpZW50L2pzL3VpTW9kdWxlcy9tZW51UmlnaHQuanMiLCJsaWIvY2xpZW50L2pzL3VpTW9kdWxlcy9vdmVybGF5LmpzIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvcHJvamVjdE1haW5OYXZpZ2F0aW9uLmpzIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvcHJvamVjdE92ZXJ2aWV3LmpzIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvc2VhcmNoQmFyL2luZGV4LmpzIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvc2VhcmNoUmVzdWx0cy9GaWx0ZXJzLmh0bWwiLCJsaWIvY2xpZW50L2pzL3VpTW9kdWxlcy9zZWFyY2hSZXN1bHRzL0hlYWRsaW5lLmh0bWwiLCJsaWIvY2xpZW50L2pzL3VpTW9kdWxlcy9zZWFyY2hSZXN1bHRzL0tleUl0ZW0uaHRtbCIsImxpYi9jbGllbnQvanMvdWlNb2R1bGVzL3NlYXJjaFJlc3VsdHMvTGFuZ0J1dHRvbi5odG1sIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvc2VhcmNoUmVzdWx0cy9Ob01hdGNoZXMuaHRtbCIsImxpYi9jbGllbnQvanMvdWlNb2R1bGVzL3NlYXJjaFJlc3VsdHMvUGFnZUJ1dHRvbi5odG1sIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvc2VhcmNoUmVzdWx0cy9Qcm9qZWN0SXRlbS5odG1sIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvc2VhcmNoUmVzdWx0cy9pbmRleC5odG1sIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvc2VhcmNoUmVzdWx0cy9pbmRleC5qcyIsImxpYi9jbGllbnQvanMvdWlNb2R1bGVzL3RleHRzLmpzIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvdHJhbnNsYXRpb25WaWV3LmpzIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvdHJhbnNsYXRpb25WaWV3RGVzY3JpcHRpb24uanMiLCJsaWIvY2xpZW50L2pzL3VpTW9kdWxlcy90cmFuc2xhdGlvblZpZXdJbWFnZVVwbG9hZC5qcyIsImxpYi9jbGllbnQvanMvdWlNb2R1bGVzL3VwbG9hZC5qcyIsImxpYi9jbGllbnQvanMvdW5pY29kZS5qcyIsImxpYi9jbGllbnQvanMvdXRpbC91cmwuanMiLCJsaWIvY2xpZW50L2pzL3V0aWwvd29yZENvdW50ZXIuanMiLCJub2RlX21vZHVsZXMvYXNzZXJ0L2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9hc3NlcnQvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYXNzZXJ0L25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Fzc2VydC9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2JhbGFuY2VkLW1hdGNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icmFjZS1leHBhbnNpb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ueS1jb29raWVNYW5hZ2VyLWxpYi9jb29raWVNYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2Nhbm55L2Nhbm55LmpzIiwibm9kZV9tb2R1bGVzL2Nhbm55L21vZC9hc3luYy5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ueS9tb2QvZmxvd0NvbnRyb2wuanMiLCJub2RlX21vZHVsZXMvY2FubnkvbW9kL3JlcGVhdC5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ueS9tb2Qvd2hpc2tlci5qcyIsIm5vZGVfbW9kdWxlcy9jb25jYXQtbWFwL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9kbm9kZS1wcm90b2NvbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kbm9kZS1wcm90b2NvbC9saWIvZm9yZWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9kbm9kZS1wcm90b2NvbC9saWIvaXNfZW51bS5qcyIsIm5vZGVfbW9kdWxlcy9kbm9kZS1wcm90b2NvbC9saWIva2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9kbm9kZS1wcm90b2NvbC9saWIvc2NydWIuanMiLCJub2RlX21vZHVsZXMvZG5vZGUtd2Vhay1uYXBpL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZG5vZGUtd2Vhay1uYXBpL2xpYi9kbm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9kb20tb3B0cy9kb21PcHRzLmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvZXhpdC9saWIvZXhpdC5qcyIsIm5vZGVfbW9kdWxlcy9mcy5yZWFscGF0aC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mcy5yZWFscGF0aC9vbGQuanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmZsaWdodC9pbmZsaWdodC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvamFzbWluZS1jb3JlL2xpYi9jb25zb2xlL2NvbnNvbGUuanMiLCJub2RlX21vZHVsZXMvamFzbWluZS1jb3JlL2xpYi9qYXNtaW5lLWNvcmUuanMiLCJub2RlX21vZHVsZXMvamFzbWluZS1jb3JlL2xpYi9qYXNtaW5lLWNvcmUvamFzbWluZS5qcyIsIm5vZGVfbW9kdWxlcy9qYXNtaW5lLWNvcmUvbGliL2phc21pbmUtY29yZS9ub2RlX2Jvb3QuanMiLCJub2RlX21vZHVsZXMvamFzbWluZS9saWIvZXhpdC5qcyIsIm5vZGVfbW9kdWxlcy9qYXNtaW5lL2xpYi9maWx0ZXJzL2NvbnNvbGVfc3BlY19maWx0ZXIuanMiLCJub2RlX21vZHVsZXMvamFzbWluZS9saWIvamFzbWluZS5qcyIsIm5vZGVfbW9kdWxlcy9qYXNtaW5lL2xpYi9wcmludERlcHJlY2F0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2phc21pbmUvbGliL3JlcG9ydGVycy9jb21wbGV0aW9uX3JlcG9ydGVyLmpzIiwibm9kZV9tb2R1bGVzL2phc21pbmUvbGliL3JlcG9ydGVycy9jb25zb2xlX3JlcG9ydGVyLmpzIiwibm9kZV9tb2R1bGVzL2phc21pbmUvbm9kZV9tb2R1bGVzL2dsb2IvY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL2phc21pbmUvbm9kZV9tb2R1bGVzL2dsb2IvZ2xvYi5qcyIsIm5vZGVfbW9kdWxlcy9qYXNtaW5lL25vZGVfbW9kdWxlcy9nbG9iL3N5bmMuanMiLCJub2RlX21vZHVsZXMvanNvbmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc29uaWZ5L2xpYi9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9qc29uaWZ5L2xpYi9zdHJpbmdpZnkuanMiLCJub2RlX21vZHVsZXMvbWluaW1hdGNoL21pbmltYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29uY2Uvb25jZS5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGF0aC1pcy1hYnNvbHV0ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2hvZS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3Nob2Uvbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvc29ja2pzLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJub2RlX21vZHVsZXMvdHJhdmVyc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIm5vZGVfbW9kdWxlcy91cmwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy93cmFwcHkvd3JhcHB5LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUNBQTs7Ozs7QUFLQSxPQUFPLE9BQVAsR0FBaUI7QUFDYixzQkFBcUIsb0JBRFI7QUFFYixjQUFZLFlBRkM7QUFHYixpQkFBZTtBQUhGLENBQWpCOzs7OztBQ0xBLElBQUksSUFBSTtBQUNKLGtCQUFlO0FBQ1gsb0JBQWE7QUFDVCxtQkFBUSxPQURDO0FBRVQsa0JBQVE7QUFGQyxTQURGO0FBS1gsa0JBQVc7QUFDUCxtQkFBUSxRQUREO0FBRVAsa0JBQU87QUFGQTtBQUxBLEtBRFg7QUFXSixhQUFVO0FBQ04sZ0NBQXdCLE9BQU87QUFEekI7QUFYTixDQUFSOztBQWdCQSxPQUFPLE9BQVAsR0FBaUIsQ0FBakI7Ozs7O0FDaEJBOzs7Ozs7QUFNQSxJQUFJLFFBQVEsSUFBSyxTQUFTLEtBQVQsQ0FBZSxFQUFmLEVBQWtCO0FBQy9CLFFBQUksUUFBUSxJQUFaO0FBQUEsUUFDQSxtQkFBbUIsSUFEbkI7QUFBQSxRQUVBLHNCQUFzQixDQUZ0QjtBQUFBLFFBR0EsWUFBWSxTQUFTLGNBQVQsQ0FBd0IsRUFBeEIsQ0FIWjtBQUFBLFFBSUEsdUJBQXVCLElBSnZCO0FBQUEsUUFLQSxhQUFhLElBTGI7QUFBQSxRQU1BLFlBQVksU0FBWixTQUFZLEdBQVU7QUFDbEIsWUFBSSxXQUFXLFNBQVMsb0JBQVQsQ0FBOEIsTUFBOUIsRUFBc0MsQ0FBdEMsQ0FBZjtBQUNBLG9CQUFZLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUFaO0FBQ0Esa0JBQVUsRUFBVixHQUFlLEVBQWY7QUFDQSxrQkFBVSxLQUFWLENBQWdCLE9BQWhCLEdBQTBCLGtSQUExQjtBQUNBLGlCQUFTLFdBQVQsQ0FBcUIsU0FBckI7QUFDSCxLQVpEO0FBQUEsUUFhQSxRQUFRO0FBQ0osaUJBQVUsaUJBQVMsS0FBVCxFQUFlLEtBQWYsRUFBc0I7QUFDNUIsZ0JBQUksT0FBTyxLQUFYO0FBQ0EsZ0JBQUksT0FBTyxLQUFYO0FBQ0EsZ0JBQUksVUFBVSxDQUFkO0FBQ0EsYUFBQyxTQUFTLGdCQUFULEdBQTJCO0FBQ3hCLG9CQUFJLFVBQVUsZ0JBQWQsRUFBZ0M7QUFDNUIsOEJBQVUsVUFBVSxnQkFBcEI7QUFDQSx5QkFBSyxLQUFMLENBQVcsT0FBWCxHQUFxQixPQUFyQjtBQUNBLCtCQUFXLFlBQVU7QUFDakI7QUFDSCxxQkFGRCxFQUVFLEVBRkY7QUFHSCxpQkFORCxNQU1PO0FBQ0gsNEJBQVEsR0FBUixDQUFZLGNBQVo7QUFDQSw0QkFBUSxHQUFSLENBQVksSUFBWjtBQUNBLDRCQUFRLEdBQVIsQ0FBWSxLQUFLLFVBQWpCO0FBQ0Esd0JBQUcsS0FBSyxVQUFMLElBQW1CLElBQXRCLEVBQTJCO0FBQ3ZCLDZCQUFLLFVBQUwsQ0FBZ0IsV0FBaEIsQ0FBNEIsSUFBNUI7QUFDSDtBQUNEO0FBQ0g7QUFDSixhQWhCRDtBQWlCSCxTQXRCRztBQXVCSixxQkFBYyxxQkFBUyxHQUFULEVBQWM7QUFDeEIsZ0JBQUcsQ0FBQyxTQUFKLEVBQWM7QUFDVjtBQUNIO0FBQ0Qsc0JBQVUsS0FBVixDQUFnQixPQUFoQixHQUEwQixDQUExQjtBQUNBLGdCQUFJLElBQUksU0FBUyxhQUFULENBQXVCLEdBQXZCLENBQVI7QUFDQSxjQUFFLEtBQUYsQ0FBUSxPQUFSLEdBQWtCLGtCQUFsQjtBQUNBLGNBQUUsU0FBRixHQUFjLEdBQWQ7QUFDQSxzQkFBVSxZQUFWLENBQXVCLENBQXZCLEVBQTBCLFVBQVUsVUFBcEM7QUFDQyxzQkFBUyxxQkFBVCxHQUFpQztBQUM5QixvQkFBSSxVQUFVLFVBQVYsQ0FBcUIsTUFBckIsR0FBOEIsbUJBQWxDLEVBQXVEO0FBQ25ELDBCQUFNLE9BQU4sQ0FBYyxVQUFVLFFBQVYsQ0FBbUIsVUFBVSxRQUFWLENBQW1CLE1BQW5CLEdBQTBCLENBQTdDLENBQWQsRUFBK0QsWUFBVztBQUN0RTtBQUNILHFCQUZEO0FBR0g7QUFDSixhQU5BLEdBQUQ7QUFPQSxnQkFBSSxVQUFVLEtBQWQ7QUFDQSx5QkFBYSxJQUFiO0FBQ0EscUJBQVMsT0FBVCxDQUFpQixHQUFqQixFQUFxQjtBQUNqQixvQkFBSSxLQUFLLEdBQVQ7QUFDQSxvQkFBSSxVQUFVLFVBQVUsS0FBVixDQUFnQixPQUE5QjtBQUNBLG9CQUFJLFVBQVUsZ0JBQWQsRUFBZ0M7QUFDNUIsd0JBQUcsVUFBSCxFQUFlO0FBQ1g7QUFDQSxxQ0FBYSxLQUFiO0FBQ0Esa0NBQVUsS0FBVjtBQUNBLGtDQUFVLEtBQVYsQ0FBZ0IsT0FBaEIsR0FBMEIsQ0FBMUI7QUFDSCxxQkFMRCxNQUtNO0FBQ0Ysa0NBQVUsVUFBUSxnQkFBbEI7QUFDQSxrQ0FBVSxLQUFWLENBQWdCLE9BQWhCLEdBQTBCLE9BQTFCO0FBQ0Esa0NBQVUsRUFBVjtBQUNIO0FBQ0Q7QUFDQSwrQkFBVyxZQUFVO0FBQ2pCLGdDQUFRLEVBQVI7QUFDSCxxQkFGRCxFQUVHLE9BRkg7QUFHSCxpQkFmRCxNQWVPO0FBQ0gsMkJBQVEsVUFBVSxVQUFsQixFQUErQjtBQUMzQixrQ0FBVSxXQUFWLENBQXVCLFVBQVUsVUFBakM7QUFDSDtBQUNELDhCQUFVLEtBQVYsQ0FBZ0IsT0FBaEIsR0FBMEIsQ0FBMUI7QUFDQTtBQUNBLHVCQUFHLElBQUg7QUFDSDtBQUNKO0FBQ0QsZ0JBQUcsb0JBQUgsRUFBd0I7QUFDcEIsdUNBQXVCLEtBQXZCO0FBQ0EsMEJBQVUsS0FBVjtBQUNBLHdCQUFRLFVBQVMsRUFBVCxFQUFZO0FBQ2hCLDJDQUF1QixJQUF2QjtBQUNILGlCQUZEO0FBR0g7QUFDSjtBQTNFRyxLQWJSO0FBMEZBLFdBQU8sS0FBUDtBQUNILENBNUZXLENBNEZULE9BNUZTLENBQVo7O0FBOEZBLElBQUcsT0FBTyxNQUFQLElBQWlCLFdBQXBCLEVBQWdDO0FBQzVCLFlBQVEsR0FBUixDQUFZLFNBQVo7QUFDQSxXQUFPLE9BQVAsR0FBaUIsS0FBakI7QUFDSCxDQUhELE1BR007QUFDRixZQUFRLEdBQVIsQ0FBWSx1QkFBWjtBQUNBLFdBQU8sS0FBUCxHQUFlLEtBQWY7QUFDSDs7Ozs7QUMxR0Q7Ozs7QUFJQSxJQUFJLFFBQVEsUUFBUSxPQUFSLENBQVo7QUFBQSxJQUNJLGVBQWUsTUFBTSxZQUR6QjtBQUFBLElBRUksaUJBQWlCLE1BQU0sY0FGM0I7QUFBQSxJQUdJLFdBQVcsUUFBUSxzQkFBUixDQUhmO0FBQUEsSUFJSSxRQUpKO0FBQUEsSUFLSSxXQUxKO0FBTUE7Ozs7QUFJQSxTQUFTLFFBQVQsQ0FBa0IsSUFBbEIsRUFBd0IsY0FBeEIsRUFBd0M7QUFDcEMsUUFBSSxNQUFNLCtCQUErQixZQUFZLEVBQTNDLEdBQWdELFdBQWhELEdBQThELFlBQVksSUFBcEY7QUFBQSxRQUNJLE1BQU0sSUFBSSxjQUFKLEVBRFY7QUFBQSxRQUVJLEtBQUssSUFBSSxRQUFKLEVBRlQ7O0FBSUEsUUFBSSxJQUFKLENBQVMsTUFBVCxFQUFpQixHQUFqQixFQUFzQixJQUF0QjtBQUNBLFFBQUksa0JBQUosR0FBeUIsWUFBVztBQUNoQyxZQUFJLElBQUo7QUFDQSxZQUFJLElBQUksVUFBSixJQUFrQixDQUFsQixJQUF1QixJQUFJLE1BQUosSUFBYyxHQUF6QyxFQUE4QztBQUMxQztBQUNBLG1CQUFPLEtBQUssS0FBTCxDQUFXLElBQUksWUFBZixDQUFQO0FBQ0EsOEJBQWtCLGVBQWUsSUFBZixDQUFsQixDQUgwQyxDQUdGO0FBQ3hDO0FBQ0Esb0JBQVEsR0FBUixDQUFZLElBQVo7QUFDQSxxQkFBUyxXQUFULENBQXFCLGtCQUFyQixFQUF5QyxZQUFZLEVBQXJELEVBQXlELFFBQXpELEVBQW1FLEtBQUssSUFBeEU7QUFDSCxTQVBELE1BT08sSUFBSSxJQUFJLFVBQUosSUFBa0IsQ0FBbEIsSUFBdUIsSUFBSSxNQUFKLEtBQWUsR0FBMUMsRUFBK0M7QUFDbEQsa0JBQU0sV0FBTixDQUFrQixvREFBbEI7QUFDSDtBQUNKLEtBWkQ7QUFhQSxPQUFHLE1BQUgsQ0FBVSxRQUFWLEVBQW9CLElBQXBCO0FBQ0E7QUFDQSxRQUFJLElBQUosQ0FBUyxFQUFUO0FBQ0g7O0FBRUQ7Ozs7QUFJQSxTQUFTLGdCQUFULENBQTBCLElBQTFCLEVBQWdDLE9BQWhDLEVBQXlDO0FBQ3JDLGtCQUFjLE9BQWQ7QUFDSDs7QUFFRCxTQUFTLGtCQUFULENBQTRCO0FBQ3hCLHNCQUFtQiwwQkFBVSxFQUFWLEVBQWM7QUFDN0IsdUJBQWUsSUFBZixDQUFvQixrQkFBcEI7QUFDSDtBQUh1QixDQUE1Qjs7QUFNQSxhQUFhLFFBQWIsQ0FBc0IsVUFBVSxJQUFWLEVBQWdCO0FBQ2xDO0FBQ0EsWUFBUSxHQUFSLENBQVksbUNBQVosRUFBaUQsUUFBakQsRUFBMkQsSUFBM0Q7QUFDQSxhQUFTLElBQVQ7QUFDSCxDQUpEOztBQU1BLE9BQU8sT0FBUCxHQUFpQjtBQUNiLHlCQUFzQixnQkFEVDtBQUViLG1CQUFnQjtBQUZILENBQWpCOzs7OztBQzFEQSxJQUFJLFFBQVEsUUFBUSxPQUFSLENBQVo7QUFBQSxJQUNJLGFBQWEsTUFBTSxVQUR2QjtBQUFBLElBRUksaUJBQWlCLE1BQU0sY0FGM0I7QUFBQSxJQUdJLFdBQVcsUUFBUSxzQkFBUixDQUhmO0FBQUEsSUFJSSxRQUpKO0FBQUEsSUFLSSxXQUxKOztBQU9BLFNBQVMsUUFBVCxDQUFrQixJQUFsQixFQUF3QjtBQUNwQixRQUFJLE1BQU0sMkJBQTJCLFlBQVksRUFBdkMsR0FBNEMsV0FBNUMsR0FBMEQsWUFBWSxJQUFoRjtBQUFBLFFBQ0ksTUFBTSxJQUFJLGNBQUosRUFEVjtBQUFBLFFBRUksS0FBSyxJQUFJLFFBQUosRUFGVDs7QUFJQSxRQUFJLElBQUosQ0FBUyxNQUFULEVBQWlCLEdBQWpCLEVBQXNCLElBQXRCO0FBQ0EsUUFBSSxrQkFBSixHQUF5QixZQUFXO0FBQ2hDLFlBQUksSUFBSSxVQUFKLElBQWtCLENBQXRCLEVBQXlCO0FBQ3JCLGdCQUFJLE9BQU8sS0FBSyxLQUFMLENBQVcsSUFBSSxZQUFmLENBQVg7QUFDQSxnQkFBSSxJQUFJLE1BQUosSUFBYyxHQUFsQixFQUF1QjtBQUNuQjtBQUNBLHlCQUFTLFdBQVQsQ0FBcUIsY0FBckIsRUFBcUMsWUFBWSxFQUFqRCxFQUFxRCxRQUFyRCxFQUErRCxLQUFLLElBQXBFO0FBQ0gsYUFIRCxNQUdPLElBQUksSUFBSSxNQUFKLEtBQWUsR0FBbkIsRUFBd0I7QUFDM0Isc0JBQU0sV0FBTixDQUFrQiw2Q0FBNkMsS0FBSyxHQUFwRTtBQUNIO0FBQ0o7QUFDSixLQVZEO0FBV0EsT0FBRyxNQUFILENBQVUsUUFBVixFQUFvQixJQUFwQjtBQUNBLFFBQUksSUFBSixDQUFTLEVBQVQ7QUFDSDs7QUFFRCxTQUFTLGdCQUFULENBQTBCLElBQTFCLEVBQWdDLE9BQWhDLEVBQXlDO0FBQ3JDLGtCQUFjLE9BQWQ7QUFDSDs7QUFFRCxTQUFTLGtCQUFULENBQTRCO0FBQ3hCLG9CQUFpQix3QkFBVSxFQUFWLEVBQWM7QUFDM0IsdUJBQWUsSUFBZixDQUFvQixnQkFBcEI7QUFDSDtBQUh1QixDQUE1Qjs7QUFNQSxXQUFXLFFBQVgsQ0FBb0IsVUFBVSxJQUFWLEVBQWdCO0FBQ2hDLGFBQVMsSUFBVDtBQUNILENBRkQ7O0FBSUEsT0FBTyxPQUFQLEdBQWlCO0FBQ2IseUJBQXNCLGdCQURUO0FBRWIsbUJBQWdCO0FBRkgsQ0FBakI7Ozs7O0FDMUNBLElBQUksUUFBUSxRQUFRLGlCQUFSLENBQVo7QUFBQSxJQUNJLE9BQU8sUUFBUSxPQUFSLEVBQWlCLElBRDVCOztBQUdBLEtBQUssUUFBTCxDQUFjLFlBQVk7QUFDdEIsVUFBTSxNQUFOLENBQWE7QUFDVCxjQUFPLFNBREU7QUFFVCxtQkFBWSxtQkFBVSxRQUFWLEVBQW9CO0FBQzVCLHFCQUFTLE1BQVQ7QUFDSDtBQUpRLEtBQWI7QUFNSCxDQVBEOztBQVNBLE9BQU8sT0FBUCxHQUFpQixFQUFqQjs7Ozs7QUNaQSxJQUFJLGFBQWEsUUFBUSx5QkFBUixDQUFqQjtBQUFBLElBQ0ksUUFBUSxRQUFRLE9BQVIsQ0FEWjtBQUFBLElBRUksUUFBUSxRQUFRLFVBQVIsQ0FGWjtBQUFBLElBR0ksV0FBVyxRQUFRLG1CQUFSLENBSGY7O0FBS0EsTUFBTSxHQUFOLENBQVUsWUFBVixFQUF3QixVQUF4Qjs7QUFFQSxXQUFXLE9BQVgsQ0FBbUIsVUFBVSxXQUFWLEVBQXVCO0FBQ3RDLFVBQU0sWUFBTixDQUFtQixXQUFuQixFQUFnQyxVQUFVLEdBQVYsRUFBZTtBQUMzQyxZQUFJLFFBQVEsS0FBWixFQUFvQjtBQUNoQjtBQUNBLHFCQUFTLFdBQVQsQ0FBcUIsa0JBQXJCO0FBQ0gsU0FIRCxNQUdPO0FBQ0gsb0JBQVEsR0FBUixDQUFZLDRFQUFaLEVBQTBGLFdBQTFGO0FBQ0g7QUFDSixLQVBEO0FBUUgsQ0FURDs7QUFXQSxPQUFPLE9BQVAsR0FBaUI7QUFDYixhQUFVLGlCQUFDLEdBQUQsRUFBUztBQUNmLFlBQUksT0FBTyxHQUFYO0FBQ0EsWUFBSSxRQUFRLEdBQVosRUFDSSxPQUFPLFdBQVcsYUFBWCxDQUF5QixDQUFDLEVBQUUsSUFBSSxHQUFOLEVBQVksTUFBTSxFQUFsQixFQUFELENBQXpCLENBQVA7O0FBRUosbUJBQVcsYUFBWCxDQUF5QixJQUFJLEtBQUosQ0FBVSxHQUFWLEVBQWUsR0FBZixDQUFtQixrQkFBVTtBQUM5QyxtQkFBTyxLQUFLLEtBQUssTUFBTCxHQUFjLENBQW5CLE1BQTBCLEdBQTFCLEdBQWdDLE9BQU8sR0FBUCxHQUFhLE1BQTdDLEdBQXNELE9BQU8sTUFBcEU7QUFDQSxtQkFBTztBQUNILG9CQUFJLElBREQsRUFDUSxNQUFNO0FBRGQsYUFBUDtBQUdILFNBTG9CLENBQXpCO0FBT0gsS0FiWTtBQWNiLGtCQUFjLHNCQUFVLElBQVYsRUFBZ0I7QUFDMUIsZ0JBQVEsR0FBUixDQUFZLHdDQUFaLEVBQXNELEtBQUssaUJBQTNEO0FBQ0EsbUJBQVcsYUFBWCxDQUF5QixLQUFLLGlCQUE5QjtBQUNIO0FBakJZLENBQWpCOzs7OztBQ2xCQSxJQUFJLG1CQUFtQixRQUFRLE9BQVIsRUFBaUIsZ0JBQXhDO0FBQUEsSUFDSSxpQkFBaUIsUUFBUSxPQUFSLEVBQWlCLGNBRHRDO0FBQUEsSUFFSSxRQUFRLFFBQVEsVUFBUixDQUZaOztBQUlBLElBQUksZ0JBQUo7O0FBRUEsaUJBQWlCLGtCQUFqQixDQUFvQyxVQUFTLFdBQVQsRUFBc0I7QUFDdEQsVUFBTSxnQkFBTixDQUF1QixXQUF2QixFQUFvQyxnQkFBcEM7QUFDQSxtQkFBZSxJQUFmLENBQW9CLHNCQUFwQjtBQUNILENBSEQ7O0FBS0EsaUJBQWlCLG1CQUFqQixDQUFxQyxVQUFTLGFBQVQsRUFBd0I7QUFDekQsVUFBTSxrQkFBTixDQUF5QixhQUF6QixFQUF3QyxnQkFBeEM7QUFDQSxtQkFBZSxJQUFmLENBQW9CLHdCQUFwQjtBQUNILENBSEQ7O0FBS0EsT0FBTyxPQUFQLEdBQWlCO0FBQ2I7QUFDQTtBQUNBLGtCQUFlLHNCQUFTLElBQVQsRUFBZTtBQUMxQiwyQkFBbUIsS0FBSyxnQkFBeEI7QUFDSDtBQUxZLENBQWpCOzs7OztBQ2hCQSxJQUFJLGFBQWEsUUFBUSxPQUFSLEVBQWlCLFVBQWxDO0FBQUEsSUFDSSx3QkFBd0IsUUFBUSw4QkFBUixFQUF3QyxNQURwRTtBQUFBLElBRUksV0FBVyxRQUFRLG1CQUFSLENBRmY7O0FBSUE7Ozs7Ozs7Ozs7Ozs7OztBQWVBLFdBQVcsUUFBWCxDQUFvQixVQUFVLEVBQVYsRUFBYztBQUM5QixRQUFJLE1BQU0sU0FBUyxjQUFULENBQXdCLHNCQUFzQixTQUF0QixHQUFrQyxFQUExRCxDQUFWO0FBQ0EsUUFBSSxHQUFKLEVBQVM7QUFDTCxZQUFJLFdBQVcsU0FBUyxJQUFULENBQWMscUJBQWQsRUFBZjtBQUFBLFlBQ0ksV0FBVyxJQUFJLHFCQUFKLEVBRGY7QUFBQSxZQUVJLFNBQVMsU0FBUyxHQUFULEdBQWUsU0FBUyxHQUZyQztBQUdBLGVBQU8sUUFBUCxDQUFnQixDQUFoQixFQUFtQixTQUFTLEVBQTVCO0FBQ0EsaUJBQVMsV0FBVCxDQUFxQixhQUFyQixFQUFvQyxNQUFNLEVBQTFDO0FBQ0g7QUFDSixDQVREOztBQVdBLFNBQVMsa0JBQVQsQ0FBNEI7QUFDeEIsaUJBQWMscUJBQVUsRUFBVixFQUFjO0FBQ3hCLG1CQUFXLFlBQVgsQ0FBd0IsR0FBRyxPQUFILENBQVcsR0FBWCxFQUFnQixFQUFoQixDQUF4QjtBQUNIO0FBSHVCLENBQTVCOztBQU1BLE9BQU8sT0FBUCxHQUFpQjtBQUNiLG9CQUFpQix3QkFBVSxPQUFWLEVBQW1CLE9BQW5CLEVBQTRCO0FBQ3pDLG1CQUFXLFVBQVg7QUFDSCxLQUhZO0FBSWIsb0JBQWdCLHdCQUFTLFlBQVQsRUFBdUI7QUFDbkMsbUJBQVcsVUFBWDtBQUNILEtBTlk7QUFPYixlQUFZLG1CQUFVLE1BQVYsRUFBa0IsTUFBbEIsRUFBMEI7QUFDbEMsbUJBQVcsVUFBWDtBQUNILEtBVFk7QUFVYixlQUFZLG1CQUFVLEdBQVYsRUFBZTtBQUN2QixtQkFBVyxVQUFYO0FBQ0gsS0FaWTtBQWFiLGlCQUFjLHVCQUFZO0FBQ3RCLG1CQUFXLFVBQVg7QUFDSCxLQWZZO0FBZ0JiLGlCQUFjLHFCQUFTLFNBQVQsRUFBb0IsSUFBcEIsRUFBMEI7QUFDcEMsbUJBQVcsVUFBWDtBQUNILEtBbEJZO0FBbUJiOzs7O0FBSUEsbUJBQWdCLHVCQUFVLFdBQVYsRUFBdUI7QUFDbkMsbUJBQVcsVUFBWDtBQUNILEtBekJZO0FBMEJiLHlCQUFxQiwrQkFBVztBQUM1QixtQkFBVyxVQUFYO0FBQ0g7QUE1QlksQ0FBakI7Ozs7O0FDcENBLElBQU0sVUFBVSxRQUFRLG1CQUFSLENBQWhCO0FBQ0EsSUFBTSxRQUFRLFFBQVEsT0FBUixDQUFkO0FBQ0EsSUFBTSxpQkFBaUIsTUFBTSxjQUE3QjtBQUNBLElBQU0sUUFBUSxRQUFRLFVBQVIsQ0FBZDtBQUNBLElBQU0sU0FBUyxRQUFRLGlCQUFSLENBQWY7O0FBRUEsSUFBTSxhQUFhO0FBQ2YsVUFBTyxTQURRO0FBRWYsU0FBTTtBQUVWO0FBSm1CLENBQW5CLENBS0EsSUFBSSxpQkFBSjtBQUNBO0FBQ0EsSUFBSSxnQkFBSjs7QUFFQSxTQUFTLFFBQVQsQ0FBa0IsSUFBbEIsRUFBd0I7QUFDcEIsU0FBSyxnQkFBTCxDQUFzQixVQUF0QixFQUFrQyxVQUFVLENBQVYsRUFBYTtBQUMzQyxZQUFNLE1BQU0sRUFBRSxPQUFGLElBQWEsRUFBRSxLQUEzQjtBQUNBLFlBQUksUUFBUSxFQUFaLEVBQWdCLEVBQUUsV0FBRixHQUFnQixLQUFoQjtBQUNoQixlQUFPLElBQVA7QUFDSCxLQUpEO0FBS0EsV0FBTyxJQUFQO0FBQ0g7O0FBRUQsU0FBUyxRQUFULENBQWtCLElBQWxCLEVBQXdCO0FBQ3BCLFNBQUssZ0JBQUwsQ0FBc0IsVUFBdEIsRUFBa0MsVUFBVSxDQUFWLEVBQWE7QUFDM0MsWUFBTSxNQUFNLEVBQUUsT0FBRixJQUFhLEVBQUUsS0FBM0I7QUFDQSxZQUFJLFFBQVEsRUFBWixFQUFnQixFQUFFLFdBQUYsR0FBZ0IsS0FBaEI7QUFDaEIsZUFBTyxJQUFQO0FBQ0gsS0FKRDtBQUtBLFdBQU8sSUFBUDtBQUNIOztBQUVELFNBQVMsV0FBVCxDQUFxQixHQUFyQixFQUEwQjs7QUFFdEIsV0FBTSxPQUFPLElBQVAsQ0FBWSxHQUFaLENBQU47QUFDSSxjQUFNLElBQUksT0FBSixDQUFZLElBQVosRUFBa0IsR0FBbEIsQ0FBTjtBQURKLEtBRnNCLENBS3RCO0FBQ0EsUUFBSSxJQUFJLE1BQUosR0FBYSxDQUFiLElBQWtCLElBQUksSUFBSSxNQUFKLEdBQWEsQ0FBakIsTUFBd0IsR0FBOUMsRUFDSSxNQUFNLElBQUksS0FBSixDQUFVLENBQVYsRUFBYSxDQUFDLENBQWQsQ0FBTjs7QUFFTCxXQUFPLEdBQVA7QUFDRjs7QUFFRCxTQUFTLFlBQVQsQ0FBc0IsQ0FBdEIsRUFBeUI7QUFDckIsV0FBTSxJQUFJLElBQUosQ0FBUyxDQUFULENBQU47QUFDSSxZQUFJLEVBQUUsT0FBRixDQUFVLEdBQVYsRUFBZSxHQUFmLENBQUo7QUFESixLQUVBLE9BQU8sQ0FBUDtBQUNIOztBQUVELFNBQVMsT0FBVCxHQUFrQjtBQUNkLFVBQU0sV0FBTixDQUFrQjtBQUNkLFlBQUssUUFBUSxFQURDO0FBRWQsYUFBTSxhQUFhLFlBQVksV0FBVyxHQUFYLENBQWUsS0FBZixJQUF3QixHQUFHLEdBQXZDLENBQWIsQ0FGUTtBQUdkLGNBQU8sV0FBVyxJQUFYLENBQWdCLEtBQWhCLElBQXlCLEdBQUc7QUFIckIsS0FBbEIsRUFJRyxVQUFDLEdBQUQsUUFBMEI7QUFBQSxZQUFuQixFQUFtQixRQUFuQixFQUFtQjtBQUFBLFlBQWYsSUFBZSxRQUFmLElBQWU7QUFBQSxZQUFULEdBQVMsUUFBVCxHQUFTOztBQUN6QixZQUFJLEdBQUosRUFBUztBQUNMLDJCQUFlLElBQWYsQ0FBb0IsYUFBcEI7QUFDQSxnQkFBSSxPQUFPLElBQUksS0FBWCxDQUFKLEVBQXVCO0FBQ25CLHNCQUFNLFdBQU4sZUFBOEIsV0FBVyxJQUFYLENBQWdCLEtBQTlDLGlCQUErRCxJQUFJLE9BQW5FO0FBQ0Esc0JBQU0sV0FBTixDQUFrQixJQUFJLEtBQXRCO0FBQ0gsYUFIRCxNQUdPO0FBQ0gsc0JBQU0sV0FBTixjQUE2QixXQUFXLElBQVgsQ0FBZ0IsS0FBN0MsaUJBQThELElBQUksT0FBbEU7QUFDQSxzQkFBTSxXQUFOO0FBQ0g7QUFFSixTQVZELE1BVU87QUFDSCwyQkFBZSxJQUFmLENBQW9CLGFBQXBCO0FBQ0E7QUFDQSxrQkFBTSxZQUFOLENBQW1CLEdBQW5CO0FBQ0EsZ0JBQUksUUFBUSxHQUFSLEtBQWdCLEdBQXBCLEVBQ0ksTUFBTSxXQUFOLDhDQUE2RCxHQUE3RDtBQUNKLGdCQUFJLFFBQVEsSUFBUixLQUFpQixJQUFyQixFQUNJLE1BQU0sV0FBTixxQ0FBb0QsSUFBcEQ7QUFDUDtBQUNKLEtBeEJEO0FBeUJIOztBQUVELElBQU0sS0FBSztBQUNQLGVBQVk7QUFBQSxlQUFLLFdBQVcsSUFBWCxHQUFrQixTQUFTLENBQVQsQ0FBdkI7QUFBQSxLQURMO0FBRVAsY0FBVztBQUFBLGVBQUssV0FBVyxHQUFYLEdBQWlCLFNBQVMsU0FBUyxDQUFULENBQVQsQ0FBdEI7QUFBQSxLQUZKO0FBR1AsWUFBUztBQUFBLGVBQUssRUFBRSxnQkFBRixDQUFtQixPQUFuQixFQUE0QjtBQUFBLG1CQUFNLFNBQU47QUFBQSxTQUE1QixDQUFMO0FBQUEsS0FIRjtBQUlQLFlBQVM7QUFBQSxlQUFLLEVBQUUsZ0JBQUYsQ0FBbUIsT0FBbkIsRUFBNEI7QUFBQSxtQkFBTSxlQUFlLElBQWYsQ0FBb0IsYUFBcEIsQ0FBTjtBQUFBLFNBQTVCLENBQUw7QUFBQSxLQUpGO0FBS1AsVUFBTyxFQUxBO0FBTVAsU0FBTSxFQU5DO0FBT1AsUUFBSSxFQVBHO0FBUVAsaUJBQWE7QUFSTixDQUFYOztBQVdBLE1BQU0sR0FBTixDQUFVLGFBQVYsRUFBeUI7QUFDckIsU0FBTyxtQkFBUTtBQUNYLGdCQUFRLEdBQVIsQ0FBWSxJQUFaLEVBQWtCLGNBQU07QUFDcEIsdUJBQVcsRUFBWDtBQUNBLHFCQUFTLEVBQVQ7QUFDSCxTQUhEO0FBSUg7QUFOb0IsQ0FBekI7O0FBU0EsT0FBTyxPQUFQLEdBQWlCO0FBQ2IsVUFBTyxxQkFBcUI7QUFBQSxZQUFuQixFQUFtQixTQUFuQixFQUFtQjtBQUFBLFlBQWYsR0FBZSxTQUFmLEdBQWU7QUFBQSxZQUFWLElBQVUsU0FBVixJQUFVOzs7QUFFeEIsa0JBQVUsRUFBQyxNQUFELEVBQUssUUFBTCxFQUFVLFVBQVYsRUFBVjs7QUFFQSxpQkFBUztBQUNMLGtCQURLO0FBRUwsb0JBRks7QUFHTCxzQkFISztBQUlMLCtCQUFrQixFQUFsQjtBQUpLLFNBQVQ7QUFNQSx1QkFBZSxJQUFmLENBQW9CLGFBQXBCO0FBQ0g7QUFaWSxDQUFqQjs7Ozs7QUNuR0EsSUFBSSxRQUFRLFFBQVEsT0FBUixDQUFaOztBQUVBOzs7O0FBSUE7Ozs7QUFJQSxTQUFTLGdCQUFULENBQTBCLElBQTFCLEVBQWdDLE9BQWhDLEVBQXlDO0FBQ3JDLFFBQUksUUFBUSxjQUFSLENBQXVCLE1BQXZCLENBQUosRUFBb0M7QUFDaEM7QUFDQSxjQUFNLEtBQU4sQ0FBWSxRQUFaLENBQXFCLEVBQUMsYUFBYyxRQUFRLElBQXZCLEVBQXJCO0FBQ0g7O0FBRUQ7QUFDQSxRQUFJLEtBQUssY0FBTCxDQUFvQixpQkFBcEIsQ0FBSixFQUE0QztBQUN4QztBQUNBLGNBQU0sS0FBTixDQUFZLFFBQVosQ0FBcUI7QUFDakIsZ0NBQXNCLEtBQUssZUFBTCxDQUFxQixlQUFyQixJQUF3QyxLQUFLLGVBQUwsQ0FBcUIsZUFBckIsQ0FBeEMsR0FBZ0Y7QUFEckYsU0FBckI7QUFHSDtBQUNKOztBQUVELE9BQU8sT0FBUCxHQUFpQjtBQUNiLHlCQUFzQixnQkFEVDtBQUViLG1CQUFnQixnQkFGSDtBQUdiLDJCQUF3QiwrQkFBUyxJQUFULEVBQWU7QUFDbkMsY0FBTSxLQUFOLENBQVksUUFBWixDQUFxQjtBQUNqQix5QkFBYyxLQUFLO0FBREYsU0FBckI7QUFHSDtBQVBZLENBQWpCOzs7OztBQ3pCQSxJQUFJLFFBQVEsUUFBUSxPQUFSLENBQVo7QUFBQSxJQUNJLFVBQVUsUUFBUSxVQUFSLENBRGQ7QUFBQSxJQUVJLFFBQVEsUUFBUSxhQUFSLENBRlo7QUFBQSxJQUdJLFNBQVMsUUFBUSxjQUFSLENBSGI7QUFBQSxJQUlJLFdBQVcsUUFBUSxzQkFBUixDQUpmO0FBQUEsSUFLSSxrQkFBa0I7QUFDZCxnQkFBYSxFQURDO0FBRWQsaUJBQWMsdUJBQVk7QUFDdEIsZUFBTztBQUNILG9CQUFTLEVBRE4sRUFDVTtBQUNiLHFCQUFVLEVBRlAsQ0FFWTtBQUZaLFNBQVA7QUFJSDtBQVBhLENBTHRCO0FBQUEsSUFjSSxnQkFBZ0IsRUFkcEI7QUFBQSxJQWVJLGNBQWMsRUFmbEI7QUFBQSxJQWdCSSxxQkFBcUIsRUFoQnpCOztBQWtCQSxNQUFNLHFCQUFOLENBQTRCLGdCQUE1QixDQUE2QyxVQUFVLEdBQVYsRUFBZTtBQUN4RCxRQUFJLFNBQUo7QUFDQSxRQUFJLElBQUksUUFBUixFQUFrQjtBQUNiLG9CQUFZLElBQUksVUFBSixHQUFpQixvQkFBakIsR0FBd0Msa0JBQXBEO0FBQ0EsaUJBQVMsV0FBVCxDQUFxQixTQUFyQixFQUFnQyxJQUFJLFFBQXBDO0FBQ0osS0FIRCxNQUdPO0FBQ0YsaUJBQVMsV0FBVCxDQUFxQixhQUFyQixFQUFvQyxJQUFJLFFBQXhDO0FBQ0o7QUFDSixDQVJEOztBQVVDLGFBQVk7QUFDVCxRQUFJLG9CQUFvQixLQUF4Qjs7QUFFQSxVQUFNLHFCQUFOLENBQTRCLGtCQUE1QixDQUErQyxZQUFZO0FBQ3ZELGdCQUFRLEdBQVIsQ0FBWSxpRkFBWjtBQUNBLGlCQUFTLFdBQVQsQ0FBcUIsa0JBQXJCLEVBQXlDLENBQUMsaUJBQTFDO0FBQ0gsS0FIRDtBQUlBO0FBQ0EsYUFBUyxrQkFBVCxDQUE0QjtBQUN4QiwwQkFBbUIsMEJBQVUsT0FBVixFQUFtQjtBQUNsQyxnQ0FBb0IsT0FBcEI7QUFDSDtBQUh1QixLQUE1QjtBQU1ILENBZEEsR0FBRDs7QUFnQkMsYUFBVztBQUNSLFFBQUksbUJBQW1CLEtBQXZCOztBQUVBLFVBQU0scUJBQU4sQ0FBNEIsaUJBQTVCLENBQThDLFlBQVc7QUFDckQsMkJBQW1CLENBQUMsZ0JBQXBCO0FBQ0EsaUJBQVMsV0FBVCxDQUFxQixpQkFBckIsRUFBd0MsZ0JBQXhDO0FBQ0gsS0FIRDtBQUlILENBUEEsR0FBRDs7QUFTQSxNQUFNLHFCQUFOLENBQTRCLFVBQTVCLENBQXVDLFlBQVk7QUFDL0MsWUFBUSxHQUFSLENBQVkseUVBQVo7QUFDQSxXQUFPLElBQVAsQ0FDSSxNQUFNLFlBQVksRUFBbEIsR0FBdUIscUJBRDNCLEVBRUksUUFGSixDQUVhO0FBRmI7QUFJSCxDQU5EOztBQVFBLE1BQU0scUJBQU4sQ0FBNEIsa0JBQTVCLENBQStDLFlBQVk7QUFDdkQsWUFBUSxHQUFSLENBQVksaUZBQVo7QUFDQSxhQUFTLFdBQVQsQ0FBcUIsa0JBQXJCO0FBQ0gsQ0FIRDs7QUFLQSxNQUFNLHFCQUFOLENBQTRCLGdCQUE1QixDQUE2QyxZQUFZO0FBQ3JELFlBQVEsR0FBUixDQUFZLDJFQUFaO0FBQ0EsYUFBUyxXQUFULENBQXFCLGdCQUFyQjtBQUNILENBSEQ7O0FBS0EsTUFBTSxxQkFBTixDQUE0QixVQUE1QixDQUF1QyxZQUFZO0FBQy9DLFlBQVEsR0FBUixDQUFZLHlFQUFaOztBQUVBLFFBQUksT0FBTyxPQUFPLE1BQVAsQ0FBYyxrQ0FBb0MsWUFBWTtBQUNqRSxZQUFJLG9CQUFvQixFQUF4QjtBQUNBLGVBQU8sSUFBUCxDQUFZLGNBQWMsSUFBMUIsRUFBZ0MsT0FBaEMsQ0FBd0MsVUFBVSxJQUFWLEVBQWdCO0FBQ3BELGdCQUFJLE9BQU8sSUFBUCxDQUFZLGNBQWMsSUFBZCxDQUFtQixJQUFuQixDQUFaLEVBQXNDLE1BQXRDLEdBQStDLENBQW5ELEVBQXNEO0FBQ2xELGtDQUFrQixJQUFsQixDQUF1QixJQUF2QjtBQUNIO0FBQ0osU0FKRDtBQUtBLGVBQU8saUJBQVA7QUFDSCxLQVJ3RCxFQUFELENBUW5ELElBUm1ELENBUTlDLElBUjhDLENBQWpELENBQVg7O0FBVUEsUUFBSSxTQUFTLElBQWIsRUFBbUI7QUFDZixlQUFPLElBQVAsQ0FDSSxNQUFNLFlBQVksRUFBbEIsR0FBdUIsYUFBdkIsSUFBd0MsU0FBUyxFQUFULEdBQWMsV0FBVyxJQUF6QixHQUFnQyxFQUF4RSxDQURKLEVBRUksUUFGSixDQUVhO0FBRmI7QUFJSDtBQUNKLENBbkJEOztBQXFCQTs7O0FBR0EsT0FBTyxpQkFBUCxDQUF5QixzQkFBekIsRUFBaUQsVUFBVSxXQUFWLEVBQXVCO0FBQ3BFLFVBQU0sV0FBTixDQUFrQiwrQkFBK0IsV0FBL0IsR0FBNkMsZ0JBQS9EO0FBQ0gsQ0FGRDtBQUdBOzs7QUFHQSxPQUFPLGlCQUFQLENBQXlCLFlBQXpCLEVBQXVDLFVBQVUsU0FBVixFQUFxQixRQUFyQixFQUErQixPQUEvQixFQUF3QyxRQUF4QyxFQUFrRDtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSCxDQVBEO0FBUUE7OztBQUdBLE9BQU8saUJBQVAsQ0FBeUIsWUFBekIsRUFBdUMsVUFBVSxVQUFWLEVBQXNCLEdBQXRCLEVBQTJCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSCxDQU5EOztBQVFBOzs7Ozs7O0FBT0EsU0FBUyxtQkFBVCxDQUE2QixXQUE3QixFQUEwQyxJQUExQyxFQUFnRCxHQUFoRCxFQUFxRCxLQUFyRCxFQUE0RDs7QUFFeEQ7QUFDQSxRQUFJLGdCQUFnQixVQUFoQixDQUEyQixXQUEzQixNQUE0QyxTQUFoRCxFQUEyRDtBQUN2RCxnQkFBUSxHQUFSLENBQVksOEVBQVosRUFBNEYsV0FBNUY7QUFDQSx3QkFBZ0IsVUFBaEIsQ0FBMkIsV0FBM0IsSUFBMEMsZ0JBQWdCLFdBQWhCLEVBQTFDO0FBQ0g7O0FBRUQsb0JBQWdCLFVBQWhCLENBQTJCLFdBQTNCLEVBQXdDLE1BQXhDLENBQStDLEdBQS9DLElBQXNELElBQXREO0FBQ0EsUUFBSSxnQkFBZ0IsVUFBaEIsQ0FBMkIsV0FBM0IsRUFBd0MsT0FBeEMsQ0FBZ0QsSUFBaEQsTUFBMEQsU0FBOUQsRUFBeUU7QUFDckUsd0JBQWdCLFVBQWhCLENBQTJCLFdBQTNCLEVBQXdDLE9BQXhDLENBQWdELElBQWhELElBQXdELEVBQXhEO0FBQ0g7QUFDRDtBQUNBLFFBQUksS0FBSixFQUFXO0FBQ1Asd0JBQWdCLFVBQWhCLENBQTJCLFdBQTNCLEVBQXdDLE9BQXhDLENBQWdELElBQWhELEVBQXNELEdBQXRELElBQTZELElBQTdEO0FBQ0gsS0FGRCxNQUVPLElBQUksZ0JBQWdCLFVBQWhCLENBQTJCLFdBQTNCLEVBQXdDLE9BQXhDLENBQWdELElBQWhELEVBQXNELEdBQXRELENBQUosRUFBZ0U7QUFDbkU7QUFDQSxlQUFPLGdCQUFnQixVQUFoQixDQUEyQixXQUEzQixFQUF3QyxPQUF4QyxDQUFnRCxJQUFoRCxFQUFzRCxHQUF0RCxDQUFQO0FBQ0g7QUFDSjs7QUFFRDtBQUNBLFNBQVMscUJBQVQsQ0FBK0IsV0FBL0IsRUFBNEMsSUFBNUMsRUFBa0QsR0FBbEQsRUFBdUQsS0FBdkQsRUFBOEQ7QUFDMUQsd0JBQW9CLFdBQXBCLEVBQWlDLElBQWpDLEVBQXVDLEdBQXZDLEVBQTRDLEtBQTVDO0FBQ0EsVUFBTSxxQkFBTixDQUE0QixnQ0FBNUIsQ0FBNkQsT0FBTyxJQUFQLENBQVksZ0JBQWdCLFVBQWhCLENBQTJCLFdBQTNCLEVBQXdDLE9BQXhDLENBQWdELElBQWhELENBQVosRUFBbUUsTUFBaEksRUFBd0ksSUFBeEk7QUFDQSxVQUFNLHFCQUFOLENBQTRCLDZCQUE1QixDQUEwRCxPQUFPLElBQVAsQ0FBWSxnQkFBZ0IsVUFBaEIsQ0FBMkIsV0FBM0IsRUFBd0MsTUFBcEQsRUFBNEQsTUFBdEg7QUFDSDs7QUFFRDtBQUNBLFNBQVMsa0JBQVQsQ0FBNEI7QUFDeEI7OztBQUdBLGVBQVksbUJBQVUsV0FBVixFQUF1QixJQUF2QixFQUE2QixHQUE3QixFQUFrQyxLQUFsQyxFQUF5QztBQUNqRCxnQkFBUSxHQUFSLENBQVksMkNBQVosRUFBeUQsV0FBekQsRUFBc0UsSUFBdEUsRUFBNEUsR0FBNUUsRUFBaUYsS0FBakY7QUFDQSw4QkFBc0IsV0FBdEIsRUFBbUMsSUFBbkMsRUFBeUMsR0FBekMsRUFBOEMsS0FBOUM7QUFDSCxLQVB1QjtBQVF4QixxQkFBa0IseUJBQVUsU0FBVixFQUFxQjtBQUNuQyxnQkFBUSxHQUFSLENBQVksa0VBQVosRUFBZ0YsU0FBaEY7QUFDQSxjQUFNLFdBQU4sQ0FBa0IsU0FBbEIsRUFBNkIsVUFBVSxLQUFWLEVBQWlCO0FBQzFDLGdCQUFJLFVBQVUsS0FBZCxFQUNJLFFBQVEsS0FBUixDQUFjLGtFQUFkLEVBQWtGLFNBQWxGO0FBQ1AsU0FIRDtBQUlILEtBZHVCO0FBZXhCLHNCQUFtQiwwQkFBVSxJQUFWLEVBQWdCO0FBQy9CLGNBQU0scUJBQU4sQ0FBNEIsWUFBNUIsQ0FBeUMsSUFBekM7QUFDSCxLQWpCdUI7QUFrQnhCLHdCQUFxQiw0QkFBVSxJQUFWLEVBQWdCO0FBQ2pDLGNBQU0scUJBQU4sQ0FBNEIsY0FBNUIsQ0FBMkMsSUFBM0M7QUFDSCxLQXBCdUI7QUFxQnhCLGlCQUFjLHFCQUFVLElBQVYsRUFBZ0I7QUFDMUIsY0FBTSxxQkFBTixDQUE0QixZQUE1QixDQUF5QyxJQUF6QztBQUNIO0FBdkJ1QixDQUE1Qjs7QUEwQkEsU0FBUyw4QkFBVCxDQUF3QyxZQUF4QyxFQUFzRDtBQUNsRCxRQUFJLGdCQUFnQixFQUFwQjtBQUNBLFdBQU8sSUFBUCxDQUFZLFlBQVosRUFBMEIsT0FBMUIsQ0FBa0MsVUFBUyxJQUFULEVBQWU7QUFDN0MsZUFBTyxJQUFQLENBQVksYUFBYSxJQUFiLENBQVosRUFBZ0MsT0FBaEMsQ0FBd0MsVUFBVSxHQUFWLEVBQWU7QUFDbkQsMEJBQWMsR0FBZCxJQUFxQixTQUFyQjtBQUNILFNBRkQ7QUFHSCxLQUpEO0FBS0EsV0FBTyxPQUFPLElBQVAsQ0FBWSxhQUFaLEVBQTJCLE1BQWxDO0FBRUg7O0FBRUQsU0FBUywwQkFBVCxDQUFvQyxZQUFwQyxFQUFrRDtBQUM5QyxRQUFJLHFCQUFxQixFQUF6QjtBQUNBLFdBQU8sSUFBUCxDQUFZLFlBQVosRUFBMEIsT0FBMUIsQ0FBa0MsVUFBUyxJQUFULEVBQWU7QUFDN0MsMkJBQW1CLElBQW5CLElBQTJCLE9BQU8sSUFBUCxDQUFZLGFBQWEsSUFBYixDQUFaLEVBQWdDLE1BQTNEO0FBQ0gsS0FGRDtBQUdBLFdBQU8sa0JBQVA7QUFDSDs7QUFFRDs7OztBQUlBLFNBQVMsZ0JBQVQsQ0FBMEIsSUFBMUIsRUFBZ0MsT0FBaEMsRUFBeUM7QUFDckMsb0JBQWdCLElBQWhCO0FBQ0Esa0JBQWMsT0FBZDs7QUFFQSxVQUFNLHFCQUFOLENBQTRCLHFCQUE1QixDQUFrRCxLQUFLLGtCQUF2RDs7QUFFQSxVQUFNLHFCQUFOLENBQTRCLDRCQUE1QixDQUNJLCtCQUErQixLQUFLLElBQXBDLENBREosRUFDK0MsMkJBQTJCLEtBQUssSUFBaEMsQ0FEL0M7O0FBR0EsV0FBTyxJQUFQLENBQVksS0FBSyxJQUFqQixFQUF1QixPQUF2QixDQUErQixVQUFVLElBQVYsRUFBZ0I7QUFDM0MsWUFBSSxPQUFPLElBQVAsQ0FBWSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQVosRUFBNkIsTUFBN0IsR0FBc0MsQ0FBdEMsSUFBMkMsbUJBQW1CLE9BQW5CLENBQTJCLElBQTNCLE1BQXFDLENBQUMsQ0FBckYsRUFBd0Y7O0FBRXBGLG1CQUFPLElBQVAsQ0FBWSxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQVosRUFBNkIsT0FBN0IsQ0FBcUMsVUFBVSxHQUFWLEVBQWU7QUFDaEQsb0NBQW9CLEtBQUssT0FBekIsRUFBa0MsSUFBbEMsRUFBd0MsR0FBeEMsRUFBNkMsS0FBSyxJQUFMLENBQVUsSUFBVixFQUFnQixHQUFoQixDQUE3QztBQUNILGFBRkQ7O0FBSUEsZ0JBQUksZ0JBQWdCLFVBQWhCLENBQTJCLEtBQUssT0FBaEMsRUFBeUMsT0FBekMsQ0FBaUQsSUFBakQsQ0FBSixFQUE0RDtBQUN4RCx3QkFBUSxHQUFSLENBQVksZ0RBQVosRUFBOEQsZ0JBQWdCLFVBQWhCLENBQTJCLEtBQUssT0FBaEMsRUFBeUMsT0FBekMsQ0FBaUQsSUFBakQsQ0FBOUQ7QUFDQSx3QkFBUSxHQUFSLENBQVksMkRBQVosRUFBeUUsT0FBTyxJQUFQLENBQVksZ0JBQWdCLFVBQWhCLENBQTJCLEtBQUssT0FBaEMsRUFBeUMsTUFBckQsRUFBNkQsTUFBdEk7QUFDWjtBQUNBO0FBQ1k7QUFDQSxzQkFBTSxxQkFBTixDQUE0QixZQUE1QixDQUF5QyxJQUF6QztBQUNBLHNCQUFNLHFCQUFOLENBQTRCLGNBQTVCLENBQTJDLElBQTNDO0FBQ0gsYUFSRCxNQVFPO0FBQ0gsd0JBQVEsR0FBUixDQUFZLHlGQUFaLEVBQXVHLElBQXZHO0FBQ0g7QUFDSjtBQUNKLEtBbkJEOztBQXFCQTtBQUNBLG9CQUFnQixVQUFoQixDQUEyQixLQUFLLE9BQWhDLElBQTJDLGdCQUFnQixXQUFoQixFQUEzQztBQUNBO0FBQ0E7QUFDQSxhQUFTLFdBQVQsQ0FBcUIsa0JBQXJCLEVBQXlDLEtBQUssZUFBOUM7QUFDSDs7QUFFRDs7O0FBR0EsT0FBTyxPQUFQLEdBQWlCO0FBQ2IseUJBQXNCLGdCQURUO0FBRWIsbUJBQWdCO0FBRkgsQ0FBakI7Ozs7O0FDclBBLElBQUksa0JBQWtCLFFBQVEsT0FBUixFQUFpQixlQUF2QztBQUFBLElBQ0ksaUJBQWlCLFFBQVEsT0FBUixFQUFpQixjQUR0QztBQUFBLElBRUksUUFBUSxRQUFRLGFBQVIsQ0FGWjtBQUFBLElBR0ksV0FBVyxRQUFRLHNCQUFSLENBSGY7QUFBQSxJQUlJLFFBQVEsUUFBUSxhQUFSLENBSlo7QUFBQSxJQUtJLFNBQVMsUUFBUSxjQUFSLENBTGI7O0FBT0EsSUFBTSxjQUFjLFFBQVEsd0JBQVIsQ0FBcEI7O0FBRUEsSUFBSSw0QkFBNkIsWUFBVzs7QUFFeEMsUUFBSSxzQkFBSixFQUNJLGdCQURKO0FBRUk7OztBQUdBLFlBTEo7QUFNSTs7O0FBR0EsZUFUSjs7QUFXQSxhQUFTLGtCQUFULENBQTRCO0FBQ3hCLDBCQUFtQiw0QkFBWTtBQUMzQiwyQkFBZSxJQUFmLENBQW9CLGtCQUFwQjtBQUNIO0FBSHVCLEtBQTVCOztBQU1BLG9CQUFnQix5QkFBaEIsQ0FBMEMsWUFBVztBQUNqRCxZQUFJLDJCQUEyQixnQkFBL0IsRUFBaUQ7QUFDN0Msa0JBQU0sWUFBTixDQUFtQixzQkFBbkI7QUFDSCxTQUZELE1BRU87QUFDSCxvQkFBUSxHQUFSLENBQVkscUJBQVo7QUFDSDtBQUNKLEtBTkQ7O0FBUUEsb0JBQWdCLGlCQUFoQixDQUFrQyxVQUFTLFdBQVQsRUFBc0I7QUFDcEQsaUJBQVMsV0FBVCxDQUFxQixpQkFBckIsRUFBd0MsU0FBUyxXQUFULEVBQXNCLEVBQTlEO0FBQ0gsS0FGRDs7QUFJQSxvQkFBZ0IsbUJBQWhCLENBQW9DLFVBQVMsYUFBVCxFQUF3QjtBQUN4RCxZQUFJLGNBQWMsWUFBWSxhQUFaLENBQWxCO0FBQ0EsY0FBTSxZQUFOLENBQW1CLFdBQW5CLEVBQWdDLFlBQVk7QUFDeEMsb0JBQVEsR0FBUixDQUFZLG9FQUFaLEVBQWtGLFdBQWxGO0FBQ0gsU0FGRDtBQUdILEtBTEQ7O0FBT0Esb0JBQWdCLHNCQUFoQixDQUF1QyxZQUFXO0FBQzlDLHVCQUFlLElBQWYsQ0FBb0Isc0JBQXBCO0FBQ0gsS0FGRDs7QUFJQSxvQkFBZ0Isd0JBQWhCLENBQXlDLFlBQVc7QUFDaEQsdUJBQWUsSUFBZixDQUFvQix3QkFBcEI7QUFDSCxLQUZEOztBQUlBLG9CQUFnQixxQkFBaEIsQ0FBc0MsVUFBUyxPQUFULEVBQWtCO0FBQ3BELFlBQUksZ0JBQWdCLGdCQUFwQjtBQUNBLFlBQUksY0FBYyxjQUFjLE1BQWQsR0FBdUIsQ0FBckMsTUFBNEMsR0FBaEQsRUFBcUQ7QUFDakQsNkJBQWlCLEdBQWpCO0FBQ0g7QUFDRCxjQUFNLFlBQU4sQ0FBbUIsZ0JBQWdCLE9BQW5DLEVBQTRDLFVBQVMsR0FBVCxFQUFjLE9BQWQsRUFBdUI7QUFDL0QsZ0JBQUksWUFBSjtBQUNBLGdCQUFJLENBQUMsR0FBTCxFQUFVO0FBQ04sZ0NBQWdCLHFCQUFoQixDQUFzQyxRQUFRLEtBQVIsQ0FBYyxHQUFkLEVBQW1CLEtBQW5CLENBQXlCLENBQUMsQ0FBMUIsRUFBNkIsQ0FBN0IsQ0FBdEM7QUFDQSwrQkFBZSxhQUFhLE9BQWIsR0FBdUIscUJBQXRDO0FBQ0gsYUFIRCxNQUdPO0FBQ0gsK0JBQWUsMEJBQTBCLElBQUksT0FBOUIsR0FBd0MsR0FBdkQ7QUFDSDtBQUNELGtCQUFNLFdBQU4sQ0FBa0IsWUFBbEI7QUFDSCxTQVREO0FBVUgsS0FmRDs7QUFpQkEsb0JBQWdCLHNCQUFoQixDQUF1QztBQUFBLGVBQWUsWUFBWSxJQUFaLENBQWlCLFNBQVMsV0FBVCxDQUFqQixDQUFmO0FBQUEsS0FBdkM7O0FBRUEsb0JBQWdCLHNCQUFoQixDQUF1QyxVQUFTLFdBQVQsRUFBc0I7QUFDekQsY0FBTSxhQUFOLENBQW9CLFNBQVMsV0FBVCxFQUFzQixFQUExQyxFQUE4QyxVQUFTLEdBQVQsRUFBYyxPQUFkLEVBQXVCO0FBQ2pFLGdCQUFJLFlBQUo7QUFDQSxnQkFBSSxDQUFDLEdBQUwsRUFBVTtBQUNOLGdDQUFnQixxQkFBaEIsQ0FBc0MsUUFBUSxJQUE5QztBQUNBLCtCQUFlLGNBQWMsUUFBUSxJQUF0QixHQUE2QixxQkFBNUM7QUFDSCxhQUhELE1BR087QUFDSCwrQkFBZSwwQkFBMEIsSUFBSSxPQUE5QixHQUF3QyxHQUF2RDtBQUNIO0FBQ0Qsa0JBQU0sV0FBTixDQUFrQixZQUFsQjtBQUNILFNBVEQ7QUFVSCxLQVhEOztBQWFBLFdBQU8saUJBQVAsQ0FBeUIscUJBQXpCLEVBQWdELFVBQVUsV0FBVixFQUF1QjtBQUNuRSxZQUFJLGdCQUFnQixZQUFZLFdBQVosQ0FBd0IsR0FBeEIsQ0FBcEI7QUFDQSxZQUFJLGtCQUFrQixZQUFZLFNBQVosQ0FBc0IsQ0FBdEIsRUFBeUIsZ0JBQWdCLENBQXpDLENBQXRCO0FBQ0EsWUFBSSxvQkFBb0Isc0JBQXhCLEVBQWdEO0FBQzVDLGdCQUFJLGdCQUFnQixZQUFZLFNBQVosQ0FBc0IsZ0JBQWdCLENBQXRDLENBQXBCO0FBQ0Esd0JBQVksYUFBWixJQUE2QixXQUE3QjtBQUNBO0FBQ0E7QUFDQSxrQkFBTSxXQUFOLENBQWtCLHNCQUFzQixhQUF0QixHQUFzQyxxQ0FBeEQ7QUFDQSw0QkFBZ0IseUJBQWhCLENBQTBDLE9BQU8sSUFBUCxDQUFZLFFBQVosQ0FBMUMsRUFBaUUsT0FBTyxJQUFQLENBQVksV0FBWixDQUFqRTtBQUNIO0FBQ0osS0FYRDs7QUFhQSxXQUFPO0FBQ0g7Ozs7O0FBS0Esc0JBQWMsc0JBQVUsSUFBVixFQUFnQjtBQUMxQixvQkFBUSxHQUFSLENBQVksMENBQVosRUFBd0QsSUFBeEQ7QUFDQSxnQkFBSSxTQUFTLEtBQWIsRUFBb0I7QUFDaEIsd0JBQVEsS0FBUixDQUFjLG9CQUFkO0FBQ0gsYUFGRCxNQUVPLElBQUksS0FBSyxjQUFMLENBQW9CLFVBQXBCLEtBQW1DLEtBQUssY0FBTCxDQUFvQixNQUFwQixDQUF2QyxFQUFvRTs7QUFFdkUsMkJBQVcsRUFBWDtBQUNBLHFCQUFLLFFBQUwsQ0FBYyxPQUFkLENBQXNCLFVBQVMsS0FBVCxFQUFnQjtBQUNsQyw2QkFBUyxNQUFNLElBQWYsSUFBdUIsS0FBdkI7QUFDSCxpQkFGRDs7QUFJQSw4QkFBYyxFQUFkO0FBQ0EscUJBQUssSUFBTCxDQUFVLE9BQVYsQ0FBa0IsVUFBUyxLQUFULEVBQWdCO0FBQy9CLGdDQUFZLE1BQU0sSUFBbEIsSUFBMEIsTUFBTSxFQUFoQztBQUNGLGlCQUZEOztBQUlBLGdDQUFnQix5QkFBaEIsQ0FBMEMsT0FBTyxJQUFQLENBQVksUUFBWixDQUExQyxFQUFpRSxPQUFPLElBQVAsQ0FBWSxXQUFaLENBQWpFO0FBQ0EseUNBQXlCLEtBQUssZUFBOUI7QUFDQSxtQ0FBbUIsS0FBSyxnQkFBeEI7QUFFSCxhQWhCTSxNQWdCQTtBQUNILHdCQUFRLElBQVIsQ0FBYSwyRUFBYjtBQUNIO0FBQ0osU0E3QkU7QUE4QkgsK0JBQXdCLCtCQUFTLElBQVQsRUFBZTtBQUNuQywyQkFBZSxJQUFmLENBQW9CLGtCQUFwQjtBQUNBLGtCQUFNLFlBQU4sQ0FBbUIsS0FBSyxXQUF4QixFQUFxQyxZQUFXO0FBQzVDLHdCQUFRLEdBQVIsQ0FBWSxpRUFBWjtBQUNILGFBRkQ7QUFHSDtBQW5DRSxLQUFQO0FBcUNILENBaEkrQixFQUFoQzs7QUFrSUEsT0FBTyxPQUFQLEdBQWlCLHlCQUFqQjs7Ozs7QUMzSUEsSUFBTSxRQUFRLFFBQVEsT0FBUixDQUFkOztBQUVBLElBQUksWUFBWSxNQUFNLFNBQXRCO0FBQUEsSUFDSSxlQUFlLE1BQU0sWUFEekI7QUFBQSxJQUVJLFFBQVEsUUFBUSxVQUFSLENBRlo7QUFBQSxJQUdJLGdCQUFnQixRQUFRLDRCQUFSLENBSHBCO0FBQUEsSUFJSSxrQkFBa0IsY0FBYztBQUM1QixhQUFTO0FBQUEsZUFBTSxnQkFBZ0IsT0FBaEIsRUFBTjtBQUFBO0FBRG1CLENBQWQsQ0FKdEI7O0FBUUEsTUFBTSxHQUFOLENBQVUsZUFBVixFQUEyQixhQUEzQjs7QUFFQSxVQUFVLFFBQVYsQ0FBbUIsWUFBWTtBQUMzQixpQkFBYSxJQUFiO0FBQ0EsUUFBTSxjQUFjLFVBQVUsU0FBVixDQUFvQixLQUF4QztBQUNBLFFBQUksWUFBWSxNQUFaLEdBQXFCLENBQXpCLEVBQTRCO0FBQ3hCLGNBQU0sVUFBTixDQUFpQixXQUFqQixFQUE4QixVQUFVLFFBQVYsRUFBb0I7QUFDOUMseUJBQWEsSUFBYjtBQUNBLDRCQUFnQixNQUFoQixDQUF1QixRQUF2QjtBQUNILFNBSEQ7QUFJSDtBQUNKLENBVEQ7O0FBV0EsT0FBTyxPQUFQLEdBQWlCLEVBQWpCOzs7OztBQ3ZCQSxJQUFJLGFBQWEsUUFBUSxPQUFSLEVBQWlCLFVBQWxDO0FBQUEsSUFDSSxRQUFRLFFBQVEsYUFBUixDQURaO0FBQUEsSUFFSSxRQUFRLFFBQVEsYUFBUixDQUZaO0FBQUEsSUFHSSxTQUFTLFFBQVEsY0FBUixDQUhiO0FBQUEsSUFJSSxnQkFKSjtBQUtBOzs7OztBQUtBLFNBQVMsdUJBQVQsQ0FBaUMsUUFBakMsRUFBMkM7QUFDdkMsUUFBSSxNQUFNLHNCQUFzQixJQUF0QixDQUEyQixRQUEzQixDQUFWO0FBQ0EsUUFBSSxPQUFPLElBQUksTUFBSixLQUFlLENBQTFCLEVBQTZCO0FBQ3pCLGVBQU8sSUFBSSxDQUFKLENBQVA7QUFDSDtBQUNELFdBQU8sS0FBUDtBQUNIOztBQUVEOzs7QUFHQSxXQUFXLFFBQVgsQ0FBb0IsVUFBVSxFQUFWLEVBQWMsS0FBZCxFQUFxQixFQUFyQixFQUF5QjtBQUN6QyxZQUFRLEdBQVIsQ0FBWSwrQkFBWixFQUE2QyxLQUE3QztBQUNBLFFBQUksZ0JBQUosRUFBc0I7QUFDbEIsWUFBSSxDQUFDLEVBQUwsRUFBUztBQUNMO0FBQ0EsaUJBQUssZUFBTDtBQUNIO0FBQ0Q7QUFDQSxjQUFNLHNCQUFOLENBQTZCLGdCQUE3QixFQUErQyxFQUEvQyxFQUFtRCxLQUFuRCxFQUEwRCxVQUFVLE9BQVYsRUFBbUI7QUFDekUsZ0JBQUksT0FBSixFQUFhO0FBQ1QsbUJBQUcsSUFBSDtBQUNBLHNCQUFNLFdBQU4sQ0FBa0IsNkNBQTZDLGdCQUEvRDtBQUNILGFBSEQsTUFHTztBQUNILG1CQUFHLEtBQUg7QUFDSDtBQUNKLFNBUEQ7QUFRSDtBQUNKLENBakJEO0FBa0JBOzs7O0FBSUEsT0FBTyxPQUFQLEdBQWlCO0FBQ2IsbUJBQWdCLHVCQUFVLElBQVYsUUFBaUM7QUFBQSxZQUFoQixFQUFnQixRQUFoQixFQUFnQjtBQUFBLFlBQVosSUFBWSxRQUFaLElBQVk7QUFBQSxZQUFOLEdBQU0sUUFBTixHQUFNOztBQUM3QyxZQUFJLEVBQUosRUFBUSxtQkFBbUIsRUFBbkI7QUFDWDtBQUhZLENBQWpCOzs7OztBQzNDQSxJQUFJLFFBQVEsUUFBUSxPQUFSLENBQVo7QUFBQSxJQUNJLGtCQUFrQixRQUFRLDhCQUFSLENBRHRCO0FBQUEsSUFFSSw2QkFBNkIsUUFBUSx5Q0FBUixDQUZqQztBQUFBLElBR0ksY0FBYyxRQUFRLHFCQUFSLENBSGxCO0FBQUEsSUFJSSxVQUFVLFFBQVEsVUFBUixDQUpkO0FBQUEsSUFLSSxXQUFXLFFBQVEsc0JBQVIsQ0FMZjtBQUFBLElBTUksU0FBUyxRQUFRLGNBQVIsQ0FOYjtBQUFBLElBT0ksUUFBUSxRQUFRLGFBQVIsQ0FQWjtBQUFBLElBUUksTUFBTSxRQUFRLGFBQVIsQ0FSVjtBQUFBLElBU0ksWUFBWSxTQUFaLFNBQVksQ0FBUyxDQUFULEVBQVksQ0FBWixFQUFlO0FBQ3ZCLFFBQUksRUFBRSxHQUFGLEdBQVEsRUFBRSxHQUFkLEVBQW1CO0FBQ2YsZUFBTyxDQUFDLENBQVI7QUFDSDtBQUNELFFBQUksRUFBRSxHQUFGLEdBQVEsRUFBRSxHQUFkLEVBQW1CO0FBQ2YsZUFBTyxDQUFQO0FBQ0g7QUFDRCxXQUFPLENBQVA7QUFDSCxDQWpCTDtBQUFBLElBa0JJLGFBbEJKO0FBQUEsSUFtQkksV0FuQko7QUFBQSxJQW9CSSxxQkFBcUIsRUFwQnpCOztBQXFCSTs7Ozs7O0FBTUEsZUFBZSxFQTNCbkI7QUFBQSxJQTRCSSxtQkFBbUIsRUE1QnZCO0FBQUEsSUE2QkksZ0JBQWdCLFNBQWhCLGFBQWdCLENBQVMsQ0FBVCxFQUFZLENBQVosRUFBZTtBQUMzQixXQUFPLGlCQUFpQixPQUFqQixDQUF5QixDQUF6QixJQUE4QixpQkFBaUIsT0FBakIsQ0FBeUIsQ0FBekIsQ0FBckM7QUFDSCxDQS9CTDs7QUFpQ0EsMkJBQTJCLGNBQTNCLENBQTBDLFVBQVMsRUFBVCxFQUFhO0FBQ25ELGFBQVMsV0FBVCxDQUFxQixnQkFBckIsRUFBdUMsRUFBdkM7QUFDSCxDQUZEOztBQUlBLDJCQUEyQixjQUEzQixDQUEwQyxVQUFTLEVBQVQsRUFBYTtBQUNuRCxRQUFJLFFBQVEscUNBQXFDLEVBQXJDLEdBQTBDLGFBQWxELENBQUosRUFBc0U7QUFDbEUsY0FBTSxXQUFOLENBQWtCLFlBQVksRUFBOUIsRUFBa0MsRUFBbEM7QUFDSDtBQUNKLENBSkQ7O0FBTUEsZ0JBQWdCLGlCQUFoQixDQUFrQyxVQUFTLEVBQVQsRUFBYTtBQUMzQyxhQUFTLFdBQVQsQ0FBcUIsYUFBckIsRUFBb0MsTUFBTSxFQUExQztBQUNILENBRkQ7QUFHQTs7Ozs7QUFLQSxnQkFBZ0IsU0FBaEIsQ0FBMEIsVUFBUyxHQUFULEVBQWMsSUFBZCxFQUFvQixLQUFwQixFQUEyQjs7QUFFakQ7O0FBRUEsWUFBUSxHQUFSLENBQVksdUNBQVosRUFBcUQsR0FBRyxLQUFILENBQVMsSUFBVCxDQUFjLFNBQWQsQ0FBckQ7QUFDQSxVQUFNLE9BQU4sQ0FDSSxZQUFZLEVBRGhCLEVBRUksUUFBUSxjQUFjLGVBRjFCLEVBR0k7QUFDSSxhQUFLLEdBRFQ7QUFFSSxlQUFPLFNBQVM7QUFGcEIsS0FISixFQU9JLFVBQVMsU0FBVCxFQUFvQixRQUFwQixFQUE4QixHQUE5QixFQUFtQyxLQUFuQyxFQUEwQztBQUN0QyxZQUFJLEtBQUo7O0FBRUEsWUFBSSxjQUFjLFlBQVksRUFBOUIsRUFBa0M7QUFBRTtBQUNoQyxvQkFBUSxJQUFJLEtBQUosQ0FBVSxHQUFWLEVBQWUsQ0FBZixDQUFSO0FBQ0EseUJBQWEsR0FBYixJQUFvQixTQUFwQixDQUY4QixDQUVDO0FBQy9CLDBCQUFjLElBQWQsQ0FBbUIsSUFBbkIsRUFBeUIsR0FBekIsSUFBZ0MsS0FBaEM7QUFDQSw0QkFBZ0IsbUJBQWhCLENBQW9DLENBQUM7QUFDakMscUJBQUssR0FENEI7QUFFakMsdUJBQU8sU0FBUztBQUZpQixhQUFELENBQXBDLEVBR0ksUUFISixFQUdjLGtCQUhkLEVBR2tDLFlBQVc7QUFDekMsd0NBQXdCLEtBQXhCLEVBQStCLFFBQS9CO0FBQ0gsYUFMRDs7QUFPQSxrQkFBTSxXQUFOLENBQWtCLGlCQUFpQixHQUFqQixHQUF1QixhQUF6Qzs7QUFFQSw0QkFBZ0IsV0FBaEIsQ0FBNEIsR0FBNUIsRUFBaUMsUUFBakM7QUFDQTtBQUNBLHFCQUFTLFdBQVQsQ0FBcUIsV0FBckIsRUFBa0MsU0FBbEMsRUFBNkMsUUFBN0MsRUFBdUQsR0FBdkQsRUFBNEQsS0FBNUQ7QUFDSDtBQUNKLEtBM0JMO0FBNEJILENBakNEOztBQW1DQTs7Ozs7QUFLQSxnQkFBZ0IsV0FBaEIsQ0FBNEIsVUFBUyxHQUFULEVBQWMsSUFBZCxFQUFvQixLQUFwQixFQUEyQjtBQUNuRCxZQUFRLEdBQVIsQ0FBWSx1Q0FBWixFQUFxRCxHQUFHLEtBQUgsQ0FBUyxJQUFULENBQWMsU0FBZCxDQUFyRDtBQUNBLFVBQU0sU0FBTixDQUNJLFlBQVksRUFEaEIsRUFFSSxRQUFRLGNBQWMsZUFGMUIsRUFHSTtBQUNJLGFBQUssR0FEVDtBQUVJLGVBQU8sU0FBUztBQUZwQixLQUhKLEVBT0ksVUFBUyxTQUFULEVBQW9CLFFBQXBCLEVBQThCLEdBQTlCLEVBQW1DLEtBQW5DLEVBQTBDO0FBQ3RDLFlBQUksUUFBUSxJQUFJLEtBQUosQ0FBVSxHQUFWLEVBQWUsQ0FBZixDQUFaO0FBQ0EsWUFBSSxjQUFjLFlBQVksRUFBOUIsRUFBa0M7QUFBRTtBQUNoQyx5QkFBYSxHQUFiLElBQW9CLFNBQXBCLENBRDhCLENBQ0M7QUFDL0IsMEJBQWMsSUFBZCxDQUFtQixRQUFuQixJQUErQixjQUFjLElBQWQsQ0FBbUIsUUFBbkIsSUFBK0IsY0FBYyxJQUFkLENBQW1CLFFBQW5CLENBQS9CLEdBQThELEVBQTdGO0FBQ0EsMEJBQWMsSUFBZCxDQUFtQixRQUFuQixFQUE2QixHQUE3QixJQUFvQyxLQUFwQztBQUNBLDRCQUFnQixtQkFBaEIsQ0FBb0MsQ0FBQztBQUNqQyxxQkFBSyxHQUQ0QjtBQUVqQyx1QkFBTyxTQUFTLEVBRmlCO0FBR2pDLHVCQUFPO0FBSDBCLGFBQUQsQ0FBcEMsRUFJSSxRQUpKLEVBSWMsa0JBSmQsRUFJa0MsWUFBVztBQUN6Qyx3Q0FBd0IsS0FBeEIsRUFBK0IsUUFBL0I7QUFDSCxhQU5EO0FBT0Esa0JBQU0sV0FBTixDQUFrQixpQkFBaUIsR0FBakIsR0FBdUIsYUFBekM7O0FBRUEsNEJBQWdCLFdBQWhCLENBQTRCLEdBQTVCLEVBQWlDLFFBQWpDO0FBQ0E7QUFDQSxxQkFBUyxXQUFULENBQXFCLFdBQXJCLEVBQWtDLFNBQWxDLEVBQTZDLFFBQTdDLEVBQXVELEdBQXZELEVBQTRELEtBQTVEO0FBQ0g7QUFDSixLQTFCTDtBQTJCSCxDQTdCRDs7QUErQkEsZ0JBQWdCLFVBQWhCLENBQTJCLFVBQVMsS0FBVCxFQUFnQixPQUFoQixFQUF5QixZQUF6QixFQUF1QyxVQUF2QyxFQUFtRDtBQUMxRSxVQUFNLFFBQU4sQ0FDSSxZQUFZLEVBRGhCLEVBRUk7QUFDSSxZQUFJLEtBRFI7QUFFSSxhQUFLLE9BRlQ7QUFHSSx3QkFBZ0IsWUFIcEI7QUFJSSx3QkFBZ0I7QUFKcEIsS0FGSixFQVFJLFVBQVMsR0FBVCxFQUFjLFNBQWQsRUFBeUIsSUFBekIsRUFBK0I7QUFDM0IsWUFBSSxLQUFKO0FBQ0EsWUFBSSxjQUFjLFlBQVksRUFBOUIsRUFBa0M7QUFDOUIseUJBQWEsS0FBSyxHQUFsQixJQUF5QixTQUF6QjtBQUNBLG9CQUFRLEtBQUssTUFBYjtBQUNBLGlCQUFLLElBQUksSUFBVCxJQUFpQixLQUFqQixFQUF3QjtBQUNwQixvQkFBSSxNQUFNLGNBQU4sQ0FBcUIsSUFBckIsQ0FBSixFQUFnQztBQUM1QixrQ0FBYyxJQUFkLENBQW1CLElBQW5CLEVBQXlCLEtBQUssR0FBOUIsSUFBcUMsTUFBTSxJQUFOLENBQXJDO0FBQ0Esb0NBQWdCLG1CQUFoQixDQUFvQyxDQUFDO0FBQ2pDLDZCQUFLLEtBQUssR0FEdUI7QUFFakMsK0JBQU8sTUFBTSxJQUFOLEtBQWU7QUFGVyxxQkFBRCxDQUFwQyxFQUdJLElBSEosRUFHVSxrQkFIVixFQUc4QixZQUFXO0FBQ3JDLGdEQUF3QixVQUF4QixFQUFvQyxJQUFwQztBQUNILHFCQUxEO0FBTUg7QUFDSjtBQUNELGtCQUFNLDBCQUFOLENBQWlDLGVBQWpDLENBQWlELEtBQUssZUFBdEQ7QUFDSDtBQUNKLEtBMUJMO0FBNEJILENBN0JEOztBQStCQTs7OztBQUlBLFNBQVMsaUJBQVQsQ0FBMkIsTUFBM0IsRUFBbUMsT0FBbkMsRUFBNEM7QUFDeEMsUUFBSSxHQUFKOztBQUNJO0FBQ0Esc0JBQWtCLFFBQVEsTUFBUixDQUFlLElBQWYsR0FBc0IsUUFBUSxNQUFSLENBQWUsSUFBckMsR0FBNEMsT0FBTyxlQUZ6RTtBQUdBLG9CQUFnQixNQUFoQjtBQUNBLGtCQUFjLE9BQWQ7O0FBRUE7QUFDQTtBQUNBLHlCQUNJLE9BQU8sSUFBUCxDQUFZLGNBQWMsSUFBMUIsRUFBZ0MsTUFBaEMsS0FBMkMsQ0FBM0MsSUFBZ0QsS0FBSyxTQUFMLENBQWUsY0FBYyxJQUE3QixNQUF1QyxLQUFLLFNBQUwsQ0FBZSxFQUFmLENBQXZGLEdBQ0ksQ0FBQyxlQUFELENBREosR0FDd0IsT0FBTyxJQUFQLENBQVksY0FBYyxJQUExQixDQUY1Qjs7QUFJQSx5QkFBcUIsbUJBQW1CLElBQW5CLENBQXdCLGFBQXhCLENBQXJCOztBQUVBLFVBQU0sbUJBQW1CLE9BQW5CLENBQTJCLGVBQTNCLENBQU47O0FBRUEsUUFBSSxRQUFRLENBQUMsQ0FBVCxJQUFjLFFBQVEsQ0FBMUIsRUFBNkI7QUFDekI7QUFDQSwyQkFBbUIsTUFBbkIsQ0FBMEIsQ0FBMUIsRUFBNkIsQ0FBN0IsRUFBZ0MsbUJBQW1CLE1BQW5CLENBQTBCLEdBQTFCLEVBQStCLENBQS9CLEVBQWtDLENBQWxDLENBQWhDO0FBQ0g7QUFDSjs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixrQkFBaEIsQ0FBbUMsVUFBUyxPQUFULEVBQWtCLEdBQWxCLEVBQXVCO0FBQ3RELFVBQU0sZ0JBQU4sQ0FBdUIsT0FBdkIsRUFBZ0MsR0FBaEM7QUFDSCxDQUZEOztBQUlBLGdCQUFnQixnQkFBaEIsQ0FBaUMsVUFBUyxHQUFULEVBQWM7QUFDM0MsWUFBUSxHQUFSLENBQVksNENBQVosRUFBMEQsR0FBMUQsRUFBK0QsWUFBWSxFQUEzRTtBQUNBLFVBQU0sY0FBTixDQUFxQixZQUFZLEVBQWpDLEVBQXFDLElBQUksUUFBekM7QUFDSCxDQUhEOztBQUtBLGdCQUFnQixnQkFBaEIsQ0FBaUMsVUFBUyxHQUFULEVBQWM7QUFDM0MsWUFBUSxHQUFSLENBQVksNENBQVosRUFBMEQsR0FBMUQsRUFBK0QsWUFBWSxFQUEzRTtBQUNBLFVBQU0sY0FBTixDQUFxQixZQUFZLEVBQWpDLEVBQXFDLElBQUksT0FBekMsRUFBa0QsSUFBSSxPQUF0RDtBQUNILENBSEQ7O0FBS0EsZ0JBQWdCLFdBQWhCLENBQTRCLFVBQVMsR0FBVCxFQUFjO0FBQ3RDLFlBQVEsR0FBUixDQUFZLHVDQUFaLEVBQXFELEdBQXJELEVBQTBELFlBQVksRUFBdEU7QUFDQSxVQUFNLFNBQU4sQ0FBZ0IsWUFBWSxFQUE1QixFQUFnQztBQUM1QixnQkFBUSxJQUFJLE1BRGdCO0FBRTVCLGdCQUFRLElBQUk7QUFGZ0IsS0FBaEM7QUFJSCxDQU5EOztBQVFBLGdCQUFnQixXQUFoQixDQUE0QixVQUFTLEdBQVQsRUFBYztBQUN0QyxZQUFRLEdBQVIsQ0FBWSx1Q0FBWixFQUFxRCxHQUFyRCxFQUEwRCxZQUFZLEVBQXRFO0FBQ0EsVUFBTSxTQUFOLENBQWdCLFlBQVksRUFBNUIsRUFBZ0MsSUFBSSxHQUFwQyxFQUF5QyxVQUFTLEdBQVQsRUFBYztBQUNuRCxZQUFJLFVBQVUsSUFBSSxLQUFKLENBQVUsR0FBVixFQUFlLENBQWYsQ0FBZDtBQUNBLGFBQUksSUFBSSxJQUFSLElBQWdCLGNBQWMsSUFBOUIsRUFBb0M7QUFDaEMsZ0JBQUksY0FBYyxJQUFkLENBQW1CLGNBQW5CLENBQWtDLElBQWxDLENBQUosRUFBNkM7QUFDekMsdUJBQU8sY0FBYyxJQUFkLENBQW1CLElBQW5CLEVBQXlCLEdBQXpCLENBQVA7QUFDQSx3Q0FBd0IsT0FBeEIsRUFBaUMsSUFBakM7QUFDSDtBQUNKO0FBQ0osS0FSRDtBQVNILENBWEQ7O0FBYUE7QUFDQSxTQUFTLGtCQUFULENBQTRCO0FBQ3hCLHNCQUFrQiwwQkFBUyxJQUFULEVBQWU7QUFDckM7QUFDUSx3QkFBZ0IsUUFBaEIsQ0FBeUIsSUFBekI7QUFDSCxLQUp1QjtBQUt4Qix3QkFBb0IsNEJBQVMsSUFBVCxFQUFlO0FBQ3ZDO0FBQ1Esd0JBQWdCLFFBQWhCLENBQXlCLElBQXpCO0FBQ0gsS0FSdUI7QUFTeEIscUJBQWlCLHlCQUFTLE1BQVQsRUFBaUI7QUFDOUIsd0JBQWdCLGVBQWhCLENBQWdDLE1BQWhDO0FBQ0gsS0FYdUI7QUFZeEI7QUFDQSxpQkFBYSxxQkFBUyxJQUFULEVBQWU7QUFDeEIsMkJBQW1CLElBQW5CLENBQXdCLElBQXhCO0FBQ0EsNkJBQXFCLG1CQUFtQixJQUFuQixDQUF3QixhQUF4QixDQUFyQjtBQUNBLHNCQUFjLElBQWQsQ0FBbUIsSUFBbkIsSUFBMkIsRUFBM0I7QUFDQSx3QkFBZ0IsV0FBaEIsQ0FDRSxPQUFPLElBQVAsQ0FBWSxZQUFaLENBREYsRUFFRSxJQUZGLEVBR0UsbUJBQW1CLE9BQW5CLENBQTJCLElBQTNCLENBSEY7QUFLUjtBQUNRLHdCQUFnQixRQUFoQixDQUF5QixJQUF6QjtBQUNILEtBeEJ1QjtBQXlCeEIsc0JBQWtCLDBCQUFTLE9BQVQsRUFBa0I7QUFDaEMsd0JBQWdCLGdCQUFoQixDQUFpQyxPQUFqQztBQUNILEtBM0J1QjtBQTRCeEIsa0JBQWMsc0JBQVMsU0FBVCxFQUFvQixHQUFwQixFQUF5QixHQUF6QixFQUE4QjtBQUN4QyxjQUFNLDBCQUFOLENBQWlDLFdBQWpDLENBQTZDLEdBQTdDLEVBQWtELEdBQWxEO0FBQ0gsS0E5QnVCO0FBK0J4QixzQkFBa0IsMEJBQVMsU0FBVCxFQUFvQjtBQUNsQyxjQUFNLFdBQU4sQ0FBa0IsU0FBbEIsRUFBNkIsVUFBUyxLQUFULEVBQWdCO0FBQ3pDLGdCQUFJLFVBQVUsS0FBZCxFQUNJLFFBQVEsS0FBUixDQUFjLDREQUFkLEVBQTRFLFlBQVksRUFBeEY7QUFDUCxTQUhEO0FBSUgsS0FwQ3VCO0FBcUN4QixrQkFBYyxzQkFBUyxTQUFULEVBQW9CO0FBQzlCLGNBQU0sV0FBTixDQUFrQixTQUFsQixFQUE2QixVQUFTLEtBQVQsRUFBZ0I7QUFDekMsZ0JBQUksVUFBVSxLQUFkLEVBQXFCO0FBQ2pCLHdCQUFRLElBQVIsQ0FBYSxxQkFBcUIsU0FBckIsR0FBaUMsdUJBQTlDO0FBQ0Esd0JBQVEsS0FBUixDQUFjLE1BQU0sUUFBTixFQUFkO0FBQ0g7QUFDSixTQUxEO0FBTUg7QUE1Q3VCLENBQTVCOztBQStDQTs7O0FBR0EsT0FBTyxpQkFBUCxDQUF5QixZQUF6QixFQUF1QyxZQUFXO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0gsQ0FSRDs7QUFVQTs7OztBQUlBLE9BQU8saUJBQVAsQ0FBeUIsYUFBekIsRUFBd0MsWUFBVztBQUMvQyxZQUFRLEdBQVIsQ0FBWSxpQ0FBaUMsR0FBRyxLQUFILENBQVMsSUFBVCxDQUFjLFNBQWQsQ0FBN0M7QUFDSCxDQUZEOztBQUlBOzs7QUFHQSxPQUFPLGlCQUFQLENBQXlCLFlBQXpCLEVBQXVDLFVBQVMsVUFBVCxFQUFxQixHQUFyQixFQUEwQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSCxDQVBEOztBQVNBLE9BQU8saUJBQVAsQ0FBeUIsaUJBQXpCLEVBQTRDLFVBQVMsVUFBVCxFQUFxQixHQUFyQixFQUEwQjtBQUNsRSxZQUFRLEdBQVIsQ0FBWSxxQ0FBcUMsR0FBRyxLQUFILENBQVMsSUFBVCxDQUFjLFNBQWQsQ0FBakQ7QUFDSCxDQUZEOztBQUlBLE9BQU8saUJBQVAsQ0FBeUIsaUJBQXpCLEVBQTRDLFVBQVMsVUFBVCxFQUFxQixHQUFyQixFQUEwQjtBQUNsRSxZQUFRLEdBQVIsQ0FBWSxxQ0FBcUMsR0FBRyxLQUFILENBQVMsSUFBVCxDQUFjLFNBQWQsQ0FBakQ7QUFDSCxDQUZEOztBQUlBOzs7QUFHQSxPQUFPLGlCQUFQLENBQXlCLGNBQXpCLEVBQXlDLFVBQVMsVUFBVCxFQUFxQixZQUFyQixFQUFtQztBQUN4RSxRQUFJLGVBQWUsWUFBWSxFQUEvQixFQUFtQztBQUMvQixjQUFNLFdBQU4sQ0FBa0IsaUNBQWlDLFlBQW5EO0FBQ0Esd0JBQWdCLFdBQWhCLENBQTRCLFlBQTVCO0FBQ0g7QUFDSixDQUxEOztBQU9BOzs7Ozs7QUFNQSxTQUFTLG9CQUFULENBQThCLFFBQTlCLEVBQXdDLElBQXhDLEVBQThDO0FBQzFDLFFBQUksWUFBWSxDQUFoQjtBQUNBLFdBQU8sSUFBUCxDQUFZLGNBQWMsSUFBZCxDQUFtQixJQUFuQixDQUFaLEVBQXNDLE9BQXRDLENBQThDLFVBQVMsR0FBVCxFQUFjO0FBQ3hELFlBQUksSUFBSSxLQUFKLENBQVUsR0FBVixFQUFlLENBQWYsTUFBc0IsUUFBMUIsRUFBb0M7QUFDaEMseUJBQWEsWUFBWSxrQkFBWixDQUErQixjQUFjLElBQWQsQ0FBbUIsSUFBbkIsRUFBeUIsR0FBekIsQ0FBL0IsQ0FBYjtBQUNIO0FBQ0osS0FKRDtBQUtBLFdBQU8sU0FBUDtBQUNIOztBQUVEOzs7OztBQUtBLFNBQVMsdUJBQVQsQ0FBaUMsS0FBakMsRUFBd0MsSUFBeEMsRUFBOEM7QUFDMUMsb0JBQWdCLHVCQUFoQixDQUF3QztBQUNwQyxZQUFJLEtBRGdDO0FBRXBDLGtCQUFVLElBRjBCO0FBR3BDLGVBQU8scUJBQXFCLEtBQXJCLEVBQTRCLElBQTVCO0FBSDZCLEtBQXhDO0FBS0g7O0FBRUQ7Ozs7O0FBS0EsU0FBUyxtQkFBVCxDQUE2QixJQUE3QixFQUFtQztBQUMvQixRQUFJLGNBQUo7QUFBQSxRQUNJLFdBREo7QUFBQSxRQUVJLGFBQWEsRUFGakI7QUFHQSxTQUFLLElBQUksSUFBVCxJQUFpQixJQUFqQixFQUF1QjtBQUNuQixZQUFJLEtBQUssY0FBTCxDQUFvQixJQUFwQixDQUFKLEVBQStCO0FBQzNCLDBCQUFjLEtBQUssSUFBTCxDQUFkO0FBQ0EsaUJBQUssSUFBSSxHQUFULElBQWdCLFdBQWhCLEVBQTZCO0FBQ3pCLG9CQUFJLFlBQVksY0FBWixDQUEyQixHQUEzQixDQUFKLEVBQXFDO0FBQ2pDLHFDQUFpQixJQUFJLEtBQUosQ0FBVSxHQUFWLEVBQWUsQ0FBZixDQUFqQjtBQUNBLHdCQUFJLFdBQVcsT0FBWCxDQUFtQixjQUFuQixNQUF1QyxDQUFDLENBQTVDLEVBQStDO0FBQzNDLG1DQUFXLElBQVgsQ0FBZ0IsY0FBaEI7QUFDSDtBQUNKO0FBQ0o7QUFDSjtBQUNKO0FBQ0QsV0FBTyxVQUFQO0FBQ0g7O0FBR0Q7Ozs7OztBQU1BLFNBQVMsa0JBQVQsQ0FBNEIsUUFBNUIsRUFBc0M7QUFDbEMsV0FBTyxJQUFQLENBQVksY0FBYyxJQUExQixFQUFnQyxPQUFoQyxDQUF3QyxVQUFTLElBQVQsRUFBZTtBQUNuRCxZQUFJLFdBQVcsY0FBYyxJQUFkLENBQW1CLElBQW5CLENBQWY7QUFDQSxlQUFPLElBQVAsQ0FBWSxRQUFaLEVBQXNCLE9BQXRCLENBQThCLFVBQVMsR0FBVCxFQUFjO0FBQ3hDLGdCQUFJLElBQUksS0FBSixDQUFVLEdBQVYsRUFBZSxDQUFmLE1BQXNCLFFBQTFCLEVBQW9DO0FBQ2hDLHVCQUFPLFNBQVMsR0FBVCxDQUFQO0FBQ0g7QUFDSixTQUpEO0FBS0gsS0FQRDtBQVFIOztBQUVELFNBQVMsc0JBQVQsQ0FBZ0MsZ0JBQWhDLEVBQWtELE9BQWxELEVBQTJEO0FBQ3ZEO0FBQ0EsWUFBUSxHQUFSLENBQVksMENBQVosRUFBd0QsZ0JBQXhEO0FBQ0E7QUFDQSxzQkFBa0IsZ0JBQWxCLEVBQW9DLE9BQXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQWdCLFNBQWhCO0FBQ0EsVUFBTSxXQUFOLENBQWtCLElBQWxCLENBQXVCLGdCQUF2QjtBQUNIOztBQUVELFNBQVMsYUFBVCxDQUF1QixXQUF2QixFQUFvQyxPQUFwQyxFQUE2QyxFQUE3QyxFQUFpRDtBQUM3QyxRQUFJLGFBQWEsb0JBQW9CLFlBQVksSUFBaEMsQ0FBakI7O0FBRUEsMkJBQXVCLFdBQXZCLEVBQW9DLE9BQXBDOztBQUVBLFdBQU8sSUFBUCxDQUFZLFlBQVksSUFBeEIsRUFBOEIsT0FBOUIsQ0FBc0MsVUFBUyxJQUFULEVBQWU7QUFDakQsWUFBSSxNQUFKO0FBQUEsWUFBWSxRQUFRLEVBQXBCO0FBQ0EsZUFBTyxJQUFQLENBQVksWUFBWSxJQUFaLENBQWlCLElBQWpCLENBQVosRUFBb0MsT0FBcEMsQ0FBNEMsVUFBUyxHQUFULEVBQWM7QUFDdEQsa0JBQU0sSUFBTixDQUFXO0FBQ1AscUJBQUssR0FERTtBQUVQLHVCQUFPLFlBQVksSUFBWixDQUFpQixJQUFqQixFQUF1QixHQUF2QjtBQUZBLGFBQVg7QUFJSCxTQUxEO0FBTUEsaUJBQVMsTUFBTSxJQUFOLENBQVcsU0FBWCxDQUFUOztBQUVBLGVBQU8sT0FBUCxDQUFlLFVBQVMsSUFBVCxFQUFlO0FBQzFCLHlCQUFhLEtBQUssR0FBbEIsSUFBeUIsU0FBekI7QUFDSCxTQUZEOztBQUlBO0FBQ0Esd0JBQWdCLG1CQUFoQixDQUFvQyxNQUFwQyxFQUE0QyxJQUE1QyxFQUFrRCxrQkFBbEQsRUFBc0UsTUFBTSxZQUFXLENBQUUsQ0FBekY7O0FBRUEsbUJBQVcsT0FBWCxDQUFtQixVQUFTLFFBQVQsRUFBbUI7QUFDbEMsb0NBQXdCLFFBQXhCLEVBQWtDLElBQWxDO0FBQ0gsU0FGRDtBQUdILEtBcEJEO0FBcUJIOztBQUVELE9BQU8sT0FBUCxHQUFpQjtBQUNiLG9CQUFnQix3QkFBUyxPQUFULEVBQWtCLE9BQWxCLEVBQTJCO0FBQ3ZDLGNBQU0sV0FBTixDQUFrQixzQkFBc0IsT0FBdEIsR0FBZ0MsTUFBaEMsR0FBeUMsT0FBekMsR0FBbUQsR0FBckU7QUFDQSx3QkFBZ0IsY0FBaEIsQ0FBK0IsT0FBL0IsRUFBd0MsT0FBeEMsRUFBaUQsa0JBQWpEO0FBQ0gsS0FKWTtBQUtiLG9CQUFnQix3QkFBUyxPQUFULEVBQWtCO0FBQzlCLGNBQU0sV0FBTixDQUFrQixzQkFBc0IsT0FBdEIsR0FBZ0MsR0FBbEQ7QUFDQSwyQkFBbUIsT0FBbkI7QUFDQSx3QkFBZ0IsY0FBaEIsQ0FBK0IsT0FBL0I7QUFDSCxLQVRZO0FBVWI7Ozs7O0FBS0EsZUFBVyxtQkFBUyxNQUFULEVBQWlCLE1BQWpCLEVBQXlCO0FBQ2hDLFlBQUksTUFBSixFQUFZO0FBQ1Isa0JBQU0sV0FBTixDQUFrQixrQ0FBa0MsTUFBbEMsR0FBMkMsTUFBM0MsR0FBb0QsTUFBdEU7QUFDQSw0QkFBZ0IsU0FBaEIsQ0FBMEIsTUFBMUIsRUFBa0MsTUFBbEMsRUFBMEMsa0JBQTFDO0FBQ0gsU0FIRCxNQUdPO0FBQ0gsa0JBQU0sV0FBTixDQUFrQixxQkFBbEI7QUFDSDtBQUNKLEtBdEJZO0FBdUJiLGVBQVcsbUJBQVMsR0FBVCxFQUFjO0FBQ3JCLGNBQU0sV0FBTixDQUFrQix5QkFBbEIsRUFBNkMsR0FBN0M7QUFDQSx3QkFBZ0IsU0FBaEIsQ0FBMEIsR0FBMUI7QUFDSCxLQTFCWTtBQTJCYixrQkFBYyxzQkFBUyxZQUFULEVBQXVCO0FBQ2pDLGNBQU0sV0FBTixDQUFrQixpQ0FBaUMsWUFBbkQ7QUFDQSx3QkFBZ0IsV0FBaEIsQ0FBNEIsWUFBNUI7QUFDSCxLQTlCWTtBQStCYjs7OztBQUlBLG1CQUFlLHVCQUFTLFdBQVQsRUFBc0IsT0FBdEIsRUFBK0I7QUFDMUMsMkJBQW1CLFlBQVksa0JBQS9CO0FBQ0EsWUFBSSxTQUFTLElBQUksU0FBSixLQUFrQixJQUFJLFNBQUosR0FBZ0IsT0FBaEIsQ0FBd0IsR0FBeEIsRUFBNkIsRUFBN0IsQ0FBbEIsR0FBcUQsS0FBbEU7QUFDQSxzQkFBYyxXQUFkLEVBQTJCLE9BQTNCLEVBQW9DLFVBQVMsTUFBVCxFQUFpQjtBQUNqRCxnQkFBSSxNQUFKLEVBQVk7QUFDUixvQkFBSSxXQUFXLE1BQWYsRUFBdUI7QUFDbkIsd0JBQUksTUFBTSxTQUFTLGNBQVQsQ0FBd0IsZ0JBQWdCLE1BQWhCLENBQXVCLFNBQXZCLEdBQW1DLE1BQTNELENBQVY7QUFDQTtBQUNBLHdCQUFJLEdBQUosRUFBUztBQUNMLGlDQUFTLFdBQVQsQ0FBcUIsYUFBckIsRUFBb0MsSUFBSSxTQUFKLEVBQXBDO0FBQ0EsbUNBQVcsWUFBVztBQUNsQixnQ0FBSSxXQUFXLFNBQVMsSUFBVCxDQUFjLHFCQUFkLEVBQWY7QUFBQSxnQ0FDSSxXQUFXLElBQUkscUJBQUosRUFEZjtBQUFBLGdDQUVJLFNBQVMsU0FBUyxHQUFULEdBQWUsU0FBUyxHQUZyQztBQUdBLG1DQUFPLFFBQVAsQ0FBZ0IsQ0FBaEIsRUFBbUIsTUFBbkI7QUFDSCx5QkFMRCxFQUtHLElBTEg7QUFNSDtBQUNKO0FBQ0o7QUFDSixTQWhCRDtBQWlCQTtBQUNBLGNBQU0sMEJBQU4sQ0FBaUMsZUFBakMsQ0FBaUQsWUFBWSxlQUE3RDtBQUNBLGVBQU8sSUFBUCxDQUFZLFlBQVksTUFBeEIsRUFBZ0MsT0FBaEMsQ0FBd0MsVUFBUyxHQUFULEVBQWM7QUFDbEQ7QUFDQSxnQkFBTSxNQUFNLFlBQVksTUFBWixDQUFtQixHQUFuQixFQUF3QixDQUF4QixNQUErQixHQUEvQixHQUFxQyxZQUFZLE1BQVosQ0FBbUIsR0FBbkIsQ0FBckMsU0FBbUUsUUFBUSxFQUEzRSxTQUFpRixZQUFZLE1BQVosQ0FBbUIsR0FBbkIsQ0FBN0Y7QUFDQSxrQkFBTSwwQkFBTixDQUFpQyxXQUFqQyxDQUE2QyxHQUE3QyxFQUFrRCxHQUFsRDtBQUNILFNBSkQ7QUFLSCxLQTlEWTtBQStEYix5QkFBcUIsNkJBQVMsV0FBVCxFQUFzQixPQUF0QixFQUErQjtBQUNoRCwyQkFBbUIsWUFBWSxrQkFBL0I7QUFDQSxzQkFBYyxXQUFkLEVBQTJCLE9BQTNCO0FBQ0g7QUFsRVksQ0FBakI7Ozs7O0FDM2JBOzs7O0FBSUEsSUFBSSxRQUFRLFFBQVEsT0FBUixDQUFaO0FBQUEsSUFDSSxTQUFTLE1BQU0sTUFEbkI7QUFBQSxJQUVJLGlCQUFpQixNQUFNLGNBRjNCO0FBQUEsSUFHSSxXQUFXLFFBQVEsc0JBQVIsQ0FIZjtBQUFBLElBSUksUUFKSjtBQUFBLElBS0ksV0FMSjtBQU1BOzs7O0FBSUEsU0FBUyxRQUFULENBQWtCLElBQWxCLEVBQXdCLGNBQXhCLEVBQXdDO0FBQ3BDLFFBQUksTUFBTSwyQkFBMkIsWUFBWSxFQUF2QyxHQUE0QyxPQUE1QyxHQUFzRCxRQUF0RCxHQUFpRSxXQUFqRSxHQUErRSxZQUFZLElBQXJHO0FBQUEsUUFDSSxNQUFNLElBQUksY0FBSixFQURWO0FBQUEsUUFFSSxLQUFLLElBQUksUUFBSixFQUZUOztBQUlBLFFBQUksSUFBSixDQUFTLE1BQVQsRUFBaUIsR0FBakIsRUFBc0IsSUFBdEI7QUFDQSxRQUFJLGtCQUFKLEdBQXlCLFlBQVc7QUFDaEMsWUFBSSxJQUFKO0FBQ0EsWUFBSSxJQUFJLFVBQUosSUFBa0IsQ0FBbEIsSUFBdUIsSUFBSSxNQUFKLElBQWMsR0FBekMsRUFBOEM7QUFDMUM7QUFDQSxtQkFBTyxLQUFLLEtBQUwsQ0FBVyxJQUFJLFlBQWYsQ0FBUDtBQUNBLDhCQUFrQixlQUFlLElBQWYsQ0FBbEIsQ0FIMEMsQ0FHRjtBQUN4QztBQUNBLG9CQUFRLEdBQVIsQ0FBWSxJQUFaO0FBQ0EscUJBQVMsV0FBVCxDQUFxQixjQUFyQixFQUFxQyxZQUFZLEVBQWpELEVBQXFELFFBQXJELEVBQStELEtBQUssSUFBcEU7QUFDSDtBQUNKLEtBVkQ7QUFXQSxPQUFHLE1BQUgsQ0FBVSxRQUFWLEVBQW9CLElBQXBCO0FBQ0E7QUFDQSxRQUFJLElBQUosQ0FBUyxFQUFUO0FBQ0g7O0FBRUQ7Ozs7QUFJQSxTQUFTLGdCQUFULENBQTBCLElBQTFCLEVBQWdDLE9BQWhDLEVBQXlDO0FBQ3JDLGtCQUFjLE9BQWQ7QUFDSDs7QUFFRCxTQUFTLGtCQUFULENBQTRCO0FBQ3hCLG9CQUFpQix3QkFBVSxFQUFWLEVBQWM7QUFDM0IsbUJBQVcsRUFBWDtBQUNBLHVCQUFlLElBQWYsQ0FBb0IsWUFBcEI7QUFDSDtBQUp1QixDQUE1Qjs7QUFPQSxPQUFPLFFBQVAsQ0FBZ0IsVUFBVSxJQUFWLEVBQWdCO0FBQzVCO0FBQ0EsWUFBUSxHQUFSLENBQVksbUNBQVosRUFBaUQsUUFBakQsRUFBMkQsSUFBM0Q7QUFDQSxhQUFTLElBQVQ7QUFDSCxDQUpEOztBQU1BLE9BQU8sT0FBUCxHQUFpQjtBQUNiLHlCQUFzQixnQkFEVDtBQUViLG1CQUFnQjtBQUZILENBQWpCOzs7OztBQzFEQSxJQUFJLFFBQVEsUUFBUSxVQUFSLENBQVo7QUFBQSxJQUNJLFdBQVcsUUFBUSxtQkFBUixDQURmO0FBQUEsSUFFSSxNQUFNLFFBQVEsYUFBUixDQUZWO0FBR0E7OztBQUdBLFNBQVMsZUFBVCxDQUF5QixRQUF6QixFQUFtQyxPQUFuQyxFQUEyQztBQUN2QyxhQUFTLEtBQVQsR0FBaUIsU0FBUyxTQUExQjtBQUNBLFdBQU8sT0FBUCxDQUFlLFNBQWYsQ0FBeUI7QUFDckIsZ0JBQVEsU0FBUyxJQURJO0FBRXJCLHFCQUFhLFNBQVMsU0FGRDtBQUdyQixZQUFLLFNBQVMsRUFITztBQUlyQixtQkFBWSxTQUFTO0FBSkEsS0FBekIsRUFLRSxFQUxGLEVBS00sVUFBVSxJQUFJLFNBQUosRUFMaEI7QUFNSDs7QUFFRDs7OztBQUlBLFNBQVMsZ0JBQVQsQ0FBMEIsSUFBMUIsRUFBZ0MsT0FBaEMsRUFBeUM7QUFDckM7QUFDQSxRQUFJLFFBQVEsSUFBWixFQUFrQjtBQUNkLHdCQUFnQjtBQUNaLHVCQUFZLFFBQVEsRUFEUjtBQUVaLGtCQUFLLEVBRk87QUFHWixnQkFBSyxRQUFRLEVBSEQ7QUFJWix1QkFBWTtBQUNaO0FBTFksU0FBaEIsRUFNRyxNQUFNLFFBQVEsRUFBZCxHQUFtQixNQU50QjtBQU9IO0FBQ0o7O0FBRUQsU0FBUyxrQkFBVCxDQUE0QjtBQUN4QixpQkFBYyxxQkFBVSxFQUFWLEVBQWM7QUFDeEI7QUFDQSxlQUFPLE9BQVAsQ0FBZSxTQUFmLENBQXlCLElBQXpCLEVBQStCLElBQS9CLEVBQXFDLEVBQXJDO0FBQ0g7QUFKdUIsQ0FBNUI7O0FBT0EsT0FBTyxVQUFQLEdBQW9CLFVBQVUsQ0FBVixFQUFhO0FBQ2pDO0FBQ0ksUUFBSSxFQUFFLEtBQU4sRUFBYTtBQUNULFlBQUksRUFBRSxLQUFGLENBQVEsU0FBWixFQUF1QjtBQUNuQixrQkFBTSxXQUFOLENBQWtCLEVBQUUsS0FBRixDQUFRLEVBQTFCLEVBQThCLFVBQVUsR0FBVixFQUFlO0FBQ3pDLG9CQUFJLFFBQVEsS0FBWixFQUNJLFFBQVEsS0FBUixDQUFjLGlEQUFkLEVBQWlFLEVBQUUsS0FBRixDQUFRLEVBQXpFO0FBQ1AsYUFIRDtBQUlILFNBTEQsTUFLTztBQUNILGtCQUFNLFlBQU4sQ0FBbUIsRUFBRSxLQUFGLENBQVEsRUFBM0IsRUFBK0IsVUFBVSxHQUFWLEVBQWU7QUFDMUMsb0JBQUksUUFBUSxLQUFaLEVBQW1CO0FBQ2Y7QUFDQSw2QkFBUyxXQUFULENBQXFCLGtCQUFyQjtBQUNILGlCQUhELE1BR087QUFDSCw0QkFBUSxHQUFSLENBQVksc0VBQVosRUFBb0YsRUFBRSxLQUFGLENBQVEsRUFBNUY7QUFDSDtBQUNKLGFBUEQ7QUFRSDtBQUNKO0FBQ0osQ0FuQkQ7O0FBcUJBOzs7Ozs7QUFNQSxPQUFPLE9BQVAsR0FBaUI7QUFDYixtQkFBZ0IsZ0JBREg7QUFFYix5QkFBc0IsZ0JBRlQ7QUFHYixrQkFBYyxzQkFBVSxJQUFWLEVBQWdCO0FBQzFCLHdCQUFnQjtBQUNaLHVCQUFZLHNCQURBO0FBRVosa0JBQUssRUFGTztBQUdaLGdCQUFLLEtBQUssZ0JBSEU7QUFJWix1QkFBWTtBQUpBLFNBQWhCLEVBS0csS0FBSyxnQkFMUjtBQU1IO0FBVlksQ0FBakI7Ozs7O0FDbkVBOzs7Ozs7Ozs7Ozs7OztBQWNBLElBQUksU0FBVSxZQUFZO0FBQ3RCOztBQUNBLFFBQUksYUFBYSxFQUFqQjtBQUFBLFFBQ0ksWUFBWSxTQUFaLFNBQVksQ0FBVSxJQUFWLEVBQWdCLElBQWhCLEVBQXNCO0FBQzlCLGdCQUFRLEdBQVIsQ0FBWSx1QkFBWixFQUFxQyxJQUFyQyxFQUEyQyxjQUEzQyxFQUEyRCxJQUEzRDtBQUNBLFlBQUksV0FBVyxjQUFYLENBQTBCLElBQTFCLENBQUosRUFBcUM7QUFDakMsdUJBQVcsSUFBWCxFQUFpQixHQUFqQixDQUFxQixVQUFVLEVBQVYsRUFBYztBQUMvQixtQkFBRyxLQUFILENBQVMsSUFBVCxFQUFlLElBQWY7QUFDSCxhQUZEO0FBR0g7QUFDSixLQVJMO0FBU0EsV0FBTztBQUNILHNCQUFlO0FBQ1g7QUFDQSxzQkFBVyxvQkFBWTtBQUNuQiwwQkFBVSxVQUFWLEVBQXNCLEdBQUcsS0FBSCxDQUFTLElBQVQsQ0FBYyxTQUFkLENBQXRCO0FBQ0gsYUFKVTtBQUtYO0FBQ0EsMEJBQWUsd0JBQVk7QUFDdkIsMEJBQVUsY0FBVixFQUEwQixHQUFHLEtBQUgsQ0FBUyxJQUFULENBQWMsU0FBZCxDQUExQjtBQUNILGFBUlU7QUFTWCx3QkFBYSxvQkFBVSxTQUFWLEVBQXFCLFFBQXJCLEVBQStCLE9BQS9CLEVBQXdDLFFBQXhDLEVBQWtEO0FBQzNELDBCQUFVLFlBQVYsRUFBd0IsQ0FBRSxTQUFGLEVBQWEsUUFBYixFQUF1QixPQUF2QixFQUFnQyxRQUFoQyxDQUF4QjtBQUNILGFBWFU7QUFZWCx5QkFBYyxxQkFBUyxTQUFULEVBQW9CLElBQXBCLEVBQTBCO0FBQ3BDLDBCQUFVLGFBQVYsRUFBeUIsQ0FBQyxTQUFELEVBQVksSUFBWixDQUF6QjtBQUNILGFBZFU7QUFlWCx3QkFBYSxvQkFBUyxTQUFULEVBQW9CLFVBQXBCLEVBQWdDLFVBQWhDLEVBQTRDO0FBQ3JELDBCQUFVLFlBQVYsRUFBd0IsQ0FBRSxTQUFGLEVBQWEsVUFBYixFQUF5QixVQUF6QixDQUF4QjtBQUNILGFBakJVO0FBa0JYOzs7O0FBSUEsd0JBQWEsb0JBQVUsU0FBVixFQUFxQixPQUFyQixFQUE4QjtBQUN2QywwQkFBVSxZQUFWLEVBQXdCLENBQUUsU0FBRixFQUFhLE9BQWIsQ0FBeEI7QUFDSCxhQXhCVTtBQXlCWCwwQkFBZSxzQkFBVSxTQUFWLEVBQXFCLFlBQXJCLEVBQW1DO0FBQzlDLDBCQUFVLGNBQVYsRUFBMEIsQ0FBRSxTQUFGLEVBQWEsWUFBYixDQUExQjtBQUNILGFBM0JVO0FBNEJYLGtDQUF1Qiw4QkFBVSxTQUFWLEVBQXFCO0FBQ3hDLDBCQUFVLHNCQUFWLEVBQWtDLENBQUUsU0FBRixDQUFsQztBQUNILGFBOUJVO0FBK0JYLDZCQUFrQix5QkFBVSxTQUFWLEVBQXFCLE9BQXJCLEVBQThCLE9BQTlCLEVBQXVDO0FBQ3JELDBCQUFVLGlCQUFWLEVBQTZCLENBQUUsU0FBRixFQUFhLE9BQWIsRUFBc0IsT0FBdEIsQ0FBN0I7QUFDSCxhQWpDVTtBQWtDWCw2QkFBa0IseUJBQVUsU0FBVixFQUFxQixPQUFyQixFQUE4QjtBQUM1QywwQkFBVSxpQkFBVixFQUE2QixDQUFFLFNBQUYsRUFBYSxPQUFiLENBQTdCO0FBQ0gsYUFwQ1U7QUFxQ1gsaUNBQXNCLDZCQUFVLFdBQVYsRUFBdUI7QUFDekMsMEJBQVUscUJBQVYsRUFBaUMsQ0FBRSxXQUFGLENBQWpDO0FBQ0gsYUF2Q1U7QUF3Q1gsdUNBQTRCLG1DQUFVLFNBQVYsRUFBcUIsRUFBckIsRUFBeUIsV0FBekIsRUFBc0M7QUFDOUQsMEJBQVUsMkJBQVYsRUFBdUMsQ0FBRSxTQUFGLEVBQWEsRUFBYixFQUFpQixXQUFqQixDQUF2QztBQUNIO0FBMUNVLFNBRFo7QUE2Q0gsMkJBQW9CLDJCQUFVLElBQVYsRUFBZ0IsRUFBaEIsRUFBb0I7QUFDcEMsZ0JBQUksV0FBVyxjQUFYLENBQTBCLElBQTFCLENBQUosRUFBcUM7QUFDakMsMkJBQVcsSUFBWCxFQUFpQixJQUFqQixDQUFzQixFQUF0QjtBQUNILGFBRkQsTUFFTztBQUNILDJCQUFXLElBQVgsSUFBbUIsQ0FBQyxFQUFELENBQW5CO0FBQ0g7QUFDSjtBQW5ERSxLQUFQO0FBcURILENBaEVhLEVBQWQ7O0FBa0VBLE9BQU8sT0FBUCxHQUFpQixNQUFqQjs7Ozs7QUNoRkEsSUFBTSxJQUFJLFFBQVEsU0FBUixDQUFWO0FBQ0EsSUFBTSxpQkFBaUIsUUFBUSw0QkFBUixDQUF2Qjs7QUFFQTs7Ozs7OztBQU9BLE9BQU8sT0FBUCxHQUFpQixTQUFTLG9CQUFULEdBQWdDO0FBQzdDLFFBQU0sbUJBQW1CLGVBQWU7QUFDcEMsa0JBQVc7QUFBQSxtQkFBTSxTQUFTLE1BQVQsRUFBTjtBQUFBLFNBRHlCO0FBRXBDLGlCQUFVO0FBQUEsbUJBQU0saUJBQWlCLE9BQWpCLEVBQU47QUFBQTtBQUYwQixLQUFmLENBQXpCO0FBSUEsUUFBTSxXQUFXLFlBQVksWUFBVztBQUNwQyxjQUFNLFNBQVMsUUFBVCxHQUFvQixJQUFwQixHQUEyQixTQUFTLElBQXBDLEdBQTJDLGVBQWpELEVBQWtFO0FBQzlELHlCQUFhO0FBRGlELFNBQWxFLEVBRUcsSUFGSCxDQUVRLGFBQUs7QUFDVCxnQkFBSSxFQUFFLE1BQUYsS0FBYSxHQUFqQixFQUFzQjtBQUNsQiw4QkFBYyxRQUFkO0FBQ0E7QUFDQSxpQ0FBaUIsTUFBakIsQ0FBd0IsTUFBeEI7QUFDSDtBQUNKLFNBUkQsRUFRRyxLQVJILENBUVMsYUFBSztBQUNWLDBCQUFjLFFBQWQ7QUFDQSw2QkFBaUIsTUFBakIsQ0FBd0IsYUFBeEIsRUFBdUMsMEVBQXZDO0FBQ0gsU0FYRDtBQVlILEtBYmdCLEVBYWQsRUFBRSxPQUFGLENBQVUsc0JBYkksQ0FBakI7QUFjSCxDQW5CRDs7Ozs7QUNWQTtBQUNBO0FBQ0EsSUFBTSxVQUFVLFFBQVEsY0FBUixDQUFoQjtBQUNBLElBQU0sUUFBUSxRQUFRLFlBQVIsQ0FBZDtBQUNBLElBQU0sUUFBUSxRQUFRLE9BQVIsQ0FBZDtBQUNBLElBQU0sUUFBUSxRQUFRLFlBQVIsQ0FBZDtBQUNBLElBQU0sdUJBQXVCLFFBQVEsd0JBQVIsQ0FBN0I7QUFDQSxJQUFNLHVCQUF1QixRQUFRLHNDQUFSLENBQTdCOztlQUM0QixRQUFRLFNBQVIsQztJQUFwQixlLFlBQUEsZTs7QUFFUixPQUFPLE9BQVAsR0FBaUIsT0FBTyxPQUFQLElBQWtCLFFBQVEsVUFBUixDQUFuQztBQUNBO0FBQ0EsT0FBTyxLQUFQLEdBQWUsS0FBZjs7QUFFQSxNQUFNLEdBQU4sQ0FBVSxRQUFWLEVBQTRCLFFBQVEsa0JBQVIsQ0FBNUI7QUFDQSxNQUFNLEdBQU4sQ0FBVSxTQUFWLEVBQTRCLFFBQVEsbUJBQVIsQ0FBNUI7QUFDQSxNQUFNLEdBQU4sQ0FBVSxPQUFWLEVBQTRCLFFBQVEsaUJBQVIsQ0FBNUI7QUFDQSxNQUFNLEdBQU4sQ0FBVSxhQUFWLEVBQTRCLFFBQVEsdUJBQVIsRUFBaUMsYUFBakMsQ0FBNUI7QUFDQSxNQUFNLEdBQU4sQ0FBVSxnQkFBVixFQUE0QixRQUFRLCtCQUFSLENBQTVCO0FBQ0EsTUFBTSxHQUFOLENBQVUsWUFBVixFQUE0QixRQUFRLGlCQUFSLENBQTVCO0FBQ0EsTUFBTSxHQUFOLENBQVUsZUFBVixFQUE0QixRQUFRLHlCQUFSLENBQTVCOztBQUVBLE1BQU0sR0FBTixDQUFVLE9BQVYsRUFBb0MsUUFBUSxzQkFBUixDQUFwQztBQUNBLE1BQU0sR0FBTixDQUFVLE1BQVYsRUFBb0MsUUFBUSxxQkFBUixDQUFwQztBQUNBLE1BQU0sR0FBTixDQUFVLHVCQUFWLEVBQW9DLFFBQVEsc0NBQVIsQ0FBcEM7QUFDQSxNQUFNLEdBQU4sQ0FBVSxpQkFBVixFQUFvQyxRQUFRLGdDQUFSLENBQXBDO0FBQ0EsTUFBTSxHQUFOLENBQVUsNEJBQVYsRUFBd0MsUUFBUSwyQ0FBUixDQUF4QztBQUNBO0FBQ0EsTUFBTSxHQUFOLENBQVUsYUFBVixFQUFvQyxRQUFRLDRCQUFSLENBQXBDO0FBQ0EsTUFBTSxHQUFOLENBQVUsaUJBQVYsRUFBb0MsUUFBUSxnQ0FBUixDQUFwQztBQUNBLE1BQU0sR0FBTixDQUFVLGtCQUFWLEVBQW9DLFFBQVEsaUNBQVIsQ0FBcEM7QUFDQSxNQUFNLEdBQU4sQ0FBVSxXQUFWLEVBQW9DLFFBQVEsMEJBQVIsQ0FBcEM7QUFDQSxNQUFNLEdBQU4sQ0FBVSxZQUFWLEVBQW9DLFFBQVEsMkJBQVIsQ0FBcEM7QUFDQTtBQUNBLE1BQU0sR0FBTixDQUFVLFdBQVYsRUFBdUMsUUFBUSxnQ0FBUixDQUF2Qzs7QUFFQSxNQUFNLEdBQU4sQ0FBVSw0QkFBVixFQUF3QyxRQUFRLDJDQUFSLENBQXhDO0FBQ0EsTUFBTSxHQUFOLENBQVUsUUFBVixFQUFvQyxRQUFRLHVCQUFSLENBQXBDO0FBQ0EsTUFBTSxHQUFOLENBQVUsY0FBVixFQUFvQyxRQUFRLDZCQUFSLENBQXBDO0FBQ0EsTUFBTSxHQUFOLENBQVUsWUFBVixFQUFrQyxRQUFRLDJCQUFSLENBQWxDO0FBQ0EsTUFBTSxHQUFOLENBQVUsY0FBVixFQUFvQyxRQUFRLDBCQUFSLENBQXBDOztBQUVBLE1BQU0sYUFBTixDQUFvQixRQUFRLGlEQUFSLENBQXBCO0FBQ0EsTUFBTSxhQUFOLENBQW9CLFFBQVEsc0NBQVIsQ0FBcEI7QUFDQSxNQUFNLGFBQU4sQ0FBb0IsUUFBUSwyQ0FBUixDQUFwQjtBQUNBLE1BQU0sYUFBTixDQUFvQixRQUFRLHNDQUFSLENBQXBCO0FBQ0EsTUFBTSxhQUFOLENBQW9CLFFBQVEsZ0NBQVIsQ0FBcEI7QUFDQSxNQUFNLGFBQU4sQ0FBb0IsUUFBUSwyQ0FBUixDQUFwQjtBQUNBLE1BQU0sYUFBTixDQUFvQixRQUFRLDRDQUFSLENBQXBCO0FBQ0EsTUFBTSxhQUFOLENBQW9CLG9CQUFwQjtBQUNBLE1BQU0sYUFBTixDQUFvQixRQUFRLGdDQUFSLENBQXBCO0FBQ0EsTUFBTSxhQUFOLENBQW9CLFFBQVEscUNBQVIsQ0FBcEI7QUFDQSxNQUFNLGFBQU4sQ0FBb0IsUUFBUSxrQ0FBUixDQUFwQjtBQUNBLE1BQU0sYUFBTixDQUFvQixRQUFRLHdDQUFSLENBQXBCO0FBQ0EsTUFBTSxhQUFOLENBQW9CLFFBQVEsc0NBQVIsQ0FBcEI7QUFDQTtBQUNBLE1BQU0sYUFBTixDQUFvQixRQUFRLGtDQUFSLENBQXBCOztBQUVBLE1BQU0sS0FBTixDQUFZLFlBQVk7QUFDcEI7QUFDQTs7QUFDQSxVQUFNLFVBQU4sQ0FBaUIsVUFBVSxVQUFWLEVBQXNCLGVBQXRCLEVBQXVDOztBQUVwRCxZQUFJLGVBQWUsSUFBbkIsRUFBeUI7QUFDckIsa0JBQU0sOENBQU47QUFDQSxxQkFBUyxNQUFUO0FBQ0E7QUFDSDtBQUNELGNBQU0sS0FBTixDQUFZLFFBQVosQ0FBcUIsRUFBQyxVQUFVLFdBQVcsSUFBdEIsRUFBckI7O0FBRUEsWUFBSSxXQUFXLE9BQWYsRUFBd0I7QUFDcEIscUJBQVMsSUFBVCxDQUFjLFNBQWQsQ0FBd0IsR0FBeEIsQ0FBNEIsU0FBNUI7QUFDSDs7QUFFRCxZQUFJLGVBQUosRUFBcUI7QUFDakI7QUFDQTtBQUNIO0FBRUosS0FsQkQ7QUFtQkgsQ0F0QkQ7O0FBd0JBLE9BQU8sS0FBUCxHQUFlLEtBQWY7QUFDQSxPQUFPLE9BQVAsR0FBaUIsUUFBUSxVQUFSLENBQWpCO0FBQ0EsT0FBTyxPQUFQLEdBQWlCLE9BQWpCO0FBQ0EsT0FBTyxLQUFQLEdBQWUsS0FBZjs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxLQUFOLENBQVksWUFBWTtBQUNwQjs7QUFDQSxRQUFNLE1BQU8sU0FBUyw0QkFBVCxHQUF3QztBQUNqRCxZQUFNLFFBQVEsU0FBUyxRQUFULENBQWtCLEtBQWxCLENBQXdCLEdBQXhCLENBQWQ7QUFDQSxZQUFJLE9BQU8sU0FBUyxRQUFwQjtBQUNBLFlBQUksZ0JBQUo7O0FBRUEsWUFBSSxRQUFRLElBQVIsQ0FBYSxNQUFNLE1BQU0sTUFBTixHQUFlLENBQXJCLENBQWIsQ0FBSixFQUEyQztBQUN2QztBQUNBLHNCQUFVLEtBQUssT0FBTCxDQUFhLE1BQWIsRUFBcUIsRUFBckIsRUFBeUIsT0FBekIsQ0FBaUMsR0FBakMsRUFBc0MsRUFBdEMsQ0FBVjtBQUNBLG1CQUFPLE1BQU0sS0FBTixDQUFZLENBQVosRUFBZSxDQUFDLENBQWhCLEVBQW1CLElBQW5CLENBQXdCLEdBQXhCLENBQVA7QUFDSDs7QUFFRCxZQUFJLEtBQUssQ0FBTCxNQUFZLEdBQWhCLEVBQXFCO0FBQ2pCLG1CQUFPLE1BQU0sSUFBYjtBQUNIOztBQUVELGVBQU87QUFDSCxrQkFBTyxJQURKO0FBRUgsdUJBQVk7QUFGVCxTQUFQO0FBSUgsS0FuQlksRUFBYjs7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLFFBQUksSUFBSSxTQUFSLEVBQW1CO0FBQ2Y7QUFDQTtBQUNBLGNBQU0sV0FBTixDQUFrQixJQUFJLFNBQXRCLEVBQWlDLFVBQVUsR0FBVixFQUFlLElBQWYsRUFBcUIsT0FBckIsRUFBOEI7QUFDM0Q7QUFDQSxnQkFBSSxRQUFRLElBQVosRUFBa0I7QUFDZCxzQkFBTSxXQUFOLENBQWtCLHVCQUF1QixJQUFJLFNBQTNCLEdBQXVDLHFDQUF6RDtBQUNBLHdCQUFRLEtBQVIsQ0FBYyw0REFBZCxFQUE0RSxJQUFJLFNBQWhGO0FBQ0gsYUFIRCxNQUdPO0FBQ0g7QUFDQSxxQ0FBcUIsT0FBckIsQ0FBNkIsUUFBUSxHQUFyQztBQUNIO0FBQ0osU0FURDtBQVVILEtBYkQsTUFhTztBQUNILGNBQU0sWUFBTixDQUFtQixJQUFJLElBQXZCLEVBQTZCLFVBQVUsR0FBVixFQUFlLENBQUcsQ0FBL0M7QUFDSDtBQUVKLENBakREOzs7OztBQ3pGQTs7O0FBR0MsYUFBWTtBQUNUOztBQUVBLFFBQUksYUFBYyxZQUFZOztBQUUxQixZQUFJLFFBQVE7QUFDUix3QkFBYSxnQ0FETDtBQUVSLHFCQUFVLE1BRkY7QUFHUix1QkFBWSxRQUhKO0FBSVIsdUJBQVk7QUFKSixTQUFaO0FBQUEsWUFNQSxrQkFBa0IsRUFObEI7O0FBUUEsaUJBQVMseUJBQVQsQ0FBbUMsT0FBbkMsRUFBNEM7QUFDeEMsbUJBQU8sQ0FBQyxVQUFVLFFBQVEsYUFBbkIsS0FBcUMsQ0FBQyxRQUFRLEVBQXJELEVBQXlELENBQUU7QUFDM0QsbUJBQU8sT0FBUDtBQUNIOztBQUVELGlCQUFTLGNBQVQsQ0FBd0IsRUFBeEIsRUFBNEIsS0FBNUIsRUFBbUMsRUFBbkMsRUFBdUM7QUFDbkMsNEJBQWdCLE9BQWhCLENBQXdCLFVBQVUsRUFBVixFQUFjO0FBQ2xDLHVCQUFPLEdBQUcsRUFBSCxFQUFPLEtBQVAsRUFBYyxFQUFkLENBQVA7QUFDSCxhQUZEO0FBR0g7O0FBRUQsaUJBQVMsZ0JBQVQsQ0FBMEIsSUFBMUIsRUFBZ0MsVUFBaEMsRUFBNEMsR0FBNUMsRUFBaUQ7QUFDN0MsZ0JBQUksT0FBTyxLQUFYO0FBQUEsZ0JBQ0ksYUFBYSxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FEakI7QUFBQSxnQkFFSSxTQUFTLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUZiO0FBQUEsZ0JBR0ksZUFBZSxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FIbkI7QUFBQSxnQkFJSSxPQUFPLFNBQVMsYUFBVCxDQUF1QixVQUF2QixDQUpYO0FBQUEsZ0JBS0ksT0FMSjs7QUFPQSxnQkFBSSxPQUFPLElBQUksY0FBSixDQUFtQixhQUFuQixDQUFYLEVBQThDO0FBQzFDLHFCQUFLLFlBQUwsQ0FBa0IsYUFBbEIsRUFBaUMsSUFBSSxXQUFyQztBQUNIOztBQUVELHFCQUFTLEtBQVQsR0FBaUI7QUFDYixxQkFBSyxTQUFMLENBQWUsR0FBZixDQUFtQixpQkFBbkI7QUFDQSx1QkFBTyxLQUFQO0FBQ0g7O0FBRUQscUJBQVMsSUFBVCxHQUFnQjtBQUNaLG9CQUFJLENBQUMsSUFBTCxFQUFXO0FBQ1AsOEJBQVUsS0FBSyxhQUFMLENBQW1CLFVBQW5CLENBQVY7QUFDQSwyQkFBTyxJQUFQO0FBQ0EseUJBQUssS0FBTCxHQUFhLFFBQVEsU0FBckI7QUFDQSwrQkFBVyxZQUFZO0FBQ25CLDZCQUFLLFNBQUwsQ0FBZSxNQUFmLENBQXNCLGlCQUF0QjtBQUNILHFCQUZELEVBRUcsR0FGSDtBQUdIO0FBQ0o7O0FBRUQ7QUFDQSx5QkFBYSxTQUFiLEdBQXlCLDhEQUF6QjtBQUNBLG1CQUFPLFNBQVAsR0FBbUIsa0VBQW5CO0FBQ0EsaUJBQUssU0FBTCxHQUFpQixpQkFBakI7QUFDQSx1QkFBVyxTQUFYLEdBQXVCLHNCQUF2QjtBQUNBLGlCQUFLLFNBQUwsQ0FBZSxHQUFmLENBQW1CLGlCQUFuQjs7QUFFQTtBQUNBLHlCQUFhLGdCQUFiLENBQThCLE9BQTlCLEVBQXVDLEtBQXZDO0FBQ0EsbUJBQU8sZ0JBQVAsQ0FBd0IsT0FBeEIsRUFBaUMsWUFBWTtBQUN6QyxvQkFBSSxNQUFNLEtBQUssS0FBZjtBQUFBLG9CQUNJLEtBQUssMEJBQTBCLElBQTFCLEVBQWdDLEVBRHpDO0FBQUEsb0JBRUksTUFBTSxlQUFlLEVBQWYsRUFBbUIsR0FBbkIsRUFBd0IsVUFBVSxPQUFWLEVBQW1CO0FBQzdDLHdCQUFJLE9BQUosRUFBYTtBQUNULGdDQUFRLFNBQVIsR0FBb0IsR0FBcEI7QUFDQTtBQUNILHFCQUhELE1BR087QUFDSCxnQ0FBUSxJQUFSLENBQWEsOERBQWI7QUFDSDtBQUNKLGlCQVBLLENBRlY7QUFVSCxhQVhEO0FBWUEsaUJBQUssZ0JBQUwsQ0FBc0IsVUFBdEIsRUFBa0MsSUFBbEM7O0FBRUE7QUFDQSxpQkFBSyxZQUFMLENBQWtCLE9BQWxCLEVBQTJCLE1BQU0sVUFBakM7QUFDQSx5QkFBYSxZQUFiLENBQTBCLE9BQTFCLEVBQW1DLE1BQU0sU0FBekM7QUFDQSxtQkFBTyxZQUFQLENBQW9CLE9BQXBCLEVBQTZCLE1BQU0sU0FBbkM7O0FBRUE7QUFDQSx1QkFBVyxXQUFYLENBQXVCLElBQXZCO0FBQ0EsdUJBQVcsV0FBWCxDQUF1QixZQUF2QjtBQUNBLHVCQUFXLFdBQVgsQ0FBdUIsTUFBdkI7O0FBRUE7QUFDQSxpQkFBSyxXQUFMLENBQWlCLFVBQWpCOztBQUVBO0FBQ0EsbUJBQU8sWUFBWTtBQUNmLG9CQUFJLENBQUMsSUFBTCxFQUFXO0FBQUU7QUFDVDtBQUNILGlCQUZELE1BRU87QUFBRTtBQUNMO0FBQ0g7QUFDSixhQU5EO0FBT0g7O0FBRUQsZUFBTztBQUNIOzs7Ozs7Ozs7QUFTQSxzQkFBVyxrQkFBVSxFQUFWLEVBQWM7QUFDckIsZ0NBQWdCLElBQWhCLENBQXFCLEVBQXJCO0FBRUgsYUFiRTtBQWNIOzs7OztBQUtBLGlCQUFNLGFBQVUsSUFBVixFQUFnQixHQUFoQixFQUFxQjtBQUN2QixvQkFBSSxhQUFhLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUFqQjtBQUFBLG9CQUNJLGlCQUFrQixTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FEdEI7QUFFQSwyQkFBVyxTQUFYLEdBQXNCLHVCQUF0QjtBQUNBLCtCQUFlLFNBQWYsR0FBMkIsaUVBQTNCO0FBQ0EsK0JBQWUsZ0JBQWYsQ0FBZ0MsT0FBaEMsRUFBeUMsaUJBQWlCLElBQWpCLEVBQXVCLFVBQXZCLEVBQW1DLEdBQW5DLENBQXpDO0FBQ0EsK0JBQWUsWUFBZixDQUE0QixPQUE1QixFQUFxQyxNQUFNLE9BQTNDO0FBQ0E7QUFDQSxxQkFBSyxTQUFMLENBQWUsR0FBZixDQUFtQixzQkFBbkI7QUFDQSwyQkFBVyxXQUFYLENBQXVCLGNBQXZCO0FBQ0EscUJBQUssV0FBTCxDQUFpQixVQUFqQjtBQUNIO0FBOUJFLFNBQVA7QUFnQ0gsS0EvSGlCLEVBQWxCOztBQWlJQTtBQUNBLFFBQUksT0FBTyxNQUFQLEtBQWtCLFdBQWxCLElBQWlDLE9BQU8sY0FBUCxDQUFzQixTQUF0QixDQUFyQyxFQUF1RTtBQUFFLGVBQU8sT0FBUCxHQUFpQixVQUFqQjtBQUE4QixLQUF2RyxNQUE2RztBQUFDLGNBQU0sR0FBTixDQUFVLFlBQVYsRUFBd0IsVUFBeEI7QUFBc0M7QUFFdkosQ0F2SUEsR0FBRDs7Ozs7QUNIQTtBQUNBOzs7QUFHQSxJQUFNLFFBQVEsUUFBUSxPQUFSLENBQWQ7QUFDQSxJQUFNLFNBQVMsUUFBUSxhQUFSLENBQWY7QUFDQSxJQUFNLE9BQU8sUUFBUSxNQUFSLENBQWI7QUFDQSxJQUFNLFFBQVEsUUFBUSxpQkFBUixDQUFkO0FBQ0EsSUFBTSxpQkFBaUIsUUFBUSxxQ0FBUixDQUF2Qjs7QUFFQSxPQUFPLE9BQVAsR0FBaUIsT0FBTyxPQUFQLElBQWtCLFFBQVEsVUFBUixDQUFuQzs7QUFFQTs7O0FBR0EsSUFBSSxRQUFTLFlBQVk7QUFDckI7QUFDQTs7QUFDQSxRQUFJLE1BQU0sRUFBVjtBQUFBLFFBQ0ksTUFESjtBQUFBLFFBRUksdUJBQXVCLEVBRjNCOztBQUdJO0FBQ0EsMEJBQXNCLEtBSjFCO0FBQUEsUUFLSSxpQkFBaUIsS0FMckI7QUFBQSxRQU1JLG1CQUFtQixlQUFlO0FBQzlCLGtCQUFXO0FBQUEsbUJBQU0sU0FBUyxNQUFULEVBQU47QUFBQSxTQURtQjtBQUU5QixxQkFBYyx1QkFBTTtBQUNoQiw2QkFBaUIsSUFBakI7QUFDQSw2QkFBaUIsWUFBakI7QUFDQSxxQkFBUyxLQUFLLFFBQUwsQ0FBVDtBQUNBLDZCQUFpQixVQUFDLFVBQUQsRUFBYSxlQUFiLEVBQWlDO0FBQzlDLG9CQUFJLGVBQWUsSUFBbkIsRUFBeUI7QUFDckI7QUFDQSxxQ0FBaUIsTUFBakIsQ0FBd0IsZ0JBQXhCO0FBQ0gsaUJBSEQsTUFHTztBQUNILHFDQUFpQixPQUFqQjtBQUNBLHFDQUFpQixLQUFqQjtBQUNIO0FBQ0osYUFSRDtBQVNILFNBZjZCO0FBZ0I5QixpQkFBVSxtQkFBTTtBQUNaLDZCQUFpQixPQUFqQjtBQUNIO0FBbEI2QixLQUFmLENBTnZCO0FBMEJBLFFBQUksU0FBUyxLQUFLLFFBQUwsQ0FBYjtBQUNBLFFBQUksVUFBSjs7QUFFQSxhQUFTLElBQVQsQ0FBYyxDQUFkLEVBQWlCLEVBQWpCLEVBQXFCO0FBQ2pCLGlCQUFTLENBQVQ7O0FBRUEsWUFBSSxPQUFPLFVBQVAsS0FBc0IsU0FBMUIsRUFBcUM7QUFDakMsa0JBQU0sU0FBTixDQUFnQixJQUFoQjtBQUNIOztBQUVELFlBQUksT0FBTyxhQUFYLEVBQTBCO0FBQ3RCLG1CQUFPLGFBQVAsQ0FBcUIsTUFBTSxhQUFOLENBQW9CLGdCQUFwQixDQUFxQyxxQkFBckMsRUFBNEQsU0FBNUQsRUFBckIsRUFBOEYsRUFBOUY7QUFDSCxTQUZELE1BRU87QUFDSCxlQUFHLEVBQUMsTUFBSyxRQUFOLEVBQWdCLFNBQVMsSUFBekIsRUFBSCxFQUFtQyxLQUFuQztBQUNIOztBQUVELGVBQU8scUJBQVAsQ0FBNkIsT0FBTyxZQUFwQztBQUNBO0FBQ0EsWUFBSSxHQUFKLENBQVEsVUFBVSxFQUFWLEVBQWM7QUFDbEIsa0JBQU0sSUFBTjtBQUNBLG1CQUFPLElBQVA7QUFDSCxTQUhEO0FBSUg7O0FBRUQsYUFBUyxnQkFBVCxDQUEwQixFQUExQixFQUE4QjtBQUMxQixZQUFJLE9BQUo7QUFDQSxVQUFFLEVBQUYsQ0FBSyxRQUFMLEVBQWUsVUFBVSxNQUFWLEVBQWtCO0FBQzdCLGtDQUFzQixJQUF0QjtBQUNBLGlCQUFLLE1BQUwsRUFBYSxFQUFiO0FBQ0gsU0FIRDtBQUlBLFVBQUUsRUFBRixDQUFLLE1BQUwsRUFBYSxVQUFVLEdBQVYsRUFBZTtBQUN4QixvQkFBUSxHQUFSLENBQVksR0FBWjtBQUNBLGtDQUFzQixLQUF0QjtBQUNBLDZCQUFpQixNQUFqQixDQUF3QixpQkFBeEI7QUFDSCxTQUpEO0FBS0EsVUFBRSxFQUFGLENBQUssT0FBTCxFQUFjLFVBQVUsR0FBVixFQUFlO0FBQ3pCLG9CQUFRLEdBQVIsQ0FBWSxHQUFaO0FBQ0E7QUFDQTtBQUNBLGtDQUFzQixLQUF0QjtBQUNBLDZCQUFpQixNQUFqQixDQUF3QixXQUF4QixFQUFxQyxJQUFJLElBQXpDO0FBQ0gsU0FORDtBQU9BLFVBQUUsRUFBRixDQUFLLEtBQUwsRUFBWSxVQUFVLEdBQVYsRUFBZTtBQUN2QjtBQUNBLGtDQUFzQixLQUF0QjtBQUNBLG9CQUFRLEtBQVIsQ0FBYyxXQUFkLEVBQTJCLEdBQTNCO0FBQ0E7QUFDQSxnQkFBSSxjQUFKLEVBQ0ksaUJBQWlCLE1BQWpCLENBQXdCLGdCQUF4QixFQURKLEtBR0ksV0FBVztBQUFBLHVCQUFNLGlCQUFpQixNQUFqQixDQUF3QixnQkFBeEIsQ0FBTjtBQUFBLGFBQVgsRUFBNEQsSUFBNUQ7QUFDUCxTQVREO0FBVUEsVUFBRSxJQUFGLENBQU8sTUFBUCxFQUFlLElBQWYsQ0FBb0IsQ0FBcEI7QUFDSDtBQUNEOzs7O0FBSUEsYUFBUyxXQUFULEdBQXVCO0FBQ25CLFlBQUksbUJBQUosRUFDSSxPQUFPLElBQVA7QUFDSix5QkFBaUIsTUFBakIsQ0FBd0IsV0FBeEI7QUFDQSxlQUFPLEtBQVA7QUFDSDs7QUFFRDs7Ozs7QUFLQSxhQUFTLGNBQVQsQ0FBd0IsWUFBeEIsRUFBc0MsSUFBdEMsRUFBNEM7QUFDeEMsNkJBQXFCLE9BQXJCLENBQTZCLFVBQVUsVUFBVixFQUFzQjtBQUMvQyxnQkFBSSxXQUFXLGNBQVgsQ0FBMEIsWUFBMUIsQ0FBSixFQUE2QztBQUN6QyxvQkFBSTtBQUNBLDRCQUFRLEdBQVIsQ0FBWSxhQUFaLEVBQTJCLFlBQTNCO0FBQ0EsK0JBQVcsWUFBWCxFQUF5QixLQUF6QixDQUErQixJQUEvQixFQUFxQyxJQUFyQztBQUNILGlCQUhELENBR0UsT0FBTSxDQUFOLEVBQVM7QUFDUCxxQ0FBaUIsTUFBakIsQ0FBd0IsT0FBeEIsRUFBaUMsRUFBRSxPQUFuQztBQUNBLDRCQUFRLEtBQVIsQ0FBYyxDQUFkO0FBQ0g7QUFDSjtBQUNKLFNBVkQ7QUFXSDs7QUFFRCxXQUFPO0FBQ0gsb0JBQWEsb0JBQVUsRUFBVixFQUFjO0FBQ3ZCLDZCQUFpQixFQUFqQjtBQUNILFNBSEU7QUFJSCx1QkFBZ0IsdUJBQVUsR0FBVixFQUFlO0FBQzNCLGlDQUFxQixJQUFyQixDQUEwQixHQUExQjtBQUNILFNBTkU7QUFPSDs7Ozs7QUFLQSxxQkFBYyxxQkFBVSxTQUFWLEVBQXFCLEVBQXJCLEVBQXlCO0FBQ25DLG1CQUFPLFdBQVAsQ0FBbUIsU0FBbkIsRUFBOEIsVUFBVSxJQUFWLFFBQWlDO0FBQUEsb0JBQWhCLEVBQWdCLFFBQWhCLEVBQWdCO0FBQUEsb0JBQVosSUFBWSxRQUFaLElBQVk7QUFBQSxvQkFBTixHQUFNLFFBQU4sR0FBTTs7QUFDM0Qsb0JBQUksSUFBSixFQUFVO0FBQ047QUFDQSx5QkFBSyxTQUFMLEdBQWlCLEVBQWpCO0FBQ0EseUJBQUssT0FBTCxHQUFlLElBQWY7QUFDQSxtQ0FBZSxlQUFmLEVBQWdDLENBQUMsSUFBRCxFQUFPLEVBQUMsTUFBRCxFQUFLLFVBQUwsRUFBVyxRQUFYLEVBQVAsQ0FBaEM7QUFDQSwwQkFBTSxHQUFHLElBQUgsRUFBUyxJQUFULEVBQWUsRUFBQyxNQUFELEVBQUssVUFBTCxFQUFXLFFBQVgsRUFBZixDQUFOO0FBQ0gsaUJBTkQsTUFNTztBQUNIO0FBQ0E7QUFDQSwwQkFBTSxHQUFHLEtBQUgsQ0FBTjtBQUNIO0FBQ0osYUFaRDtBQWFILFNBMUJFO0FBMkJIOzs7Ozs7O0FBT0EsbUJBQVksbUJBQVUsU0FBVixFQUFxQixRQUFyQixFQUErQixXQUEvQixFQUE0QyxFQUE1QyxFQUFnRDtBQUN4RCxnQkFBSSxhQUFKLEVBQ0ksT0FBTyxPQUFQLENBQWUsU0FBZixFQUEwQixRQUExQixFQUFvQyxXQUFwQyxFQUNJLFVBQVMsR0FBVCxFQUFjLEdBQWQsRUFBbUIsS0FBbkIsRUFBMEI7QUFDdEI7QUFDQSxvQkFBSSxDQUFDLEdBQUwsRUFBVTtBQUNOLHVCQUFHLFNBQUgsRUFBYyxRQUFkLEVBQXdCLEdBQXhCLEVBQTZCLEtBQTdCO0FBQ0EsbUNBQWUsYUFBZixFQUE4QixDQUFDLFNBQUQsRUFBWSxRQUFaLEVBQXNCLEdBQXRCLEVBQTJCLEtBQTNCLENBQTlCO0FBQ0g7QUFDSixhQVBMO0FBUVAsU0E1Q0U7QUE2Q0g7Ozs7OztBQU1BLGtCQUFVLGtCQUFTLFNBQVQsRUFBb0IsV0FBcEIsRUFBaUMsRUFBakMsRUFBcUM7QUFDM0MsZ0JBQUksYUFBSixFQUNJLE9BQU8sUUFBUCxDQUFnQixTQUFoQixFQUEyQixXQUEzQixFQUNJLFVBQVMsR0FBVCxFQUFjLFNBQWQsRUFBeUIsSUFBekIsRUFBK0I7QUFDM0IsbUJBQUcsR0FBSCxFQUFRLFNBQVIsRUFBbUIsSUFBbkI7QUFDQSwrQkFBZSxhQUFmLEVBQThCLENBQUMsU0FBRCxFQUFZLElBQVosQ0FBOUI7QUFDSCxhQUpMO0FBS1AsU0ExREU7QUEyREg7Ozs7Ozs7QUFPQSxpQkFBVSxpQkFBVSxTQUFWLEVBQXFCLFFBQXJCLEVBQStCLFdBQS9CLEVBQTRDLEVBQTVDLEVBQWdEO0FBQ3RELGdCQUFJLGFBQUosRUFDSSxPQUFPLE9BQVAsQ0FBZSxTQUFmLEVBQTBCLFFBQTFCLEVBQW9DLFdBQXBDLEVBQ0ksVUFBUyxHQUFULEVBQWMsR0FBZCxFQUFtQixLQUFuQixFQUEwQjtBQUN0QjtBQUNBLG9CQUFJLENBQUMsR0FBTCxFQUFVO0FBQ04sdUJBQUcsU0FBSCxFQUFjLFFBQWQsRUFBd0IsR0FBeEIsRUFBNkIsS0FBN0I7QUFDSDtBQUNKLGFBTkw7QUFPUCxTQTNFRTtBQTRFSDs7Ozs7QUFLQSwwQkFBbUIsMEJBQVUsV0FBVixFQUF1QixZQUF2QixFQUFxQztBQUNwRCxnQkFBSSxhQUFKLEVBQ0ksT0FBTyxnQkFBUCxDQUF3QixZQUF4QixFQUFzQyxXQUF0QyxFQUFtRCxFQUFuRCxFQUNJLFVBQVMsR0FBVCxFQUFjLFdBQWQsRUFBMkIsT0FBM0IsRUFBb0M7QUFDaEM7QUFDQSxvQkFBSSxDQUFDLEdBQUwsRUFBVTtBQUNOLG1DQUFlLHFCQUFmLEVBQXNDLENBQUMsV0FBRCxFQUFjLE9BQWQsQ0FBdEM7QUFDSDtBQUNKLGFBTkw7QUFPUCxTQTFGRTtBQTJGSDs7Ozs7QUFLQSw0QkFBcUIsNEJBQVMsYUFBVCxFQUF3QixnQkFBeEIsRUFBMEM7QUFDM0QsZ0JBQUksYUFBSixFQUNJLE9BQU8sa0JBQVAsQ0FBMEIsYUFBMUIsRUFBeUMsZ0JBQXpDLEVBQ0ksVUFBUyxHQUFULEVBQWMsYUFBZCxFQUE2QjtBQUN6QjtBQUNBLG9CQUFJLENBQUMsR0FBTCxFQUFVO0FBQ04sbUNBQWUsdUJBQWYsRUFBd0MsQ0FBQyxhQUFELENBQXhDO0FBQ0g7QUFDSixhQU5MO0FBT1AsU0F6R0U7QUEwR0g7Ozs7OztBQU1BLHdCQUFpQix3QkFBVSxTQUFWLEVBQXFCLE9BQXJCLEVBQThCLE9BQTlCLEVBQXVDO0FBQ3BELGdCQUFJLGFBQUosRUFDSSxPQUFPLGNBQVAsQ0FBc0IsU0FBdEIsRUFBaUMsT0FBakMsRUFBMEMsT0FBMUMsRUFDSSxVQUFVLEdBQVYsRUFBZSxPQUFmLEVBQXdCLE9BQXhCLEVBQWlDO0FBQzdCLG9CQUFJLENBQUMsR0FBTCxFQUFVO0FBQ04sbUNBQWUsZ0JBQWYsRUFBaUMsQ0FBQyxPQUFELEVBQVUsT0FBVixDQUFqQztBQUNIO0FBQ0osYUFMTDtBQU1QLFNBeEhFO0FBeUhIOzs7OztBQUtBLHdCQUFpQix3QkFBVSxTQUFWLEVBQXFCLE9BQXJCLEVBQThCO0FBQzNDLGdCQUFJLGFBQUosRUFDSSxPQUFPLGNBQVAsQ0FBc0IsU0FBdEIsRUFBaUMsT0FBakMsRUFDSSxVQUFVLEdBQVYsRUFBZSxPQUFmLEVBQXdCO0FBQ3BCLG9CQUFJLENBQUMsR0FBTCxFQUFVO0FBQ04sbUNBQWUsZ0JBQWYsRUFBaUMsQ0FBQyxPQUFELENBQWpDO0FBQ0g7QUFDSixhQUxMO0FBTVAsU0F0SUU7QUF1SUg7Ozs7O0FBS0EsbUJBQVksbUJBQVUsU0FBVixFQUFxQixHQUFyQixFQUEwQjtBQUNsQyxnQkFBSSxhQUFKLEVBQ0ksT0FBTyxTQUFQLENBQWlCLFNBQWpCLEVBQTRCO0FBQ3hCLHdCQUFTLElBQUksTUFEVztBQUV4Qix3QkFBUyxJQUFJO0FBRlcsYUFBNUIsRUFHRyxVQUFVLEdBQVYsRUFBZSxNQUFmLEVBQXVCLE1BQXZCLEVBQStCO0FBQzlCLG9CQUFJLENBQUMsR0FBTCxFQUFVO0FBQ04sbUNBQWUsV0FBZixFQUE0QixDQUFDLE1BQUQsRUFBUyxNQUFULENBQTVCO0FBQ0gsaUJBRkQsTUFFTztBQUNILG1DQUFlLFdBQWYsRUFBNEIsQ0FBQyxLQUFELENBQTVCO0FBQ0g7QUFDSixhQVREO0FBVVAsU0F4SkU7QUF5Skg7Ozs7OztBQU1BLG1CQUFZLG1CQUFVLFNBQVYsRUFBcUIsT0FBckIsRUFBOEIsRUFBOUIsRUFBa0M7QUFDMUMsZ0JBQUksYUFBSixFQUNJLE9BQU8sU0FBUCxDQUFpQixTQUFqQixFQUE0QixPQUE1QixFQUNJLFVBQVUsR0FBVixFQUFlLE9BQWYsRUFBd0I7QUFDcEIsb0JBQUksQ0FBQyxHQUFMLEVBQVU7QUFDTix1QkFBRyxPQUFIO0FBQ0EsbUNBQWUsV0FBZixFQUE0QixDQUFDLE9BQUQsQ0FBNUI7QUFDSDtBQUNKLGFBTkw7QUFPUCxTQXhLRTtBQXlLSDs7Ozs7QUFLQSxxQkFBYyxxQkFBUyxTQUFULEVBQW9CLFlBQXBCLEVBQWtDO0FBQzVDLGdCQUFJLGFBQUosRUFDSSxPQUFPLFdBQVAsQ0FBbUIsU0FBbkIsRUFBOEIsWUFBOUIsRUFBNEMsVUFBVSxHQUFWLEVBQWUsWUFBZixFQUE2QjtBQUNyRSxvQkFBSSxDQUFDLEdBQUwsRUFBVTtBQUNOLG1DQUFlLGNBQWYsRUFBK0IsQ0FBQyxZQUFELENBQS9CO0FBQ0gsaUJBRkQsTUFFTztBQUNILDBCQUFNLFdBQU4sQ0FBa0IsSUFBSSxPQUF0QjtBQUNIO0FBQ0osYUFORDtBQU9QLFNBdkxFO0FBd0xIOzs7Ozs7O0FBT0Esc0JBQWUsc0JBQVUsR0FBVixFQUFlLEVBQWYsRUFBbUI7QUFDOUIsZ0JBQUksYUFBSixFQUNJLE9BQU8sWUFBUCxDQUFvQixHQUFwQixFQUNJLFVBQVUsR0FBVixFQUFlLElBQWYsRUFBcUI7QUFDakIsb0JBQUksUUFBUSxJQUFaLEVBQWtCO0FBQ2QsMEJBQU0sV0FBTixDQUFrQix1RUFBdUUsSUFBSSxPQUE3RjtBQUNBLDRCQUFRLEtBQVIsQ0FBYyxJQUFJLE9BQWxCO0FBQ0E7QUFDSDtBQUNEO0FBQ0Esc0JBQU0sR0FBRyxJQUFILENBQU47QUFDQSxvQkFBSSxTQUFTLEtBQWIsRUFBb0I7QUFDaEIsbUNBQWUsY0FBZixFQUErQixDQUFDLElBQUQsQ0FBL0I7QUFDSDtBQUNKLGFBWkw7QUFhUCxTQTlNRTtBQStNSDs7Ozs7OztBQU9BLGdDQUF5QixnQ0FBUyxTQUFULEVBQW9CLEVBQXBCLEVBQXdCLFdBQXhCLEVBQXFDLFFBQXJDLEVBQStDO0FBQ3BFLGdCQUFJLGFBQUosRUFDSSxPQUFPLHNCQUFQLENBQThCLFNBQTlCLEVBQXlDLEVBQXpDLEVBQTZDLFdBQTdDLEVBQ0ksVUFBUyxHQUFULEVBQWM7QUFDVixvQkFBSSxDQUFDLEdBQUwsRUFBVTtBQUNOLGdDQUFZLFNBQVMsSUFBVCxDQUFaO0FBQ0EsbUNBQWUseUJBQWYsRUFBMEMsRUFBMUM7QUFDSCxpQkFIRCxNQUdPO0FBQ0gsZ0NBQVksU0FBUyxLQUFULENBQVo7QUFDSDtBQUNKLGFBUkw7QUFTUCxTQWpPRTtBQWtPSDs7Ozs7Ozs7OztBQVVBLHFCQUFjLDRCQUEyQixFQUEzQixFQUErQjtBQUFBLGdCQUFwQixFQUFvQixTQUFwQixFQUFvQjtBQUFBLGdCQUFoQixHQUFnQixTQUFoQixHQUFnQjtBQUFBLGdCQUFYLElBQVcsU0FBWCxJQUFXOztBQUN6QyxnQkFBSSxhQUFKLEVBQW1CO0FBQ2YsdUJBQU8sV0FBUCxDQUFtQixFQUFDLE1BQUQsRUFBSyxRQUFMLEVBQVUsVUFBVixFQUFuQixFQUFvQyxVQUFDLEdBQUQsRUFBTSxPQUFOLEVBQWtCO0FBQ2xELHVCQUFHLEdBQUgsRUFBUSxXQUFXLEVBQW5CO0FBQ0gsaUJBRkQ7QUFHSDtBQUNKLFNBbFBFO0FBbVBIOzs7Ozs7O0FBT0EsdUJBQWdCLHVCQUFVLEVBQVYsRUFBYyxFQUFkLEVBQWtCO0FBQzlCLGdCQUFJLGFBQUosRUFBbUI7QUFDZix1QkFBTyxhQUFQLENBQXFCLEVBQXJCLEVBQ0ksVUFBVSxHQUFWLEVBQWUsT0FBZixFQUF3QjtBQUNwQix3QkFBSSxDQUFDLEdBQUwsRUFBVTtBQUNOO0FBQ0EsOEJBQU0sR0FBRyxJQUFILEVBQVMsT0FBVCxDQUFOO0FBQ0EsdUNBQWUsZ0JBQWYsRUFBaUMsQ0FBQyxPQUFELENBQWpDO0FBQ0gscUJBSkQsTUFJTztBQUNILDhCQUFNLEdBQUcsR0FBSCxDQUFOO0FBQ0g7QUFDSixpQkFUTDtBQVVIO0FBQ0osU0F2UUU7QUF3UUg7Ozs7OztBQU1BLHNCQUFlLHNCQUFVLEVBQVYsRUFBYyxRQUFkLEVBQXdCO0FBQ25DLGdCQUFJLGFBQUosRUFDSSxPQUFPLFlBQVAsQ0FBb0IsRUFBcEIsRUFDSSxVQUFVLEdBQVYsRUFBZSxLQUFmLEVBQXNCO0FBQ2xCLG9CQUFJLENBQUMsR0FBTCxFQUFVO0FBQ04sZ0NBQVksU0FBUyxJQUFULEVBQWUsS0FBZixDQUFaO0FBQ0EsbUNBQWUsZUFBZixFQUFnQyxDQUFDLEtBQUQsQ0FBaEM7QUFDSCxpQkFIRCxNQUdPO0FBQ0gsZ0NBQVksU0FBUyxHQUFULENBQVo7QUFDSDtBQUNKLGFBUkw7QUFTUCxTQXpSRTtBQTBSSDs7Ozs7QUFLQSxvQkFBWSxvQkFBVSxXQUFWLEVBQXNCLFFBQXRCLEVBQWdDO0FBQ3hDLGdCQUFJLGFBQUosRUFDSSxPQUFPLFVBQVAsQ0FBa0IsV0FBbEIsRUFBOEIsVUFBVSxHQUFWLEVBQWUsT0FBZixFQUF3QjtBQUNsRCxvQkFBSSxDQUFDLEdBQUwsRUFBVTtBQUNOLGdDQUFZLFNBQVMsT0FBVCxDQUFaO0FBQ0gsaUJBRkQsTUFFTztBQUNILHFDQUFpQixNQUFqQixDQUF3QixjQUF4QjtBQUNIO0FBQ0osYUFORDtBQU9QLFNBeFNFO0FBeVNIO0FBQ0EsZUFBUSxlQUFVLEVBQVYsRUFBYztBQUNsQixnQkFBSSxNQUFKLEVBQVk7QUFDUjtBQUNILGFBRkQsTUFFTztBQUNILG9CQUFJLElBQUosQ0FBUyxFQUFUO0FBQ0g7QUFDSjtBQWhURSxLQUFQO0FBa1RILENBbmFZLEVBQWI7O0FBcWFBLE9BQU8sT0FBUCxHQUFpQixLQUFqQjs7Ozs7QUNwYkEsSUFBSSxVQUFXLFlBQVk7QUFDdkIsUUFBSSxjQUFjO0FBQ1YsMEJBQW1CLEVBRFQ7QUFFViw0QkFBcUIsRUFGWDtBQUdWLHFCQUFhLEVBSEg7QUFJViwwQkFBa0IsRUFKUjtBQUtWLHlCQUFpQixFQUxQO0FBTVYsMEJBQWtCLEVBTlI7QUFPVixtQkFBVyxFQVBEO0FBUVYscUJBQWEsRUFSSDtBQVNWLDBCQUFrQixFQVRSO0FBVVYseUJBQWlCLEVBVlA7QUFXVix3QkFBZ0IsRUFYTjtBQVlWLDBCQUFrQixFQVpSO0FBYVYsd0JBQWdCLEVBYk47QUFjViwwQkFBa0IsRUFkUjtBQWVWLHNCQUFjLEVBZko7QUFnQlYsc0JBQWM7QUFoQkosS0FBbEI7QUFrQkEsV0FBTztBQUNILDRCQUFxQiw0QkFBVSxHQUFWLEVBQWU7QUFDaEMsbUJBQU8sSUFBUCxDQUFZLEdBQVosRUFBaUIsT0FBakIsQ0FBeUIsVUFBVSxHQUFWLEVBQWU7QUFDcEMsb0JBQUksWUFBWSxjQUFaLENBQTJCLEdBQTNCLENBQUosRUFBcUM7QUFDakMsZ0NBQVksR0FBWixFQUFpQixJQUFqQixDQUFzQixJQUFJLEdBQUosQ0FBdEI7QUFDSDtBQUNKLGFBSkQ7QUFLSCxTQVBFO0FBUUgscUJBQWMscUJBQVUsU0FBVixFQUFxQixJQUFyQixFQUEyQjtBQUNyQyxnQkFBSSxXQUFXLEdBQUcsS0FBSCxDQUFTLElBQVQsQ0FBYyxTQUFkLEVBQXlCLENBQXpCLEVBQTRCLFVBQVUsTUFBdEMsQ0FBZjtBQUNBLGdCQUFJLFlBQVksY0FBWixDQUEyQixTQUEzQixDQUFKLEVBQTJDO0FBQ3ZDLDRCQUFZLFNBQVosRUFBdUIsT0FBdkIsQ0FBK0IsVUFBVSxFQUFWLEVBQWM7QUFDMUMsdUJBQUcsS0FBSCxDQUFTLElBQVQsRUFBZSxRQUFmO0FBQ0YsaUJBRkQ7QUFHSDtBQUNKO0FBZkUsS0FBUDtBQWlCSCxDQXBDYyxFQUFmOztBQXNDQSxPQUFPLE9BQVAsR0FBaUIsT0FBakI7Ozs7O0FDdENBOzs7QUFHQSxJQUFJLFlBQVcsb0JBQVksQ0FBRSxDQUE3QjtBQUFBLElBQ0ksUUFBUTtBQUNKLGVBQVk7QUFDUixjQUFNLGNBQVUsSUFBVixFQUFnQjtBQUNsQixpQkFBSyxnQkFBTCxDQUFzQixRQUF0QixFQUFnQyxNQUFoQztBQUNIO0FBSE87QUFEUixDQURaOztBQVNBLFNBQVMsTUFBVCxHQUFrQjtBQUNkLFlBQVEsR0FBUixDQUFZLHlCQUFaO0FBQ0EsUUFBSSxPQUFPLEtBQUssS0FBTCxDQUFXLENBQVgsQ0FBWDtBQUNBLFFBQUksSUFBSixFQUFVO0FBQ047QUFDQSxXQUFHLEtBQUgsQ0FBUyxJQUFULENBQWMsS0FBSyxLQUFuQixFQUEwQixPQUExQixDQUFrQyxVQUFVLElBQVYsRUFBZ0I7QUFDOUM7QUFDQSxzQkFBUyxJQUFUO0FBQ0gsU0FIRDtBQUlBO0FBQ0EsYUFBSyxLQUFMLEdBQWEsSUFBYjtBQUNBLGVBQU8sS0FBUDtBQUNIO0FBQ0o7QUFDRDs7OztBQUlBLE9BQU8sT0FBUCxHQUFpQjtBQUNiLGNBQVcsa0JBQVUsRUFBVixFQUFjO0FBQ3JCLG9CQUFXLEVBQVg7QUFDSCxLQUhZO0FBSWIsU0FBTSxhQUFVLElBQVYsRUFBZ0IsSUFBaEIsRUFBc0I7QUFDeEIsWUFBSSxNQUFNLGNBQU4sQ0FBcUIsSUFBckIsQ0FBSixFQUFnQztBQUM1QixrQkFBTSxJQUFOLEVBQVksSUFBWixDQUFpQixJQUFqQjtBQUNIO0FBQ0o7QUFSWSxDQUFqQjs7Ozs7QUM5QkE7OztBQUdBLElBQUksWUFBVyxvQkFBWSxDQUFFLENBQTdCO0FBQUEsSUFDSSxRQUFRO0FBQ0osZUFBWTtBQUNSLGNBQU0sY0FBVSxJQUFWLEVBQWdCO0FBQ2xCLGlCQUFLLGdCQUFMLENBQXNCLFFBQXRCLEVBQWdDLE1BQWhDO0FBQ0g7QUFITztBQURSLENBRFo7O0FBU0EsU0FBUyxNQUFULEdBQWtCO0FBQ2QsUUFBSSxPQUFPLEtBQUssS0FBTCxDQUFXLENBQVgsQ0FBWDtBQUNBLFFBQUksSUFBSixFQUFVO0FBQ047QUFDQSxXQUFHLEtBQUgsQ0FBUyxJQUFULENBQWMsS0FBSyxLQUFuQixFQUEwQixPQUExQixDQUFrQyxVQUFVLElBQVYsRUFBZ0I7QUFDOUM7QUFDQSxzQkFBUyxJQUFUO0FBQ0gsU0FIRDtBQUlBO0FBQ0EsYUFBSyxLQUFMLEdBQWEsSUFBYjtBQUNBLGVBQU8sS0FBUDtBQUNIO0FBQ0o7QUFDRDs7OztBQUlBLE9BQU8sT0FBUCxHQUFpQjtBQUNiLGNBQVcsa0JBQVUsRUFBVixFQUFjO0FBQ3JCLG9CQUFXLEVBQVg7QUFDSCxLQUhZO0FBSWIsU0FBTSxhQUFVLElBQVYsRUFBZ0IsSUFBaEIsRUFBc0I7QUFDeEIsWUFBSSxNQUFNLGNBQU4sQ0FBcUIsSUFBckIsQ0FBSixFQUFnQztBQUM1QixrQkFBTSxJQUFOLEVBQVksSUFBWixDQUFpQixJQUFqQjtBQUNIO0FBQ0o7QUFSWSxDQUFqQjs7Ozs7OztBQzdCQTs7Ozs7Ozs7Ozs7Ozs7O0FBZUEsSUFBSSxPQUFPLFFBQVEsYUFBUixDQUFYO0FBQUEsSUFDSSx3QkFBd0IsUUFBUSxtQkFBUixFQUE2QixNQUR6RDtBQUFBLElBRUksUUFGSjtBQUFBLElBR0ksaUJBQWlCLEVBSHJCO0FBQUEsSUFJSSxZQUFXLG9CQUFZLENBQUUsQ0FKN0I7QUFBQSxJQUtJLCtCQUErQixHQUxuQztBQUFBLElBTUksc0JBQXVCLFlBQVc7O0FBRTlCLFFBQUksZUFBSjs7QUFFQTs7OztBQUlBLFdBQU8sWUFBVzs7QUFFZCxZQUFJLG9CQUFvQixTQUFTLGFBQVQsQ0FBdUIsYUFBdkIsQ0FBeEI7QUFBQSxZQUNJLDJCQURKO0FBQUEsWUFFSSxpQ0FGSjtBQUFBLFlBR0ksc0JBSEo7O0FBS0EsWUFBSSxDQUFDLGlCQUFMLEVBQXdCO0FBQ3BCO0FBQ0g7O0FBRUQ7QUFDQSxZQUFJLGVBQUosRUFBcUI7QUFDakIsNEJBQWdCLFNBQWhCLENBQTBCLE1BQTFCLENBQWlDLGlCQUFqQztBQUNIOztBQUVEO0FBQ0Esc0NBQThCLFNBQVMsSUFBVCxDQUFjLGFBQWQsQ0FBNEIsTUFBTSxzQkFBc0IsU0FBNUIsR0FBd0Msa0JBQWtCLFVBQWxCLENBQTZCLElBQTdCLENBQWtDLFNBQWxDLENBQTRDLE9BQTVDLENBQW9ELFNBQXBELEVBQStELEVBQS9ELENBQXBFLENBQTlCO0FBQ0EsWUFBSSwyQkFBSixFQUFpQztBQUM3QixnREFBb0MsNEJBQTRCLGdCQUE1QixDQUE2QyxxQkFBN0MsQ0FBcEM7QUFDQSxxQ0FBeUIsMEJBQTBCLGlDQUExQixDQUF6QjtBQUNILFNBSEQsTUFHTztBQUNILG9CQUFRLEtBQVIsQ0FBYyxrREFBZCxFQUFrRSxzQkFBc0IsU0FBdEIsR0FBa0Msa0JBQWtCLFVBQWxCLENBQTZCLElBQTdCLENBQWtDLFNBQWxDLENBQTRDLE9BQTVDLENBQW9ELFNBQXBELEVBQStELEVBQS9ELENBQXBHO0FBQ0g7O0FBRUQsWUFBSSxzQkFBSixFQUE0QjtBQUN4Qiw4QkFBa0IsU0FBUyxhQUFULENBQXVCLGtCQUFrQix1QkFBdUIsRUFBdkIsQ0FBMEIsT0FBMUIsQ0FBa0Msc0JBQXNCLFNBQXhELEVBQW1FLEVBQW5FLENBQWxCLEdBQTJGLEdBQWxILENBQWxCO0FBQ0EsZ0JBQUksZUFBSixFQUFxQjtBQUNqQixnQ0FBZ0IsU0FBaEIsQ0FBMEIsR0FBMUIsQ0FBOEIsaUJBQTlCO0FBQ0g7QUFDSjtBQUNKLEtBL0JEO0FBZ0NILENBeENxQixFQU4xQjs7QUFnREEsU0FBUyxhQUFULENBQXNCLEVBQXRCLEVBQTBCLElBQTFCLEVBQWdDO0FBQzVCLFFBQUksR0FBSjtBQUNBO0FBQ0EsT0FBRyxLQUFILENBQVMsSUFBVCxDQUFjLFNBQVMsZ0JBQVQsQ0FBMEIsV0FBMUIsQ0FBZCxFQUFzRCxPQUF0RCxDQUE4RCxVQUFVLENBQVYsRUFBYTtBQUN2RSxVQUFFLFNBQUYsQ0FBWSxNQUFaLENBQW1CLFVBQW5CO0FBQ0gsS0FGRDtBQUdBLFNBQUssU0FBTCxDQUFlLEdBQWYsQ0FBbUIsVUFBbkI7QUFDQSxTQUFLLFVBQUwsQ0FBZ0IsVUFBaEIsQ0FBMkIsU0FBM0IsQ0FBcUMsR0FBckMsQ0FBeUMsVUFBekM7QUFDQTtBQUNBLE9BQUcsS0FBSCxDQUFTLElBQVQsQ0FBYyxTQUFTLGdCQUFULENBQTBCLHFCQUExQixDQUFkLEVBQWdFLE9BQWhFLENBQXdFLFVBQVUsQ0FBVixFQUFhO0FBQ2pGLFVBQUUsU0FBRixDQUFZLE1BQVosQ0FBbUIsb0JBQW5CO0FBQ0gsS0FGRDtBQUdBLFVBQU0sU0FBUyxjQUFULENBQXdCLHNCQUFzQixTQUF0QixHQUFrQyxFQUExRCxDQUFOO0FBQ0EsUUFBSSxHQUFKLEVBQVM7QUFDTCxZQUFJLFNBQUosQ0FBYyxHQUFkLENBQWtCLG9CQUFsQjtBQUNILEtBRkQsTUFFTztBQUNILGdCQUFRLEdBQVIsQ0FBWSwwREFBWixFQUF3RSxFQUF4RTtBQUNIO0FBQ0o7QUFDRDs7OztBQUlBLFNBQVMsUUFBVCxDQUFrQixJQUFsQixFQUF3QixLQUF4QixFQUErQjtBQUMzQixRQUFJLEtBQUssU0FBUyxhQUFULENBQXVCLElBQXZCLENBQVQ7QUFBQSxRQUNJLFNBQVMsS0FBSyxTQUFMLEVBRGI7QUFFQSxTQUFLLFdBQUwsQ0FBaUIsRUFBakI7QUFDQSxVQUFNLE9BQU4sQ0FBYyxVQUFVLE1BQVYsRUFBa0I7QUFDNUIsWUFBSSxLQUFLLFNBQVMsYUFBVCxDQUF1QixJQUF2QixDQUFUO0FBQUEsWUFDSSxPQUFPLFNBQVMsYUFBVCxDQUF1QixNQUF2QixDQURYO0FBRUE7QUFDQSxZQUFJLFFBQU8sTUFBUCx5Q0FBTyxNQUFQLE9BQWtCLFFBQXRCLEVBQWdDO0FBQzVCLG9CQUFRLEtBQVIsQ0FBYywyQ0FBZCxFQUEyRCxNQUEzRDtBQUNIO0FBQ0QsYUFBSyxXQUFMLENBQWlCLFNBQVMsY0FBVCxDQUF3QixPQUFPLEVBQS9CLENBQWpCO0FBQ0EsV0FBRyxXQUFILENBQWUsSUFBZjtBQUNBLFdBQUcsWUFBSCxDQUFnQixNQUFoQixFQUF3QixZQUFZLE9BQU8sRUFBM0M7QUFDQSxhQUFLLGdCQUFMLENBQXNCLE9BQXRCLEVBQStCLFlBQVk7QUFDdkMsc0JBQVMsT0FBTyxFQUFoQjtBQUNBLDBCQUFhLE9BQU8sRUFBcEIsRUFBd0IsRUFBeEI7QUFDSCxTQUhEOztBQUtBLFlBQUksT0FBTyxRQUFYLEVBQXFCO0FBQ2pCLHFCQUFTLEVBQVQsRUFBYSxPQUFPLFFBQXBCO0FBQ0g7QUFDRCxXQUFHLFdBQUgsQ0FBZSxFQUFmO0FBQ0EsWUFBSSxNQUFNLE9BQU8sRUFBYixLQUFvQixNQUF4QixFQUFnQztBQUM1QiwwQkFBYSxPQUFPLEVBQXBCLEVBQXdCLEVBQXhCO0FBQ0g7QUFDSixLQXRCRDtBQXVCSDs7QUFFRDs7OztBQUlBLFNBQVMsWUFBVCxDQUFzQixJQUF0QixFQUE0QjtBQUN4QixRQUFJLFVBQVUsT0FBTyxPQUFQLElBQWtCLE9BQU8sV0FBdkM7QUFBQSxRQUNJLElBQUk7QUFDQSxhQUFLLE9BREw7QUFFQSxnQkFBUyxVQUFVLE9BQU87QUFGMUIsS0FEUjtBQUFBLFFBS0ksV0FBVyxTQUFTLElBQVQsQ0FBYyxxQkFBZCxFQUxmO0FBQUEsUUFNSSxXQUFXLEtBQUsscUJBQUwsRUFOZjtBQUFBLFFBT0ksU0FBUyxTQUFTLEdBQVQsR0FBZSxTQUFTLEdBQXhCLEdBQThCLDRCQVAzQztBQUFBLFFBUUksYUFBYSxTQUFTLEtBQUssWUFBZCxHQUE4QiwrQkFBK0IsQ0FSOUU7QUFTQSxXQUFPLFNBQVMsRUFBRSxHQUFYLElBQWtCLFNBQVMsRUFBRSxNQUE3QixJQUEwQztBQUM3QyxpQkFBYSxFQUFFLEdBQWYsSUFBc0IsYUFBYSxFQUFFLE1BRGxDLElBQzZDO0FBQ2hELGFBQVMsRUFBRSxHQUFYLElBQWtCLGFBQWEsRUFBRSxNQUZyQyxDQVZ3QixDQVl3QjtBQUNuRDs7QUFFRCxTQUFTLGFBQVQsQ0FBdUIsR0FBdkIsRUFBNEI7QUFDeEIsUUFBSSxRQUFRLElBQUksS0FBSixDQUFVLEdBQVYsQ0FBWjtBQUNBLFFBQUksTUFBTSxNQUFOLEdBQWUsQ0FBbkIsRUFBc0I7QUFDbEIsY0FBTSxNQUFOLENBQWEsQ0FBYixFQUFnQixDQUFoQjtBQUNIO0FBQ0QsV0FBTztBQUNILFlBQUssR0FERjtBQUVILGVBQVEsTUFBTSxJQUFOLENBQVcsR0FBWDtBQUZMLEtBQVA7QUFJSDs7QUFFRCxTQUFTLHNCQUFULEdBQXNDO0FBQ2xDLG1CQUFlLE9BQWYsQ0FBdUIsVUFBVSxHQUFWLEVBQWU7QUFDbEMsWUFBSSxLQUFLLFNBQVMsYUFBVCxDQUF1QixrQkFBa0IsSUFBSSxFQUF0QixHQUEyQixHQUFsRCxDQUFUO0FBQ0EsWUFBSSxhQUFhLElBQUksSUFBakIsQ0FBSixFQUE0QjtBQUN4QixlQUFHLFNBQUgsQ0FBYSxHQUFiLENBQWlCLFVBQWpCO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsZUFBRyxTQUFILENBQWEsTUFBYixDQUFvQixVQUFwQjtBQUNIO0FBQ0osS0FQRDtBQVFIOztBQUVELFNBQVMseUJBQVQsQ0FBbUMsS0FBbkMsRUFBMEM7QUFDdEMsUUFBSSxPQUFKO0FBQUEsUUFDSSxtQkFBbUIsU0FBUyxJQUFULENBQWMsU0FBZCxJQUE0QixTQUFTLGVBQVQsSUFBNEIsU0FBUyxlQUFULENBQXlCLFNBRHhHO0FBQUEsUUFFSSxJQUFJLE1BQU0sTUFGZDtBQUFBLFFBR0ksVUFISjs7QUFLQSxXQUFNLEdBQU4sRUFBVztBQUNQLGtCQUFVLE1BQU0sQ0FBTixDQUFWO0FBQ0EscUJBQWEsU0FBUyxPQUFPLGdCQUFQLENBQXdCLE9BQXhCLEVBQWlDLElBQWpDLEVBQXVDLFlBQWhELEVBQThELEVBQTlELENBQWI7QUFDQSxZQUFHLHdCQUF3QixPQUF4QixJQUFtQyxhQUFhLENBQWhELElBQXFELGdCQUF4RCxFQUEwRTtBQUN0RSxtQkFBTyxPQUFQO0FBQ0g7QUFDSjs7QUFFRDtBQUNBLFdBQU8sTUFBTSxDQUFOLENBQVA7QUFDSDs7QUFFRCxTQUFTLHVCQUFULENBQWlDLElBQWpDLEVBQXVDO0FBQ25DLFFBQUksV0FBVyxTQUFTLElBQVQsQ0FBYyxxQkFBZCxFQUFmO0FBQUEsUUFDSSxXQUFXLEtBQUsscUJBQUwsRUFEZjtBQUVBLFdBQU8sU0FBUyxHQUFULEdBQWUsU0FBUyxHQUEvQjtBQUNIOztBQUVELE9BQU8sT0FBUCxHQUFpQjtBQUNiLGtCQUFlLHNCQUFVLEVBQVYsRUFBYztBQUN6QixZQUFJLEtBQUssU0FBUyxhQUFULENBQXVCLGtCQUFrQixFQUFsQixHQUF1QixHQUE5QyxDQUFUO0FBQ0EsWUFBSSxFQUFKLEVBQVE7QUFDSiwwQkFBYSxFQUFiLEVBQWdCLEVBQWhCO0FBQ0g7QUFDSixLQU5ZO0FBT2IsY0FBVyxrQkFBVSxFQUFWLEVBQWM7QUFDckIsb0JBQVcsRUFBWDtBQUNILEtBVFk7QUFVYixnQkFBYSxzQkFBWTtBQUNyQixZQUFJLFNBQVMsRUFBYjtBQUNBO0FBQ0EseUJBQWlCLEVBQWpCOztBQUVBLFdBQUcsS0FBSCxDQUFTLElBQVQsQ0FBYyxTQUFTLGdCQUFULENBQTBCLHNCQUExQixDQUFkLEVBQWlFLE9BQWpFLENBQXlFLFVBQVUsTUFBVixFQUFrQjtBQUN2RixnQkFBSSxLQUFLLE9BQU8sWUFBUCxDQUFvQixJQUFwQixDQUFUO0FBQUEsZ0JBQ0ksV0FBVyxFQURmO0FBRUEsZ0JBQUksRUFBSixFQUFRO0FBQ0oscUJBQUssR0FBRyxPQUFILENBQVcsc0JBQXNCLFNBQWpDLEVBQTRDLEVBQTVDLENBQUw7QUFDQTtBQUNBLCtCQUFlLElBQWYsQ0FBb0IsRUFBQyxNQUFPLE1BQVIsRUFBZ0IsSUFBSyxFQUFyQixFQUFwQjs7QUFFQSxtQkFBRyxLQUFILENBQVMsSUFBVCxDQUFjLE9BQU8sZ0JBQVAsQ0FBd0IscUJBQXhCLENBQWQsRUFBOEQsT0FBOUQsQ0FBc0UsVUFBVSxLQUFWLEVBQWlCO0FBQ25GLHdCQUFJLEtBQUssTUFBTSxZQUFOLENBQW1CLElBQW5CLENBQVQ7QUFDQSx3QkFBSSxFQUFKLEVBQVE7QUFDSixpQ0FBUyxJQUFULENBQWMsY0FBYyxHQUFHLE9BQUgsQ0FBVyxzQkFBc0IsU0FBakMsRUFBNEMsRUFBNUMsQ0FBZCxDQUFkO0FBQ0g7QUFDSixpQkFMRDtBQU1BLHVCQUFPLElBQVAsQ0FBWSxFQUFDLElBQUssRUFBTixFQUFVLFVBQVcsUUFBckIsRUFBWjtBQUVIO0FBQ0osU0FqQkQ7QUFrQkEsV0FBRyxLQUFILENBQVMsSUFBVCxDQUFjLFNBQVMsUUFBdkIsRUFBaUMsT0FBakMsQ0FBeUMsVUFBVSxLQUFWLEVBQWlCO0FBQ3RELGtCQUFNLFVBQU4sQ0FBaUIsV0FBakIsQ0FBNkIsS0FBN0I7QUFDSCxTQUZEO0FBR0EsaUJBQVMsUUFBVCxFQUFtQixNQUFuQjtBQUNBLGlCQUFTLFFBQVQsQ0FBa0IsQ0FBbEIsRUFBcUIsS0FBckIsQ0FBMkIsTUFBM0IsR0FBb0MsT0FBTyxXQUFQLEdBQXFCLEdBQXJCLEdBQTJCLElBQS9EOztBQUVBO0FBQ0EsbUJBQVcsWUFBWTtBQUNuQjtBQUNBO0FBQ0gsU0FIRCxFQUdHLElBSEg7QUFJSCxLQTVDWTtBQTZDYixTQUFNLGFBQVUsSUFBVixFQUFnQixJQUFoQixFQUFzQjtBQUN4QixtQkFBVyxJQUFYO0FBQ0gsS0EvQ1k7QUFnRGIsV0FBUSxpQkFBWTtBQUNoQixlQUFPLGdCQUFQLENBQXdCLFFBQXhCLEVBQWtDLFVBQVUsQ0FBVixFQUFhO0FBQzNDO0FBQ0E7QUFDSCxTQUhEO0FBSUEsZUFBTyxnQkFBUCxDQUF3QixRQUF4QixFQUFrQyxZQUFZO0FBQzFDLGdCQUFJLFNBQVMsUUFBVCxDQUFrQixDQUFsQixDQUFKLEVBQTBCO0FBQ3RCLHlCQUFTLFFBQVQsQ0FBa0IsQ0FBbEIsRUFBcUIsS0FBckIsQ0FBMkIsTUFBM0IsR0FBb0MsT0FBTyxXQUFQLEdBQXFCLEdBQXJCLEdBQTJCLElBQS9EO0FBQ0g7QUFDSixTQUpEO0FBS0E7QUFDQSxtQkFBVyxZQUFZO0FBQ25CO0FBQ0E7QUFDSCxTQUhELEVBR0csSUFISDtBQUtIO0FBaEVZLENBQWpCOzs7OztBQ3BMQSxJQUFJLFlBQVcsb0JBQVk7QUFBQyxZQUFRLEdBQVIsQ0FBWSw4QkFBWjtBQUE0QyxDQUF4RTtBQUFBLElBQ0ksUUFBUTtBQUNKLGtCQUFlLHNCQUFVLElBQVYsRUFBZ0I7QUFDM0IsYUFBSyxnQkFBTCxDQUFzQixPQUF0QixFQUErQixTQUEvQjtBQUNIO0FBSEcsQ0FEWjs7QUFPQSxPQUFPLE9BQVAsR0FBaUI7QUFDYixjQUFXLGtCQUFVLEVBQVYsRUFBYztBQUNyQixvQkFBVyxFQUFYO0FBQ0gsS0FIWTtBQUliLFNBQU0sYUFBVSxJQUFWLEVBQWdCLElBQWhCLEVBQXNCO0FBQ3hCLFlBQUksTUFBTSxjQUFOLENBQXFCLElBQXJCLENBQUosRUFBZ0M7QUFDNUIsa0JBQU0sSUFBTixFQUFZLElBQVo7QUFDSDtBQUNKO0FBUlksQ0FBakI7Ozs7O0FDUEEsSUFBSSxlQUFKO0FBQUEsSUFDSSxXQUFVLGlCQUFVLElBQVYsRUFBZ0I7QUFDdEIsWUFBUSxJQUFSLENBQWEseUNBQWIsRUFBd0QsSUFBeEQ7QUFDSCxDQUhMOztBQUtBLE9BQU8sT0FBUCxHQUFpQjtBQUNiLGFBQVUsaUJBQVUsRUFBVixFQUFjO0FBQ3BCLG1CQUFVLEVBQVY7QUFDSCxLQUhZO0FBSWIsU0FBTSxhQUFVLElBQVYsRUFBZ0IsSUFBaEIsRUFBc0IsQ0FBRSxDQUpqQjtBQUtiOzs7O0FBSUEsbUJBQWdCLHVCQUFVLGlCQUFWLEVBQTZCO0FBQ3pDLHdCQUFnQixrQkFBa0IsR0FBbEIsQ0FBc0IsVUFBVSxJQUFWLEVBQWdCO0FBQ2xELG1CQUFPLEVBQUMsTUFBTyxLQUFLLElBQWIsRUFBbUIsU0FBVSxtQkFBWTtBQUM1Qyw2QkFBUSxLQUFLLEVBQWI7QUFDSCxpQkFGTSxFQUFQO0FBR0gsU0FKZSxDQUFoQjtBQUtILEtBZlk7QUFnQmI7OztBQUdBLHlCQUFzQiw2QkFBVSxFQUFWLEVBQWM7QUFDaEMsMEJBQWtCLEVBQWxCO0FBQ0g7QUFyQlksQ0FBakI7OztBQ0xBO0FBQ0E7Ozs7QUNEQSxJQUFNLFVBQVUsUUFBUSxtQkFBUixDQUFoQjtBQUNBLElBQU0sV0FBVyxRQUFRLGNBQVIsQ0FBakI7QUFDQSxJQUFNLFFBQVEsU0FBUixLQUFRLENBQVUsSUFBVixFQUFnQjtBQUMxQixZQUFPLElBQVA7QUFDSSxhQUFLLFdBQUw7QUFDSSxtQkFBTyw2REFBUDtBQUNKLGFBQUssT0FBTDtBQUNJLG1CQUFPLGdFQUFQO0FBQ0osYUFBSyxNQUFMO0FBQ0ksbUJBQU8sb0NBQVA7QUFDSixhQUFLLGdCQUFMO0FBQ0ksbUJBQU8sNEJBQVA7QUFDSixhQUFLLGNBQUw7QUFDSSxtQkFBTyw0QkFBUDtBQUNKO0FBQ0ksbUJBQU8sbUNBQVA7QUFaUjtBQWNILENBZkQ7QUFnQkE7Ozs7OztBQU1BLE9BQU8sT0FBUCxHQUFpQixnQkFBNEM7QUFBQSxRQUFqQyxRQUFpQyxRQUFqQyxRQUFpQztBQUFBLFFBQXZCLFdBQXVCLFFBQXZCLFdBQXVCO0FBQUEsUUFBVixPQUFVLFFBQVYsT0FBVTs7QUFDekQ7QUFDQSxRQUFJLFdBQUo7O0FBRUEsYUFBUyxPQUFULFFBQTJDO0FBQUEsWUFBMUIsU0FBMEIsU0FBMUIsU0FBMEI7QUFBQSxZQUFmLGFBQWUsU0FBZixZQUFlOztBQUN2QyxZQUFJLEVBQUosRUFBUSxHQUFHLE1BQUg7QUFDUixZQUFNLElBQUksU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQVY7QUFDQSxVQUFFLFNBQUYsR0FBYyxRQUFkO0FBQ0EsZ0JBQVEsR0FBUixDQUFZLEVBQUUsUUFBRixDQUFXLENBQVgsQ0FBWixFQUEyQjtBQUN2Qix1QkFBWSxzQkFBSztBQUNiLG9CQUFJLGNBQWMsZ0JBQWQsSUFBa0MsY0FBYyxPQUFoRCxJQUEyRCxjQUFjLE1BQXpFLElBQW1GLGNBQWMsYUFBakcsSUFBa0gsY0FBYyxXQUFoSSxJQUErSSxjQUFjLGNBQWpLLEVBQ0ksT0FBTyxLQUFQO0FBQ0osa0JBQUUsZ0JBQUYsQ0FBbUIsT0FBbkIsRUFBNEIsV0FBNUI7QUFDSCxhQUxzQjtBQU12QixtQkFBUTtBQUFBLHVCQUFLLEVBQUUsZ0JBQUYsQ0FBbUIsT0FBbkIsRUFBNEIsT0FBNUIsQ0FBTDtBQUFBLGFBTmU7QUFPdkIsb0JBQVM7QUFBQSx1QkFBSyxFQUFFLGdCQUFGLENBQW1CLE9BQW5CLEVBQTRCLFFBQTVCLENBQUw7QUFBQSxhQVBjO0FBUXZCLGdDQVJ1QjtBQVN2QixtQkFBUSxNQUFNLFNBQU4sQ0FUZTtBQVV2QiwwQkFBZSx5QkFBSztBQUNoQixvQkFBSSxhQUFKLEVBQWtCO0FBQ2Qsc0JBQUUsU0FBRixTQUFrQixhQUFsQjtBQUNILGlCQUZELE1BR0ksT0FBTyxLQUFQO0FBQ1A7QUFmc0IsU0FBM0I7QUFpQkEsaUJBQVMsSUFBVCxDQUFjLFdBQWQsQ0FBMEIsS0FBSyxFQUFFLFFBQUYsQ0FBVyxDQUFYLENBQS9CO0FBQ0g7O0FBRUQsV0FBTztBQUNIOzs7O0FBSUEsZ0JBQVMsZ0JBQUMsR0FBRCxFQUFNLEdBQU47QUFBQSxtQkFBYyxRQUFPLEVBQUMsV0FBWSxHQUFiLEVBQWtCLGNBQWMsR0FBaEMsRUFBUCxDQUFkO0FBQUEsU0FMTjtBQU1IOzs7QUFHQSxpQkFBVSxtQkFBTTtBQUNaLGVBQUcsTUFBSDtBQUNBLGlCQUFLLFNBQUw7QUFDSCxTQVpFO0FBYUg7OztBQUdBLHNCQUFlLHdCQUFNO0FBQ2pCLGVBQUcsU0FBSCxDQUFhLEdBQWIsQ0FBaUIsVUFBakI7QUFDSDtBQWxCRSxLQUFQO0FBb0JILENBaEREOzs7OztBQ3hCQSxJQUFJLHNCQUFxQiw4QkFBVztBQUFFLFlBQVEsSUFBUixDQUFhLDZDQUFiO0FBQTRELENBQWxHO0FBQUEsSUFDSSx1QkFBdUIsZ0NBQVc7QUFBRSxZQUFRLElBQVIsQ0FBYSwrQ0FBYjtBQUE4RCxDQUR0Rzs7QUFHQSxJQUFJLG9CQUFKLEVBQ0ksc0JBREo7O0FBR0EsU0FBUyxRQUFULENBQWtCLElBQWxCLEVBQXdCO0FBQ3BCLFNBQUssZ0JBQUwsQ0FBc0IsVUFBdEIsRUFBa0MsVUFBVSxDQUFWLEVBQWE7QUFDM0MsWUFBTSxNQUFNLEVBQUUsT0FBRixJQUFhLEVBQUUsS0FBM0I7QUFDQSxZQUFJLFFBQVEsRUFBWixFQUFnQixFQUFFLFdBQUYsR0FBZ0IsS0FBaEI7QUFDaEIsZUFBTyxJQUFQO0FBQ0gsS0FKRDtBQUtBLFdBQU8sSUFBUDtBQUNIOztBQUVELFNBQVMsa0JBQVQsQ0FBNEIsV0FBNUIsRUFBeUM7QUFDckMsV0FBUSxZQUFZLE1BQVosR0FBcUIsQ0FBckIsSUFBMEIsWUFBWSxNQUFaLENBQW1CLFNBQW5CLE1BQWtDLENBQUMsQ0FBOUQsR0FBbUUsSUFBbkUsR0FBMEUsS0FBakY7QUFDSDs7QUFFRCxTQUFTLG9CQUFULENBQThCLGFBQTlCLEVBQTZDO0FBQ3pDO0FBQ0EsV0FBUSxjQUFjLE1BQWQsR0FBdUIsQ0FBdkIsSUFBNEIsY0FBYyxNQUFkLENBQXFCLEdBQXJCLE1BQThCLENBQUMsQ0FBNUQsR0FBaUUsSUFBakUsR0FBd0UsS0FBL0U7QUFDSDs7QUFFRCxPQUFPLE9BQVAsR0FBaUI7QUFDYixTQUFNLGFBQVMsSUFBVCxFQUFlLFNBQWYsRUFBMEI7QUFDNUIsZ0JBQVEsU0FBUjtBQUNJLGlCQUFLLDhCQUFMO0FBQ0ksdUNBQXVCLElBQXZCO0FBQ0E7QUFDSixpQkFBSyx1QkFBTDtBQUNJLHlDQUF5QixTQUFTLElBQVQsQ0FBekI7QUFDQTtBQUNKLGlCQUFLLHdCQUFMO0FBQ0kscUJBQUssZ0JBQUwsQ0FBc0IsT0FBdEIsRUFBK0IsWUFBVztBQUN0Qyx3QkFBSSxjQUFjLHFCQUFxQixLQUF2QztBQUNBLHdCQUFJLG1CQUFtQixXQUFuQixDQUFKLEVBQXFDO0FBQ2pDLDRDQUFtQixXQUFuQjtBQUNILHFCQUZELE1BRU87QUFDSCw2Q0FBcUIsU0FBckIsQ0FBK0IsR0FBL0IsQ0FBbUMsT0FBbkM7QUFDSDtBQUNKLGlCQVBEO0FBUUE7QUFDSixpQkFBSywwQkFBTDtBQUNJLHFCQUFLLGdCQUFMLENBQXNCLE9BQXRCLEVBQStCLFlBQVc7QUFDdEMsd0JBQUksZ0JBQWdCLHVCQUF1QixLQUEzQztBQUNBLHdCQUFJLHFCQUFxQixhQUFyQixDQUFKLEVBQXlDO0FBQ3JDLDZDQUFxQixhQUFyQjtBQUNILHFCQUZELE1BRU87QUFDSCwrQ0FBdUIsU0FBdkIsQ0FBaUMsR0FBakMsQ0FBcUMsT0FBckM7QUFDSDtBQUNKLGlCQVBEO0FBUUE7QUFDSixpQkFBSyxRQUFMO0FBQ0kscUJBQUssZ0JBQUwsQ0FBc0IsT0FBdEIsRUFBK0IsWUFBVztBQUN0QywwQkFBTSxjQUFOLENBQXFCLElBQXJCLENBQTBCLEtBQUssT0FBTCxDQUFhLElBQXZDO0FBQ0gsaUJBRkQ7QUFHQTtBQS9CUjtBQWlDSCxLQW5DWTtBQW9DYjs7OztBQUlBLHdCQUFxQiw0QkFBUyxJQUFULEVBQWU7QUFDaEMsOEJBQXFCLElBQXJCO0FBQ0gsS0ExQ1k7QUEyQ2I7Ozs7QUFJQSx5QkFBc0IsNkJBQVMsSUFBVCxFQUFlO0FBQ2pDLCtCQUF1QixJQUF2QjtBQUNIO0FBakRZLENBQWpCOzs7Ozs7O0FDeEJBLElBQUksVUFBVSxRQUFRLFdBQVIsQ0FBZDtBQUFBLElBQ0MsaUJBQWlCLFNBQWpCLGNBQWlCLEdBQVc7O0FBRTNCLEtBQUksaUJBQWlCLE1BQU0sV0FBM0I7QUFBQSxLQUNDLG9CQUFvQixNQUFNLFdBQU4sQ0FBa0IsaUJBQWxCLENBQW9DLFVBQXBDLENBRHJCO0FBQUEsS0FFQyxXQUFXO0FBQ1YsV0FBUztBQUNSLFFBQUssRUFERztBQUVSLGVBQVksaUJBRko7QUFHUixRQUFLLGFBQVMsSUFBVCxFQUFlLEVBQWYsRUFBbUI7O0FBRXZCLFFBQUksVUFBVSxJQUFJLE9BQUosQ0FBWSxJQUFaLEVBQWtCLEVBQWxCLENBQWQ7QUFDQSxZQUFRLE9BQVIsQ0FBZ0IsWUFBVztBQUMxQix5QkFBb0IsRUFBcEIsRUFBd0IsS0FBeEI7QUFDQSxLQUZEOztBQUlBLFNBQUssVUFBTCxDQUFnQixHQUFoQixDQUFvQixRQUFRLElBQTVCLEVBQWtDO0FBQ2pDLGFBQVEsUUFBUTtBQURpQixLQUFsQztBQUdBLFNBQUssR0FBTCxDQUFTLElBQVQsQ0FBYyxRQUFRLEVBQXRCO0FBQ0E7QUFkTyxHQURDO0FBaUJWLFFBQU07QUFDTCxRQUFLLEVBREE7QUFFTCxlQUFZLGNBRlA7QUFHTCxRQUFLLGFBQVMsSUFBVCxFQUFlLEVBQWYsRUFBbUI7QUFDdkIsU0FBSyxVQUFMLENBQWdCLEdBQWhCLENBQW9CLElBQXBCLEVBQTBCO0FBQ3pCLGFBQVE7QUFEaUIsS0FBMUI7QUFHQSxTQUFLLEdBQUwsQ0FBUyxJQUFULENBQWMsRUFBZDtBQUNBO0FBUkk7QUFqQkksRUFGWjs7QUErQkEsVUFBUyxtQkFBVCxDQUE2QixFQUE3QixFQUFpQyxJQUFqQyxFQUF1QztBQUN0QyxTQUFPLElBQVAsQ0FBWSxRQUFaLEVBQXNCLEdBQXRCLENBQTBCLFVBQVMsSUFBVCxFQUFlO0FBQ3hDLE9BQUksT0FBTyxTQUFTLElBQVQsQ0FBWDtBQUFBLE9BQ0MsTUFBTSxLQUFLLEdBRFo7QUFBQSxPQUVDLFNBRkQ7O0FBSUEsUUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLElBQUksTUFBeEIsRUFBZ0MsR0FBaEMsRUFBcUM7QUFDcEMsZ0JBQVksSUFBSSxDQUFKLENBQVo7QUFDQSxRQUFJLE9BQU8sU0FBWCxFQUFzQjtBQUNyQixTQUFJLElBQUosRUFBVTtBQUNULFdBQUssVUFBTCxDQUFnQixJQUFoQixDQUFxQixTQUFyQjtBQUNBLE1BRkQsTUFHSyxJQUFJLEtBQUssVUFBTCxDQUFnQixHQUFoQixDQUFvQixFQUFwQixDQUFKLEVBQTZCO0FBQ2pDLFdBQUssVUFBTCxDQUFnQixHQUFoQixDQUFvQixFQUFwQixFQUF3QixPQUF4QixDQUFnQyxVQUFTLEdBQVQsRUFBYztBQUM3QyxXQUFJLElBQUo7QUFDQSxPQUZEO0FBR0E7QUFDRDtBQUNBO0FBQ0Q7QUFDRCxHQW5CRDtBQW9CQTs7QUFFRCxRQUFPO0FBQ04sT0FBSyxhQUFTLElBQVQsRUFBZSxVQUFmLEVBQTJCO0FBQy9CLE9BQUksSUFBSixFQUFVLEdBQVY7QUFDQSxPQUFJLFFBQU8sVUFBUCx5Q0FBTyxVQUFQLE9BQXNCLFFBQTFCLEVBQW9DO0FBQ25DLFdBQU8sT0FBTyxJQUFQLENBQVksVUFBWixDQUFQO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssTUFBekIsRUFBaUMsR0FBakMsRUFBc0M7QUFDckMsV0FBTSxLQUFLLENBQUwsQ0FBTjtBQUNBLFNBQUksU0FBUyxjQUFULENBQXdCLEdBQXhCLENBQUosRUFBa0M7QUFDakMsZUFBUyxHQUFULEVBQWMsR0FBZCxDQUFrQixJQUFsQixFQUF3QixXQUFXLEdBQVgsQ0FBeEI7QUFDQTtBQUNEO0FBQ0QsSUFSRCxNQVNLO0FBQ0osWUFBUSxJQUFSLENBQWEsNERBQTRELFVBQXpFO0FBQ0E7QUFDRCxHQWZLO0FBZ0JOLFFBQU0sY0FBUyxFQUFULEVBQWE7QUFDbEIsdUJBQW9CLEVBQXBCLEVBQXdCLElBQXhCO0FBQ0EsR0FsQks7QUFtQk4sUUFBTSxjQUFTLEVBQVQsRUFBYTtBQUNsQix1QkFBb0IsRUFBcEIsRUFBd0IsS0FBeEI7QUFDQTs7QUFyQkssRUFBUDtBQXdCQSxDQWpGRjs7QUFtRkEsT0FBTyxPQUFQLEdBQWlCLGNBQWpCOzs7OztBQ25GQTs7O0FBR0EsSUFBSSxVQUFVLFFBQVEsVUFBUixDQUFkO0FBQUEsSUFDSSxVQUFVO0FBQ04sUUFBSSxJQURFO0FBRU4sUUFBSSxJQUZFO0FBR04sUUFBSSxJQUhFO0FBSU4sUUFBSSxJQUpFO0FBS04sUUFBSSxJQUxFO0FBTU4sV0FBTyxJQU5EO0FBT04sUUFBSSxJQVBFO0FBUU4sUUFBSTtBQVJFLENBRGQ7O0FBWUEsU0FBUyxPQUFULENBQWlCLElBQWpCLEVBQXVCO0FBQ25CLFFBQUksV0FBVyxJQUFmO0FBQ0EsUUFBSSxRQUFRLGNBQVIsQ0FBdUIsSUFBdkIsQ0FBSixFQUFrQztBQUM5QixtQkFBVyxRQUFRLElBQVIsQ0FBWDtBQUNIO0FBQ0QsV0FBTyxRQUFQO0FBQ0g7O0FBRUQsT0FBTyxPQUFQLEdBQWlCO0FBQ2IsYUFBVSxpQkFBVSxJQUFWLEVBQWdCO0FBQ3RCLGVBQU8sUUFBUSxhQUFSLENBQXNCLE1BQXRCLEVBQThCLElBQTlCLEVBQW9DLHlCQUF5QixRQUFRLElBQVIsQ0FBN0QsQ0FBUDtBQUNILEtBSFk7QUFJYixvQkFBaUIsd0JBQVUsSUFBVixFQUFnQjtBQUM3QixlQUFPLENBQUMsV0FBRCxFQUFjLGVBQWUsUUFBUSxJQUFSLENBQTdCLENBQVA7QUFDSCxLQU5ZO0FBT2IsZ0JBQVksT0FQQztBQVFiLGFBQVM7QUFSSSxDQUFqQjs7Ozs7QUN2QkE7QUFDQTtBQUNBLElBQU0sU0FBUyxRQUFRLGNBQVIsQ0FBZjtBQUNBLElBQU0sSUFBSSxRQUFRLGFBQVIsQ0FBVjs7QUFFQSxPQUFPLE9BQVAsR0FBaUIsT0FBTyxPQUFQLElBQWtCLFFBQVEsVUFBUixDQUFuQzs7QUFFQSxJQUFJLGNBQWUsWUFBWTtBQUMzQjs7QUFFQSxRQUFJLFlBQUo7QUFBQSxRQUNJLE9BQU8sS0FEWDtBQUFBLFFBRUksU0FBUztBQUNMLGtCQUFXO0FBRE4sS0FGYjtBQUFBLFFBS0ksb0JBQW9CLFNBQXBCLGlCQUFvQixDQUFVLElBQVYsRUFBZ0IsR0FBaEIsRUFBcUI7QUFDckMsYUFBSyxJQUFJLElBQVQsSUFBaUIsR0FBakIsRUFBc0I7QUFDbEIsaUJBQUssS0FBTCxDQUFXLElBQVgsSUFBb0IsSUFBSSxJQUFKLENBQXBCO0FBQ0g7QUFDSixLQVRMO0FBQUEsUUFVSSxXQUFXO0FBQ1Asa0JBQVcsR0FESjtBQUVQLG1CQUFXO0FBRkosS0FWZjtBQUFBLFFBY0ksS0FBSztBQUNELHlCQUFrQiwyQkFBWTtBQUMxQixnQkFBSSxPQUFPLGFBQWEsWUFBYixDQUEwQixLQUExQixDQUFYOztBQUVBLGdCQUFJLEtBQUssTUFBTCxHQUFjLENBQWxCLEVBQXFCO0FBQ2pCO0FBQ0EscUJBQUssT0FBTCxDQUFhLFVBQVUsQ0FBVixFQUFhO0FBQ3RCLHNCQUFFLFdBQUYsQ0FBYyxRQUFkO0FBQ0gsaUJBRkQ7QUFHSDtBQUNKLFNBVkE7QUFXRCxtQkFBWSxtQkFBVSxHQUFWLEVBQWU7QUFDdkIsZ0JBQUksR0FBSjtBQUFBLGdCQUFTLEtBQUssT0FBTyxRQUFQLEdBQWtCLElBQUksRUFBcEM7QUFBQSxnQkFDSSxZQUFZLFNBQVMsY0FBVCxDQUF3QixFQUF4QixDQURoQjs7QUFHQSxnQkFBSSxjQUFjLElBQWxCLEVBQXdCO0FBQ3BCLDBCQUFVLGNBQVYsQ0FBeUIsUUFBekI7QUFDSCxhQUZELE1BRU87QUFDSCxzQkFBTSxJQUFJLEtBQUosRUFBTjtBQUNBLG9CQUFJLE1BQUosR0FBYSxZQUFZO0FBQ3JCLDRCQUFRLEdBQVIsQ0FBWSxZQUFaO0FBQ0gsaUJBRkQ7QUFHQSxvQkFBSSxHQUFKLEdBQVcsMkJBQTJCLElBQUksSUFBMUM7QUFDQSxrQ0FBa0IsR0FBbEIsRUFBdUI7QUFDbkIsOEJBQVcsTUFEUTtBQUVuQiwrQkFBWTtBQUZPLGlCQUF2QjtBQUlBLG9CQUFJLFlBQUosQ0FBaUIsSUFBakIsRUFBdUIsRUFBdkI7QUFDQSxvQkFBSSxXQUFKLENBQWdCLFlBQWhCO0FBQ0g7QUFDSjtBQTlCQSxLQWRUOztBQStDSSxXQUFPLGlCQUFQLENBQXlCLFVBQXpCLEVBQXFDLFVBQVUsR0FBVixFQUFlO0FBQ2hELFlBQUksSUFBSixFQUFVO0FBQ04sZUFBRyxlQUFIOztBQUVBLGdCQUFJLElBQUksUUFBSixLQUFpQixFQUFFLFlBQUYsQ0FBZSxVQUFmLENBQTBCLEtBQS9DLEVBQXNEO0FBQ2xELG1CQUFHLFNBQUgsQ0FBYSxHQUFiO0FBQ0g7QUFDSjtBQUNKLEtBUkQ7O0FBV0osV0FBTztBQUNILGFBQU0sYUFBVSxJQUFWLEVBQWdCLElBQWhCLEVBQXNCO0FBQ3hCLG1CQUFPLElBQVA7QUFDQSwyQkFBZSxJQUFmO0FBQ0EseUJBQWEsWUFBYixDQUEwQixJQUExQixFQUFnQyxhQUFoQzs7QUFFQSw4QkFBa0IsWUFBbEIsRUFBZ0M7QUFDNUIsdUJBQVEsU0FBUyxRQUFULEdBQW9CLElBREE7QUFFNUIsd0JBQVEsU0FBUyxTQUFULEdBQXFCO0FBRkQsYUFBaEM7QUFJSCxTQVZFO0FBV0gsZUFBUSxlQUFVLE1BQVYsRUFBa0I7QUFDdEIsZ0JBQUksR0FBSjtBQUNBLGlCQUFLLEdBQUwsSUFBWSxNQUFaLEVBQW9CO0FBQ2hCLHlCQUFTLEdBQVQsSUFBZ0IsT0FBTyxHQUFQLENBQWhCO0FBQ0g7QUFDSjtBQWhCRSxLQUFQO0FBa0JILENBL0VrQixFQUFuQjs7QUFpRkEsT0FBTyxPQUFQLEdBQWlCLFdBQWpCOzs7OztBQ3ZGQSxTQUFTLE9BQVQsQ0FBaUIsSUFBakIsRUFBdUIsRUFBdkIsRUFBMkI7QUFDeEIsUUFBSSxNQUFNLFFBQVEsYUFBUixDQUFzQixLQUF0QixFQUE2QixJQUE3QixFQUFtQyxxREFBbkMsQ0FBVjtBQUNDLFFBQUksZ0JBQUosQ0FBcUIsT0FBckIsRUFBOEIsVUFBVSxLQUFWLEVBQWlCO0FBQzNDLGFBQUssU0FBTCxDQUFlLEdBQWYsQ0FBbUIsUUFBbkI7QUFDQSxXQUFHLEtBQUg7QUFDSCxLQUhEO0FBSUEsUUFBSSxZQUFKLENBQWlCLE9BQWpCLEVBQTBCLE1BQTFCO0FBQ0EsU0FBSyxXQUFMLENBQWlCLEdBQWpCO0FBQ0g7QUFDRCxTQUFTLFNBQVQsQ0FBbUIsSUFBbkIsRUFBeUIsRUFBekIsRUFBNkI7QUFDekIsUUFBSSxNQUFNLFFBQVEsYUFBUixDQUFzQixLQUF0QixFQUE2QixJQUE3QixFQUFtQyxrREFBbkMsQ0FBVjtBQUNBLFFBQUksZ0JBQUosQ0FBcUIsT0FBckIsRUFBOEIsVUFBVSxLQUFWLEVBQWlCO0FBQzNDLGFBQUssU0FBTCxDQUFlLE1BQWYsQ0FBc0IsUUFBdEI7QUFDQSxXQUFHLEtBQUg7QUFDSCxLQUhEO0FBSUEsUUFBSSxZQUFKLENBQWlCLE9BQWpCLEVBQTBCLFFBQTFCO0FBQ0EsU0FBSyxXQUFMLENBQWlCLEdBQWpCO0FBQ0g7O0FBRUQsU0FBUyxPQUFULENBQWlCLElBQWpCLEVBQXVCLEVBQXZCLEVBQTJCO0FBQ3ZCLFFBQUksTUFBTSxRQUFRLGFBQVIsQ0FBc0IsS0FBdEIsRUFBNkIsSUFBN0IsRUFBbUMsb0RBQW5DLENBQVY7QUFDQSxRQUFJLGdCQUFKLENBQXFCLE9BQXJCLEVBQThCLFVBQVUsS0FBVixFQUFpQjtBQUMzQyxXQUFHLEtBQUg7QUFDSCxLQUZEO0FBR0EsUUFBSSxZQUFKLENBQWlCLE9BQWpCLEVBQTBCLGNBQTFCO0FBQ0EsU0FBSyxXQUFMLENBQWlCLEdBQWpCO0FBQ0g7O0FBRUQsU0FBUyxRQUFULENBQWtCLElBQWxCLEVBQXdCLEVBQXhCLEVBQTRCO0FBQ3hCLFFBQUksTUFBTSxRQUFRLGFBQVIsQ0FBc0IsS0FBdEIsRUFBNkIsSUFBN0IsRUFBbUMsZ0VBQW5DLENBQVY7QUFDQSxRQUFJLGdCQUFKLENBQXFCLE9BQXJCLEVBQThCLFVBQVUsS0FBVixFQUFpQjtBQUMzQyxXQUFHLEtBQUg7QUFDSCxLQUZEO0FBR0EsUUFBSSxZQUFKLENBQWlCLE9BQWpCLEVBQTBCLDhCQUExQjtBQUNBLFNBQUssV0FBTCxDQUFpQixHQUFqQjtBQUNIOztBQUVELFNBQVMsU0FBVCxDQUFtQixJQUFuQixFQUF5QixFQUF6QixFQUE2QjtBQUN6QixRQUFJLE1BQU0sUUFBUSxhQUFSLENBQXNCLEtBQXRCLEVBQTZCLElBQTdCLEVBQW1DLHlEQUFuQyxDQUFWO0FBQ0EsUUFBSSxnQkFBSixDQUFxQixPQUFyQixFQUE4QixVQUFVLEtBQVYsRUFBaUI7QUFDM0MsV0FBRyxLQUFIO0FBQ0gsS0FGRDtBQUdBLFFBQUksWUFBSixDQUFpQixPQUFqQixFQUEwQixpQkFBMUI7QUFDQSxTQUFLLFdBQUwsQ0FBaUIsR0FBakI7QUFDSDs7QUFFRCxTQUFTLGVBQVQsQ0FBeUIsWUFBekIsRUFBdUM7QUFDbkMsUUFBSSxrQkFBa0IsYUFBYSxVQUFiLENBQXdCLGFBQXhCLENBQXNDLHdCQUF0QyxDQUF0QjtBQUNBLFFBQUksZUFBSixFQUFxQjtBQUNqQix3QkFBZ0IsU0FBaEIsQ0FBMEIsTUFBMUIsQ0FBaUMsUUFBakM7QUFDSDtBQUNKOztBQUVELE9BQU8sT0FBUCxHQUFpQjtBQUNiOzs7O0FBSUEsbUJBQWdCLHVCQUFVLFlBQVYsRUFBd0I7QUFDcEMsWUFBSSxZQUFKLEVBQWtCO0FBQ2QsNEJBQWdCLFlBQWhCO0FBQ0g7QUFDSixLQVRZO0FBVWIsb0JBQWlCLHdCQUFVLE9BQVYsRUFBbUIsU0FBbkIsRUFBOEI7QUFDM0MsWUFBSSxnQkFBZ0IsUUFBUSxhQUFSLENBQXNCLEtBQXRCLEVBQTZCLElBQTdCLEVBQW1DLHVCQUFuQyxDQUFwQjs7QUFFQSxZQUFJLFVBQVUsY0FBVixDQUF5QixRQUF6QixDQUFKLEVBQXdDO0FBQ3BDLG9CQUFRLGFBQVIsRUFBdUIsVUFBVSxNQUFqQztBQUNIO0FBQ0QsWUFBSSxVQUFVLGNBQVYsQ0FBeUIsVUFBekIsQ0FBSixFQUEwQztBQUN0QyxzQkFBVSxhQUFWLEVBQXlCLFVBQVUsUUFBbkM7QUFDSDtBQUNELFlBQUksVUFBVSxjQUFWLENBQXlCLFFBQXpCLENBQUosRUFBd0M7QUFDcEMsb0JBQVEsYUFBUixFQUF1QixVQUFVLE1BQWpDO0FBQ0g7QUFDRCxZQUFJLFVBQVUsY0FBVixDQUF5QixTQUF6QixDQUFKLEVBQXlDO0FBQ3JDLHFCQUFTLGFBQVQsRUFBd0IsVUFBVSxPQUFsQztBQUNIO0FBQ0QsWUFBSSxVQUFVLGNBQVYsQ0FBeUIsVUFBekIsQ0FBSixFQUEwQztBQUN0QyxzQkFBVSxhQUFWLEVBQXlCLFVBQVUsUUFBbkM7QUFDSDs7QUFFRCxzQkFBYyxXQUFkLENBQTBCLE9BQTFCOztBQUVBLGVBQU8sYUFBUDtBQUNILEtBaENZO0FBaUNiLGlCQUFjLHFCQUFVLElBQVYsRUFBZ0I7QUFDMUIsYUFBSyxhQUFMLENBQW1CLHdCQUFuQixFQUE2QyxTQUE3QztBQUNIO0FBbkNZLENBQWpCOzs7OztBQ3REQSxPQUFPLE9BQVAsR0FBaUIsWUFBWTtBQUMzQixNQUFJLGFBQUo7O0FBRUEsU0FBTztBQUNMLFNBQUssYUFBQyxDQUFELEVBQU87QUFDVixhQUFPLENBQVA7QUFDRCxLQUhJO0FBSUwsVUFBTSxnQkFBTTtBQUNWLFdBQUssU0FBTCxDQUFlLEdBQWYsQ0FBbUIsTUFBbkI7QUFDRCxLQU5JO0FBT0wsVUFBTSxnQkFBTTtBQUNWLFdBQUssU0FBTCxDQUFlLE1BQWYsQ0FBc0IsTUFBdEI7QUFDRDtBQVRJLEdBQVA7QUFXRCxDQWREOzs7OztBQ0NBLElBQUksUUFBSjs7QUFFQSxPQUFPLE9BQVAsR0FBaUI7QUFDYixVQUFPLGdCQUFZO0FBQ2YsaUJBQVMsU0FBVCxDQUFtQixHQUFuQixDQUF1QixRQUF2QjtBQUNILEtBSFk7QUFJYixVQUFPLGdCQUFZO0FBQ2YsaUJBQVMsU0FBVCxDQUFtQixNQUFuQixDQUEwQixRQUExQjtBQUNILEtBTlk7QUFPYixTQUFNLGFBQVUsSUFBVixFQUFnQixJQUFoQixFQUFzQjtBQUN4QixZQUFJLFNBQVMsUUFBYixFQUF1QjtBQUNuQixpQkFBSyxnQkFBTCxDQUFzQixPQUF0QixFQUErQixZQUFZO0FBQ3hDLG9CQUFJLFNBQVMsU0FBVCxDQUFtQixRQUFuQixDQUE0QixRQUE1QixDQUFKLEVBQTJDO0FBQ3ZDLDZCQUFTLFNBQVQsQ0FBbUIsTUFBbkIsQ0FBMEIsUUFBMUI7QUFDSCxpQkFGRCxNQUVPO0FBQ0gsNkJBQVMsU0FBVCxDQUFtQixHQUFuQixDQUF1QixRQUF2QjtBQUNIO0FBQ0gsYUFORDtBQU9ILFNBUkQsTUFRTztBQUNILHVCQUFXLElBQVg7QUFDSDtBQUNKO0FBbkJZLENBQWpCOzs7OztBQ0hBLE9BQU8sT0FBUCxHQUFpQixTQUFTLE9BQVQsQ0FBaUIsSUFBakIsRUFBdUIsRUFBdkIsRUFBMkI7O0FBRTNDLEtBQUksS0FBSyxFQUFUO0FBQUEsS0FDQyxPQUFPLElBRFI7QUFBQSxLQUVDLGVBQWUsd0JBQVc7QUFDekIsVUFBUSxJQUFSLENBQWEsc0RBQXNELEVBQW5FO0FBQ0EsRUFKRjs7QUFNQSxNQUFLLFNBQUwsQ0FBZSxHQUFmLENBQW1CLHdCQUFuQjtBQUNBLE1BQUssZ0JBQUwsQ0FBc0IsT0FBdEIsRUFBK0IsVUFBVSxDQUFWLEVBQWE7QUFDM0MsTUFBSSxTQUFTLEVBQUUsTUFBZixFQUF1QjtBQUN0QjtBQUNBO0FBQ0QsRUFKRDs7QUFNQSxRQUFPO0FBQ04sTUFBSSxFQURFO0FBRU4sUUFBTSxJQUZBO0FBR04sV0FBUyxpQkFBUyxFQUFULEVBQWE7QUFDckIsa0JBQWUsRUFBZjtBQUNBO0FBTEssRUFBUDtBQU9BLENBdEJEOzs7OztBQ0FBO0FBQ0E7O0FBRUEsSUFBSSxRQUFRLFFBQVEsT0FBUixDQUFaO0FBQUEsSUFDSSxPQUFPLFFBQVEsUUFBUixDQURYO0FBQUEsSUFFSSxRQUFRLFFBQVEsU0FBUixDQUZaOztBQUlBOzs7Ozs7Ozs7QUFTQSxJQUFJLHdCQUF5QixZQUFZO0FBQ3JDOztBQUVBLFFBQUksUUFBSjtBQUFBLFFBQ0ksc0JBQXNCLEVBRDFCO0FBQUEsUUFFSSxrQkFBa0IsRUFGdEI7QUFBQSxRQUdJLDBCQUEwQixFQUg5QjtBQUFBLFFBSUkseUJBQXlCLEVBSjdCO0FBQUEsUUFLSSxrQkFBa0IsRUFMdEI7QUFBQSxRQU1JLDBCQUEwQixFQU45QjtBQUFBLFFBT0ksd0JBQXdCLEVBUDVCO0FBQUEsUUFRSSxhQUFhLE9BQU8sT0FBUCxDQUFlLE1BQWYsQ0FBc0IsTUFSdkM7QUFBQSxRQVNJLFdBQVc7QUFDUCxjQUFPLGNBQVUsSUFBVixFQUFnQjtBQUNuQix1QkFBVyxJQUFYO0FBQ0gsU0FITTtBQUlQLDBCQUFtQiwwQkFBVSxJQUFWLEVBQWdCO0FBQy9CLGdCQUFJLE9BQUosQ0FBWSxJQUFaLEVBQWtCO0FBQ2QsZ0NBQWlCO0FBQ2IseUJBQU0scUNBRE87QUFFYiwrQkFBWSxDQUNSO0FBQ0ksNEJBQUssbUJBRFQ7QUFFSSx3Q0FBaUI7QUFDYixrQ0FBTyxFQUFFLEtBQU0saURBQVIsRUFETTtBQUViLGdDQUFLLEVBQUUsS0FBTSx3REFBUjtBQUZRO0FBRnJCLHFCQURRLEVBUVI7QUFDSSw0QkFBSyxtQkFEVDtBQUVJLHdDQUFpQjtBQUNiLGtDQUFPLEVBQUUsS0FBTSx1Q0FBUixFQUFpRCxRQUFTLHdCQUExRCxFQURNO0FBRWIsZ0NBQUssRUFBRSxLQUFNLGlCQUFSO0FBRlE7QUFGckIscUJBUlEsRUFlUjtBQUNJLDRCQUFLLG1CQURUO0FBRUksd0NBQWlCO0FBQ2Isa0NBQU8sRUFBRSxLQUFNLGdEQUFSLEVBRE07QUFFYixnQ0FBSyxFQUFFLEtBQU0sd0RBQVI7QUFGUTtBQUZyQixxQkFmUTtBQUZDO0FBREgsYUFBbEIsRUEyQkc7QUFDQyx3QkFBUyxLQUFLLE9BRGYsRUFDd0IsT0FBTyxJQUQvQixFQUNxQyxNQUFPLEVBQUMsR0FBSSxLQUFMLEVBQVksR0FBSSxLQUFoQjtBQUQ1QyxhQTNCSDtBQThCQSxpQkFBSyxnQkFBTCxDQUFzQixPQUF0QixFQUErQixZQUFZO0FBQ3ZDLG9CQUFJLFNBQVMsU0FBVCxDQUFtQixRQUFuQixDQUE0QixRQUE1QixDQUFKLEVBQTJDO0FBQ3ZDLDZCQUFTLFNBQVQsQ0FBbUIsTUFBbkIsQ0FBMEIsUUFBMUI7QUFDSCxpQkFGRCxNQUVPO0FBQ0gsNkJBQVMsU0FBVCxDQUFtQixHQUFuQixDQUF1QixRQUF2QjtBQUNIO0FBQ0osYUFORDtBQU9ILFNBMUNNO0FBMkNQLGtDQUEyQixrQ0FBVSxJQUFWLEVBQWdCO0FBQ3ZDO0FBQ0EsaUJBQUssWUFBTCxDQUFrQixNQUFsQixFQUEwQixHQUExQjtBQUNBLGlCQUFLLGdCQUFMLENBQXNCLE9BQXRCLEVBQStCLFlBQVk7QUFDdkMseUJBQVMsTUFBVDtBQUNILGFBRkQ7QUFHSCxTQWpETTtBQWtEUCxpQ0FBMEIsaUNBQVUsSUFBVixFQUFnQjtBQUN0QyxpQkFBSyxnQkFBTCxDQUFzQixPQUF0QixFQUErQixZQUFZO0FBQ3ZDLGdDQUFnQixPQUFoQixDQUF3QixVQUFVLEVBQVYsRUFBYztBQUNsQztBQUNILGlCQUZEO0FBR0gsYUFKRDtBQUtILFNBeERNO0FBeURQLHdCQUFpQix3QkFBUyxJQUFULEVBQWU7QUFDNUIsaUJBQUssZ0JBQUwsQ0FBc0IsT0FBdEIsRUFBK0IsWUFBVztBQUN0QyxnQ0FBZ0IsT0FBaEIsQ0FBd0IsVUFBVSxFQUFWLEVBQWM7QUFDbEM7QUFDSCxpQkFGRDtBQUdILGFBSkQ7QUFLSCxTQS9ETTtBQWdFUCwwQkFBbUIsMEJBQVMsSUFBVCxFQUFlO0FBQzlCLGlCQUFLLGdCQUFMLENBQXNCLE9BQXRCLEVBQStCLFlBQVc7QUFDdEMsd0NBQXdCLE9BQXhCLENBQWdDLFVBQVUsRUFBVixFQUFjO0FBQzFDO0FBQ0gsaUJBRkQ7QUFHSCxhQUpEO0FBS0gsU0F0RU07QUF1RVAsd0JBQWlCLHdCQUFTLElBQVQsRUFBZTtBQUM1QixpQkFBSyxnQkFBTCxDQUFzQixPQUF0QixFQUErQixZQUFXO0FBQ3RDLHNDQUFzQixPQUF0QixDQUE4QixVQUFVLEVBQVYsRUFBYztBQUN4QztBQUNILGlCQUZEO0FBR0gsYUFKRDtBQUtILFNBN0VNO0FBOEVQLDBCQUFtQiwwQkFBUyxJQUFULEVBQWU7QUFDOUIsaUJBQUssZ0JBQUwsQ0FBc0IsT0FBdEIsRUFBK0IsWUFBVztBQUN0Qyx3Q0FBd0IsT0FBeEIsQ0FBZ0MsVUFBVSxFQUFWLEVBQWM7QUFDMUM7QUFDSCxpQkFGRDtBQUdILGFBSkQ7QUFLSCxTQXBGTTtBQXFGUCx5QkFBa0IseUJBQVMsSUFBVCxFQUFlO0FBQzdCLGlCQUFLLGdCQUFMLENBQXNCLE9BQXRCLEVBQStCLFlBQVc7QUFDdEMsdUNBQXVCLE9BQXZCLENBQStCLFVBQVUsRUFBVixFQUFjO0FBQ3pDO0FBQ0gsaUJBRkQ7QUFHSCxhQUpEO0FBS0gsU0EzRk07QUE0RlAsY0FBTyxjQUFVLElBQVYsRUFBZ0I7QUFDbkIsaUJBQUssSUFBTCxDQUFVLElBQVYsR0FBaUIsSUFBakI7QUFDSCxTQTlGTTtBQStGUCxZQUFLLFlBQVUsSUFBVixFQUFnQjtBQUNqQixpQkFBSyxFQUFMLENBQVEsSUFBUixHQUFlLElBQWY7QUFDSDtBQWpHTSxLQVRmOztBQTZHQTs7Ozs7QUFLQSxhQUFTLFNBQVQsQ0FBbUIsT0FBbkIsRUFBNEIsSUFBNUIsRUFBa0M7QUFDOUIsWUFBSSxLQUFLLEtBQUssYUFBTCxDQUFtQixZQUFuQixDQUFUO0FBQUEsWUFBMkMsRUFBM0M7QUFBQSxZQUErQyxnQkFBL0M7QUFBQSxZQUFpRSxZQUFqRTtBQUFBLFlBQStFLE1BQS9FO0FBQ0EsWUFBSSxFQUFKLEVBQVE7QUFDSjtBQUNBLGVBQUcsS0FBSCxDQUFTLElBQVQsQ0FBYyxHQUFHLGdCQUFILENBQW9CLElBQXBCLENBQWQsRUFBeUMsT0FBekMsQ0FBaUQsVUFBVSxJQUFWLEVBQWdCO0FBQzdELG1CQUFHLFdBQUgsQ0FBZSxJQUFmO0FBQ0gsYUFGRDtBQUdILFNBTEQsTUFLTztBQUNILGlCQUFLLE9BQU8sT0FBUCxDQUFlLGFBQWYsQ0FBNkIsSUFBN0IsRUFBbUMsSUFBbkMsRUFBeUMsMEJBQXpDLENBQUw7QUFDSDtBQUNELGdCQUFRLE9BQVIsQ0FBZ0IsVUFBVSxHQUFWLEVBQWU7QUFDM0IsZ0JBQUksaUJBQWlCLE9BQU8sT0FBUCxDQUFlLGFBQWYsQ0FBNkIsTUFBN0IsRUFBcUMsSUFBckMsRUFBMkMsZ0JBQTNDLENBQXJCO0FBQUEsZ0JBQ0ksYUFBYSxPQUFPLE9BQVAsQ0FBZSxhQUFmLENBQTZCLE1BQTdCLEVBQXFDLElBQXJDLEVBQTJDLFFBQTNDLENBRGpCO0FBRUEsaUJBQUssT0FBTyxPQUFQLENBQWUsYUFBZixDQUE2QixJQUE3QixDQUFMO0FBQ0EsK0JBQW1CLE9BQU8sT0FBUCxDQUFlLGFBQWYsQ0FBNkIsTUFBN0IsQ0FBbkI7QUFDQSwyQkFBZSxPQUFPLE9BQVAsQ0FBZSxhQUFmLENBQTZCLE1BQTdCLEVBQXFDLElBQXJDLEVBQTJDLFVBQTNDLENBQWY7QUFDQSwyQkFBZSxXQUFmLENBQTJCLFNBQVMsY0FBVCxDQUF3QixHQUF4QixDQUEzQjtBQUNBLDJCQUFlLFdBQWYsQ0FBMkIsWUFBM0I7QUFDQSx5QkFBYSxXQUFiLENBQXlCLFNBQVMsY0FBVCxDQUF3QixHQUF4QixDQUF6QjtBQUNBLHVCQUFXLFdBQVgsQ0FBdUIsU0FBUyxjQUFULENBQXdCLEdBQXhCLENBQXZCO0FBQ0EsdUJBQVcsV0FBWCxDQUF1QixZQUF2Qjs7QUFFQSxlQUFHLFNBQUgsQ0FBYSxHQUFiLENBQWlCLE1BQWpCO0FBQ0EsZUFBRyxTQUFILENBQWEsR0FBYixDQUFpQixHQUFqQjs7QUFFQSxlQUFHLGdCQUFILENBQW9CLE9BQXBCLEVBQTZCLFlBQVk7QUFDckMsb0JBQUksYUFBYSxJQUFqQjtBQUFBLG9CQUNJLFdBQVcsS0FBSyxTQUFMLENBQWUsUUFBZixDQUF3QixVQUF4QixDQURmOztBQUdBLG9CQUFJLFFBQUosRUFBYztBQUNWLHlCQUFLLFNBQUwsQ0FBZSxNQUFmLENBQXNCLFlBQXRCO0FBQ0EsaUNBQWEsS0FBSyxTQUFMLENBQWUsUUFBZixDQUF3QixZQUF4QixDQUFiO0FBQ0gsaUJBSEQsTUFHTztBQUNIO0FBQ0g7O0FBRUQsb0NBQW9CLE9BQXBCLENBQTRCLFVBQVUsRUFBVixFQUFjO0FBQ3RDLHVCQUFHO0FBQ0Msa0NBQVcsUUFEWjtBQUVDLG9DQUFhLFVBRmQ7QUFHQyxpQ0FBVSxVQUhYO0FBSUMsa0NBQVU7QUFKWCxxQkFBSDtBQU1ILGlCQVBEO0FBUUgsYUFuQkQ7O0FBcUJBLDZCQUFpQixTQUFqQixHQUE2QixNQUFNLGdCQUFOLENBQXVCLEdBQXZCLENBQTdCO0FBQ0EsNkJBQWlCLFNBQWpCLEdBQTZCLFVBQTdCO0FBQ0EsNkJBQWlCLFdBQWpCLENBQTZCLEVBQTdCO0FBQ0EseUJBQWEsV0FBYixDQUF5QixFQUF6QjtBQUNBLHFCQUFTLEtBQUssT0FBTCxDQUFhLEdBQWIsQ0FBVDtBQUNBLG1CQUFPLFNBQVAsQ0FBaUIsR0FBakIsQ0FBcUIsTUFBckIsRUFBNkIsU0FBN0IsRUFBd0MsY0FBeEM7QUFDQSxtQkFBTyxXQUFQLENBQW1CLEVBQW5CO0FBQ0EsZUFBRyxXQUFILENBQWUsRUFBZjtBQUNILFNBNUNEO0FBNkNBLFdBQUcsV0FBSCxDQUFlLElBQWY7QUFDSDs7QUFFRDs7Ozs7QUFLQSxhQUFTLGFBQVQsQ0FBdUIsSUFBdkIsRUFBNkIsSUFBN0IsRUFBbUM7QUFDL0IsV0FBRyxLQUFILENBQVMsSUFBVCxDQUFjLEtBQUssZ0JBQUwsQ0FBc0Isa0JBQXRCLENBQWQsRUFBeUQsT0FBekQsQ0FBaUUsVUFBUyxRQUFULEVBQW1CO0FBQ2hGLHFCQUFTLGFBQVQsQ0FBdUIsU0FBdkIsRUFBa0MsU0FBbEMsR0FBOEMsSUFBOUM7QUFDSCxTQUZEO0FBR0g7O0FBRUQ7Ozs7OztBQU1BLGFBQVMsc0JBQVQsQ0FBZ0MsR0FBaEMsRUFBcUMsSUFBckMsRUFBMkMsSUFBM0MsRUFBaUQ7QUFDN0MsZ0JBQVEsR0FBUixDQUFZLDhDQUFaLEVBQTRELEdBQTVELEVBQWlFLElBQWpFO0FBQ0EsYUFBSyxhQUFMLENBQW1CLHNCQUFzQixJQUF0QixHQUE2QixrQkFBaEQsRUFBb0UsU0FBcEUsR0FBZ0YsR0FBaEY7QUFDSDs7QUFFRCxXQUFPO0FBQ0gsdUNBQWdDLHVDQUFVLE9BQVYsRUFBbUI7QUFDL0MsMEJBQWMsT0FBZCxFQUF1QixTQUFTLElBQVQsQ0FBYyxJQUFyQztBQUNILFNBSEU7QUFJSCwwQ0FBbUMsMENBQVUsWUFBVixFQUF3QixJQUF4QixFQUE4QjtBQUM3RCxtQ0FBdUIsWUFBdkIsRUFBcUMsSUFBckMsRUFBMkMsU0FBUyxJQUFULENBQWMsSUFBekQ7QUFDSCxTQU5FO0FBT0gsMEJBQW1CLDBCQUFVLEVBQVYsRUFBYztBQUM3QixnQ0FBb0IsSUFBcEIsQ0FBeUIsRUFBekI7QUFDSCxTQVRFO0FBVUgsb0JBQWEsb0JBQVUsRUFBVixFQUFjO0FBQ3ZCLDRCQUFnQixJQUFoQixDQUFxQixFQUFyQjtBQUNILFNBWkU7QUFhSCxvQkFBYSxvQkFBVSxFQUFWLEVBQWM7QUFDdkIsNEJBQWdCLElBQWhCLENBQXFCLEVBQXJCO0FBQ0gsU0FmRTtBQWdCSCw0QkFBcUIsNEJBQVUsRUFBVixFQUFjO0FBQy9CLG9DQUF3QixJQUF4QixDQUE2QixFQUE3QjtBQUNILFNBbEJFO0FBbUJILDBCQUFtQiwwQkFBVSxFQUFWLEVBQWM7QUFDN0Isa0NBQXNCLElBQXRCLENBQTJCLEVBQTNCO0FBQ0gsU0FyQkU7QUFzQkgsNEJBQXFCLDRCQUFVLEVBQVYsRUFBYztBQUMvQixvQ0FBd0IsSUFBeEIsQ0FBNkIsRUFBN0I7QUFDSCxTQXhCRTtBQXlCSCwyQkFBb0IsMkJBQVUsRUFBVixFQUFjO0FBQzlCLG1DQUF1QixJQUF2QixDQUE0QixFQUE1QjtBQUNILFNBM0JFO0FBNEJILHNCQUFlLHNCQUFVLElBQVYsRUFBZ0I7QUFDM0IsZ0JBQUksT0FBTyxTQUFTLGFBQVQsQ0FBdUIsUUFBUSxJQUEvQixDQUFYO0FBQ0EsaUJBQUssU0FBTCxDQUFlLE1BQWYsQ0FBc0IsWUFBdEI7QUFDQSxpQkFBSyxTQUFMLENBQWUsR0FBZixDQUFtQixVQUFuQjtBQUNILFNBaENFO0FBaUNILHdCQUFpQix3QkFBVSxJQUFWLEVBQWdCO0FBQzdCLGdCQUFJLE9BQU8sU0FBUyxhQUFULENBQXVCLFFBQVEsSUFBL0IsQ0FBWDtBQUNBLGlCQUFLLFNBQUwsQ0FBZSxHQUFmLENBQW1CLFlBQW5CO0FBQ0gsU0FwQ0U7QUFxQ0g7Ozs7OztBQU1BLHNDQUErQixzQ0FBVSxTQUFWLEVBQXFCLHFCQUFyQixFQUE0QztBQUN2RSxlQUFHLEtBQUgsQ0FBUyxJQUFULENBQWMsU0FBUyxnQkFBVCxDQUEwQixJQUExQixDQUFkLEVBQStDLE9BQS9DLENBQXVELFVBQVUsSUFBVixFQUFnQjtBQUNuRSxvQkFBSSxlQUFlLEtBQUssYUFBTCxDQUFtQixXQUFuQixDQUFuQjtBQUNBLHFCQUFLLFNBQUwsQ0FBZSxNQUFmLENBQXNCLFVBQXRCO0FBQ0Esb0JBQUksWUFBSixFQUFrQjtBQUNkLGlDQUFhLFFBQWIsQ0FBc0IsQ0FBdEIsRUFBeUIsU0FBekIsR0FBcUMsR0FBckM7QUFDQSxpQ0FBYSxRQUFiLENBQXNCLENBQXRCLEVBQXlCLFNBQXpCLEdBQXFDLEdBQXJDO0FBQ0g7QUFDSixhQVBEOztBQVNBLG1CQUFPLElBQVAsQ0FBWSxxQkFBWixFQUFtQyxPQUFuQyxDQUEyQyxVQUFVLEdBQVYsRUFBZTtBQUN0RCxtQkFBRyxLQUFILENBQVMsSUFBVCxDQUFjLFNBQVMsZ0JBQVQsQ0FBMEIsUUFBUSxHQUFsQyxDQUFkLEVBQXNELE9BQXRELENBQThELFVBQVUsSUFBVixFQUFnQjtBQUMxRSx3QkFBSSxlQUFlLEtBQUssYUFBTCxDQUFtQixXQUFuQixDQUFuQjtBQUNBLHlCQUFLLFNBQUwsQ0FBZSxHQUFmLENBQW1CLFVBQW5CO0FBQ0Esd0JBQUksWUFBSixFQUFrQjtBQUNmLHFDQUFhLFFBQWIsQ0FBc0IsQ0FBdEIsRUFBeUIsU0FBekIsR0FBcUMsc0JBQXNCLEdBQXRCLENBQXJDO0FBQ0EscUNBQWEsUUFBYixDQUFzQixDQUF0QixFQUF5QixTQUF6QixHQUFxQyxTQUFyQztBQUNGO0FBQ0osaUJBUEQ7QUFRSCxhQVREO0FBVUgsU0EvREU7QUFnRUgsK0JBQXdCLCtCQUFVLFNBQVYsRUFBcUI7QUFDekMsc0JBQVUsU0FBVixFQUFxQixTQUFTLElBQVQsQ0FBYyxJQUFuQztBQUNILFNBbEVFO0FBbUVILGVBQVEsaUJBQVk7QUFDaEIsb0JBQVEsR0FBUixDQUFZLDRCQUFaO0FBQ0gsU0FyRUU7QUFzRUgsYUFBTSxhQUFVLElBQVYsRUFBZ0IsSUFBaEIsRUFBc0I7QUFBSztBQUM3QixnQkFBSSxTQUFTLGNBQVQsQ0FBd0IsSUFBeEIsQ0FBSixFQUFtQztBQUMvQix5QkFBUyxJQUFULEVBQWUsSUFBZjtBQUNILGFBRkQsTUFFTztBQUNILHdCQUFRLEdBQVIsQ0FBWSxzQkFBWjtBQUNIO0FBQ0o7QUE1RUUsS0FBUDtBQThFSCxDQW5SNEIsRUFBN0I7O0FBcVJBLE9BQU8sT0FBUCxHQUFrQixxQkFBbEI7Ozs7O0FDclNBLElBQUksa0JBQW1CLFlBQVc7QUFDOUI7O0FBRUEsUUFBSSxpQkFBSjtBQUFBLFFBQ0ksZ0NBREo7QUFBQSxRQUVJLDBCQUF5QixrQ0FBVztBQUFFLGdCQUFRLElBQVIsQ0FBYSxnREFBYjtBQUErRCxLQUZ6RztBQUFBLFFBR0ksNkJBQTRCLHFDQUFXO0FBQUMsZ0JBQVEsSUFBUixDQUFhLG1EQUFiO0FBQWtFLEtBSDlHO0FBQUEsUUFJSSxxQkFBb0IsNkJBQVc7QUFBRSxnQkFBUSxJQUFSLENBQWEsMkNBQWI7QUFBMEQsS0FKL0Y7QUFBQSxRQUtJLDBCQUF5QixrQ0FBVztBQUFFLGdCQUFRLElBQVIsQ0FBYSxnREFBYjtBQUErRCxLQUx6RztBQUFBLFFBTUksd0JBQXdCLGlDQUFXO0FBQUUsZ0JBQVEsSUFBUixDQUFhLCtDQUFiO0FBQThELEtBTnZHO0FBQUEsUUFPSSx5QkFBd0IsaUNBQVc7QUFBRSxnQkFBUSxJQUFSLENBQWEsK0NBQWI7QUFBOEQsS0FQdkc7QUFBQSxRQVFJLHVCQUFzQiwrQkFBVztBQUFFLGdCQUFRLElBQVIsQ0FBYSw2Q0FBYjtBQUE0RCxLQVJuRztBQUFBLFFBU0ksNEJBQTJCLG9DQUFXO0FBQUUsZ0JBQVEsSUFBUixDQUFhLGtEQUFiO0FBQWlFLEtBVDdHO0FBQUEsUUFVSSxrQkFBa0IsS0FWdEI7O0FBWUEsV0FBTztBQUNIOzs7Ozs7QUFNQSxhQUFLLGFBQVUsSUFBVixFQUFnQixJQUFoQixFQUFzQjtBQUN2QixnQkFBSSxzQkFBc0IsU0FBMUIsRUFBcUM7QUFDakMsb0NBQW9CLElBQXBCO0FBQ0gsYUFGRCxNQUVPO0FBQ0gsd0JBQVEsSUFBUixDQUFhLDZGQUFiO0FBQ0g7QUFDSixTQWJFO0FBY0g7OztBQUdBLGVBQU8saUJBQVc7O0FBRWQsZ0JBQUksMEJBQTBCLGtCQUFrQixhQUFsQixDQUFnQyx5QkFBaEMsQ0FBOUI7QUFDQSxnQkFBSSxDQUFDLHVCQUFMLEVBQThCO0FBQzFCLHdCQUFRLEtBQVIsQ0FBYyx1RkFBZDtBQUNILGFBRkQsTUFFTztBQUNILHdDQUF3QixnQkFBeEIsQ0FBeUMsT0FBekMsRUFBa0QsVUFBUyxLQUFULEVBQWdCO0FBQzlEO0FBQ0gsaUJBRkQ7QUFHSDs7QUFFRCxnQkFBSSx5QkFBeUIsa0JBQWtCLGFBQWxCLENBQWdDLHdCQUFoQyxDQUE3QjtBQUNBLGdCQUFJLENBQUMsc0JBQUwsRUFBNkI7QUFDekIsd0JBQVEsS0FBUixDQUFjLHNGQUFkO0FBQ0gsYUFGRCxNQUVPO0FBQ0gsdUNBQXVCLGdCQUF2QixDQUF3QyxPQUF4QyxFQUFpRCxVQUFTLEtBQVQsRUFBZ0I7QUFDN0Q7QUFDSCxpQkFGRDtBQUdIOztBQUVELGdCQUFJLDJCQUEyQixrQkFBa0IsYUFBbEIsQ0FBZ0MsMEJBQWhDLENBQS9CO0FBQ0EsZ0JBQUksQ0FBQyx3QkFBTCxFQUErQjtBQUMzQix3QkFBUSxLQUFSLENBQWMsc0ZBQWQ7QUFDSCxhQUZELE1BRU87QUFDSCx5Q0FBeUIsZ0JBQXpCLENBQTBDLE9BQTFDLEVBQW1ELFVBQVMsS0FBVCxFQUFnQjtBQUMvRCxzQ0FBa0IsQ0FBQyxlQUFuQjtBQUNBLHNDQUFrQixTQUFsQixDQUE0QixNQUE1QixDQUFtQyxrQkFBbkMsRUFBdUQsZUFBdkQ7QUFDQSw2Q0FBeUIsU0FBekIsQ0FBbUMsTUFBbkMsQ0FBMEMsUUFBMUMsRUFBb0QsZUFBcEQ7QUFDSCxpQkFKRDtBQUtIOztBQUVELGdCQUFJLDhCQUE4QixrQkFBa0IsYUFBbEIsQ0FBZ0MsaUNBQWhDLENBQWxDO0FBQ0EsZ0JBQUksQ0FBQywyQkFBTCxFQUFrQztBQUM5Qix3QkFBUSxLQUFSLENBQWMsZ0dBQWQ7QUFDSCxhQUZELE1BRU87QUFDSCw0Q0FBNEIsZ0JBQTVCLENBQTZDLE9BQTdDLEVBQXNELFVBQVMsS0FBVCxFQUFnQjtBQUNsRTtBQUNILGlCQUZEO0FBR0g7QUFDSixTQXhERTtBQXlESDs7Ozs7O0FBTUEsbUNBQTJCLG1DQUFVLFlBQVYsRUFBd0IsY0FBeEIsRUFBd0M7QUFDL0QsZ0JBQUkseUJBQXlCLEVBQTdCOztBQUVBLGdCQUFJLENBQUMsWUFBRCxJQUFpQixDQUFDLGNBQXRCLEVBQXNDO0FBQ2xDO0FBQ0gsYUFGRCxNQUVPLElBQUksQ0FBQyxnQ0FBTCxFQUF1QztBQUMxQyx3QkFBUSxLQUFSLENBQWMsc0ZBQWQ7QUFDQTtBQUNIOztBQUVELG9CQUFRLEdBQVIsQ0FBWSxjQUFaLEVBQTRCLFlBQTVCO0FBQ0Esb0JBQVEsR0FBUixDQUFZLGlCQUFaLEVBQStCLGNBQS9COztBQUVBLHlCQUFhLE9BQWIsQ0FBcUIsVUFBUyxXQUFULEVBQXNCO0FBQ3ZDLHVDQUF1QixJQUF2QixDQUE0QjtBQUN4QiwwQkFBTyxXQURpQjtBQUV4Qix5QkFBTSxLQUZrQjtBQUd4Qix5Q0FBc0IsK0JBQVk7QUFDOUIsZ0NBQVEsR0FBUixDQUFZLG1CQUFaLEVBQWlDLFdBQWpDO0FBQ0EsNEJBQUksa0JBQUosRUFBdUI7QUFDbkIsK0NBQWtCLFdBQWxCO0FBQ0g7QUFDSixxQkFSdUI7QUFTeEIsMkNBQXdCLGlDQUFXO0FBQy9CLDRCQUFJLG9CQUFvQixPQUFPLE9BQVAsQ0FBZSwyQkFBMkIsV0FBM0IsR0FBeUMsR0FBeEQsQ0FBeEI7QUFDQSw0QkFBSSwyQkFBMEIsaUJBQTlCLEVBQWlEO0FBQzdDLG9EQUF1QixXQUF2QjtBQUNIO0FBQ0oscUJBZHVCO0FBZXhCLGlDQUFjLHVCQUFNO0FBQ2hCLDhDQUFzQixXQUF0QjtBQUNIO0FBakJ1QixpQkFBNUI7QUFtQkgsYUFwQkQ7QUFxQkEsMkJBQWUsT0FBZixDQUF1QixVQUFTLGFBQVQsRUFBd0I7QUFDM0MsdUNBQXVCLElBQXZCLENBQTRCO0FBQ3hCLDBCQUFPLGFBRGlCO0FBRXhCLHlCQUFNLElBRmtCO0FBR3hCLHlDQUFzQiwrQkFBVztBQUM3QixnQ0FBUSxHQUFSLENBQVkscUJBQVosRUFBbUMsYUFBbkM7QUFDQSw0QkFBSSxvQkFBSixFQUF5QjtBQUNyQixpREFBb0IsYUFBcEI7QUFDSDtBQUNKLHFCQVJ1QjtBQVN4QiwyQ0FBd0IsaUNBQVc7QUFDL0IsNEJBQUksb0JBQW9CLE9BQU8sT0FBUCxDQUFlLDBCQUEwQixhQUExQixHQUEwQyxHQUF6RCxDQUF4QjtBQUNBLDRCQUFJLDBCQUF5QixpQkFBN0IsRUFBZ0Q7QUFDNUMsbURBQXNCLGFBQXRCO0FBQ0g7QUFDSjtBQWR1QixpQkFBNUI7QUFnQkgsYUFqQkQ7O0FBbUJBLDZDQUFpQyxzQkFBakM7QUFDSCxTQXJIRTtBQXNISDs7OztBQUlBLHFEQUE4QyxxREFBUyxJQUFULEVBQWU7QUFDekQsK0NBQW1DLElBQW5DO0FBQ0gsU0E1SEU7QUE2SEgsK0JBQXdCLCtCQUFTLFFBQVQsRUFBbUI7QUFDdkMsZ0JBQUksT0FBTyxrQkFBa0IsYUFBbEIsQ0FBZ0Msc0JBQXNCLFFBQXRCLEdBQWlDLEdBQWpFLENBQVg7QUFDQSxnQkFBSSxRQUFRLEtBQUssVUFBakIsRUFBNkI7QUFDekIscUJBQUssVUFBTCxDQUFnQixXQUFoQixDQUE0QixJQUE1QjtBQUNIO0FBQ0osU0FsSUU7QUFtSUg7Ozs7QUFJQSxtQ0FBNEIsbUNBQVMsUUFBVCxFQUFtQjtBQUMzQyx5Q0FBNEIsUUFBNUI7QUFDSCxTQXpJRTtBQTBJSDs7Ozs7QUFLQSwyQkFBb0IsMkJBQVMsUUFBVCxFQUFtQjtBQUNuQyxpQ0FBb0IsUUFBcEI7QUFDSCxTQWpKRTtBQWtKSDs7Ozs7QUFLQSw2QkFBc0IsNkJBQVMsUUFBVCxFQUFtQjtBQUNyQyxtQ0FBc0IsUUFBdEI7QUFDSCxTQXpKRTtBQTBKSCxnQ0FBeUIsZ0NBQVMsSUFBVCxFQUFlO0FBQ3BDLHNDQUF5QixJQUF6QjtBQUNILFNBNUpFO0FBNkpILGdDQUF5QixnQ0FBUyxJQUFULEVBQWU7QUFDcEMsc0NBQXlCLElBQXpCO0FBQ0gsU0EvSkU7QUFnS0gsK0JBQXdCLCtCQUFTLElBQVQsRUFBZTtBQUNuQyxxQ0FBd0IsSUFBeEI7QUFDSCxTQWxLRTtBQW1LSCxrQ0FBMkIsa0NBQVMsSUFBVCxFQUFlO0FBQ3RDLHdDQUEyQixJQUEzQjtBQUNILFNBcktFO0FBc0tILGdDQUF5QixnQ0FBUyxJQUFULEVBQWU7QUFDcEMsb0NBQXdCLElBQXhCO0FBQ0g7QUF4S0UsS0FBUDtBQTBLSCxDQXpMcUIsRUFBdEI7O0FBMkxBLE9BQU8sT0FBUCxHQUFpQixlQUFqQjs7Ozs7QUMzTEEsSUFBSSxZQUFXLG9CQUFZO0FBQUMsWUFBUSxHQUFSLENBQVksZ0NBQVo7QUFBOEMsQ0FBMUU7QUFBQSxJQUNJLFNBQVMsS0FEYjtBQUFBLElBRUksUUFGSjtBQUFBLElBR0ksU0FISjtBQUFBLElBSUksUUFBUTtBQUNKLFVBQU0sY0FBUyxJQUFULEVBQWU7QUFDakIsbUJBQVcsSUFBWDtBQUNILEtBSEc7QUFJSixXQUFRLGVBQVUsSUFBVixFQUFnQjtBQUNwQixvQkFBWSxJQUFaO0FBQ0EsYUFBSyxnQkFBTCxDQUFzQixPQUF0QixFQUErQixVQUFTLEtBQVQsRUFBZ0I7QUFDM0Msa0JBQU0sY0FBTjtBQUNBLGdCQUFJLFVBQVUsTUFBTSxPQUFOLEtBQWtCLEVBQWhDLEVBQW9DO0FBQ2hDO0FBQ0g7QUFDSixTQUxEO0FBTUgsS0FaRztBQWFKLFlBQVMsZ0JBQVUsSUFBVixFQUFnQjtBQUNyQixhQUFLLGdCQUFMLENBQXNCLE9BQXRCLEVBQStCLFVBQVMsS0FBVCxFQUFnQjtBQUMzQyxnQkFBSSxNQUFKLEVBQVk7QUFDUjtBQUNIO0FBQ0osU0FKRDtBQUtIO0FBbkJHLENBSlo7O0FBMEJBLE9BQU8sT0FBUCxHQUFpQjtBQUNiLGNBQVcsa0JBQVMsRUFBVCxFQUFhO0FBQ3BCLG9CQUFXLEVBQVg7QUFDSCxLQUhZO0FBSWIsUUFBSSxTQUFKLEdBQWdCO0FBQ1osZUFBTyxTQUFQO0FBQ0gsS0FOWTtBQU9iLFNBQU0sYUFBUyxJQUFULEVBQWUsSUFBZixFQUFxQjtBQUN2QixZQUFJLE1BQU0sY0FBTixDQUFxQixJQUFyQixDQUFKLEVBQWdDO0FBQzVCLGtCQUFNLElBQU4sRUFBWSxJQUFaO0FBQ0g7QUFDSixLQVhZO0FBWWIsVUFBTyxnQkFBVztBQUNkLGlCQUFTLFNBQVQsQ0FBbUIsR0FBbkIsQ0FBdUIsTUFBdkI7QUFDQSxpQkFBUyxJQUFUO0FBQ0gsS0FmWTtBQWdCYixVQUFPLGdCQUFXO0FBQ2QsaUJBQVMsS0FBVDtBQUNBLGlCQUFTLFNBQVQsQ0FBbUIsTUFBbkIsQ0FBMEIsTUFBMUI7QUFDSDtBQW5CWSxDQUFqQjs7O0FDMUJBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7OztBQ0RBLElBQU0sVUFBVSxRQUFRLG1CQUFSLENBQWhCO0FBQ0EsSUFBTSxRQUFRLFFBQVEsU0FBUixDQUFkO0FBQ0EsSUFBTSxXQUFXLFFBQVEsY0FBUixDQUFqQjtBQUNBLElBQU0sV0FBVyxRQUFRLGlCQUFSLENBQWpCO0FBQ0EsSUFBTSxVQUFVLFFBQVEsZ0JBQVIsQ0FBaEI7QUFDQSxJQUFNLGNBQWMsUUFBUSxvQkFBUixDQUFwQjtBQUNBLElBQU0sVUFBVSxRQUFRLGdCQUFSLENBQWhCO0FBQ0EsSUFBTSxZQUFZLFFBQVEsa0JBQVIsQ0FBbEI7QUFDQSxJQUFNLGFBQWEsUUFBUSxtQkFBUixDQUFuQjtBQUNBLElBQU0sYUFBYSxRQUFRLG1CQUFSLENBQW5COztBQUVBLE9BQU8sT0FBUCxHQUFpQixnQkFBdUI7QUFBQSxNQUFYLE9BQVcsUUFBWCxPQUFXOztBQUN0QyxNQUFJLGdCQUFKOztBQUVBLE1BQU0sT0FBTyxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBYjtBQUNBLE9BQUssU0FBTCxHQUFpQixRQUFqQjs7QUFFQSxNQUFNLFVBQVUsS0FBSyxRQUFMLENBQWMsQ0FBZCxDQUFoQjtBQUNBLE1BQU0sV0FBVyxRQUFRLGFBQVIsQ0FBc0IsV0FBdEIsQ0FBakI7QUFDQSxNQUFNLGFBQWEsUUFBUSxhQUFSLENBQXNCLGtCQUF0QixDQUFuQjtBQUNBLE1BQU0sT0FBTyxRQUFRLGFBQVIsQ0FBc0IsZUFBdEIsQ0FBYjtBQUNBLE1BQU0sVUFBVSxRQUFRLGFBQVIsQ0FBc0IsVUFBdEIsQ0FBaEI7QUFDQSxVQUFRLFNBQVIsR0FBb0IsT0FBcEI7O0FBRUEsTUFBTSxlQUFlLFFBQVEsYUFBUixDQUFzQix1QkFBdEIsQ0FBckI7QUFDQSxlQUFhLGdCQUFiLENBQThCLFFBQTlCLEVBQXdDLFVBQVUsS0FBVixFQUFpQjtBQUN2RCxrQkFBYyxDQUFkO0FBQ0EsZUFBVyxXQUFXLE9BQVgsQ0FBWDtBQUNELEdBSEQ7O0FBS0EsTUFBTSxhQUFhLFFBQVEsYUFBUixDQUFzQixhQUF0QixDQUFuQjtBQUNBLE1BQU0sbUJBQW1CLEVBQXpCO0FBQ0EsTUFBSSxjQUFjLENBQWxCOztBQUVBLFdBQVMsbUJBQVQsQ0FBNkIsUUFBN0IsRUFBdUMsVUFBdkMsRUFBbUQsV0FBbkQsRUFBZ0U7QUFDOUQsV0FBTyxTQUNKLEdBREksQ0FDQSxVQUFDLElBQUQsRUFBVTtBQUNiLFdBQUssT0FBTCxHQUFlLEtBQUssT0FBTCxDQUFhLE1BQWIsQ0FDYixVQUFDLE1BQUQ7QUFBQSxlQUNFLENBQUMsV0FBRCxJQUNDLGVBQWUsT0FBTyxJQUFQLENBQVksT0FBWixDQUFvQixVQUFwQixNQUFvQyxDQUFDLENBRnZEO0FBQUEsT0FEYSxDQUFmO0FBS0EsYUFBTyxJQUFQO0FBQ0QsS0FSSSxFQVNKLE1BVEksQ0FTRyxVQUFDLElBQUQ7QUFBQSxhQUFVLEtBQUssT0FBTCxDQUFhLE1BQWIsR0FBc0IsQ0FBaEM7QUFBQSxLQVRILENBQVA7QUFVRDs7QUFFRCxXQUFTLFdBQVQsQ0FBcUIsT0FBckIsRUFBOEI7QUFDNUIsUUFBSSxpQkFBaUIsQ0FBckI7QUFDQSxRQUFJLFlBQVksRUFBaEI7QUFDQSxZQUFRLE9BQVIsQ0FBZ0IsVUFBQyxJQUFELEVBQVU7QUFDeEIsV0FBSyxPQUFMLENBQWEsT0FBYixDQUFxQixVQUFDLE1BQUQsRUFBWTtBQUMvQixZQUFNLE9BQU8sTUFBTSxPQUFOLENBQWMsT0FBTyxJQUFyQixDQUFiO0FBQ0EsWUFBSSxVQUFVLE9BQVYsQ0FBa0IsSUFBbEIsTUFBNEIsQ0FBQyxDQUFqQyxFQUFvQztBQUNsQyxvQkFBVSxJQUFWLENBQWUsSUFBZjtBQUNEO0FBQ0Q7QUFDRCxPQU5EO0FBT0QsS0FSRDtBQVNBLFdBQU87QUFDTCxvQ0FESztBQUVMO0FBRkssS0FBUDtBQUlEOztBQUVELFdBQVMsWUFBVCxDQUFzQixJQUF0QixFQUE0QixXQUE1QixFQUF5QztBQUN2QyxZQUFRLEdBQVIsQ0FBWSxXQUFaLEVBQXlCO0FBQ3ZCLGFBQU8sS0FBSyxVQURXO0FBRXZCLHNCQUFnQixLQUFLLGNBRkU7QUFHdkIsYUFBTyxlQUFDLENBQUQ7QUFBQSxlQUFPLEVBQUUsZ0JBQUYsQ0FBbUIsT0FBbkIsRUFBNEIsT0FBNUIsQ0FBUDtBQUFBO0FBSGdCLEtBQXpCO0FBS0Q7O0FBRUQsV0FBUyxXQUFULENBQXFCLFNBQXJCLEVBQWdDLFdBQWhDLEVBQTZDO0FBQzNDO0FBQ0EsY0FDRyxJQURILENBQ1EsVUFBQyxDQUFELEVBQUksQ0FBSjtBQUFBLGFBQVcsSUFBSSxDQUFKLEdBQVEsQ0FBQyxDQUFULEdBQWEsQ0FBeEI7QUFBQSxLQURSLEVBRUcsT0FGSCxDQUVXLFVBQUMsSUFBRCxFQUFVO0FBQ2pCLGFBQU8sTUFBTSxPQUFOLENBQWMsSUFBZCxDQUFQO0FBQ0EsVUFBSSxhQUFhLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUFqQjtBQUNBLGlCQUFXLFNBQVgsR0FBdUIsVUFBdkI7QUFDQSxjQUFRLEdBQVIsQ0FBWSxVQUFaLEVBQXdCO0FBQ3RCLGNBQU07QUFEZ0IsT0FBeEI7QUFHQSxrQkFBWSxXQUFaLENBQXdCLFdBQVcsUUFBWCxDQUFvQixDQUFwQixDQUF4QjtBQUNELEtBVkg7QUFXRDs7QUFFRCxXQUFTLGFBQVQsQ0FBdUIsS0FBdkIsRUFBOEIsVUFBOUIsRUFBMEMsUUFBMUMsRUFBb0QsUUFBcEQsRUFBOEQ7QUFDNUQsVUFDRyxNQURILENBQ1UsVUFBQyxJQUFELEVBQU8sS0FBUDtBQUFBLGFBQWlCLFNBQVMsVUFBVCxJQUF1QixRQUFRLFFBQWhEO0FBQUEsS0FEVixFQUVHLE9BRkgsQ0FFVyxVQUFDLElBQUQsRUFBVTtBQUNqQixVQUFJLGNBQWMsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQWxCO0FBQ0Esa0JBQVksU0FBWixHQUF3QixXQUF4QjtBQUNBLGNBQVEsR0FBUixDQUFZLFdBQVosRUFBeUI7QUFDdkIsb0JBQVksS0FBSztBQURNLE9BQXpCOztBQUlBLFVBQU0sVUFBVSxZQUFZLGFBQVosQ0FBMEIsV0FBMUIsQ0FBaEI7O0FBRUEsV0FBSyxPQUFMLENBQWEsT0FBYixDQUFxQixVQUFDLE1BQUQsRUFBWTtBQUMvQixZQUFJLFVBQVUsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQWQ7QUFDQSxnQkFBUSxTQUFSLEdBQW9CLE9BQXBCO0FBQ0EsWUFBTSxPQUFPLE1BQU0sT0FBTixDQUFjLE9BQU8sSUFBckIsQ0FBYjtBQUNBLGdCQUFRLEdBQVIsQ0FBWSxPQUFaLEVBQXFCO0FBQ25CLGVBQUssT0FBTyxHQURPO0FBRW5CLGVBQUssT0FBTyxHQUZPO0FBR25CLGdCQUFNLElBSGE7QUFJbkIsZ0JBQU0sT0FBTztBQUpNLFNBQXJCO0FBTUEsZ0JBQVEsV0FBUixDQUFvQixRQUFRLFFBQVIsQ0FBaUIsQ0FBakIsQ0FBcEI7QUFDRCxPQVhEOztBQWFBLFVBQUksUUFBUSxpQkFBUixHQUE0QixDQUFoQyxFQUFtQztBQUNqQyxpQkFBUyxXQUFULENBQXFCLFlBQVksUUFBWixDQUFxQixDQUFyQixDQUFyQjtBQUNEO0FBQ0YsS0EzQkg7QUE0QkQ7O0FBRUQsV0FBUyxnQkFBVCxDQUEwQixRQUExQixFQUFvQyxXQUFwQyxFQUFpRDtBQUFBLCtCQUN0QyxVQURzQztBQUU3QyxVQUFNLFVBQVUsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQWhCO0FBQ0EsY0FBUSxTQUFSLEdBQW9CLFVBQXBCOztBQUVBLFVBQU0sU0FBUyxRQUFRLFFBQVIsQ0FBaUIsQ0FBakIsQ0FBZjs7QUFFQSxjQUFRLEdBQVIsQ0FBWSxNQUFaLEVBQW9CO0FBQ2xCLG9CQUFZLGFBQWE7QUFEUCxPQUFwQjs7QUFJQSxhQUFPLGdCQUFQLENBQXdCLE9BQXhCLEVBQWlDLFlBQVk7QUFDM0Msc0JBQWMsVUFBZDtBQUNBLG1CQUFXLFdBQVcsT0FBWCxDQUFYO0FBQ0QsT0FIRDs7QUFLQSxVQUFJLGdCQUFnQixVQUFwQixFQUFnQztBQUM5QixlQUFPLFNBQVAsQ0FBaUIsR0FBakIsQ0FBcUIsUUFBckI7QUFDRDs7QUFFRCxrQkFBWSxXQUFaLENBQXdCLE1BQXhCO0FBcEI2Qzs7QUFDL0MsU0FBSyxJQUFJLGFBQWEsQ0FBdEIsRUFBeUIsY0FBYyxRQUF2QyxFQUFpRCxZQUFqRCxFQUErRDtBQUFBLFlBQXRELFVBQXNEO0FBb0I5RDtBQUNGOztBQUVELFdBQVMsVUFBVCxDQUFvQixJQUFwQixFQUEwQjtBQUN4QixjQUFVLElBQVY7O0FBRUEsUUFBSSxhQUFhLEtBQUssS0FBTCxDQUFXLEtBQUssU0FBTCxDQUFlLE9BQWYsQ0FBWCxDQUFqQjtBQUNBLFFBQUksaUJBQWlCLFdBQVcsSUFBaEM7QUFDQSxRQUFNLGFBQWEsV0FBVyxXQUE5Qjs7QUFFQSxhQUFTLFNBQVQsR0FBcUIsUUFBckI7QUFDQSxlQUFXLFNBQVgsR0FBdUIsRUFBdkI7QUFDQSxTQUFLLFNBQUwsR0FBaUIsRUFBakI7QUFDQSxlQUFXLFNBQVgsR0FBdUIsRUFBdkI7O0FBRUEsUUFBSSxlQUFlLE1BQWYsR0FBd0IsQ0FBNUIsRUFBK0I7QUFDN0IsVUFBTSxhQUFhLGNBQWMsZ0JBQWpDO0FBQ0EsVUFBTSxXQUFXLENBQUMsY0FBYyxDQUFmLElBQW9CLGdCQUFyQzs7QUFFQSx1QkFBaUIsb0JBQ2YsV0FBVyxJQURJLEVBRWYsVUFGZSxFQUdmLGFBQWEsT0FIRSxDQUFqQjtBQUtBLFVBQU0sV0FBVyxZQUFZLGNBQVosQ0FBakI7O0FBRUEsbUJBQ0UsRUFBRSxzQkFBRixFQUFjLGdCQUFnQixTQUFTLGNBQXZDLEVBREYsRUFFRSxPQUZGO0FBSUEsa0JBQVksU0FBUyxTQUFyQixFQUFnQyxVQUFoQztBQUNBLG9CQUFjLGNBQWQsRUFBOEIsVUFBOUIsRUFBMEMsUUFBMUMsRUFBb0QsSUFBcEQ7QUFDQSxVQUFNLFdBQVcsS0FBSyxLQUFMLENBQVcsZUFBZSxNQUFmLEdBQXdCLGdCQUFuQyxDQUFqQjtBQUNBLFVBQUksV0FBVyxDQUFmLEVBQWtCO0FBQ2hCLHlCQUFpQixRQUFqQixFQUEyQixVQUEzQjtBQUNEO0FBQ0YsS0FyQkQsTUFxQk87QUFDTCxtQkFBYSxFQUFFLHNCQUFGLEVBQWMsZ0JBQWdCLENBQTlCLEVBQWIsRUFBZ0QsT0FBaEQ7QUFDQSxVQUFNLGNBQWMsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQXBCO0FBQ0Esa0JBQVksU0FBWixHQUF3QixTQUF4QjtBQUNBLFdBQUssV0FBTCxDQUFpQixZQUFZLFFBQVosQ0FBcUIsQ0FBckIsQ0FBakI7QUFDRDs7QUFFRCxhQUFTLElBQVQsQ0FBYyxXQUFkLENBQTBCLE9BQTFCO0FBQ0Q7O0FBRUQsU0FBTztBQUNMOzs7O0FBSUEsWUFBUSxVQUxIO0FBTUw7OztBQUdBLGFBQVMsbUJBQVk7QUFDbkIsaUJBQVcsU0FBWCxHQUF1QixFQUF2QjtBQUNBLGVBQVMsSUFBVCxDQUFjLFdBQWQsQ0FBMEIsT0FBMUI7QUFDQSxvQkFBYyxDQUFkO0FBQ0Q7QUFiSSxHQUFQO0FBZUQsQ0E5TEQ7Ozs7O0FDWEE7OztBQUdBLElBQUksUUFBUyxZQUFZO0FBQ3JCOztBQUNBLFFBQUksSUFBSjtBQUFBLFFBQ0ksZ0JBQWdCO0FBQ1osWUFBSSxTQURRO0FBRVosWUFBSSxhQUZRO0FBR1osWUFBSSxRQUhRO0FBSVosWUFBSSxXQUpRO0FBS1osWUFBSSx5QkFMUTtBQU1aLGVBQU8sZ0JBTks7QUFPWixZQUFJLFNBUFE7QUFRWixZQUFJO0FBUlEsS0FEcEI7QUFBQSxRQVdJLFFBQVE7QUFDSixxQkFBZSx1QkFBWSxDQUFFLENBRHpCO0FBRUosY0FBTztBQUNILHlCQUFhLEVBRFY7QUFFSCxnQ0FBb0I7QUFGakI7QUFGSCxLQVhaOztBQW1CQSxXQUFPO0FBQ0gsMEJBQW1CLDBCQUFVLEdBQVYsRUFBZTtBQUFDLG1CQUFPLGNBQWMsR0FBZCxDQUFQO0FBQTBCLFNBRDFEO0FBRUgsa0JBQVcsa0JBQVUsSUFBVixFQUFnQjtBQUN2QixrQkFBTSxXQUFOLENBQWtCLEtBQWxCLEVBQXlCLElBQXpCO0FBQ0gsU0FKRTtBQUtILGtCQUFXLGtCQUFVLEVBQVYsRUFBYztBQUNyQixvQkFBUSxHQUFSLENBQVksNkJBQVo7QUFDQSxrQkFBTSxXQUFOLEdBQW9CLEVBQXBCO0FBQ0Esa0JBQU0sV0FBTixDQUFrQixLQUFsQixFQUF5QixNQUFNLElBQS9CO0FBQ0gsU0FURTtBQVVILGFBQU0sYUFBVSxJQUFWLEVBQWdCLElBQWhCLEVBQXNCO0FBQ3hCLG1CQUFPLElBQVA7QUFDSCxTQVpFO0FBYUgsZUFBUSxpQkFBWTtBQUNoQixvQkFBUSxHQUFSLENBQVksY0FBWjtBQUNIO0FBZkUsS0FBUDtBQWlCSCxDQXRDWSxFQUFiOztBQXdDQSxPQUFPLE9BQVAsR0FBaUIsS0FBakI7Ozs7Ozs7QUMzQ0EsSUFBSSxPQUFPLFFBQVEsV0FBUixDQUFYO0FBQUEsSUFDSSxtQkFBbUIsUUFBUSx1QkFBUixDQUR2QjtBQUFBLElBRUksY0FBYyxRQUFRLHFCQUFSLENBRmxCO0FBQUEsSUFHSSxpQkFBaUIsUUFBUSxPQUFSLEVBQWlCLGNBSHRDO0FBQUEsSUFJSSxPQUFPO0FBQ0gsZUFBVyxLQURSO0FBRUgsaUJBQWEsV0FGVjtBQUdILHNCQUFrQjtBQUhmLENBSlg7QUFBQSxJQVNJLFlBQVksS0FUaEI7QUFVQTs7Ozs7QUFLQSxTQUFTLFlBQVQsQ0FBc0IsTUFBdEIsRUFBOEIsTUFBOUIsRUFBc0Msa0JBQXRDLEVBQTBEO0FBQ3RELFdBQU8sSUFBUCxDQUFZLElBQVosRUFBa0IsT0FBbEIsQ0FBMEIsVUFBUyxJQUFULEVBQWU7QUFDckMsWUFBSSxJQUFKO0FBQ0EsWUFBSSxTQUFTLGtCQUFiLEVBQWlDO0FBQzdCLCtCQUFtQixPQUFuQixDQUEyQixVQUFTLElBQVQsRUFBZTtBQUN0Qyx1QkFBTyxTQUFTLGNBQVQsQ0FBd0Isa0JBQWtCLE1BQWxCLEVBQTBCLElBQTFCLENBQXhCLENBQVA7QUFDQSxvQkFBSSxJQUFKLEVBQVU7QUFDTix5QkFBSyxZQUFMLENBQWtCLElBQWxCLEVBQXdCLGtCQUFrQixNQUFsQixFQUEwQixJQUExQixDQUF4QjtBQUNILGlCQUZELE1BRU87QUFDSCw0QkFBUSxLQUFSLENBQWMsd0RBQWQsRUFBd0Usa0JBQWtCLE1BQWxCLEVBQTBCLElBQTFCLENBQXhFO0FBQ0g7QUFDSixhQVBEO0FBUUgsU0FURCxNQVNPO0FBQ0gsbUJBQU8sU0FBUyxjQUFULENBQXdCLEtBQUssSUFBTCxJQUFhLE1BQXJDLENBQVA7QUFDQSxnQkFBSSxJQUFKLEVBQVU7QUFDTixxQkFBSyxZQUFMLENBQWtCLElBQWxCLEVBQXdCLEtBQUssSUFBTCxJQUFhLE1BQXJDO0FBQ0gsYUFGRCxNQUVPO0FBQ0gsd0JBQVEsS0FBUixDQUFjLHdEQUFkLEVBQXdFLEtBQUssSUFBTCxJQUFhLE1BQXJGLEVBQTZGLFdBQTdGLEVBQTBHLElBQTFHO0FBQ0g7QUFDSjtBQUNKLEtBbkJEO0FBb0JIOztBQUVELFNBQVMsbUJBQVQsQ0FBNkIsQ0FBN0IsRUFBZ0M7QUFDNUIsUUFBSSxNQUFNLEVBQUUsT0FBRixJQUFhLEVBQUUsS0FBekI7QUFDQSxRQUFJLFFBQVEsRUFBWixFQUFnQjtBQUNaLFVBQUUsV0FBRixHQUFnQixLQUFoQjtBQUNIO0FBQ0QsV0FBTyxJQUFQO0FBQ0g7O0FBRUQsU0FBUyxjQUFULENBQXdCLE1BQXhCLEVBQWdDO0FBQzVCLFdBQVEsT0FBTyxNQUFQLEdBQWdCLENBQWhCLElBQXFCLE9BQU8sTUFBUCxDQUFjLFNBQWQsTUFBNkIsQ0FBQyxDQUFwRCxHQUF5RCxJQUF6RCxHQUFnRSxLQUF2RTtBQUNIOztBQUVELFNBQVMsaUJBQVQsQ0FBMkIsR0FBM0IsRUFBZ0MsSUFBaEMsRUFBc0M7QUFDbEMsV0FBTyxLQUFLLGdCQUFMLEdBQXdCLENBQUMsR0FBRCxFQUFNLElBQU4sRUFBWSxJQUFaLENBQWlCLEdBQWpCLENBQS9CO0FBQ0g7O0FBRUQsU0FBUyxnQkFBVCxDQUEwQixLQUExQixFQUFpQztBQUM3QixXQUFPLFlBQVksS0FBbkI7QUFDSDs7QUFFRDs7Ozs7Ozs7OztBQVVBLFNBQVMsaUJBQVQsQ0FBMkIsS0FBM0IsRUFBa0M7QUFDOUIsV0FBTyxRQUFRLElBQVIsQ0FBYSxLQUFiLENBQVAsRUFBMkI7QUFBQztBQUN4QixnQkFBUSxNQUFNLE9BQU4sQ0FBYyxPQUFkLEVBQXVCLEVBQXZCLENBQVI7QUFDSDtBQUNELFdBQU8sUUFBUSxJQUFSLENBQWEsS0FBYixDQUFQLEVBQTJCO0FBQUM7QUFDeEIsZ0JBQVEsTUFBTSxPQUFOLENBQWMsT0FBZCxFQUF1QixFQUF2QixDQUFSO0FBQ0g7QUFDRCxXQUFPLE1BQU0sSUFBTixDQUFXLEtBQVgsQ0FBUCxFQUF5QjtBQUFDO0FBQ3RCLGdCQUFRLE1BQU0sT0FBTixDQUFjLEtBQWQsRUFBcUIsR0FBckIsQ0FBUjtBQUNIO0FBQ0QsV0FBTyw2QkFBSSxLQUFKLEdBQVcsTUFBWCxDQUFrQixVQUFDLElBQUQ7QUFBQSxlQUFVLFFBQU8sSUFBUCxDQUFZLElBQVo7QUFBVjtBQUFBLEtBQWxCLEVBQStDLE1BQXREO0FBQ0g7O0FBRUQsU0FBUyxvQkFBVCxDQUE4QixRQUE5QixFQUF3QztBQUNwQyxXQUFPLHNCQUFzQixRQUE3QjtBQUNIOztBQUVELFNBQVMsMEJBQVQsQ0FBb0MsSUFBcEMsRUFBMEM7QUFDdEMsUUFBSSxlQUFlLFFBQVEsYUFBUixDQUFzQixLQUF0QixFQUE2QixJQUE3QixFQUFtQyxhQUFhLElBQWhELENBQW5CO0FBQUEsUUFDSSxZQUFZLEtBQUssY0FBTCxDQUFvQixJQUFwQixFQUEwQixHQUExQixFQURoQjtBQUFBLFFBRUksaUJBQWlCLFFBQVEsYUFBUixDQUFzQixNQUF0QixFQUE4QixJQUE5QixFQUFvQyxrQkFBa0IsTUFBbEIsQ0FBeUIsU0FBekIsQ0FBcEMsQ0FGckI7QUFHQSxtQkFBZSxTQUFmLEdBQTJCLGlCQUFpQixDQUFqQixDQUEzQjtBQUNBLGlCQUFhLFdBQWIsQ0FBeUIsY0FBekI7QUFDQSxXQUFPLFlBQVA7QUFDSDs7QUFFRDs7OztBQUlBLElBQUksa0JBQW1CLFlBQVc7QUFDOUI7O0FBRUE7Ozs7Ozs7Ozs7O0FBVUEsYUFBUyxXQUFULENBQXFCLElBQXJCLEVBQTJCLEdBQTNCLEVBQWdDLElBQWhDLEVBQXNDLElBQXRDLEVBQTRDO0FBQ3hDLFlBQUksV0FBVyxDQUFDLElBQUQsQ0FBZjtBQUFBLFlBQ0ksVUFBVSxDQURkOztBQUdBOzs7OztBQUtBLGlCQUFTLFlBQVQsQ0FBc0IsSUFBdEIsRUFBNEI7QUFDeEIsbUJBQU8sS0FBSyxVQUFMLENBQWdCLFVBQWhCLENBQTJCLFVBQTNCLENBQXNDLFlBQXRDLENBQW1ELElBQW5ELEVBQXlELE9BQXpELENBQWlFLEtBQUssU0FBdEUsRUFBaUYsRUFBakYsQ0FBUDtBQUNIOztBQUVELGFBQUssZ0JBQUwsQ0FBc0IsUUFBdEIsRUFBZ0MsVUFBUyxDQUFULEVBQVk7QUFDeEMsb0JBQVEsR0FBUixDQUFZLFVBQVUsU0FBUyxPQUFULENBQXRCO0FBQ0EsZ0JBQUksV0FBVyxLQUFLLEtBQXBCO0FBQ0EsZ0JBQUksU0FBUyxPQUFULE1BQXNCLFFBQTFCLEVBQW9DO0FBQ2hDLHlCQUFTLElBQVQsQ0FBYyxRQUFkO0FBQ0E7QUFDSDtBQUNELG9CQUFRLEdBQVIsQ0FBWSxRQUFaO0FBQ0EsMEJBQWEsV0FBVSxhQUFhLElBQWIsQ0FBVixFQUE4QixJQUE5QixFQUFvQyxRQUFwQyxDQUFiO0FBQ0gsU0FURDtBQVVIOztBQUVEOzs7Ozs7O0FBT0EsYUFBUywyQkFBVCxDQUFxQyxPQUFyQyxFQUE4QztBQUMxQyxXQUFHLEtBQUgsQ0FBUyxJQUFULENBQWMsUUFBUSxnQkFBUixDQUF5QixVQUF6QixDQUFkLEVBQW9ELE9BQXBELENBQTRELFVBQVMsS0FBVCxFQUFnQjtBQUN4RSxrQkFBTSxtQkFBTixDQUEwQixRQUExQixFQUFvQyxLQUFwQztBQUNBLGtCQUFNLFlBQU4sQ0FBbUIsVUFBbkIsRUFBK0IsTUFBL0I7QUFDSCxTQUhEOztBQUtBLFdBQUcsS0FBSCxDQUFTLElBQVQsQ0FBYyxRQUFRLGdCQUFSLENBQXlCLE9BQXpCLENBQWQsRUFBaUQsT0FBakQsQ0FBeUQsVUFBUyxLQUFULEVBQWdCO0FBQ3JFLGtCQUFNLG1CQUFOLENBQTBCLFVBQTFCLEVBQXNDLEtBQXRDO0FBQ0Esa0JBQU0sWUFBTixDQUFtQixVQUFuQixFQUErQixNQUEvQjtBQUNILFNBSEQ7QUFJSDs7QUFFRDs7Ozs7QUFLQSxhQUFTLGNBQVQsQ0FBd0IsZUFBeEIsRUFBeUMsUUFBekMsRUFBbUQ7QUFDL0MsWUFBSSxnQkFBZ0IsZ0JBQWdCLEVBQWhCLENBQW1CLFdBQW5CLEVBQXBCO0FBQUEsWUFDSSxZQURKO0FBQUEsWUFFSSxVQUZKOztBQUlBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxTQUFTLE1BQTdCLEVBQXFDLEdBQXJDLEVBQTBDO0FBQ3RDLDJCQUFlLFNBQVMsQ0FBVCxDQUFmO0FBQ0EseUJBQWEsU0FBUyxDQUFULEVBQVksRUFBWixDQUFlLFdBQWYsRUFBYjtBQUNBLGdCQUFJLGdCQUFnQixVQUFwQixFQUFnQztBQUM1Qix5QkFBUyxZQUFULENBQXNCLGVBQXRCLEVBQXVDLFlBQXZDO0FBQ0E7QUFDSDtBQUNKOztBQUVELFlBQUksU0FBUyxNQUFULEtBQW9CLENBQXBCLElBQXlCLGdCQUFnQixVQUE3QyxFQUF5RDtBQUNyRCxxQkFBUyxXQUFULENBQXFCLGVBQXJCO0FBQ0g7QUFDSjs7QUFFRCxRQUFJLFFBQUo7QUFBQSxRQUFjO0FBQ1YsZ0JBREo7QUFBQSxRQUVJLFlBQVk7QUFDUixjQUFNLHFCQURFO0FBRVIsZUFBTyxnQkFGQztBQUdSLGFBQUs7QUFDRCx1QkFBVztBQURWO0FBSEcsS0FGaEI7O0FBU0k7QUFDQSxlQUFXO0FBQ1AsbUJBQVcsRUFESjtBQUVQLDBCQUFrQixFQUZYO0FBR1AsbUJBQVcsRUFISjtBQUlQLG1CQUFXLEVBSko7QUFLUCx5QkFBaUIsRUFMVjtBQU1QLHdCQUFnQixFQU5UO0FBT1Asd0JBQWdCO0FBUFQsS0FWZjtBQUFBLFFBbUJJLEtBQUs7QUFDRCxhQUFLO0FBQ0QseUJBQWEsYUFEWjtBQUVELHVCQUFXO0FBRlYsU0FESjtBQUtEOzs7OztBQUtBLHFCQUFhLHFCQUFTLEdBQVQsRUFBYyxXQUFkLEVBQTJCO0FBQ3BDLGdCQUFJLFFBQVEsU0FBUyxjQUFULENBQXdCLEtBQUssU0FBTCxHQUFpQixHQUF6QyxDQUFaO0FBQUEsZ0JBQ0ksUUFBUSxTQUFTLGNBQVQsQ0FBd0IsY0FBYyxHQUF0QyxDQURaO0FBRUEsZ0JBQUksS0FBSixFQUFXO0FBQ1AsbUJBQUcsa0JBQUgsQ0FBc0IsS0FBdEIsRUFBNkIsU0FBN0IsQ0FBdUMsTUFBdkMsQ0FBOEMsR0FBRyxHQUFILENBQU8sV0FBckQ7QUFDQSwyQkFBVyxZQUFXO0FBQ2xCLHVCQUFHLGtCQUFILENBQXNCLEtBQXRCLEVBQTZCLFNBQTdCLENBQXVDLEdBQXZDLENBQTJDLEdBQUcsR0FBSCxDQUFPLFdBQWxEO0FBQ0gsaUJBRkQsRUFFRyxHQUZIO0FBR0g7QUFDRCxnQkFBSSxLQUFKLEVBQVc7QUFDUCxtQkFBRyxrQkFBSCxDQUFzQixLQUF0QixFQUE2QixTQUE3QixDQUF1QyxNQUF2QyxDQUE4QyxHQUFHLEdBQUgsQ0FBTyxXQUFyRDtBQUNBLDJCQUFXLFlBQVc7QUFDbEIsdUJBQUcsa0JBQUgsQ0FBc0IsS0FBdEIsRUFBNkIsU0FBN0IsQ0FBdUMsR0FBdkMsQ0FBMkMsR0FBRyxHQUFILENBQU8sV0FBbEQ7QUFDSCxpQkFGRCxFQUVHLEdBRkg7QUFHSDtBQUNKLFNBekJBO0FBMEJELDJCQUFtQiwyQkFBUyxHQUFULEVBQWMsV0FBZCxFQUEyQjtBQUMxQyxvQkFBUSxLQUFSLENBQWMsbUNBQWQsRUFBbUQsMERBQW5EO0FBQ0E7QUFDQSxnQkFBSSxPQUFPLFNBQVMsY0FBVCxDQUF3QixjQUFjLEdBQXRDLENBQVg7QUFDQSxnQkFBSSxJQUFKLEVBQVU7QUFDTixtQkFBRyxrQkFBSCxDQUFzQixJQUF0QixFQUE0QixXQUE1QixDQUF3QyxHQUFHLEdBQUgsQ0FBTyxTQUEvQztBQUNIO0FBQ0osU0FqQ0E7QUFrQ0QsNEJBQW9CLDRCQUFTLElBQVQsRUFBZTtBQUMvQixnQkFBSSxRQUFKO0FBQUEsZ0JBQWMsVUFBVSxFQUF4QjtBQUNBLGdCQUFJLENBQUMsSUFBTCxFQUFXO0FBQ1A7QUFDSDtBQUNEO0FBQ0EsaUJBQUssUUFBTCxJQUFpQixHQUFHLEdBQXBCLEVBQXlCO0FBQ3JCLDJCQUFXLFdBQVcsR0FBdEI7QUFDSDtBQUNELGlCQUFLLGNBQUwsQ0FBb0IsT0FBcEI7QUFDQSxtQkFBTyxJQUFQO0FBQ0g7QUE3Q0EsS0FuQlQ7O0FBa0VJOzs7QUFHQSxpQkFBWSxxQkFBVztBQUNuQixnQkFBUSxJQUFSLENBQWEsMkNBQWI7QUFDSCxLQXZFTDtBQUFBLFFBd0VJLGVBQWMsdUJBQVc7QUFDckIsZ0JBQVEsSUFBUixDQUFhLDZDQUFiO0FBQ0gsS0ExRUw7QUFBQSxRQTJFSSxjQUFhLHNCQUFXO0FBQ3BCLGdCQUFRLElBQVIsQ0FBYSw0Q0FBYjtBQUNILEtBN0VMO0FBQUEsUUE4RUksUUFBUTtBQUNKLHlCQUFpQjtBQUNiLGtCQUFNLGNBQVMsSUFBVCxFQUFlO0FBQ2pCLHFCQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0gsYUFIWTtBQUliLHFCQUFTLGlCQUFTLElBQVQsRUFBZTtBQUNwQixxQkFBSyxJQUFMLEdBQVksSUFBWjtBQUNBLDZCQUFhLHFCQUFiLEVBQW9DO0FBQ2hDLDZCQUFTLEtBQUssT0FEa0I7QUFFaEMsa0NBQWMsS0FBSztBQUZhLGlCQUFwQztBQUlILGFBVlk7QUFXYixxQkFBUyxtQkFBVztBQUNoQix1QkFBTyxLQUFLLElBQVo7QUFDSDtBQWJZLFNBRGI7QUFnQkosK0JBQXVCO0FBQ25CLGtCQUFNLGNBQVMsSUFBVCxFQUFlO0FBQ2pCLHFCQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0g7QUFIa0IsU0FoQm5CO0FBcUJKLDhCQUFzQjtBQUNsQixrQkFBTSxjQUFTLElBQVQsRUFBZTtBQUNqQixxQkFBSyxnQkFBTCxDQUFzQixPQUF0QixFQUErQixZQUFXO0FBQ3RDLHdCQUFJLE1BQU0scUJBQU4sQ0FBNEIsSUFBNUIsQ0FBaUMsS0FBakMsQ0FBdUMsTUFBdkMsS0FBa0QsQ0FBdEQsRUFBeUQ7QUFDckQsOEJBQU0scUJBQU4sQ0FBNEIsSUFBNUIsQ0FBaUMsU0FBakMsQ0FBMkMsR0FBM0MsQ0FBK0MsT0FBL0M7QUFDQTtBQUNIO0FBQ0Qsd0JBQU0sT0FBTyxNQUFNLGVBQU4sQ0FBc0IsT0FBdEIsRUFBYjtBQUNBLGdDQUFXLEtBQUssR0FBaEIsRUFBcUIsS0FBSyxPQUExQixFQUFtQyxLQUFLLFdBQXhDLEVBQXFELE1BQU0scUJBQU4sQ0FBNEIsSUFBNUIsQ0FBaUMsS0FBdEY7QUFDSCxpQkFQRDtBQVFIO0FBVmlCLFNBckJsQjtBQWlDSixzQ0FBOEI7QUFDMUIsa0JBQU0sY0FBUyxJQUFULEVBQWU7QUFDakIscUJBQUssSUFBTCxHQUFZLElBQVo7QUFDSDtBQUh5QixTQWpDMUI7QUFzQ0osNENBQW9DO0FBQ2hDLGtCQUFNLGNBQVMsSUFBVCxFQUFlO0FBQ2pCLHFCQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0g7QUFIK0IsU0F0Q2hDO0FBMkNKLGdDQUF5QixZQUFXO0FBQ2hDLGdCQUFJLElBQUo7QUFDQSxtQkFBTztBQUNILHNCQUFNLGNBQVMsSUFBVCxFQUFlO0FBQ2pCLDJCQUFPLElBQVA7QUFDQSx5QkFBSyxnQkFBTCxDQUFzQixPQUF0QixFQUErQixZQUFXO0FBQ3RDLDRCQUFJLGVBQWUsTUFBTSw0QkFBTixDQUFtQyxJQUFuQyxDQUF3QyxLQUEzRDs7QUFFQSw0QkFBSSxlQUFlLFlBQWYsQ0FBSixFQUFrQztBQUM5QjtBQUNBLHFDQUFTLGdCQUFULENBQTBCLE9BQTFCLENBQWtDLFVBQVMsRUFBVCxFQUFhO0FBQzNDLG1DQUFHLFlBQUgsRUFBaUI7QUFDYixpREFBYSxNQUFNLGtDQUFOLENBQXlDLElBQXpDLENBQThDO0FBRDlDLGlDQUFqQjtBQUdILDZCQUpEO0FBS0E7QUFDQSwyQ0FBZSxJQUFmLENBQW9CLHNCQUFwQjtBQUNILHlCQVRELE1BU087QUFDSDtBQUNBLGtDQUFNLDRCQUFOLENBQW1DLElBQW5DLENBQXdDLEtBQXhDLENBQThDLGVBQTlDLEdBQWdFLFNBQWhFO0FBQ0g7QUFDSixxQkFoQkQ7QUFpQkg7QUFwQkUsYUFBUDtBQXNCSCxTQXhCd0IsRUEzQ3JCO0FBb0VKLHFCQUFhO0FBQ1Qsa0JBQU0sY0FBUyxJQUFULEVBQWU7QUFDakIscUJBQUssZ0JBQUwsQ0FBc0IsT0FBdEIsRUFBK0IsWUFBVztBQUN0QyxtQ0FBZSxJQUFmLENBQW9CLG1DQUFwQjtBQUNILGlCQUZEO0FBR0g7QUFMUSxTQXBFVDtBQTJFSiw4QkFBc0I7QUFDbEIsa0JBQU0sY0FBUyxJQUFULEVBQWU7QUFDakIscUJBQUssSUFBTCxHQUFZLElBQVo7QUFDSDtBQUhpQixTQTNFbEI7QUFnRkoseUJBQWlCO0FBQ2Isa0JBQU0sY0FBUyxJQUFULEVBQWU7QUFDakIscUJBQUssSUFBTCxHQUFZLElBQVo7QUFDSDtBQUhZLFNBaEZiO0FBcUZKLGdCQUFVLFlBQU07QUFDWixtQkFBTztBQUNILHNCQUFPLGNBQUMsSUFBRCxFQUFVO0FBQ2IseUJBQUssZ0JBQUwsQ0FBc0IsT0FBdEIsRUFBK0IsWUFBVztBQUN0Qyw4QkFBTSxjQUFOLENBQXFCLElBQXJCLENBQTBCLEtBQUssT0FBTCxDQUFhLElBQXZDO0FBQ0gscUJBRkQ7QUFHSDtBQUxFLGFBQVA7QUFPSCxTQVJRLEVBckZMO0FBOEZKLHVCQUFnQixZQUFXO0FBQ3ZCLGdCQUFJLElBQUo7QUFDQSxtQkFBTztBQUNILHNCQUFNLGNBQVMsSUFBVCxFQUFlO0FBQ2pCLDJCQUFPLElBQVA7QUFDQSx5QkFBSyxnQkFBTCxDQUFzQixPQUF0QixFQUErQixZQUFXO0FBQ3RDLDRCQUFJLGNBQWMsTUFBTSxvQkFBTixDQUEyQixJQUEzQixDQUFnQyxLQUFsRDtBQUFBLDRCQUNJLE1BQU0sTUFBTSxlQUFOLENBQXNCLElBQXRCLENBQTJCLEtBRHJDO0FBQUEsNEJBRUksTUFGSjs7QUFJQSw0QkFBSSxlQUFlLFdBQWYsS0FBK0IsZUFBZSxHQUFmLENBQW5DLEVBQXdEO0FBQ3BEO0FBQ0EscUNBQVMsY0FBYyxHQUFkLEdBQW9CLEdBQTdCO0FBQ0EseUNBQVksTUFBWjtBQUNILHlCQUpELE1BSU87QUFDSDtBQUNBLGtDQUFNLG9CQUFOLENBQTJCLElBQTNCLENBQWdDLFNBQWhDLENBQTBDLEdBQTFDLENBQThDLE9BQTlDO0FBQ0Esa0NBQU0sZUFBTixDQUFzQixJQUF0QixDQUEyQixTQUEzQixDQUFxQyxHQUFyQyxDQUF5QyxPQUF6QztBQUNIO0FBQ0oscUJBZEQ7QUFlSDtBQWxCRSxhQUFQO0FBb0JILFNBdEJlO0FBOUZaLEtBOUVaO0FBQUEsUUFvTUksS0FBSztBQUNEOzs7O0FBSUEsWUFBSSxNQUFKLEdBQWM7QUFDVixtQkFBTyxJQUFQO0FBQ0gsU0FQQTtBQVFELDBCQUFrQiwwQkFBUyxNQUFULEVBQWlCO0FBQy9CLGdCQUFJLE1BQUosRUFBWTtBQUNSLHlCQUFTLFNBQVQsQ0FBbUIsR0FBbkIsQ0FBdUIsb0JBQXZCO0FBQ0gsYUFGRCxNQUVPO0FBQ0gseUJBQVMsU0FBVCxDQUFtQixNQUFuQixDQUEwQixvQkFBMUI7QUFDSDtBQUNKLFNBZEE7QUFlRCx5QkFBaUIseUJBQVMsTUFBVCxFQUFpQjtBQUM5QixxQkFBUyxTQUFULENBQW1CLE1BQW5CLENBQTBCLG9CQUExQixFQUFnRCxNQUFoRDtBQUNILFNBakJBO0FBa0JELHFCQUFhLEdBQUcsV0FsQmY7QUFtQkQsYUFBSyxhQUFTLElBQVQsRUFBZSxJQUFmLEVBQXFCO0FBQ3RCLGdCQUFJLFNBQVMsTUFBYixFQUFxQjtBQUNqQiwyQkFBVyxJQUFYO0FBQ0gsYUFGRCxNQUVPLElBQUksTUFBTSxjQUFOLENBQXFCLElBQXJCLENBQUosRUFBZ0M7QUFDbkMsc0JBQU0sSUFBTixFQUFZLElBQVosQ0FBaUIsSUFBakI7QUFDSDtBQUNKLFNBekJBO0FBMEJELDBCQUFrQiwwQkFBUyxHQUFULEVBQWM7QUFDNUIsZ0JBQUksTUFBSjtBQUFBLGdCQUNJLGNBQWMsSUFEbEI7QUFBQSxnQkFFSSxZQUFZLEdBRmhCO0FBR0EsZ0JBQUksS0FBSyxJQUFMLENBQVUsSUFBSSxHQUFkLENBQUosRUFBd0I7QUFDcEIsNEJBQVksR0FBWjtBQUNIOztBQUVELHFCQUFTLElBQUksR0FBSixDQUFRLEtBQVIsQ0FBYyxTQUFkLENBQVQ7O0FBRUEsZ0JBQUksT0FBTyxNQUFQLEdBQWdCLENBQXBCLEVBQXVCO0FBQ25CO0FBQ0EsOEJBQWMsT0FBTyxNQUFQLENBQWMsQ0FBZCxFQUFpQixDQUFqQixFQUFvQixDQUFwQixDQUFkO0FBQ0g7QUFDRCxtQkFBTztBQUNILG9CQUFJLElBQUksR0FETCxFQUNXO0FBQ2QscUJBQUssSUFBSSxHQUZOO0FBR0gsNkJBQWEsV0FIVjtBQUlILHlCQUFTLE9BQU8sSUFBUCxDQUFZLFNBQVosQ0FKTjtBQUtILHVCQUFPLElBQUk7QUFMUixhQUFQO0FBT0gsU0EvQ0E7QUFnREQsdUJBQWUsdUJBQVMsT0FBVCxFQUFrQixPQUFsQixFQUEyQjtBQUN0QyxnQkFBSSxRQUFRLE1BQVIsS0FBbUIsUUFBUSxNQUEzQixJQUFxQyxRQUFRLE1BQVIsS0FBbUIsUUFBUSxNQUFwRSxFQUE0RTtBQUN4RSx1QkFBTyxJQUFQO0FBQ0g7QUFDRCxtQkFBTyxLQUFQO0FBQ0gsU0FyREE7QUFzREQsMkJBQW1CLDZCQUFXOztBQUUxQixtQkFBTztBQUNILHdCQUFRLFFBQVEsTUFBUixDQUFlLE1BQWYsSUFBeUIsVUFEOUI7QUFFSCx3QkFBUSxLQUFLLFlBQUw7QUFGTCxhQUFQO0FBSUgsU0E1REE7QUE2REQsc0JBQWMsd0JBQVc7QUFDckIsbUJBQU8sUUFBUSxNQUFSLENBQWUsSUFBZixJQUF1QixJQUE5QjtBQUNILFNBL0RBO0FBZ0VELHlCQUFpQiwyQkFBVzs7QUFFeEIsbUJBQU87QUFDSCx3QkFBUSxRQUFRLE1BQVIsQ0FBZSxNQUFmLElBQXlCLFVBRDlCO0FBRUgsd0JBQVEsUUFBUSxNQUFSLENBQWUsRUFBZixJQUFxQjtBQUYxQixhQUFQO0FBSUgsU0F0RUE7QUF1RUQsdUJBQWUsdUJBQVMsTUFBVCxFQUFpQjtBQUM1QixnQkFBSSxTQUFTLFFBQVEsTUFBUixDQUFlLE1BQWYsSUFBeUIsVUFBdEM7QUFDQSxtQkFBTyxTQUFTLEdBQVQsR0FBZSxNQUF0QjtBQUNILFNBMUVBO0FBMkVEOzs7Ozs7OztBQVFBLDZCQUFxQiw2QkFBUyxPQUFULEVBQWtCLGNBQWxCLEVBQWtDLHlCQUFsQyxFQUE2RCxFQUE3RCxFQUFpRTtBQUNsRixnQkFBSSxNQUFKO0FBQUEsZ0JBQ0ksV0FESjtBQUFBLGdCQUVJLGtCQUFrQixHQUFHLEtBQUgsQ0FBUyxJQUFULENBQWMsU0FBUyxnQkFBVCxDQUEwQixlQUExQixDQUFkLENBRnRCO0FBR0k7Ozs7OztBQU1BLHFCQUFTLG1CQUFULENBQTZCLFdBQTdCLEVBQTBDLFNBQTFDLEVBQXFEO0FBQ2pELG9CQUFJLGVBQWUsU0FBUyxjQUFULENBQXdCLEtBQUssU0FBTCxHQUFpQixXQUF6QyxDQUFuQjtBQUNBLG9CQUFJLENBQUMsWUFBTCxFQUFtQjtBQUNmLG1DQUFlLFNBQVMsYUFBVCxDQUF1QiwwQkFBdkIsRUFBbUQsU0FBbkQsQ0FBNkQsSUFBN0QsQ0FBZjtBQUNBLGlDQUFhLFNBQWIsQ0FBdUIsR0FBdkIsQ0FBMkIscUJBQTNCO0FBQ0Esd0JBQUksZUFBZSxXQUFuQjtBQUNBLHdCQUFJLGlCQUFpQixZQUFyQjtBQUNBLGlDQUFhLFlBQWIsQ0FBMEIsSUFBMUIsRUFBZ0MsS0FBSyxTQUFMLEdBQWlCLGNBQWpEO0FBQ0Esd0JBQUksWUFBSixFQUFrQjtBQUNkLDRCQUFJLFVBQVUsYUFBYSxhQUFiLENBQTJCLGtCQUEzQixDQUFkO0FBQUEsNEJBQ0ksS0FBSyxhQUFhLGFBQWIsQ0FBMkIsSUFBM0IsQ0FEVDtBQUVBO0FBQ0EsMkJBQUcsV0FBSCxDQUFnQixZQUFZO0FBQ3hCLGdDQUFJLE9BQU8sU0FBUyxhQUFULENBQXVCLE1BQXZCLENBQVg7QUFDQSxpQ0FBSyxXQUFMLENBQWlCLFNBQVMsY0FBVCxDQUF3QixZQUF4QixDQUFqQjtBQUNBLGlDQUFLLFNBQUwsR0FBaUIsU0FBakI7QUFDQSxtQ0FBTyxJQUFQO0FBQ0gseUJBTGUsRUFBaEI7QUFNQSwyQkFBRyxnQkFBSCxDQUFvQixPQUFwQixFQUE2QixVQUFTLEtBQVQsRUFBZ0I7QUFDekMscUNBQVMsZUFBVCxDQUF5QixPQUF6QixDQUFpQyxVQUFTLEVBQVQsRUFBYTtBQUMxQyxtQ0FBRyxjQUFIO0FBQ0gsNkJBRkQ7QUFHSCx5QkFKRDs7QUFNQSw0QkFBSSxZQUFZLGlCQUFpQixjQUFqQixDQUFnQyxZQUFoQyxFQUE4QztBQUMxRCxvQ0FBUSxnQkFBUyxLQUFULEVBQWdCO0FBQ3BCLHNDQUFNLHdCQUFOO0FBQ0EsNkNBQWEsZUFBYixDQUE2QixVQUE3QjtBQUNBLDhDQUFjLGFBQWEsS0FBM0I7QUFDQSw2Q0FBYSxLQUFiO0FBQ0gsNkJBTnlEO0FBTzFELHNDQUFVLGtCQUFTLEtBQVQsRUFBZ0I7QUFDdEIsc0NBQU0sd0JBQU47QUFDQSw2Q0FBYSxZQUFiLENBQTBCLFVBQTFCLEVBQXNDLE1BQXRDO0FBQ0EsNkNBQWEsS0FBYixHQUFxQixXQUFyQjtBQUNILDZCQVh5RDtBQVkxRCxvQ0FBUSxnQkFBUyxLQUFULEVBQWdCO0FBQ3BCLHNDQUFNLHdCQUFOO0FBQ0EseUNBQVMsY0FBVCxDQUF3QixPQUF4QixDQUFnQyxVQUFTLEVBQVQsRUFBYTtBQUN6Qyx1Q0FBRztBQUNDLGlEQUFTLFdBRFY7QUFFQyxpREFBUyxhQUFhO0FBRnZCLHFDQUFIO0FBSUgsaUNBTEQ7QUFNSCw2QkFwQnlEO0FBcUIxRCxzQ0FBVSxrQkFBUyxLQUFULEVBQWdCO0FBQ3RCLHNDQUFNLHdCQUFOO0FBQ0Esb0NBQUksTUFBTSxPQUFPLE9BQVAsQ0FBZSwyREFBZixDQUFWO0FBQ0Esb0NBQUksR0FBSixFQUFTO0FBQ0wsNkNBQVMsY0FBVCxDQUF3QixPQUF4QixDQUFnQyxVQUFTLEVBQVQsRUFBYTtBQUN6QywyQ0FBRztBQUNDLHNEQUFVO0FBRFgseUNBQUg7QUFHSCxxQ0FKRDtBQUtIO0FBQ0o7QUEvQnlELHlCQUE5QyxDQUFoQjtBQWlDQSxnQ0FBUSxXQUFSLENBQW9CLFNBQXBCOztBQUVBLDRCQUFJLGVBQWUsUUFBUSxhQUFSLENBQXNCLE9BQXRCLEVBQStCLEtBQUssU0FBTCxHQUFpQixZQUFqQixHQUFnQyxRQUEvRCxFQUF5RSxlQUF6RSxDQUFuQjtBQUNBLHFDQUFhLFlBQWIsQ0FBMEIsVUFBMUIsRUFBc0MsTUFBdEM7QUFDQSxxQ0FBYSxnQkFBYixDQUE4QixPQUE5QixFQUF1QyxVQUFTLEtBQVQsRUFBZ0I7QUFDbkQsa0NBQU0sd0JBQU47QUFDSCx5QkFGRDtBQUdBLHFDQUFhLGdCQUFiLENBQThCLFVBQTlCLEVBQTBDLG1CQUExQztBQUNBLDJCQUFHLFdBQUgsQ0FBZSxZQUFmO0FBQ0EscUNBQWEsS0FBYixHQUFxQixZQUFyQjs7QUFFQTtBQUNBLDRCQUFJLGNBQWMsYUFBYSxhQUFiLENBQTJCLHFCQUEzQixDQUFsQjtBQUNBLDRCQUFJLE9BQU8sU0FBUyxhQUFULENBQXVCLE1BQXZCLENBQVg7QUFDQSw2QkFBSyxTQUFMLEdBQWlCLFNBQWpCO0FBQ0Esb0NBQVksV0FBWixDQUF3QixJQUF4QjtBQUNBLDRCQUFJLFdBQUosRUFBaUI7QUFDYixrQ0FBTSxVQUFOLENBQWlCLEdBQWpCLENBQXFCLFdBQXJCLEVBQWtDO0FBQzlCLG9DQUFJLFlBRDBCO0FBRTlCLDZDQUFhO0FBRmlCLDZCQUFsQztBQUlBLGtDQUFNLDBCQUFOLENBQWlDLEdBQWpDLENBQXFDLGFBQWEsYUFBYixDQUEyQiw0QkFBM0IsQ0FBckMsRUFBK0YsWUFBL0Y7QUFDSDtBQUNEO0FBQ0EsNEJBQUksZUFBZSxhQUFhLGFBQWIsQ0FBMkIscUJBQTNCLENBQW5CO0FBQ0EscUNBQWEsWUFBYixDQUEwQixVQUExQixFQUFzQyxZQUF0QztBQUNBLHFDQUFhLGdCQUFiLENBQThCLFVBQTlCLEVBQTBDLG1CQUExQztBQUNBLHFDQUFhLGFBQWIsQ0FBMkIsT0FBM0IsRUFBb0MsU0FBcEMsR0FBZ0QsZUFBZSxHQUEvRDtBQUNBLDRCQUFJLFNBQVMsYUFBYSxhQUFiLENBQTJCLFFBQTNCLENBQWI7QUFDQSwrQkFBTyxnQkFBUCxDQUF3QixPQUF4QixFQUFpQyxZQUFXO0FBQ3hDLGdDQUFJLGVBQWUsYUFBYSxLQUE1QixDQUFKLEVBQXdDO0FBQ3BDLG9DQUFJLFNBQVMsYUFBYSxZQUFiLENBQTBCLFVBQTFCLElBQXdDLEdBQXhDLEdBQThDLGFBQWEsS0FBeEU7QUFDQTtBQUNBLDZDQUFZLE1BQVosRUFBb0IsY0FBcEI7QUFDSCw2QkFKRCxNQUlPO0FBQ0gsdUNBQU8sS0FBUCxDQUFhLEtBQWIsR0FBcUIsU0FBckI7QUFDQSw2Q0FBYSxLQUFiLENBQW1CLGVBQW5CLEdBQXFDLFNBQXJDO0FBQ0g7QUFDSix5QkFURDtBQVVIOztBQUVEO0FBQ0Esd0JBQUksc0JBQXNCLGFBQWEsYUFBYixDQUEyQiwwQkFBM0IsQ0FBMUI7QUFBQSx3QkFDSSxrQkFBa0Isb0JBQW9CLGFBQXBCLENBQWtDLHVCQUFsQyxDQUR0QjtBQUFBLHdCQUVJLGtCQUFrQixvQkFBb0IsYUFBcEIsQ0FBa0MsdUJBQWxDLENBRnRCO0FBR0Esb0NBQWdCLFNBQWhCLEdBQTRCLHFCQUFxQixZQUFyQixDQUE1QjtBQUNBLDhCQUFVLE9BQVYsQ0FBa0IsVUFBUyxJQUFULEVBQWU7QUFDN0Isd0NBQWdCLFdBQWhCLENBQTRCLDJCQUEyQixJQUEzQixDQUE1QjtBQUNILHFCQUZEO0FBR0g7QUFDRCx1QkFBTyxZQUFQO0FBQ0g7O0FBRUwsb0JBQVEsT0FBUixDQUFnQixVQUFTLElBQVQsRUFBZTtBQUMzQix5QkFBUyxHQUFHLGdCQUFILENBQW9CLElBQXBCLENBQVQ7QUFDQTtBQUNBLDhCQUFjLG9CQUFvQixPQUFPLFdBQTNCLEVBQXdDLHlCQUF4QyxDQUFkO0FBQ0EsK0JBQWUsV0FBZixFQUE0QixlQUE1QjtBQUNBLG1CQUFHLG1CQUFILENBQXVCLFdBQXZCLEVBQW9DLE1BQXBDLEVBQTRDLGNBQTVDLEVBQTRELHlCQUE1RDtBQUNBLG1CQUFHLFlBQVksWUFBWixDQUF5QixJQUF6QixFQUErQixPQUEvQixDQUF1QyxLQUFLLFNBQTVDLEVBQXVELEVBQXZELENBQUg7QUFDQSxtQkFBRyxPQUFPLEdBQVY7QUFDSCxhQVJEO0FBU0gsU0FwTkE7QUFxTkQ7Ozs7QUFJQSxpQ0FBeUIsaUNBQVMsSUFBVCxFQUFlO0FBQ3BDLGdCQUFJLFFBQVEsU0FBUyxhQUFULENBQXVCLE1BQU0sS0FBSyxTQUFYLEdBQXVCLEtBQUssRUFBNUIsR0FBaUMsZ0NBQWpDLEdBQW9FLEtBQUssUUFBekUsR0FBb0Ysa0JBQTNHLENBQVo7QUFDQSxnQkFBSSxLQUFKLEVBQVc7QUFDUCxzQkFBTSxTQUFOLEdBQWtCLGlCQUFpQixLQUFLLEtBQXRCLENBQWxCO0FBQ0g7QUFDSixTQTlOQTtBQStORDs7Ozs7O0FBTUEscUJBQWEscUJBQVMsSUFBVCxFQUFlLElBQWYsRUFBcUI7QUFDOUIsZ0JBQUksZUFBZSxTQUFTLGNBQVQsQ0FBd0IsS0FBSyxXQUFMLEdBQW1CLEtBQUssR0FBaEQsQ0FBbkI7QUFBQSxnQkFDSSxPQURKO0FBRUEsZ0JBQUksQ0FBQyxZQUFMLEVBQW1CO0FBQ2YsK0JBQWUsUUFBUSxhQUFSLENBQXNCLE9BQXRCLEVBQStCLEtBQUssV0FBTCxHQUFtQixLQUFLLEdBQXZELEVBQTRELFVBQTVELENBQWY7QUFDQSwwQkFBVSxRQUFRLGFBQVIsQ0FBc0IsS0FBdEIsRUFBNkIsSUFBN0IsRUFBbUMsOEJBQW5DLENBQVY7QUFDQSw2QkFBYSxZQUFiLENBQTBCLFVBQTFCLEVBQXNDLE1BQXRDO0FBQ0EsaUNBQWlCLGNBQWpCLENBQWdDLE9BQWhDLEVBQXlDO0FBQ3JDLDhCQUFVLG9CQUFXO0FBQ2pCLDRCQUFJLE1BQU0sT0FBTyxPQUFQLENBQWUsZ0VBQWYsQ0FBVjtBQUNBLDRCQUFJLEdBQUosRUFBUztBQUNMLHFDQUFTLFNBQVQsQ0FBbUIsT0FBbkIsQ0FBMkIsVUFBUyxFQUFULEVBQWE7QUFDcEMsbUNBQUc7QUFDQyx5Q0FBSyxLQUFLO0FBRFgsaUNBQUg7QUFHSCw2QkFKRDtBQUtIO0FBQ0oscUJBVm9DO0FBV3JDLDRCQUFRLGtCQUFXO0FBQ2YscUNBQWEsZUFBYixDQUE2QixVQUE3QjtBQUNBO0FBQ0EsNkJBQUssT0FBTCxHQUFlLGFBQWEsS0FBNUI7QUFDQTtBQUNBLDZCQUFLLEdBQUwsR0FBVyxhQUFhLFlBQWIsQ0FBMEIsSUFBMUIsRUFBZ0MsT0FBaEMsQ0FBd0MsS0FBSyxXQUE3QyxFQUEwRCxFQUExRCxDQUFYO0FBQ0EsNkJBQUssV0FBTCxHQUFtQixLQUFLLEdBQUwsQ0FBUyxLQUFULENBQWUsR0FBZixFQUFvQixDQUFwQixDQUFuQjtBQUNBLHFDQUFhLEtBQWI7QUFDSCxxQkFuQm9DO0FBb0JyQyw4QkFBVSxvQkFBVztBQUNqQixxQ0FBYSxZQUFiLENBQTBCLFVBQTFCLEVBQXNDLE1BQXRDO0FBQ0EscUNBQWEsS0FBYixHQUFxQixLQUFLLE9BQTFCO0FBQ0gscUJBdkJvQztBQXdCckMsNEJBQVEsa0JBQVc7QUFDZixnQ0FBUSxHQUFSLENBQVksMENBQVo7QUFDQSw0QkFBSSxRQUFRLEtBQUssV0FBTCxHQUFtQixLQUFLLFdBQUwsR0FBbUIsR0FBbkIsR0FBeUIsYUFBYSxLQUF6RCxHQUFpRSxhQUFhLEtBQTFGO0FBQ0EsNEJBQUksYUFBYSxLQUFiLElBQXNCLEVBQXRCLElBQTRCLFNBQVMsS0FBSyxHQUE5QyxFQUFtRDtBQUMvQyxxQ0FBUyxTQUFULENBQW1CLE9BQW5CLENBQTJCLFVBQVMsRUFBVCxFQUFhO0FBQ3BDLG1DQUFHO0FBQ0MsNENBQVEsS0FEVDtBQUVDLDRDQUFRLEtBQUs7QUFGZCxpQ0FBSDtBQUlILDZCQUxEO0FBTUg7QUFDSixxQkFuQ29DO0FBb0NyQyw2QkFBUyxtQkFBVztBQUNoQiw4QkFBTSxlQUFOLENBQXNCLE9BQXRCLENBQThCLElBQTlCO0FBQ0EsdUNBQWUsSUFBZixDQUFvQix5QkFBcEI7QUFDSDtBQXZDb0MsaUJBQXpDO0FBeUNBO0FBQ0EsNkJBQWEsZ0JBQWIsQ0FBOEIsVUFBOUIsRUFBMEMsbUJBQTFDO0FBQ0Esd0JBQVEsV0FBUixDQUFxQixZQUFZO0FBQzdCLHdCQUFJLE9BQU8sU0FBUyxhQUFULENBQXVCLE1BQXZCLENBQVg7QUFDQSx5QkFBSyxXQUFMLENBQWlCLFNBQVMsY0FBVCxDQUF3QixLQUFLLE9BQTdCLENBQWpCO0FBQ0EseUJBQUssU0FBTCxHQUFpQixTQUFqQjtBQUNBLDJCQUFPLElBQVA7QUFDSCxpQkFMb0IsRUFBckI7O0FBT0Esd0JBQVEsV0FBUixDQUFvQixZQUFwQjtBQUNBLHFCQUFLLFlBQUwsQ0FBa0IsT0FBbEIsRUFBMkIsS0FBSyxRQUFMLENBQWMsQ0FBZCxDQUEzQjtBQUNBLDZCQUFhLEtBQWIsR0FBcUIsS0FBSyxPQUExQjtBQUNIO0FBQ0osU0FsU0E7QUFtU0Q7Ozs7Ozs7O0FBUUEsMEJBQWtCLDBCQUFTLElBQVQsRUFBZSxHQUFmLEVBQW9CLEtBQXBCLEVBQTJCLElBQTNCLEVBQWlDLFNBQWpDLEVBQTRDLFFBQTVDLEVBQXNEOztBQUVwRSxnQkFBSSxXQUFXLFNBQVMsY0FBVCxDQUF3QixrQkFBa0IsR0FBbEIsRUFBdUIsSUFBdkIsQ0FBeEIsQ0FBZjtBQUFBLGdCQUNJLFFBREo7QUFBQSxnQkFFSSxhQUZKO0FBQUEsZ0JBR0ksYUFISjtBQUFBLGdCQUlJLFFBSko7QUFBQSxnQkFLSSxtQkFMSjs7QUFPQSxnQkFBSSxDQUFDLFFBQUwsRUFBZTtBQUNYLDJCQUFXLFFBQVEsYUFBUixDQUFzQixVQUF0QixFQUFrQyxrQkFBa0IsR0FBbEIsRUFBdUIsSUFBdkIsQ0FBbEMsRUFBZ0UsV0FBaEUsQ0FBWDtBQUNBLDJCQUFXLFFBQVEsYUFBUixDQUFzQixLQUF0QixFQUE2QixJQUE3QixFQUFtQyxpQkFBaUIsSUFBcEQsQ0FBWDtBQUNBLHNDQUFzQixRQUFRLGFBQVIsQ0FBc0IsS0FBdEIsRUFBNkIsSUFBN0IsRUFBbUMsaUJBQW5DLENBQXRCO0FBQ0EsZ0NBQWdCLFFBQVEsYUFBUixDQUFzQixNQUF0QixFQUE4QixJQUE5QixFQUFvQyxnQ0FBcEMsQ0FBaEI7QUFDQSxnQ0FBZ0IsUUFBUSxhQUFSLENBQXNCLE1BQXRCLEVBQThCLElBQTlCLEVBQW9DLGdDQUFwQyxDQUFoQjtBQUNBLDhCQUFjLFNBQWQsR0FBMEIsaUJBQWlCLENBQWpCLENBQTFCO0FBQ0EsMkJBQVcsUUFBUSxhQUFSLENBQXNCLEtBQXRCLEVBQTZCLElBQTdCLEVBQW1DLHlEQUFuQyxDQUFYO0FBQ0EseUJBQVMsWUFBVCxDQUFzQixPQUF0QixFQUErQixtRkFBL0I7O0FBRUEsb0NBQW9CLFdBQXBCLENBQWdDLEtBQUssT0FBTCxDQUFhLElBQWIsQ0FBaEM7QUFDQSxvQ0FBb0IsV0FBcEIsQ0FBZ0MsYUFBaEM7QUFDQSxvQ0FBb0IsV0FBcEIsQ0FBZ0MsUUFBaEM7QUFDQSxvQ0FBb0IsV0FBcEIsQ0FBZ0MsYUFBaEM7O0FBRUEseUJBQVMsZ0JBQVQsQ0FBMEIsT0FBMUIsRUFBbUMsWUFBWTtBQUMzQyx3QkFBTSxRQUFRLFNBQVMsS0FBVCxDQUFlLE9BQWYsQ0FBdUIsTUFBdkIsQ0FBZDtBQUNBLDZCQUFTLEtBQVQ7QUFDQSw2QkFBUyxpQkFBVCxDQUEyQixLQUEzQixFQUFrQyxRQUFNLENBQXhDO0FBQ0EseUJBQUssU0FBTCxDQUFlLEdBQWYsQ0FBbUIsUUFBbkI7QUFDSCxpQkFMRDs7QUFPQSx5QkFBUyxnQkFBVCxDQUEwQixNQUExQixFQUFrQyxVQUFVLEtBQVYsRUFBaUI7QUFDL0MsNkJBQVMsU0FBVCxDQUFtQixNQUFuQixDQUEwQixRQUExQjtBQUNILGlCQUZEOztBQUlBLHlCQUFTLGdCQUFULENBQTBCLE9BQTFCLEVBQW1DLFlBQVk7QUFDM0Msa0NBQWMsU0FBZCxHQUEwQixrQkFBa0IsS0FBSyxLQUF2QixDQUExQjtBQUNBLGtDQUFjLFNBQWQsR0FBMEIsaUJBQWlCLFlBQVksa0JBQVosQ0FBK0IsS0FBSyxLQUFwQyxDQUFqQixDQUExQjtBQUNBLHdCQUFJLFlBQVksS0FBSyxLQUFqQixDQUFKLEVBQTZCO0FBQ3pCO0FBQ0EsaUNBQVMsYUFBVCxDQUF1QixTQUF2QixDQUFpQyxHQUFqQyxDQUFxQyxVQUFyQztBQUNILHFCQUhELE1BR087QUFDSDtBQUNBLGlDQUFTLGFBQVQsQ0FBdUIsU0FBdkIsQ0FBaUMsTUFBakMsQ0FBd0MsVUFBeEM7QUFDSDtBQUNKLGlCQVZEOztBQVlBLHlCQUFTLFlBQVQsQ0FBc0IsTUFBdEIsRUFBOEIsTUFBOUI7O0FBRUEsb0JBQUksV0FBSixDQUFnQixRQUFoQixFQUEwQixHQUExQixFQUErQixJQUEvQixFQUFxQyxLQUFyQzs7QUFFQSx5QkFBUyxXQUFULENBQXFCLFFBQXJCO0FBQ0EseUJBQVMsV0FBVCxDQUFxQixtQkFBckI7O0FBRUEscUJBQUssWUFBTCxDQUNFLFFBREYsRUFFRSxLQUFLLFFBQUwsQ0FBYyxRQUFkLENBRkY7QUFJSCxhQWpERCxNQWlETztBQUNILGdDQUFnQixTQUFTLGFBQVQsQ0FBdUIsYUFBdkIsQ0FBcUMsaUNBQXJDLENBQWhCO0FBQ0EsZ0NBQWdCLFNBQVMsYUFBVCxDQUF1QixhQUF2QixDQUFxQyxpQ0FBckMsQ0FBaEI7QUFDQSwyQkFBVyxTQUFTLGFBQVQsQ0FBdUIsYUFBdkIsQ0FBcUMsNkJBQXJDLENBQVg7QUFDSDs7QUFFRCxnQkFBSSxTQUFTLFVBQVUsRUFBdkIsRUFBMkI7QUFDdkIseUJBQVMsS0FBVCxHQUFpQixRQUFRLFFBQVEsTUFBUixDQUFlLEtBQWYsQ0FBUixHQUFnQyxFQUFqRDtBQUNBLDhCQUFjLFNBQWQsR0FBMEIsaUJBQWlCLFlBQVksa0JBQVosQ0FBK0IsS0FBL0IsQ0FBakIsQ0FBMUI7QUFDQSw4QkFBYyxTQUFkLEdBQTBCLGtCQUFrQixLQUFsQixDQUExQjtBQUNBLDRCQUFZLFNBQVMsS0FBckIsSUFBOEIsU0FBUyxhQUFULENBQXVCLFNBQXZCLENBQWlDLEdBQWpDLENBQXFDLFVBQXJDLENBQTlCLEdBQWlGLFNBQVMsYUFBVCxDQUF1QixTQUF2QixDQUFpQyxNQUFqQyxDQUF3QyxVQUF4QyxDQUFqRjtBQUNIOztBQUVELHFCQUFTLFdBQVQsQ0FBcUIsSUFBckIsRUFBMkI7QUFDdkIsdUJBQU8sVUFBUyxJQUFULENBQWMsSUFBZDtBQUFQO0FBQ0g7QUFDSixTQXJYQTtBQXNYRDs7Ozs7O0FBTUEsZ0JBQVEsZ0JBQVMsSUFBVCxFQUFlLEdBQWYsRUFBb0I7QUFDeEI7QUFDQSxnQkFBSSxNQUFNLFNBQVMsY0FBVCxDQUF3QixLQUFLLFNBQUwsR0FBaUIsR0FBekMsQ0FBVjtBQUFBLGdCQUNJLHVCQUF1QixRQUFRLElBQVIsR0FBZSxJQUFJLGFBQUosQ0FBa0IsdUJBQWxCLENBQWYsR0FBNEQsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBRHZGOztBQUdBLGlDQUFxQixTQUFyQixHQUFpQyxzQkFBakM7O0FBRUE7QUFDQSxnQkFBSSxPQUFPLElBQUksU0FBSixDQUFjLFFBQWQsQ0FBdUIsV0FBdkIsQ0FBWCxFQUFnRDtBQUM1QyxvQkFBSSxTQUFKO0FBQ0Esc0JBQU0sU0FBTjtBQUNIO0FBQ0Q7QUFDQSxnQkFBSSxDQUFDLEdBQUwsRUFBVTtBQUNOLHNCQUFNLFFBQVEsYUFBUixDQUFzQixLQUF0QixFQUE2QixLQUFLLFNBQUwsR0FBaUIsR0FBOUMsRUFBbUQsOEJBQW5ELENBQU47QUFDQTtBQUNBLG9CQUFJLGNBQWMsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQWxCO0FBQ0Esb0JBQUksT0FBTyxTQUFTLGFBQVQsQ0FBdUIsTUFBdkIsQ0FBWDtBQUNBLHFCQUFLLFNBQUwsR0FBaUIsU0FBakI7QUFDQSw0QkFBWSxXQUFaLENBQXdCLElBQXhCO0FBQ0EsNEJBQVksU0FBWixHQUF3QixvQkFBeEI7QUFDQSxvQkFBSSxXQUFKLENBQWdCLFdBQWhCO0FBQ0Esc0JBQU0sVUFBTixDQUFpQixHQUFqQixDQUFxQixXQUFyQixFQUFrQyxFQUFDLElBQUksR0FBTCxFQUFVLGFBQWEsOEJBQXZCLEVBQWxDOztBQUVBO0FBQ0Esb0JBQUksV0FBSixDQUFnQixvQkFBaEI7QUFDQSxxQkFBSyxhQUFMLENBQW1CLGNBQW5CLEVBQW1DLFdBQW5DLENBQStDLEdBQS9DO0FBQ0g7QUFDRCxtQkFBTyxHQUFQO0FBQ0gsU0F6WkE7QUEwWkQsNkJBQXFCLDZCQUFTLElBQVQsRUFBZSxJQUFmLEVBQXFCLGNBQXJCLEVBQXFDLG1CQUFyQyxFQUEwRDtBQUMzRSxnQkFBSSxNQUFNLEdBQUcsTUFBSCxDQUFVLElBQVYsRUFBZ0IsS0FBSyxHQUFyQixDQUFWOztBQUVBLGVBQUcsV0FBSCxDQUFlLEdBQWYsRUFBb0IsSUFBcEI7O0FBRUEsZ0NBQW9CLE9BQXBCLENBQTRCLFVBQVMsSUFBVCxFQUFlO0FBQ3ZDLG1CQUFHLGdCQUFILENBQW9CLElBQUksYUFBSixDQUFrQix1QkFBbEIsQ0FBcEIsRUFDSSxLQUFLLEdBRFQsRUFFSSxtQkFBbUIsSUFBbkIsR0FBMEIsS0FBSyxLQUEvQixHQUF1QyxJQUYzQyxFQUdJLElBSEo7QUFJSCxhQUxEO0FBTUgsU0FyYUE7QUFzYUQscUJBQWEscUJBQVMsSUFBVCxFQUFlLElBQWYsRUFBcUIsUUFBckIsRUFBK0I7QUFDeEMsZ0JBQUksR0FBSjtBQUFBLGdCQUNJLGFBQWEsRUFEakI7QUFBQSxnQkFFSSxlQUZKO0FBR0EsaUJBQUssT0FBTCxDQUFhLFVBQVMsR0FBVCxFQUFjO0FBQ3ZCLHNCQUFNLFNBQVMsY0FBVCxDQUF3QixLQUFLLFNBQUwsR0FBaUIsR0FBekMsQ0FBTjtBQUNBLG9CQUFJLEdBQUosRUFBUztBQUNMLHVCQUFHLGdCQUFILENBQ0UsSUFBSSxhQUFKLENBQWtCLHVCQUFsQixDQURGLEVBRUUsR0FGRixFQUdFLElBSEYsRUFJRSxJQUpGLEVBS0UsQ0FMRixFQU1FLFFBTkY7O0FBU0Esc0NBQWtCLElBQUksS0FBSixDQUFVLEdBQVYsRUFBZSxDQUFmLENBQWxCO0FBQ0Esd0JBQUksV0FBVyxPQUFYLENBQW1CLGVBQW5CLE1BQXdDLENBQUMsQ0FBN0MsRUFBZ0Q7QUFDNUMsbUNBQVcsSUFBWCxDQUFnQixlQUFoQjtBQUNIO0FBRUosaUJBZkQsTUFlTztBQUNILDRCQUFRLEdBQVIsQ0FBWSx1RUFBWixFQUFxRixHQUFyRjtBQUNIO0FBQ0osYUFwQkQ7O0FBc0JBLHVCQUFXLE9BQVgsQ0FBbUIsVUFBUyxRQUFULEVBQW1CO0FBQ2xDLG9CQUFNLG1CQUFtQixTQUFTLGFBQVQsQ0FBdUIsTUFBTSxLQUFLLFNBQVgsR0FBdUIsUUFBdkIsR0FBa0MsaURBQXpELENBQXpCO0FBQ0EsaUNBQWlCLFdBQWpCLENBQTZCLDJCQUEyQixJQUEzQixDQUE3QjtBQUNILGFBSEQ7QUFJSCxTQXBjQTtBQXFjRCxtQkFBVyxxQkFBVztBQUNsQjtBQUNBO0FBQ0EsZUFBRyxLQUFILENBQVMsSUFBVCxDQUFjLFNBQVMsUUFBdkIsRUFBaUMsT0FBakMsQ0FBeUMsVUFBUyxLQUFULEVBQWdCO0FBQ3JELHlCQUFTLFdBQVQsQ0FBcUIsS0FBckI7QUFDSCxhQUZEO0FBR0gsU0EzY0E7QUE0Y0Qsa0JBQVUsa0JBQVMsSUFBVCxFQUFlO0FBQ3JCO0FBQ0EscUJBQVMsU0FBVCxDQUFtQixNQUFuQixDQUEwQixZQUFZLElBQXRDO0FBQ0gsU0EvY0E7QUFnZEQ7Ozs7QUFJQSx3QkFBZ0Isd0JBQVMsT0FBVCxFQUFrQixPQUFsQixFQUEyQix5QkFBM0IsRUFBc0Q7QUFDbEUsZ0JBQUksZUFBZSxTQUFTLGNBQVQsQ0FBd0IsS0FBSyxTQUFMLEdBQWlCLE9BQXpDLENBQW5CO0FBQUEsZ0JBQ0ksT0FBTyxhQUFhLGdCQUFiLENBQThCLFFBQTlCLENBRFg7QUFBQSxnQkFFSSxXQUFXLGFBQWEsYUFBYixDQUEyQixJQUEzQixDQUZmO0FBQUEsZ0JBR0ksYUFBYSxhQUFhLGFBQWIsQ0FBMkIsZUFBM0IsQ0FIakI7O0FBS0EseUJBQWEsRUFBYixHQUFrQixLQUFLLFNBQUwsR0FBaUIsT0FBbkM7O0FBRUEscUJBQVMsYUFBVCxDQUF1QixVQUF2QixFQUFtQyxVQUFuQyxDQUE4QyxDQUE5QyxFQUFpRCxTQUFqRCxHQUE2RCxPQUE3RDs7QUFFQSx1QkFBVyxhQUFYLENBQXlCLE9BQXpCLEVBQWtDLFNBQWxDLEdBQThDLFVBQVUsR0FBeEQ7QUFDQSx1QkFBVyxhQUFYLENBQXlCLE9BQXpCLEVBQWtDLFlBQWxDLENBQStDLFVBQS9DLEVBQTJELE9BQTNEOztBQUVBLGVBQUcsS0FBSCxDQUFTLElBQVQsQ0FBYyxJQUFkLEVBQW9CLE9BQXBCLENBQTRCLFVBQVMsR0FBVCxFQUFjO0FBQ3RDLG9CQUFJLEtBQUssSUFBSSxFQUFKLENBQU8sT0FBUCxDQUFlLEtBQUssU0FBcEIsRUFBK0IsRUFBL0IsQ0FBVDtBQUFBLG9CQUNJLFlBQVksR0FBRyxLQUFILENBQVMsR0FBVCxDQURoQjtBQUFBLG9CQUVJLFVBRko7O0FBSUEsMEJBQVUsS0FBVjtBQUNBLDZCQUFhLFVBQVUsR0FBVixHQUFnQixVQUFVLElBQVYsQ0FBZSxHQUFmLENBQTdCO0FBQ0Esb0JBQUksT0FBTyxFQUFYLEVBQWU7QUFDWCxpQ0FBYSxFQUFiLEVBQWlCLFVBQWpCLEVBQTZCLHlCQUE3QjtBQUNILGlCQUZELE1BRU87QUFDSCw0QkFBUSxLQUFSLENBQWMsMkRBQWQsRUFBMkUsR0FBM0U7QUFDSDtBQUNKLGFBWkQ7QUFhQSw2QkFBaUIsYUFBakIsQ0FBK0IsUUFBL0I7QUFDQSxxQkFBUyxhQUFULENBQXVCLGdCQUF2QixFQUF5QyxZQUF6QyxDQUFzRCxVQUF0RCxFQUFrRSxNQUFsRTtBQUVILFNBamZBO0FBa2ZEOzs7QUFHQSx3QkFBZ0Isd0JBQVMsR0FBVCxFQUFjO0FBQzFCLGdCQUFJLE1BQU0sU0FBUyxjQUFULENBQXdCLEtBQUssU0FBTCxHQUFpQixHQUF6QyxDQUFWO0FBQ0EsZ0JBQUksR0FBSixFQUFTO0FBQ0wsb0JBQUksU0FBSjtBQUNIO0FBQ0osU0ExZkE7QUEyZkQ7Ozs7QUFJQSwwQkFBa0IsMEJBQVMsR0FBVCxFQUFjO0FBQzVCLGdCQUFJLE1BQU0sU0FBUyxjQUFULENBQXdCLEtBQUssU0FBTCxHQUFpQixHQUF6QyxDQUFWO0FBQUEsZ0JBQ0ksUUFESjtBQUVBLGdCQUFJLE9BQU8sQ0FBQyxJQUFJLFNBQUosQ0FBYyxRQUFkLENBQXVCLFdBQXZCLENBQVosRUFBaUQ7QUFDN0Msb0JBQUksU0FBSixDQUFjLEdBQWQsQ0FBa0IsV0FBbEI7QUFDQSwyQkFBVyxRQUFRLGFBQVIsQ0FBc0IsS0FBdEIsRUFBNkIsSUFBN0IsRUFBbUMsaUNBQW5DLENBQVg7QUFDQSx5QkFBUyxnQkFBVCxDQUEwQixPQUExQixFQUFtQyxZQUFXO0FBQzFDLHdCQUFJLFNBQUo7QUFDSCxpQkFGRDtBQUdBLHlCQUFTLFdBQVQsQ0FBcUIsR0FBckI7QUFDQSw0Q0FBNEIsR0FBNUI7QUFDQSxpQ0FBaUIsV0FBakIsQ0FBNkIsR0FBN0I7QUFDSCxhQVRELE1BU087QUFDSCx3QkFBUSxLQUFSLENBQWMsd0RBQWQsRUFBd0UsR0FBeEUsRUFBNkUsR0FBN0U7QUFDSDtBQUNKLFNBOWdCQTtBQStnQkQ7OztBQUdBLG1CQUFXLG1CQUFTLEdBQVQsRUFBYztBQUNyQixnQkFBSSxNQUFNLFNBQVMsY0FBVCxDQUF3QixLQUFLLFNBQUwsR0FBaUIsR0FBekMsQ0FBVjtBQUNBLGdCQUFJLEdBQUosRUFBUztBQUNMLG9CQUFJLFNBQUo7QUFDSDtBQUNKLFNBdmhCQTtBQXdoQkQ7Ozs7Ozs7QUFPQSxtQkFBVyxtQkFBUyxNQUFULEVBQWlCLE1BQWpCLEVBQXlCLHlCQUF6QixFQUFvRDtBQUMzRCxnQkFBSSxlQUFlLFNBQVMsY0FBVCxDQUF3QixLQUFLLFdBQUwsR0FBbUIsTUFBM0MsQ0FBbkI7QUFBQSxnQkFDSSxPQURKOztBQUdBLGdCQUFJLFlBQUosRUFBa0I7QUFDZCwwQkFBVSxHQUFHLGdCQUFILENBQW9CLEVBQUMsS0FBSyxNQUFOLEVBQXBCLEVBQW1DLE9BQTdDO0FBQ0EsNkJBQWEsTUFBYixFQUFxQixNQUFyQixFQUE2Qix5QkFBN0I7QUFDQSw2QkFBYSxLQUFiLEdBQXFCLE9BQXJCO0FBQ0E7QUFDQSxpQ0FBaUIsYUFBakIsQ0FBK0IsWUFBL0I7QUFDQTtBQUNBLDZCQUFhLFlBQWIsQ0FBMEIsVUFBMUIsRUFBc0MsTUFBdEM7QUFDQSw2QkFBYSxVQUFiLENBQXdCLGFBQXhCLENBQXNDLFVBQXRDLEVBQWtELFVBQWxELENBQTZELENBQTdELEVBQWdFLFNBQWhFLEdBQTRFLE9BQTVFO0FBQ0g7QUFDSixTQTdpQkE7QUE4aUJELHFCQUFhLHFCQUFTLFlBQVQsRUFBdUI7QUFDaEMsZ0JBQUksV0FBVyxTQUFTLGFBQVQsQ0FBdUIsTUFBTSxLQUFLLFNBQVgsR0FBdUIsWUFBdkIsR0FBc0Msd0JBQTdELENBQWY7QUFDQSxtQkFBTyxTQUFTLFVBQWhCLEVBQTRCO0FBQ3hCLHlCQUFTLFdBQVQsQ0FBcUIsU0FBUyxVQUE5QjtBQUNIO0FBQ0QscUJBQVMsU0FBVCxDQUFtQixNQUFuQixDQUEwQixRQUExQjtBQUNILFNBcGpCQTtBQXFqQkQsa0JBQVUsa0JBQVMsSUFBVCxFQUFlO0FBQ3JCLHFCQUFTLFNBQVQsQ0FBbUIsR0FBbkIsQ0FBdUIsWUFBWSxJQUFuQztBQUNILFNBdmpCQTtBQXdqQkQsNEJBQW9CLDRCQUFTLEVBQVQsRUFBYTtBQUM3QixxQkFBUyxnQkFBVCxDQUEwQixJQUExQixDQUErQixFQUEvQjtBQUNILFNBMWpCQTtBQTJqQkQsMkJBQW1CLDJCQUFTLEVBQVQsRUFBYTtBQUM1QixxQkFBUyxlQUFULENBQXlCLElBQXpCLENBQThCLEVBQTlCO0FBQ0gsU0E3akJBO0FBOGpCRCxxQkFBYSxxQkFBUyxFQUFULEVBQWE7QUFDdEIscUJBQVMsU0FBVCxDQUFtQixJQUFuQixDQUF3QixFQUF4QjtBQUNILFNBaGtCQTtBQWlrQkQscUJBQWEscUJBQVMsRUFBVCxFQUFhO0FBQ3RCLHFCQUFTLFNBQVQsQ0FBbUIsSUFBbkIsQ0FBd0IsRUFBeEI7QUFDSCxTQW5rQkE7QUFva0JELHFCQUFhLHFCQUFTLEVBQVQsRUFBYTtBQUN0QixxQkFBUyxTQUFULENBQW1CLElBQW5CLENBQXdCLEVBQXhCO0FBQ0gsU0F0a0JBO0FBdWtCRCwwQkFBa0IsMEJBQVMsRUFBVCxFQUFhO0FBQzNCLHFCQUFTLGNBQVQsQ0FBd0IsSUFBeEIsQ0FBNkIsRUFBN0I7QUFDSCxTQXprQkE7QUEwa0JELDBCQUFrQiwwQkFBUyxFQUFULEVBQWE7QUFDM0IscUJBQVMsY0FBVCxDQUF3QixJQUF4QixDQUE2QixFQUE3QjtBQUNILFNBNWtCQTtBQTZrQkQ7Ozs7QUFJQSxtQkFBVyxtQkFBUyxJQUFULEVBQWU7QUFDdEIseUJBQVksSUFBWjtBQUNILFNBbmxCQTtBQW9sQkQ7Ozs7QUFJQSxxQkFBYSxxQkFBUyxJQUFULEVBQWU7QUFDeEIsMkJBQWMsSUFBZDtBQUNILFNBMWxCQTtBQTJsQkQsb0JBQVksb0JBQVMsSUFBVCxFQUFlO0FBQ3ZCLDBCQUFhLElBQWI7QUFDSCxTQTdsQkE7QUE4bEJELHlCQUFpQix5QkFBUyxFQUFULEVBQWE7QUFDMUIsMkJBQWUsRUFBZjtBQUNIO0FBaG1CQSxLQXBNVDtBQXN5QkEsV0FBTyxFQUFQO0FBQ0gsQ0F4M0JzQixFQUF2Qjs7QUEwM0JBLE9BQU8sT0FBUCxHQUFpQixlQUFqQjs7Ozs7QUM1OUJBLElBQUksSUFBSjtBQUNBLE9BQU8sT0FBUCxHQUFpQjtBQUNiLFNBQU0sYUFBVSxJQUFWLEVBQWdCLElBQWhCLEVBQXNCO0FBQ3hCLGVBQU8sSUFBUDtBQUNILEtBSFk7QUFJYixxQkFBa0IseUJBQVUsZUFBVixFQUEyQjtBQUN6QyxlQUFPLElBQVAsQ0FBWSxlQUFaLEVBQTZCLE9BQTdCLENBQXFDLFVBQVUsR0FBVixFQUFlO0FBQ2hELGdCQUFJLFNBQVMsU0FBUyxjQUFULENBQXdCLEdBQXhCLENBQWI7QUFBQSxnQkFDSSxLQURKO0FBRUEsZ0JBQUksTUFBSixFQUFZO0FBQ1Isd0JBQVEsT0FBTyxhQUFQLENBQXFCLFVBQXJCLENBQVI7QUFDQSxvQkFBSSxLQUFKLEVBQVc7QUFDUCwwQkFBTSxTQUFOLEdBQWtCLGdCQUFnQixHQUFoQixDQUFsQjtBQUNIO0FBQ0o7QUFDSixTQVREO0FBVUg7QUFmWSxDQUFqQjs7Ozs7QUNEQTs7O0FBR0EsSUFBSSxRQUFKO0FBQUEsSUFDSSxrQkFBaUIsMEJBQVk7QUFBRSxZQUFRLElBQVIsQ0FBYSwrREFBYjtBQUFnRixDQURuSDtBQUFBLElBRUksa0JBQWlCLDBCQUFZO0FBQUUsWUFBUSxJQUFSLENBQWEsK0RBQWI7QUFBZ0YsQ0FGbkg7O0FBSUEsU0FBUyxZQUFULENBQXNCLEVBQXRCLEVBQTBCO0FBQ3RCLFFBQUksT0FBTyxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBWDtBQUNBLFNBQUssU0FBTCxHQUFpQix5Q0FBakI7QUFDQSxTQUFLLGdCQUFMLENBQXNCLE9BQXRCLEVBQStCLFlBQVk7QUFDdkMsd0JBQWUsRUFBZjtBQUNILEtBRkQ7QUFHQSxTQUFLLFlBQUwsQ0FBa0IsT0FBbEIsRUFBMkIscUJBQTNCO0FBQ0EsV0FBTyxJQUFQO0FBQ0g7O0FBRUQsU0FBUyxTQUFULENBQW1CLEVBQW5CLEVBQXVCO0FBQ25CLFFBQUksWUFBWSxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBaEI7QUFBQSxRQUNJLFVBQVUsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBRGQ7QUFBQSxRQUVJLFlBQVksU0FBUyxhQUFULENBQXVCLEtBQXZCLENBRmhCO0FBQUEsUUFHSSxZQUFZLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUhoQjs7QUFLQSxjQUFVLFNBQVYsR0FBc0IsZ0NBQXRCO0FBQ0EsWUFBUSxTQUFSLEdBQW9CLGlDQUFwQjtBQUNBLFlBQVEsZ0JBQVIsQ0FBeUIsT0FBekIsRUFBa0MsWUFBWTtBQUMxQyxrQkFBVSxTQUFWLENBQW9CLEdBQXBCLENBQXdCLFFBQXhCO0FBQ0gsS0FGRDtBQUdBLGNBQVUsU0FBVixHQUFzQiw4QkFBdEI7QUFDQSxjQUFVLGdCQUFWLENBQTJCLE9BQTNCLEVBQW9DLFlBQVk7QUFDNUMsa0JBQVUsU0FBVixDQUFvQixNQUFwQixDQUEyQixRQUEzQjtBQUNILEtBRkQ7QUFHQSxjQUFVLFNBQVYsR0FBc0IscUNBQXRCO0FBQ0EsY0FBVSxnQkFBVixDQUEyQixPQUEzQixFQUFvQyxZQUFZO0FBQzVDLHdCQUFlLEVBQWY7QUFDSCxLQUZEOztBQUlBLGNBQVUsWUFBVixDQUF1QixPQUF2QixFQUFnQyxjQUFoQztBQUNBLGNBQVUsWUFBVixDQUF1QixPQUF2QixFQUFnQyxRQUFoQztBQUNBLFlBQVEsWUFBUixDQUFxQixPQUFyQixFQUE4QixNQUE5Qjs7QUFFQSxjQUFVLFdBQVYsQ0FBc0IsT0FBdEI7QUFDQSxjQUFVLFdBQVYsQ0FBc0IsU0FBdEI7QUFDQSxjQUFVLFdBQVYsQ0FBc0IsU0FBdEI7QUFDQSxXQUFPLFNBQVA7QUFDSDs7QUFFRCxTQUFTLFFBQVQsQ0FBa0IsSUFBbEIsRUFBd0I7QUFDcEIsUUFBSSxNQUFNLElBQUksS0FBSixFQUFWO0FBQ0EsUUFBSSxHQUFKLEdBQVUsSUFBVjtBQUNBLFFBQUksZ0JBQUosQ0FBcUIsT0FBckIsRUFBOEIsWUFBWTtBQUN0QyxZQUFJLE1BQU0sT0FBTyxJQUFQLENBQVksSUFBWixFQUFrQixRQUFsQixDQUFWO0FBQ0EsWUFBSSxLQUFKO0FBQ0gsS0FIRDtBQUlBLFdBQU8sR0FBUDtBQUNIOztBQUVELFNBQVMsZUFBVCxDQUF5QixFQUF6QixFQUE2QixHQUE3QixFQUFrQztBQUM5QixRQUFJLE9BQU8sU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQVg7QUFBQSxRQUNJLGFBQWEsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBRGpCO0FBRUEsZUFBVyxTQUFYLEdBQXVCLGlDQUF2QjtBQUNBLFNBQUssU0FBTCxHQUFpQiw4QkFBakI7QUFDQSxlQUFXLFdBQVgsQ0FBdUIsR0FBdkI7QUFDQSxTQUFLLFdBQUwsQ0FBaUIsVUFBakI7QUFDQSxTQUFLLFdBQUwsQ0FBaUIsVUFBVSxFQUFWLENBQWpCO0FBQ0EsV0FBTyxJQUFQO0FBQ0g7O0FBRUQsT0FBTyxPQUFQLEdBQWlCO0FBQ2Isb0JBQWlCLHdCQUFVLEVBQVYsRUFBYztBQUMzQiwwQkFBaUIsRUFBakI7QUFDSCxLQUhZO0FBSWIsb0JBQWdCLHdCQUFVLEVBQVYsRUFBYztBQUMxQiwwQkFBaUIsRUFBakI7QUFDSCxLQU5ZO0FBT2IsU0FBTSxhQUFVLElBQVYsRUFBZ0IsSUFBaEIsRUFBc0I7QUFDeEIsYUFBSyxXQUFMLENBQWlCLGFBQWEsSUFBYixDQUFqQjtBQUNILEtBVFk7QUFVYixpQkFBYyxxQkFBVSxFQUFWLEVBQWMsR0FBZCxFQUFtQjtBQUM3QixZQUFJLE1BQU0sU0FBUyxjQUFULENBQXdCLFFBQVEsRUFBaEMsQ0FBVjtBQUFBLFlBQ0ksWUFESjtBQUVBLFlBQUksR0FBSixFQUFTO0FBQ0wsMkJBQWUsSUFBSSxhQUFKLENBQWtCLHFCQUFsQixDQUFmO0FBQ0EsZ0JBQUksWUFBSixFQUFrQjtBQUNkLG1CQUFHLEtBQUgsQ0FBUyxJQUFULENBQWMsYUFBYSxRQUEzQixFQUFxQyxPQUFyQyxDQUE2QyxVQUFVLENBQVYsRUFBYTtBQUN0RCxzQkFBRSxNQUFGO0FBQ0gsaUJBRkQ7QUFHQSw2QkFBYSxTQUFiLENBQXVCLEdBQXZCLENBQTJCLFFBQTNCO0FBQ0EsNkJBQWEsV0FBYixDQUF5QixnQkFBZ0IsRUFBaEIsRUFBb0IscUJBQW1CLEdBQW5CLENBQXBCLENBQXpCO0FBQ0g7QUFDSjtBQUNKO0FBdkJZLENBQWpCOzs7OztBQ3BFQTs7O0FBR0EsSUFBSSxZQUFXLG9CQUFZLENBQUUsQ0FBN0I7QUFBQSxJQUNJLFFBQVE7QUFDSixlQUFZO0FBQ1IsY0FBTSxjQUFVLElBQVYsRUFBZ0I7QUFDbEIsaUJBQUssZ0JBQUwsQ0FBc0IsUUFBdEIsRUFBZ0MsTUFBaEM7QUFDSDtBQUhPO0FBRFIsQ0FEWjs7QUFTQSxTQUFTLE1BQVQsR0FBa0I7QUFDZCxZQUFRLEdBQVIsQ0FBWSx5QkFBWjtBQUNBLFFBQUksT0FBTyxLQUFLLEtBQUwsQ0FBVyxDQUFYLENBQVg7QUFDQSxRQUFJLElBQUosRUFBVTtBQUNOO0FBQ0EsV0FBRyxLQUFILENBQVMsSUFBVCxDQUFjLEtBQUssS0FBbkIsRUFBMEIsT0FBMUIsQ0FBa0MsVUFBVSxJQUFWLEVBQWdCO0FBQzlDO0FBQ0Esc0JBQVMsSUFBVDtBQUNILFNBSEQ7QUFJQTtBQUNBLGFBQUssS0FBTCxHQUFhLElBQWI7QUFDQSxlQUFPLEtBQVA7QUFDSDtBQUNKO0FBQ0Q7Ozs7QUFJQSxPQUFPLE9BQVAsR0FBaUI7QUFDYixjQUFXLGtCQUFVLEVBQVYsRUFBYztBQUNyQixvQkFBVyxFQUFYO0FBQ0gsS0FIWTtBQUliLFNBQU0sYUFBVSxJQUFWLEVBQWdCLElBQWhCLEVBQXNCO0FBQ3hCLFlBQUksTUFBTSxjQUFOLENBQXFCLElBQXJCLENBQUosRUFBZ0M7QUFDNUIsa0JBQU0sSUFBTixFQUFZLElBQVosQ0FBaUIsSUFBakI7QUFDSDtBQUNKO0FBUlksQ0FBakI7Ozs7O0FDN0JBLElBQUksVUFBVyxZQUFVOztBQUVyQixXQUFPLFNBQVAsQ0FBaUIsV0FBakIsR0FBK0IsVUFBUyxFQUFULEVBQVk7QUFDdkMsWUFBSSxZQUFZLElBQWhCO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFVBQVUsTUFBOUIsRUFBc0MsR0FBdEMsRUFBMkM7QUFDdkMsc0JBQVUsQ0FBVixJQUFlLEdBQUcsVUFBVSxDQUFWLENBQUgsQ0FBZjtBQUNIO0FBQ0QsZUFBTyxVQUFVLFFBQVYsRUFBUDtBQUNILEtBTkQ7QUFPQSxRQUFJLE1BQU0sSUFBSSxNQUFKLENBQVcsdUJBQVgsRUFBbUMsR0FBbkMsQ0FBVjtBQUNBLFdBQU87QUFDSCxnQkFBUyxnQkFBUyxNQUFULEVBQWdCO0FBQ3JCLGdCQUFHLENBQUMsTUFBSixFQUFXO0FBQUMsdUJBQU8sRUFBUDtBQUFXO0FBQ3ZCLGdCQUFJLFlBQVksT0FBTyxPQUFQLENBQWUsR0FBZixFQUNaLFVBQVUsS0FBVixFQUFpQixRQUFqQixFQUEyQjtBQUN2Qix1QkFBTyxPQUFPLFlBQVAsQ0FBb0IsU0FBUyxRQUFULEVBQW1CLEVBQW5CLENBQXBCLENBQVA7QUFDSCxhQUhXLENBQWhCO0FBSUEsbUJBQU8sU0FBUDtBQUNILFNBUkU7QUFTSCxnQkFBUyxnQkFBUyxNQUFULEVBQWdCO0FBQ3JCLG1CQUFPLE9BQU8sV0FBUCxDQUFtQixVQUFTLENBQVQsRUFBVztBQUNqQyxxQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE1BQU0sTUFBMUIsRUFBa0MsR0FBbEMsRUFBdUM7QUFDbkMsd0JBQUcsTUFBTSxDQUFOLEtBQVksQ0FBZixFQUFpQjtBQUNiLGdDQUFRLEdBQVIsQ0FBWSxXQUFTLE1BQU0sQ0FBTixDQUFyQjtBQUNBLCtCQUFPLE1BQU0sQ0FBTixDQUFQO0FBQ0g7QUFDSjtBQUNELHVCQUFPLENBQVA7QUFDSCxhQVJNLENBQVA7QUFTSDs7QUFuQkUsS0FBUDtBQXNCSCxDQWhDYyxFQUFmOztBQWtDQSxPQUFPLE9BQVAsR0FBaUIsT0FBakI7O0FBRUEsSUFBSSxRQUFRLENBQ1IsTUFEUSxFQUVSLE1BRlEsRUFHUixNQUhRLEVBSVIsTUFKUSxFQUtSLE1BTFEsRUFNUixNQU5RLEVBT1IsTUFQUSxFQVFSLE1BUlEsRUFTUixNQVRRLEVBVVIsTUFWUSxFQVdSLE1BWFEsRUFZUixNQVpRLEVBYVIsTUFiUSxFQWNSLE1BZFEsRUFlUixNQWZRLEVBZ0JSLE1BaEJRLEVBaUJSLE1BakJRLEVBa0JSLE1BbEJRLEVBbUJSLE1BbkJRLEVBb0JSLE1BcEJRLEVBcUJSLE1BckJRLEVBc0JSLE1BdEJRLEVBdUJSLE1BdkJRLEVBd0JSLE1BeEJRLEVBeUJSLE1BekJRLEVBMEJSLE1BMUJRLEVBMkJSLE1BM0JRLEVBNEJSLE1BNUJRLEVBNkJSLE1BN0JRLEVBOEJSLE1BOUJRLEVBK0JSLE1BL0JRLEVBZ0NSLE1BaENRLEVBaUNSLE1BakNRLEVBa0NSLE1BbENRLEVBbUNSLE1BbkNRLEVBb0NSLE1BcENRLEVBcUNSLE1BckNRLEVBc0NSLE1BdENRLEVBdUNSLE1BdkNRLEVBd0NSLE1BeENRLEVBeUNSLE1BekNRLEVBMENSLE1BMUNRLEVBMkNSLE1BM0NRLEVBNENSLE1BNUNRLEVBNkNSLE1BN0NRLEVBOENSLE1BOUNRLEVBK0NSLE1BL0NRLEVBZ0RSLE1BaERRLEVBaURSLE1BakRRLEVBa0RSLE1BbERRLEVBbURSLE1BbkRRLEVBb0RSLE1BcERRLEVBcURSLE1BckRRLEVBc0RSLE1BdERRLEVBdURSLE1BdkRRLEVBd0RSLE1BeERRLEVBeURSLE1BekRRLEVBMERSLE1BMURRLEVBMkRSLE1BM0RRLEVBNERSLE1BNURRLEVBNkRSLE1BN0RRLEVBOERSLE1BOURRLENBQVo7Ozs7O0FDckNBLFNBQVMsU0FBVCxHQUFxQjtBQUNqQixRQUFJLE9BQU8sU0FBUyxJQUFwQjtBQUNBLFFBQUksSUFBSSxJQUFKLENBQVMsSUFBVCxDQUFKLEVBQW9CO0FBQ2hCLGVBQU8sTUFBTSxTQUFTLElBQVQsQ0FBYyxPQUFkLENBQXNCLEtBQXRCLEVBQTZCLEVBQTdCLENBQWI7QUFDSDtBQUNELFdBQU8sRUFBUDtBQUNIOztBQUVELE9BQU8sT0FBUCxHQUFpQjtBQUNiLGVBQVksU0FEQztBQUViLGVBQVkscUJBQVk7QUFDcEIsZUFBTyxnQkFBZ0IsRUFBdkI7QUFDSDtBQUpZLENBQWpCOzs7OztBQ1JBLElBQU0sWUFBWSxJQUFJLE1BQUosQ0FBVyw4QkFBWCxDQUFsQjs7QUFFQTs7Ozs7QUFLQSxPQUFPLE9BQVAsQ0FBZSxrQkFBZixHQUFvQyxTQUFTLGtCQUFULENBQTRCLEdBQTVCLEVBQWlDO0FBQ2pFLFFBQUksR0FBSixFQUFTO0FBQ0wsZUFBTyxJQUFJLE9BQUosQ0FBWSxTQUFaLEVBQXVCLEdBQXZCLEVBQTRCLElBQTVCLEdBQW1DLEtBQW5DLENBQXlDLEdBQXpDLEVBQThDLE1BQXJEO0FBQ0g7QUFDRCxXQUFPLENBQVA7QUFDSCxDQUxEOzs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TUE7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDenhEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5ZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2w5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDek1BO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3B4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BlQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM5U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcmhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMS9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDck5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlNBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNueEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzV0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIvKipcbiAqIEVycm9yIGNvbnN0YW50c1xuICpcbiAqIEB0eXBlIHt7UFJPSkVDVF9OT1RfRVhJU1RTOiBudW1iZXIsIElOVkFMSURfVVJMOiBudW1iZXIsIE5PX1BFUk1JU1NJT046IG51bWJlcn19XG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFBST0pFQ1RfTk9UX0VYSVNUUyA6ICdQUk9KRUNUX05PVF9FWElTVFMnLFxuICAgIFZBTElEQVRJT046ICdWQUxJREFUSU9OJyxcbiAgICBOT19QRVJNSVNTSU9OOiAnTk9fUEVSTUlTU0lPTidcbn0iLCJ2YXIgQyA9IHtcbiAgICBGSUxFX01BTkFHRVIgOiB7XG4gICAgICAgIEZJTEVfVFlQRVMgOiB7XG4gICAgICAgICAgICBJTUFHRSA6ICdpbWFnZScsXG4gICAgICAgICAgICBGSUxFICA6ICdmaWxlJ1xuICAgICAgICB9LFxuICAgICAgICBFTkNPRElORyA6IHtcbiAgICAgICAgICAgIGltYWdlIDogJ2Jhc2U2NCcsXG4gICAgICAgICAgICBmaWxlIDogJ3V0ZjgnXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFNFU1NJT04gOiB7XG4gICAgICAgIHJlbmV3YWxfaW50ZXJ2YWxfaW5fbXM6IDEwMDAgKiAxNVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQztcbiIsIi8qKlxuICogVE9ETyBmYWRlIG91dCB3aGVuIG1heExlbmd0aE9mTWVzc2FnZXMgZXhjZWVkZWQgbG9va3Mgbm90IHNvIG5pY2VcbiAqIEBwYXJhbSBpZFxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciB0b2FzdCA9IG5ldyAoZnVuY3Rpb24gVG9hc3QoaWQpe1xuICAgIHZhciBERUxBWSA9IDQwMDAsXG4gICAgb3BhY2l0eUZhZGVTdGVwcyA9IDAuMDQsXG4gICAgbWF4TGVuZ3RoT2ZNZXNzYWdlcyA9IDQsXG4gICAgdG9hc3ROb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpLFxuICAgIGlzUmVhZHlGb3JTdGFydEFnYWluID0gdHJ1ZSxcbiAgICBuZXdNZXNzYWdlID0gdHJ1ZSxcbiAgICBpbml0VG9hc3QgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgcm9vdE5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdO1xuICAgICAgICB0b2FzdE5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdG9hc3ROb2RlLmlkID0gaWQ7XG4gICAgICAgIHRvYXN0Tm9kZS5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjpmaXhlZDt6LWluZGV4Ojk5OTt0b3A6NC41ZW07cmlnaHQ6MmVtO2JvcmRlci1yYWRpdXM6NXB4O2NvbG9yOiNmZmY7Zm9udC1zaXplOjEuMmVtO2ZvbnQtd2VpZ2h0OmJvbGQ7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDYzLDE0MywyNTEsMC45KTtwYWRkaW5nOiAxZW0gMC41ZW07IGJveC1zaXppbmc6IGJvcmRlci1ib3g7IG1heC13aWR0aDogNTAlOyB0ZXh0LWFsaWduOiBjZW50ZXI7IHdvcmQtd3JhcDogYnJlYWstd29yZDsgYnJlYWstd29yZDogYnJlYWstYWxsO1wiXG4gICAgICAgIHJvb3ROb2RlLmFwcGVuZENoaWxkKHRvYXN0Tm9kZSk7XG4gICAgfSxcbiAgICB0b2FzdCA9IHtcbiAgICAgICAgZmFkZU91dCA6IGZ1bmN0aW9uKF9ub2RlLF9kb25lKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IF9ub2RlO1xuICAgICAgICAgICAgdmFyIGRvbmUgPSBfZG9uZTtcbiAgICAgICAgICAgIHZhciBvcGFjaXR5ID0gMTtcbiAgICAgICAgICAgIChmdW5jdGlvbiBkZWNyZW1lbnRPcGFjaXR5KCl7XG4gICAgICAgICAgICAgICAgaWYgKG9wYWNpdHkgPiBvcGFjaXR5RmFkZVN0ZXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHkgPSBvcGFjaXR5IC0gb3BhY2l0eUZhZGVTdGVwcztcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZS5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjcmVtZW50T3BhY2l0eSgpO1xuICAgICAgICAgICAgICAgICAgICB9LDQwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUEFSRU5UIE5PREU6Jyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhub2RlLnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZihub2RlLnBhcmVudE5vZGUgIT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNob3dNZXNzYWdlIDogZnVuY3Rpb24obXNnKSB7XG4gICAgICAgICAgICBpZighdG9hc3ROb2RlKXtcbiAgICAgICAgICAgICAgICBpbml0VG9hc3QoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9hc3ROb2RlLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICAgICAgdmFyIHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgICAgICAgICBwLnN0eWxlLmNzc1RleHQgPSBcInBhZGRpbmc6MHB4IDEwcHhcIjtcbiAgICAgICAgICAgIHAuaW5uZXJIVE1MID0gbXNnO1xuICAgICAgICAgICAgdG9hc3ROb2RlLmluc2VydEJlZm9yZShwLCB0b2FzdE5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAoZnVuY3Rpb24gZmFkZU91dFRvTXVjaE1lc3NhZ2VzKCkge1xuICAgICAgICAgICAgICAgIGlmICh0b2FzdE5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiBtYXhMZW5ndGhPZk1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvYXN0LmZhZGVPdXQodG9hc3ROb2RlLmNoaWxkcmVuW3RvYXN0Tm9kZS5jaGlsZHJlbi5sZW5ndGgtMV0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFkZU91dFRvTXVjaE1lc3NhZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICB2YXIgdGltZU91dCA9IERFTEFZO1xuICAgICAgICAgICAgbmV3TWVzc2FnZSA9IHRydWU7XG4gICAgICAgICAgICBmdW5jdGlvbiBmYWRlT3V0KF9mYyl7XG4gICAgICAgICAgICAgICAgdmFyIGZjID0gX2ZjO1xuICAgICAgICAgICAgICAgIHZhciBvcGFjaXR5ID0gdG9hc3ROb2RlLnN0eWxlLm9wYWNpdHk7XG4gICAgICAgICAgICAgICAgaWYgKG9wYWNpdHkgPiBvcGFjaXR5RmFkZVN0ZXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKG5ld01lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc2V0TWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZU91dCA9IERFTEFZO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9hc3ROb2RlLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5ID0gb3BhY2l0eS1vcGFjaXR5RmFkZVN0ZXBzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9hc3ROb2RlLnN0eWxlLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZU91dCA9IDQwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IHRpbWVyXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhZGVPdXQoZmMpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aW1lT3V0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIHRvYXN0Tm9kZS5maXJzdENoaWxkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9hc3ROb2RlLnJlbW92ZUNoaWxkKCB0b2FzdE5vZGUuZmlyc3RDaGlsZCApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRvYXN0Tm9kZS5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgZmModHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoaXNSZWFkeUZvclN0YXJ0QWdhaW4pe1xuICAgICAgICAgICAgICAgIGlzUmVhZHlGb3JTdGFydEFnYWluID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGltZU91dCA9IERFTEFZO1xuICAgICAgICAgICAgICAgIGZhZGVPdXQoZnVuY3Rpb24oX2Ipe1xuICAgICAgICAgICAgICAgICAgICBpc1JlYWR5Rm9yU3RhcnRBZ2FpbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB0b2FzdDtcbn0pKCd0b2FzdCcpO1xuXG5pZih0eXBlb2YgbW9kdWxlICE9IFwidW5kZWZpbmVkXCIpe1xuICAgIGNvbnNvbGUubG9nKCdleHBvcnRzJyk7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0b2FzdDtcbn1lbHNlIHtcbiAgICBjb25zb2xlLmxvZygnYXNpZ24gdG8gZ2xvYmFsIHNjb3BlJyk7XG4gICAgd2luZG93LnRvYXN0ID0gdG9hc3Q7XG59IiwiLyoqXG4gKiBjb250cm9sbGVyIGZvciB0aGUgaW1hZ2UgdXBsYW9kZXIgdmlldyAtIGNhbGxzIHRoZSBzZXJ2ZXIgdG8gdXBsb2FkIGEgaW1hZ2UgYW5kIG5vdGlmaWVyIHRoZSB1aSBldmVudCBoYW5kbGVyXG4gKiBAdHlwZSB7e319XG4gKi9cbnZhciBjYW5ueSA9IHJlcXVpcmUoJ2Nhbm55JyksXG4gICAgSk1CRlVwbG9hZGVyID0gY2FubnkuSk1CRlVwbG9hZGVyLFxuICAgIGRpc3BsYXlNYW5hZ2VyID0gY2FubnkuZGlzcGxheU1hbmFnZXIsXG4gICAgdWlFdmVudHMgPSByZXF1aXJlKCcuLi91aUV2ZW50TWFuYWdlci5qcycpLFxuICAgIHVwbG9hZElkLFxuICAgIHByb2plY3RJbmZvO1xuLyoqXG4gKiBDYWxsIHRoaXMgZm9yIGVhY2ggZmlsZSAtIHdpbGwgY2FsbCBhIGNhbGwgYmFjayB3aXRoIHRoZSBzZXJ2ZXIgYW5zd2VyXG4gKiBAcGFyYW0gZmlsZVxuICovXG5mdW5jdGlvbiBzZW5kRmlsZShmaWxlLCBkaXJlY3RDYWxsYmFjaykge1xuICAgIHZhciB1cmkgPSAnL3VwbG9hZEpNQkZGaWxlP3Byb2plY3RJZD0nICsgcHJvamVjdEluZm8uaWQgKyAnJnByb2plY3Q9JyArIHByb2plY3RJbmZvLm5hbWUsXG4gICAgICAgIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLFxuICAgICAgICBmZCA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gICAgeGhyLm9wZW4oXCJQT1NUXCIsIHVyaSwgdHJ1ZSk7XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09IDQgJiYgeGhyLnN0YXR1cyA9PSAyMDApIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSByZXNwb25zZS5cbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgZGlyZWN0Q2FsbGJhY2sgJiYgZGlyZWN0Q2FsbGJhY2soZGF0YSk7IC8vIGhhbmRsZSByZXNwb25zZS5cbiAgICAgICAgICAgIC8vIHtmaWxlOiBcIi8vc3ViL3N1YjEvc3ViMV9ibHVlX2Nva2UuanBnXCIsIG5hbWU6IFwic3ViMV9ibHVlX2Nva2UuanBnXCIsIHR5cGU6IFwiaW1hZ2UvanBnXCJ9XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgICAgIHVpRXZlbnRzLmNhbGxVaWV2ZW50KCdKTUJGRmlsZVVwbG9hZGVkJywgcHJvamVjdEluZm8uaWQsIHVwbG9hZElkLCBkYXRhLm5hbWUpXG4gICAgICAgIH0gZWxzZSBpZiAoeGhyLnJlYWR5U3RhdGUgPT0gNCAmJiB4aHIuc3RhdHVzID09PSA0MDYpIHtcbiAgICAgICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKCdVcGxvYWQgZmFpbHVyZS4gVGhlIGZpbGUgbGFuZ3VhZ2UgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmZC5hcHBlbmQoJ215RmlsZScsIGZpbGUpO1xuICAgIC8vIEluaXRpYXRlIGEgbXVsdGlwYXJ0L2Zvcm0tZGF0YSB1cGxvYWRcbiAgICB4aHIuc2VuZChmZCk7XG59XG5cbi8qKlxuICogU2F2ZSBkYXRhIGluIG1lbWJlciB2YXJpYWJsZSB1c2VkIGJ5IGZ1cnRoZXIgdXBsb2FkIG9wZXJhdGlvbnNcbiAqIEBwYXJhbSBkYXRhOiBQcm9qZWN0IGRhdGFcbiAqL1xuZnVuY3Rpb24gYXBwbHlQcm9qZWN0RGF0YShkYXRhLCBwcm9qZWN0KSB7XG4gICAgcHJvamVjdEluZm8gPSBwcm9qZWN0XG59XG5cbnVpRXZlbnRzLmFkZFVpRXZlbnRMaXN0ZW5lcih7XG4gICAgc2hvd0pNQkZVcGxvYWRlciA6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBkaXNwbGF5TWFuYWdlci5zaG93KCdKTUJGVXBsb2FkZXJWaWV3Jyk7XG4gICAgfVxufSk7XG5cbkpNQkZVcGxvYWRlci5vblVwbG9hZChmdW5jdGlvbiAoZmlsZSkge1xuICAgIC8vIFRPRE8gYWRkaXRpb25hbCB0byB0aGUgdXBsb2FkIGlkIHdlIG5lZWQgdGhlIHByb2plY3QgSURcbiAgICBjb25zb2xlLmxvZygndXBsb2FkQ29udHJvbGxlcjp1cGxvYWQgaWQ6IGZpbGU6JywgdXBsb2FkSWQsIGZpbGUpO1xuICAgIHNlbmRGaWxlKGZpbGUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG9uTmV3UHJvamVjdENyZWF0ZWQgOiBhcHBseVByb2plY3REYXRhLFxuICAgIG9uTG9hZFByb2plY3QgOiBhcHBseVByb2plY3REYXRhXG59OyIsInZhciBjYW5ueSA9IHJlcXVpcmUoJ2Nhbm55JyksXG4gICAgSnNvbkltcG9ydCA9IGNhbm55Lkpzb25JbXBvcnQsXG4gICAgZGlzcGxheU1hbmFnZXIgPSBjYW5ueS5kaXNwbGF5TWFuYWdlcixcbiAgICB1aUV2ZW50cyA9IHJlcXVpcmUoJy4uL3VpRXZlbnRNYW5hZ2VyLmpzJyksXG4gICAgdXBsb2FkSWQsXG4gICAgcHJvamVjdEluZm87XG5cbmZ1bmN0aW9uIHNlbmRGaWxlKGZpbGUpIHtcbiAgICB2YXIgdXJpID0gJy9pbXBvcnRKU09OP3Byb2plY3RJZD0nICsgcHJvamVjdEluZm8uaWQgKyAnJnByb2plY3Q9JyArIHByb2plY3RJbmZvLm5hbWUsXG4gICAgICAgIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLFxuICAgICAgICBmZCA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gICAgeGhyLm9wZW4oXCJQT1NUXCIsIHVyaSwgdHJ1ZSk7XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgLy8gZGF0YS5uYW1lIGRvZXMgbm90IGV4aXN0IC0gYW5kIGlzIGFsc28gbm90IHVzZWQsIGlzIGl0ID9cbiAgICAgICAgICAgICAgICB1aUV2ZW50cy5jYWxsVWlldmVudCgnanNvbkltcG9ydGVkJywgcHJvamVjdEluZm8uaWQsIHVwbG9hZElkLCBkYXRhLm5hbWUpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHhoci5zdGF0dXMgPT09IDQwNikge1xuICAgICAgICAgICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKCdVcGxvYWQgZmFpbHVyZS4gVGhlcmUgaXMgYW4gZXJyb3I6PGJyIC8+JyArIGRhdGEubXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgZmQuYXBwZW5kKCdteUZpbGUnLCBmaWxlKTtcbiAgICB4aHIuc2VuZChmZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5UHJvamVjdERhdGEoZGF0YSwgcHJvamVjdCkge1xuICAgIHByb2plY3RJbmZvID0gcHJvamVjdDtcbn1cblxudWlFdmVudHMuYWRkVWlFdmVudExpc3RlbmVyKHtcbiAgICBzaG93SlNPTkltcG9ydCA6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBkaXNwbGF5TWFuYWdlci5zaG93KCdKU09OSW1wb3J0VmlldycpO1xuICAgIH1cbn0pO1xuXG5Kc29uSW1wb3J0Lm9uVXBsb2FkKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgc2VuZEZpbGUoZmlsZSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgb25OZXdQcm9qZWN0Q3JlYXRlZCA6IGFwcGx5UHJvamVjdERhdGEsXG4gICAgb25Mb2FkUHJvamVjdCA6IGFwcGx5UHJvamVjdERhdGFcbn07IiwidmFyIGFzeW5jID0gcmVxdWlyZSgnY2FubnkvbW9kL2FzeW5jJyksXG4gICAgYXV0aCA9IHJlcXVpcmUoJ2Nhbm55JykuYXV0aDtcblxuYXV0aC5vbkxvZ291dChmdW5jdGlvbiAoKSB7XG4gICAgYXN5bmMuZG9BamF4KHtcbiAgICAgICAgcGF0aCA6ICcvbG9nb3V0JyxcbiAgICAgICAgb25TdWNjZXNzIDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBsb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgfVxuICAgIH0pXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7fTsiLCJ2YXIgYnJlYWRjcnVtYiA9IHJlcXVpcmUoJy4uL3VpTW9kdWxlcy9icmVhZGNydW1iJyksXG4gICAgY2FubnkgPSByZXF1aXJlKCdjYW5ueScpLFxuICAgIHRyYWRlID0gcmVxdWlyZSgnLi4vdHJhZGUnKSxcbiAgICB1aUV2ZW50cyA9IHJlcXVpcmUoJy4uL3VpRXZlbnRNYW5hZ2VyJyk7XG5cbmNhbm55LmFkZCgnYnJlYWRjcnVtYicsIGJyZWFkY3J1bWIpXG5cbmJyZWFkY3J1bWIub25DbGljayhmdW5jdGlvbiAoZGlyZWN0b3J5SWQpIHtcbiAgICB0cmFkZS5nZXREaXJlY3RvcnkoZGlyZWN0b3J5SWQsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAhPT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAvLyBUT0RPIGNhbGwgdGhlXG4gICAgICAgICAgICB1aUV2ZW50cy5jYWxsVWlldmVudCgnc2hvd092ZXJ2aWV3UGFnZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2JyZWFkY3J1bWJDb250cm9sbGVyOmdldERpcmVjdG9yeSBjYW4gbm90IGxvYWQgcHJvamVjdCBmb3IgZGlyZWN0b3J5IG5hbWU6JywgZGlyZWN0b3J5SWQpO1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc2V0UGF0aCA6ICh1cmwpID0+IHtcbiAgICAgICAgbGV0IHBhdGggPSAnLydcbiAgICAgICAgaWYgKHVybCA9PT0gJy8nKVxuICAgICAgICAgICAgcmV0dXJuIGJyZWFkY3J1bWIudXBkYXRlRm9sZGVycyhbeyBpZDogJy8nICwgbmFtZTogJycgfV0pXG4gICAgICAgIFxuICAgICAgICBicmVhZGNydW1iLnVwZGF0ZUZvbGRlcnModXJsLnNwbGl0KCcvJykubWFwKGZvbGRlciA9PiB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXSAhPT0gJy8nID8gcGF0aCArICcvJyArIGZvbGRlciA6IHBhdGggKyBmb2xkZXJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpZDogcGF0aCAsIG5hbWU6IGZvbGRlclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKSlcbiAgICB9LFxuICAgIGdldERpcmVjdG9yeTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2JyZWFkY3J1bWJDb250cm9sbGVyOnBhcmVudERpcmVjdG9yaWVzJywgZGF0YS5wYXJlbnREaXJlY3Rvcmllcyk7XG4gICAgICAgIGJyZWFkY3J1bWIudXBkYXRlRm9sZGVycyhkYXRhLnBhcmVudERpcmVjdG9yaWVzKTtcbiAgICB9XG59O1xuIiwidmFyIGNyZWF0ZU5ld1Byb2plY3QgPSByZXF1aXJlKCdjYW5ueScpLmNyZWF0ZU5ld1Byb2plY3QsXG4gICAgZGlzcGxheU1hbmFnZXIgPSByZXF1aXJlKCdjYW5ueScpLmRpc3BsYXlNYW5hZ2VyLFxuICAgIHRyYWRlID0gcmVxdWlyZSgnLi4vdHJhZGUnKTtcblxudmFyIGN1cnJlbnREaXJlY3Rvcnk7XG5cbmNyZWF0ZU5ld1Byb2plY3Qub25DcmVhdGVOZXdQcm9qZWN0KGZ1bmN0aW9uKHByb2plY3ROYW1lKSB7XG4gICAgdHJhZGUuY3JlYXRlTmV3UHJvamVjdChwcm9qZWN0TmFtZSwgY3VycmVudERpcmVjdG9yeSk7XG4gICAgZGlzcGxheU1hbmFnZXIuaGlkZSgnY3JlYXRlTmV3UHJvamVjdFZpZXcnKTtcbn0pO1xuXG5jcmVhdGVOZXdQcm9qZWN0Lm9uQ3JlYXRlTmV3RGlyZWN0b3koZnVuY3Rpb24oZGlyZWN0b3J5TmFtZSkge1xuICAgIHRyYWRlLmNyZWF0ZU5ld0RpcmVjdG9yeShkaXJlY3RvcnlOYW1lLCBjdXJyZW50RGlyZWN0b3J5KTtcbiAgICBkaXNwbGF5TWFuYWdlci5oaWRlKCdjcmVhdGVOZXdEaXJlY3RvcnlWaWV3Jyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLy8gVE9ETyBpbnRyb2R1Y2UgbmV3IGV2ZW50OiBvbkRpcmVjdG9yeUNoYW5nZWQgLSBiZWNhdXNlIGEgXCJnZXREaXJlY3RvcnlcIiBldmVudCBkb2VzIG5vdCByZWFsbHkgZXhwbGFpbiB3aGF0J3NcbiAgICAvLyBoYXBwZW5pbmcgaGVyZVxuICAgIGdldERpcmVjdG9yeSA6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgY3VycmVudERpcmVjdG9yeSA9IGRhdGEuY3VycmVudERpcmVjdG9yeTtcbiAgICB9XG59O1xuIiwidmFyIGFuY2hvck1lbnUgPSByZXF1aXJlKCdjYW5ueScpLmFuY2hvck1lbnUsXG4gICAgdHJhbnNsYXRpb25WaWV3Q29uZmlnID0gcmVxdWlyZSgnLi4vdWlNb2R1bGVzL3RyYW5zbGF0aW9uVmlldycpLmNvbmZpZyxcbiAgICB1aUV2ZW50cyA9IHJlcXVpcmUoJy4uL3VpRXZlbnRNYW5hZ2VyJyk7XG5cbi8qKlxuICogTmljZSBhcHByb2FjaCBidXQgdGhlIG9yZGVyIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBET00uXG4gKiBUT0RPIEl0IHdvdWxkIGJlIGJldHRlciB0byByZWFkIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBET01cbiAqICAxLiBpdCdzIGVhc2llciB0byByZWluaXRpYWxpemUgaWYgYSBrZXkgaXMgcmVuYW1lZCBvciBjcmVhdGVkIG5ldyAoWSlcbiAqICAyLiB0aGUgb3JkZXIgd2lsbCBiZSBzYW1lIGFzIGluIHRoZSBET00gKFkpXG4gKiAgY29uOiB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgdGhlIERPTSBpcyByZW5kZXJlZCAtIG90aGVyd2lzZSBlbGVtZW50cyB3aWxsIGJlIG1pc3NpbmdcbiAqXG4gKiAgV2UgbmVlZDpcbiAqICAqIERPTSByZW5kZXIgc3VjY2VzcyBldmVudCAodGhlIHRyYW5zbGF0aW9uVmlldyBjb250cm9sbGVyIGhhcyB0byB0aHJvdyBpdCkgKHNvIGZhciB0aGUgY29udHJvbGxlciBpcyBhZGRlZCBhZnRlciB0aGUgdHJhbnNsYXRpb25Db250cm9sbGVyIGl0IGxvb2tzIGxpa2UgdGhhdCB0aGlzIGlzIG5vdCBhbiBpc3N1ZSlcbiAqICAqIGFuIGEgaWYgYW5jaG9yIGlzIGNsaWNrZWQgKGluIHZpZXcpIGV2ZW50IDsgdGhlbiBhbHNvIGZvY3VzIHRoZSBjb3JyZWN0IG1lbnUgcmlnaHQgZWxlbWVudFxuICogICogdGhlIHJpZ2h0IG1lbnUgZWxlbWVudCBpbnRlcmFjdCBvbmx5IGFzIHNjcm9sbCBvdmVydmlldyAtIG5vdCBhcyBhbmNob3IgaGVscGVyIGFzIGl0IGlzIHJpZ2h0IG5vd1xuICpcbiAqIEBwYXJhbSBrZXlzXG4gKi9cblxuYW5jaG9yTWVudS5vblNlbGVjdChmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZG9tID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodHJhbnNsYXRpb25WaWV3Q29uZmlnLnJvd1ByZWZpeCArIGlkKTtcbiAgICBpZiAoZG9tKSB7XG4gICAgICAgIHZhciBib2R5UmVjdCA9IGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICBlbGVtUmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIG9mZnNldCA9IGVsZW1SZWN0LnRvcCAtIGJvZHlSZWN0LnRvcDtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIG9mZnNldCAtIDYwKTtcbiAgICAgICAgdWlFdmVudHMuY2FsbFVpZXZlbnQoJ2FuY2hvckZvY3VzJywgJyMnICsgaWQpO1xuICAgIH1cbn0pO1xuXG51aUV2ZW50cy5hZGRVaUV2ZW50TGlzdGVuZXIoe1xuICAgIGFuY2hvckZvY3VzIDogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGFuY2hvck1lbnUuZm9jdXNFbGVtZW50KGlkLnJlcGxhY2UoJyMnLCAnJykpO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICByZW5hbWVDYXRlZ29yeSA6IGZ1bmN0aW9uIChvbGROYW1lLCBuZXdOYW1lKSB7XG4gICAgICAgIGFuY2hvck1lbnUucmVuZGVyTWVudSgpO1xuICAgIH0sXG4gICAgcmVtb3ZlQ2F0ZWdvcnk6IGZ1bmN0aW9uKGNhdGVnb3J5TmFtZSkge1xuICAgICAgICBhbmNob3JNZW51LnJlbmRlck1lbnUoKTtcbiAgICB9LFxuICAgIHJlbmFtZUtleSA6IGZ1bmN0aW9uIChvbGRLZXksIG5ld0tleSkge1xuICAgICAgICBhbmNob3JNZW51LnJlbmRlck1lbnUoKTtcbiAgICB9LFxuICAgIHJlbW92ZUtleSA6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgYW5jaG9yTWVudS5yZW5kZXJNZW51KCk7XG4gICAgfSxcbiAgICBvbkNyZWF0ZUtleSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYW5jaG9yTWVudS5yZW5kZXJNZW51KCk7XG4gICAgfSxcbiAgICBvbktleUNsb25lZCA6IGZ1bmN0aW9uKHByb2plY3RJZCwgZGF0YSkge1xuICAgICAgICBhbmNob3JNZW51LnJlbmRlck1lbnUoKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGNvbXBsZXRlIEpTT04gb2JqZWN0IGZyb20gYSBzcGVjaWZpYyBwcm9qZWN0XG4gICAgICogQHBhcmFtIHByb2plY3REYXRhXG4gICAgICovXG4gICAgb25Mb2FkUHJvamVjdCA6IGZ1bmN0aW9uIChwcm9qZWN0RGF0YSkge1xuICAgICAgICBhbmNob3JNZW51LnJlbmRlck1lbnUoKTtcbiAgICB9LFxuICAgIG9uTmV3UHJvamVjdENyZWF0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBhbmNob3JNZW51LnJlbmRlck1lbnUoKTtcbiAgICB9XG59OyIsImNvbnN0IHdoaXNrZXIgPSByZXF1aXJlKCdjYW5ueS9tb2Qvd2hpc2tlcicpXG5jb25zdCBjYW5ueSA9IHJlcXVpcmUoJ2Nhbm55JylcbmNvbnN0IGRpc3BsYXlNYW5hZ2VyID0gY2FubnkuZGlzcGxheU1hbmFnZXJcbmNvbnN0IHRyYWRlID0gcmVxdWlyZSgnLi4vdHJhZGUnKVxuY29uc3QgRVJST1JTID0gcmVxdWlyZSgnLi4vLi4vLi4vRVJST1JTJylcblxuY29uc3QgaW5wdXROb2RlcyA9IHtcbiAgICBuYW1lIDogdW5kZWZpbmVkLFxuICAgIHVybCA6IHVuZGVmaW5lZCxcbn1cbi8vIHdoaXNrZXIgY2FsbGJhY2sgZm9yIHJlbmRlcmluZyB0aGUgdWkgbW9kdWxlXG5sZXQgcmVuZGVyVWlcbi8vIHNhdmUgdGhlIGFjdHVhbCBsb2FkZWQgcHJvamVjdCBjb25maWcgLSBuZWVkZWQgZm9yIGNvbXBhcmlzaW9uXG5sZXQgcHJvamVjdFxuXG5mdW5jdGlvbiBub1JldHVybihub2RlKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGUua2V5Q29kZSB8fCBlLndoaWNoXG4gICAgICAgIGlmIChrZXkgPT09IDEzKSBlLnJldHVyblZhbHVlID0gZmFsc2VcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9KVxuICAgIHJldHVybiBub2RlXG59XG5cbmZ1bmN0aW9uIG5vU3BhY2VzKG5vZGUpIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZS5rZXlDb2RlIHx8IGUud2hpY2hcbiAgICAgICAgaWYgKGtleSA9PT0gMzIpIGUucmV0dXJuVmFsdWUgPSBmYWxzZVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pXG4gICAgcmV0dXJuIG5vZGVcbn1cblxuZnVuY3Rpb24gdHJpbVNsYXNoZXModXJsKSB7XG4gICAgXG4gICAgd2hpbGUoL1xcL1xcLy8udGVzdCh1cmwpKVxuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgnLy8nLCAnLycpXG4gICBcbiAgICAvLyByZW1vdmUgbGFzdCBzbGFzaCBpZiB0aGVyZSBpcyBvbmVcbiAgICBpZiAodXJsLmxlbmd0aCA+IDEgJiYgdXJsW3VybC5sZW5ndGggLSAxXSA9PT0gJy8nKVxuICAgICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgLTEpXG4gICAgXG4gICByZXR1cm4gdXJsXG59XG5cbmZ1bmN0aW9uIHJlbW92ZVNwYWNlcyhzKSB7XG4gICAgd2hpbGUoLyAvLnRlc3QocykpXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoJyAnLCAnXycpXG4gICAgcmV0dXJuIHNcbn1cblxuZnVuY3Rpb24gc3VibWl0KCkge1xuICAgIHRyYWRlLm1vdmVQcm9qZWN0KHtcbiAgICAgICAgaWQgOiBwcm9qZWN0LmlkLFxuICAgICAgICB1cmwgOiByZW1vdmVTcGFjZXModHJpbVNsYXNoZXMoaW5wdXROb2Rlcy51cmwudmFsdWUgfHwgdWkudXJsKSksXG4gICAgICAgIG5hbWUgOiBpbnB1dE5vZGVzLm5hbWUudmFsdWUgfHwgdWkubmFtZVxuICAgIH0sIChlcnIsIHtpZCwgbmFtZSwgdXJsfSkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBkaXNwbGF5TWFuYWdlci5oaWRlKCdtb3ZlUHJvamVjdCcpXG4gICAgICAgICAgICBpZiAoRVJST1JTW2Vyci5lcnJvcl0pIHtcbiAgICAgICAgICAgICAgICB0b2FzdC5zaG93TWVzc2FnZShgQ2hhbmdpbmcgJHtpbnB1dE5vZGVzLm5hbWUudmFsdWV9IGZhaWxlZDogJHtlcnIubWVzc2FnZX1gKVxuICAgICAgICAgICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKGVyci5lcnJvcilcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9hc3Quc2hvd01lc3NhZ2UoYEZhaWx1cmUgJHtpbnB1dE5vZGVzLm5hbWUudmFsdWV9IGZhaWxlZDogJHtlcnIubWVzc2FnZX1gKVxuICAgICAgICAgICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKGBFUlJPUiBVTktOT1dOYClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlzcGxheU1hbmFnZXIuaGlkZSgnbW92ZVByb2plY3QnKVxuICAgICAgICAgICAgLy8gc2hvdy9yZWxvYWQgYWN0dWFsIGRpcmVjdG9yeVxuICAgICAgICAgICAgdHJhZGUuZ2V0RGlyZWN0b3J5KHVybClcbiAgICAgICAgICAgIGlmIChwcm9qZWN0LnVybCAhPT0gdXJsKVxuICAgICAgICAgICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKGBDaGFuZ2UgcHJvamVjdCBsb2NhdGlvbiBzdWNjZXNzZnVsbHkgdG8gJHt1cmx9YClcbiAgICAgICAgICAgIGlmIChwcm9qZWN0Lm5hbWUgIT09IG5hbWUpXG4gICAgICAgICAgICAgICAgdG9hc3Quc2hvd01lc3NhZ2UoYFJlbmFtZSBwcm9qZWN0IHN1Y2Nlc3NmdWxseSB0byAke25hbWV9YClcbiAgICAgICAgfVxuICAgIH0pXG59XG5cbmNvbnN0IHVpID0ge1xuICAgIGlucHV0TmFtZSA6IG4gPT4gaW5wdXROb2Rlcy5uYW1lID0gbm9SZXR1cm4obiksXG4gICAgaW5wdXRVcmwgOiBuID0+IGlucHV0Tm9kZXMudXJsID0gbm9SZXR1cm4obm9TcGFjZXMobikpLFxuICAgIHN1Ym1pdCA6IG4gPT4gbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHN1Ym1pdCgpKSxcbiAgICBjYW5jZWwgOiBuID0+IG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiBkaXNwbGF5TWFuYWdlci5oaWRlKCdtb3ZlUHJvamVjdCcpKSxcbiAgICBuYW1lIDogJycsXG4gICAgdXJsIDogJycsXG4gICAgaWQ6ICcnLFxuICAgIHByb2plY3RMaW5rOiAnJ1xufVxuXG5jYW5ueS5hZGQoJ21vdmVQcm9qZWN0Jywge1xuICAgIGFkZCA6IChub2RlID0+IHtcbiAgICAgICAgd2hpc2tlci5hZGQobm9kZSwgZmMgPT4ge1xuICAgICAgICAgICAgcmVuZGVyVWkgPSBmY1xuICAgICAgICAgICAgcmVuZGVyVWkodWkpXG4gICAgICAgIH0pXG4gICAgfSlcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHNob3cgOiAoe2lkLCB1cmwsIG5hbWV9KSA9PiB7XG4gICAgICAgIFxuICAgICAgICBwcm9qZWN0ID0ge2lkLCB1cmwsIG5hbWV9XG4gICAgICAgIFxuICAgICAgICByZW5kZXJVaSh7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBwcm9qZWN0TGluayA6IGAvJHtpZH0ucHJqYFxuICAgICAgICB9KVxuICAgICAgICBkaXNwbGF5TWFuYWdlci5zaG93KCdtb3ZlUHJvamVjdCcpXG4gICAgfVxufSIsInZhciBjYW5ueSA9IHJlcXVpcmUoJ2Nhbm55Jyk7XG5cbi8qKlxuICoganVzdCB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIGNhbGxiYWNrc1xuICovXG5cbi8qKlxuICogQXBwbHkgcHJvamVjdCBkZXNjcmlwdGlvbiBkYXRhIHRvIGRvbSBlbGVtZW50c1xuICogQHBhcmFtIGRhdGE6IFByb2plY3QgY29uZmlndXJhdGlvbiBkYXRhXG4gKi9cbmZ1bmN0aW9uIGFwcGx5UHJvamVjdERhdGEoZGF0YSwgcHJvamVjdCkge1xuICAgIGlmIChwcm9qZWN0Lmhhc093blByb3BlcnR5KCduYW1lJykpIHtcbiAgICAgICAgLy8gcHJvamVjdCBzcGVjaWZpYyBjb25maWdcbiAgICAgICAgY2FubnkudGV4dHMuc2V0VGV4dHMoe3Byb2plY3ROYW1lIDogcHJvamVjdC5uYW1lfSlcbiAgICB9XG5cbiAgICAvLyBGSVhNRTogQ2F0ZWdvcmllcyBzaG91bGQgbm90IGJlIG5hbWVkIFwiX19kZXNjcmlwdGlvblwiIGFzIHRoZXkgd291bGQgb3ZlcnJpZGUgdGhlIHByb2plY3QgZGVzY3JpcHRpb25cbiAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eSgna2V5RGVzY3JpcHRpb25zJykpIHtcbiAgICAgICAgLy8gcHJvamVjdCBzcGVjaWZpYyBjb25maWcgLSBpZiBwcm9wZXJ0eSBpcyBwcmVzZW50XG4gICAgICAgIGNhbm55LnRleHRzLnNldFRleHRzKHtcbiAgICAgICAgICAgIHByb2plY3REZXNjcmlwdGlvbiA6IChkYXRhLmtleURlc2NyaXB0aW9uc1snX19kZXNjcmlwdGlvbiddID8gZGF0YS5rZXlEZXNjcmlwdGlvbnNbJ19fZGVzY3JpcHRpb24nXSA6ICcnKVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG9uTmV3UHJvamVjdENyZWF0ZWQgOiBhcHBseVByb2plY3REYXRhLFxuICAgIG9uTG9hZFByb2plY3QgOiBhcHBseVByb2plY3REYXRhLFxuICAgIG9uTmV3RGlyZWN0b3J5Q3JlYXRlZCA6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgY2FubnkudGV4dHMuc2V0VGV4dHMoe1xuICAgICAgICAgICAgcHJvamVjdE5hbWUgOiBkYXRhLmRpcmVjdG9yeUlkXG4gICAgICAgIH0pO1xuICAgIH1cbn07IiwidmFyIGNhbm55ID0gcmVxdWlyZSgnY2FubnknKSxcbiAgICBkb21PcHRzID0gcmVxdWlyZSgnZG9tLW9wdHMnKSxcbiAgICB0cmFkZSA9IHJlcXVpcmUoJy4uL3RyYWRlLmpzJyksXG4gICAgZXZlbnRzID0gcmVxdWlyZSgnLi4vZXZlbnRzLmpzJyksXG4gICAgdWlFdmVudHMgPSByZXF1aXJlKCcuLi91aUV2ZW50TWFuYWdlci5qcycpLFxuICAgIGtleVZhbHVlQ291bnRlciA9IHtcbiAgICAgICAgcHJvamVjdE1hcCA6IHt9LFxuICAgICAgICBnZXRDb3VudE9iaiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2V5TWFwIDoge30sIC8vIGp1c3QgY29sbGVjdCBhbGwgdW5pcXVlIGtleXMgZm9yIGdldHRpbmcgdG90YWwgbnVtYmVyIG9mIGV4aXN0aW5nIGtleXNcbiAgICAgICAgICAgICAgICBsYW5nTWFwIDoge30gICAvLyBzYXZlIGZvciBlYWNoIGxhbmd1YWdlIGFsbCBcInZhbGlkXCIga2V5c1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBwcm9qZWN0Q29uZmlnID0ge30sXG4gICAgcHJvamVjdEluZm8gPSB7fSxcbiAgICBhdmFpbGFibGVMYW5ndWFnZXMgPSBbXTtcblxuY2FubnkucHJvamVjdE1haW5OYXZpZ2F0aW9uLm9uTGFuZ3VhZ2VTZWxlY3QoZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBldmVudE5hbWU7XG4gICAgaWYgKG9iai5pc0FjdGl2ZSkge1xuICAgICAgICAgZXZlbnROYW1lID0gb2JqLmlzSW5hY3RpdmUgPyAnZGVBY3RpdmF0ZUxhbmd1YWdlJyA6ICdhY3RpdmF0ZUxhbmd1YWdlJztcbiAgICAgICAgIHVpRXZlbnRzLmNhbGxVaWV2ZW50KGV2ZW50TmFtZSwgb2JqLmxhbmd1YWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAgdWlFdmVudHMuY2FsbFVpZXZlbnQoJ2FkZExhbmd1YWdlJywgb2JqLmxhbmd1YWdlKTtcbiAgICB9XG59KTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWRpdG9yTW9kZUVuYWJsZWQgPSBmYWxzZTtcblxuICAgIGNhbm55LnByb2plY3RNYWluTmF2aWdhdGlvbi5vbkVuYWJsZUVkaXRvck1vZGUoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlLmxvZygncHJvamVjdE1haW5OYXZpZ2F0aW9uQ29udHJvbGxlcjpvbkVuYWJsZUVkaXRvck1vZGUgc2hvdyBKU09OIGZvcm1hdCBpbiBuZXcgdGFiLicpO1xuICAgICAgICB1aUV2ZW50cy5jYWxsVWlldmVudCgnZW5hYmxlRWRpdG9yTW9kZScsICFlZGl0b3JNb2RlRW5hYmxlZCk7XG4gICAgfSk7XG4gICAgLy9tYXliZSBzb21lb25lIGVsc2UgY2FsbHMgdGhpcyB0b29cbiAgICB1aUV2ZW50cy5hZGRVaUV2ZW50TGlzdGVuZXIoe1xuICAgICAgICBlbmFibGVFZGl0b3JNb2RlIDogZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICAgICAgICAgIGVkaXRvck1vZGVFbmFibGVkID0gZW5hYmxlZDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG59KCkpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgdmFyIHdvcmRDb3VudEVuYWJsZWQgPSBmYWxzZTtcblxuICAgIGNhbm55LnByb2plY3RNYWluTmF2aWdhdGlvbi5vblRvZ2dsZVdvcmRDb3VudChmdW5jdGlvbigpIHtcbiAgICAgICAgd29yZENvdW50RW5hYmxlZCA9ICF3b3JkQ291bnRFbmFibGVkO1xuICAgICAgICB1aUV2ZW50cy5jYWxsVWlldmVudCgndG9nZ2xlV29yZENvdW50Jywgd29yZENvdW50RW5hYmxlZCk7XG4gICAgfSk7XG59KCkpO1xuXG5jYW5ueS5wcm9qZWN0TWFpbk5hdmlnYXRpb24ub25TaG93SlNPTihmdW5jdGlvbiAoKSB7XG4gICAgY29uc29sZS5sb2coJ3Byb2plY3RNYWluTmF2aWdhdGlvbkNvbnRyb2xsZXI6b25TaG93SlNPTiBzaG93IEpTT04gZm9ybWF0IGluIG5ldyB0YWIuJyk7XG4gICAgd2luZG93Lm9wZW4oXG4gICAgICAgICcvJyArIHByb2plY3RJbmZvLmlkICsgJy5qc29uP2NhdGVnb3J5PXRydWUnLFxuICAgICAgICAnX2JsYW5rJyAvLyA8LSBUaGlzIGlzIHdoYXQgbWFrZXMgaXQgb3BlbiBpbiBhIG5ldyB3aW5kb3cuXG4gICAgKTtcbn0pO1xuXG5jYW5ueS5wcm9qZWN0TWFpbk5hdmlnYXRpb24ub25TaG93Sk1CRlVwbG9hZGVyKGZ1bmN0aW9uICgpIHtcbiAgICBjb25zb2xlLmxvZygncHJvamVjdE1haW5OYXZpZ2F0aW9uQ29udHJvbGxlcjpvblNob3dKTUJGVXBsb2FkZXIgc2hvdyBtZXNzYWdlIGJ1bmRsZSB1cGxvYWRlcicpO1xuICAgIHVpRXZlbnRzLmNhbGxVaWV2ZW50KCdzaG93Sk1CRlVwbG9hZGVyJylcbn0pO1xuXG5jYW5ueS5wcm9qZWN0TWFpbk5hdmlnYXRpb24ub25TaG93SlNPTkltcG9ydChmdW5jdGlvbiAoKSB7XG4gICAgY29uc29sZS5sb2coJ3Byb2plY3RNYWluTmF2aWdhdGlvbkNvbnRyb2xsZXI6b25TaG93SlNPTkltcG9ydCBzaG93IEpTT04gaW1wb3J0IG92ZXJsYXknKTtcbiAgICB1aUV2ZW50cy5jYWxsVWlldmVudCgnc2hvd0pTT05JbXBvcnQnKTtcbn0pO1xuXG5jYW5ueS5wcm9qZWN0TWFpbk5hdmlnYXRpb24ub25TaG93Sk1CRihmdW5jdGlvbiAoKSB7XG4gICAgY29uc29sZS5sb2coJ3Byb2plY3RNYWluTmF2aWdhdGlvbkNvbnRyb2xsZXI6b25TaG93Sk1CRiBzaG93IEpNQkYgZm9ybWF0IGluIG5ldyB0YWIuJyk7XG5cbiAgICB2YXIgbGFuZyA9IHdpbmRvdy5wcm9tcHQoJ0VudGVyIGEgbGFuZ3VhZ2UgY29kZS4gRS5nLjogJyArICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nTGFuZ3VhZ2VzID0gW107XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwcm9qZWN0Q29uZmlnLmtleXMpLmZvckVhY2goZnVuY3Rpb24gKGxhbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMocHJvamVjdENvbmZpZy5rZXlzW2xhbmddKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nTGFuZ3VhZ2VzLnB1c2gobGFuZylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0xhbmd1YWdlcztcbiAgICAgICAgfSgpKS5qb2luKCcsICcpKTtcblxuICAgIGlmIChsYW5nICE9PSBudWxsKSB7XG4gICAgICAgIHdpbmRvdy5vcGVuKFxuICAgICAgICAgICAgJy8nICsgcHJvamVjdEluZm8uaWQgKyAnLnByb3BlcnRpZXMnICsgKGxhbmcgIT09ICcnID8gJz9sYW5nPScgKyBsYW5nIDogJycpLFxuICAgICAgICAgICAgJ19ibGFuaycgLy8gPC0gVGhpcyBpcyB3aGF0IG1ha2VzIGl0IG9wZW4gaW4gYSBuZXcgd2luZG93LlxuICAgICAgICApO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIHNlcnZlciBldmVudCBsaXN0ZW5lclxuICovXG5ldmVudHMuYWRkU2VydmVyTGlzdGVuZXIoJ25ld1Byb2plY3RXYXNDcmVhdGVkJywgZnVuY3Rpb24gKHByb2plY3ROYW1lKSB7XG4gICAgdG9hc3Quc2hvd01lc3NhZ2UoJ0EgbmV3IHByb2plY3Qgd2l0aCBuYW1lOiBcIicgKyBwcm9qZWN0TmFtZSArICdcIiB3YXMgY3JlYXRlZC4nKTtcbn0pO1xuLyoqXG4gKiBzZXJ2ZXIgZXZlbnQgbGlzdGVuZXJcbiAqL1xuZXZlbnRzLmFkZFNlcnZlckxpc3RlbmVyKCdrZXlVcGRhdGVkJywgZnVuY3Rpb24gKHByb2plY3RJZCwgbGFuZ3VhZ2UsIGtleU5hbWUsIGtleVZhbHVlKSB7XG4gICAgLy8gVE9ETyBtb3JlIGNsaWVudCBjaGFuZ2VzIGFyZSBjb21pbmcsIHdlJ2xsIGZpbmlzaCB0aGUgY29kZSBiZWxvdyB0aGVuXG4gICAgLy9pZiAocHJvamVjdElkID09PSBjdXJyZW50UHJvamVjdElkKSB7XG4gICAgLy8gICAgdmFyIHByb2plY3ROYW1lID0gcHJvamVjdElkLnN1YnN0cmluZyhwcm9qZWN0SWQubGFzdEluZGV4T2YoJy8nKSArIDEpO1xuICAgIC8vICAgIHVwZGF0ZUtleVRvUHJvamVjdE1hcChwcm9qZWN0TmFtZSwgbGFuZ3VhZ2UsIGtleU5hbWUsIGtleVZhbHVlKTtcbiAgICAvLyAgICBjb25zb2xlLmxvZygncHJvamVjdE1haW5OYXZpZ2F0aW9uQ29udHJvbGxlcjp1cGRhdGVLZXknLCBwcm9qZWN0SWQsIGxhbmd1YWdlLCBrZXlOYW1lLCBrZXlWYWx1ZSk7XG4gICAgLy99XG59KTtcbi8qKlxuICogc2VydmVyIGV2ZW50IGxpc3RlbmVyXG4gKi9cbmV2ZW50cy5hZGRTZXJ2ZXJMaXN0ZW5lcigna2V5RGVsZXRlZCcsIGZ1bmN0aW9uIChidW5kbGVOYW1lLCBvYmopIHtcbiAgICAvLyBUT0RPIG1vcmUgY2xpZW50IGNoYW5nZXMgYXJlIGNvbWluZywgd2UnbGwgZmluaXNoIHRoZSBjb2RlIGJlbG93IHRoZW5cbiAgICAvL2lmIChidW5kbGVOYW1lID09PSBwcm9qZWN0Q29uZmlnLnByb2plY3QpIHtcbiAgICAvLyAgICBjb25zb2xlLmxvZygncHJvamVjdE1haW5OYXZpZ2F0aW9uQ29udHJvbGxlcjprZXlSZW5hbWVkJywgYnVuZGxlTmFtZSwgb2JqKTtcbiAgICAvLyAgICAvLyBUT0RPIHVwZGF0ZSB0aGUgc3RhdGlzdGljcy4uLlxuICAgIC8vfVxufSk7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBwcm9qZWN0TmFtZVxuICogQHBhcmFtIGxhbmdcbiAqIEBwYXJhbSBrZXlcbiAqIEBwYXJhbSB2YWx1ZVxuICovXG5mdW5jdGlvbiBzYXZlS2V5VG9Qcm9qZWN0TWFwKHByb2plY3ROYW1lLCBsYW5nLCBrZXksIHZhbHVlKSB7XG5cbiAgICAvLyBqdXN0IGNvbGxlY3QgYWxsIGtleXMgKG9ubHkgdGhlIHVuaXF1ZSBrZXlzIGFyZSByZWxldmFudClcbiAgICBpZiAoa2V5VmFsdWVDb3VudGVyLnByb2plY3RNYXBbcHJvamVjdE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3Byb2plY3RNYWluTmF2aWdhdGlvbkNvbnRyb2xsZXI6c2F2ZUtleVRvUHJvamVjdE1hcCBwcm9qZWN0IG5hbWUgbm90IGV4aXN0czonLCBwcm9qZWN0TmFtZSk7XG4gICAgICAgIGtleVZhbHVlQ291bnRlci5wcm9qZWN0TWFwW3Byb2plY3ROYW1lXSA9IGtleVZhbHVlQ291bnRlci5nZXRDb3VudE9iaigpO1xuICAgIH1cblxuICAgIGtleVZhbHVlQ291bnRlci5wcm9qZWN0TWFwW3Byb2plY3ROYW1lXS5rZXlNYXBba2V5XSA9IHRydWU7XG4gICAgaWYgKGtleVZhbHVlQ291bnRlci5wcm9qZWN0TWFwW3Byb2plY3ROYW1lXS5sYW5nTWFwW2xhbmddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2V5VmFsdWVDb3VudGVyLnByb2plY3RNYXBbcHJvamVjdE5hbWVdLmxhbmdNYXBbbGFuZ10gPSB7fTtcbiAgICB9XG4gICAgLy8gb25seSBzYXZlIHRoZSBrZXlzIGFzIG9iamVjdCBpZiBpdCBpcyBhIHZhbGlkIGtleSBvdGhlcndpc2UgZGVsZXRlIGl0XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGtleVZhbHVlQ291bnRlci5wcm9qZWN0TWFwW3Byb2plY3ROYW1lXS5sYW5nTWFwW2xhbmddW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoa2V5VmFsdWVDb3VudGVyLnByb2plY3RNYXBbcHJvamVjdE5hbWVdLmxhbmdNYXBbbGFuZ11ba2V5XSkge1xuICAgICAgICAvLyBpZiB0aGlzIGtleSBleGlzdHMgdGhhbiByZW1vdmUgaXRcbiAgICAgICAgZGVsZXRlIGtleVZhbHVlQ291bnRlci5wcm9qZWN0TWFwW3Byb2plY3ROYW1lXS5sYW5nTWFwW2xhbmddW2tleV07XG4gICAgfVxufVxuXG4vLyBUT0RPIHNob3VsZCB1c2UgcHJvamVjdElkLCBub3QgcHJvamVjdE5hbWVcbmZ1bmN0aW9uIHVwZGF0ZUtleVRvUHJvamVjdE1hcChwcm9qZWN0TmFtZSwgbGFuZywga2V5LCB2YWx1ZSkge1xuICAgIHNhdmVLZXlUb1Byb2plY3RNYXAocHJvamVjdE5hbWUsIGxhbmcsIGtleSwgdmFsdWUpO1xuICAgIGNhbm55LnByb2plY3RNYWluTmF2aWdhdGlvbi5zZXROdW1iZXJPZlRyYW5zbGF0ZWRMYW5ndWFnZUtleShPYmplY3Qua2V5cyhrZXlWYWx1ZUNvdW50ZXIucHJvamVjdE1hcFtwcm9qZWN0TmFtZV0ubGFuZ01hcFtsYW5nXSkubGVuZ3RoLCBsYW5nKTtcbiAgICBjYW5ueS5wcm9qZWN0TWFpbk5hdmlnYXRpb24uc2V0TnVtYmVyT2ZUcmFuc2xhdGlvbk1heEtleXMoT2JqZWN0LmtleXMoa2V5VmFsdWVDb3VudGVyLnByb2plY3RNYXBbcHJvamVjdE5hbWVdLmtleU1hcCkubGVuZ3RoKTtcbn1cblxuLy8gcmVnaXN0ZXIgbGlzdGVuZXIgZnVuY3Rpb24gdG8gdGhlIHVpIGV2ZW50c1xudWlFdmVudHMuYWRkVWlFdmVudExpc3RlbmVyKHtcbiAgICAvKipcbiAgICAgKiB0aGUgaW50ZXJuYWwgdXBkYXRlS2V5IGV2ZW50IC0gdGhlIHNlcnZlciB3aWxsIG5vdCB0cmlnZ2VyIHRoZSB1cGRhdGVLZXkgZm9yIHRoZSBvd24gY2xpZW50XG4gICAgICovXG4gICAgdXBkYXRlS2V5IDogZnVuY3Rpb24gKHByb2plY3ROYW1lLCBsYW5nLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdwcm9qZWN0TWFpbk5hdmlnYXRpb25Db250cm9sbGVyOnVwZGF0ZUtleScsIHByb2plY3ROYW1lLCBsYW5nLCBrZXksIHZhbHVlKTtcbiAgICAgICAgdXBkYXRlS2V5VG9Qcm9qZWN0TWFwKHByb2plY3ROYW1lLCBsYW5nLCBrZXksIHZhbHVlKTtcbiAgICB9LFxuICAgIHByb2plY3RTZWxlY3RlZCA6IGZ1bmN0aW9uIChwcm9qZWN0SWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3Byb2plY3RNYWluTmF2aWdhdGlvbkNvbnRyb2xsZXI6cHJvamVjdFNlbGVjdGVkIENsaWNrIG9uIHByb2plY3QnLCBwcm9qZWN0SWQpO1xuICAgICAgICB0cmFkZS5sb2FkUHJvamVjdChwcm9qZWN0SWQsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdwcm9qZWN0TWFpbk5hdmlnYXRpb25Db250cm9sbGVyOmxvYWRQcm9qZWN0IGZhaWxzIGZvciBwcm9qZWN0SWQ6JywgcHJvamVjdElkKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBhY3RpdmF0ZUxhbmd1YWdlIDogZnVuY3Rpb24gKGxhbmcpIHtcbiAgICAgICAgY2FubnkucHJvamVjdE1haW5OYXZpZ2F0aW9uLmFjdGl2YXRlTGFuZyhsYW5nKTtcbiAgICB9LFxuICAgIGRlQWN0aXZhdGVMYW5ndWFnZSA6IGZ1bmN0aW9uIChsYW5nKSB7XG4gICAgICAgIGNhbm55LnByb2plY3RNYWluTmF2aWdhdGlvbi5kZUFjdGl2YXRlTGFuZyhsYW5nKTtcbiAgICB9LFxuICAgIGFkZExhbmd1YWdlIDogZnVuY3Rpb24gKGxhbmcpIHtcbiAgICAgICAgY2FubnkucHJvamVjdE1haW5OYXZpZ2F0aW9uLmFjdGl2YXRlTGFuZyhsYW5nKTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gY29tcHV0ZVRvdGFsVHJhbnNsYXRpb25Qcm9ncmVlKHRyYW5zbGF0aW9ucykge1xuICAgIHZhciB0b3RhbFByb2dyZXNzID0ge307XG4gICAgT2JqZWN0LmtleXModHJhbnNsYXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKGxhbmcpIHtcbiAgICAgICAgT2JqZWN0LmtleXModHJhbnNsYXRpb25zW2xhbmddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHRvdGFsUHJvZ3Jlc3Nba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRvdGFsUHJvZ3Jlc3MpLmxlbmd0aDtcblxufVxuXG5mdW5jdGlvbiBjb21wdXRlVHJhbnNsYXRpb25Qcm9ncmVzcyh0cmFuc2xhdGlvbnMpIHtcbiAgICB2YXIgcHJvZ3Jlc3NCeUxhbmd1YWdlID0ge307XG4gICAgT2JqZWN0LmtleXModHJhbnNsYXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKGxhbmcpIHtcbiAgICAgICAgcHJvZ3Jlc3NCeUxhbmd1YWdlW2xhbmddID0gT2JqZWN0LmtleXModHJhbnNsYXRpb25zW2xhbmddKS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb2dyZXNzQnlMYW5ndWFnZTtcbn1cblxuLyoqXG4gKiBDYWxsYmFjayBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgb25Mb2FkUHJvamVjdCAmIG9uTmV3UHJvamVjdENyZWF0ZWRcbiAqIEBwYXJhbSBwcm9qZWN0RGF0YSAoc2VlIHByb2plY3QgSlNPTiBmaWxlKVxuICovXG5mdW5jdGlvbiBhcHBseVByb2plY3REYXRhKGRhdGEsIHByb2plY3QpIHtcbiAgICBwcm9qZWN0Q29uZmlnID0gZGF0YTtcbiAgICBwcm9qZWN0SW5mbyA9IHByb2plY3RcblxuICAgIGNhbm55LnByb2plY3RNYWluTmF2aWdhdGlvbi5zZXRBdmFpbGFibGVMYW5ndWFnZXMoZGF0YS5hdmFpbGFibGVMYW5ndWFnZXMpO1xuXG4gICAgY2FubnkucHJvamVjdE1haW5OYXZpZ2F0aW9uLnNldEFjdGl2YXRlZFByb2plY3RMYW5ndWFnZXMoXG4gICAgICAgIGNvbXB1dGVUb3RhbFRyYW5zbGF0aW9uUHJvZ3JlZShkYXRhLmtleXMpLCBjb21wdXRlVHJhbnNsYXRpb25Qcm9ncmVzcyhkYXRhLmtleXMpKTtcblxuICAgIE9iamVjdC5rZXlzKGRhdGEua2V5cykuZm9yRWFjaChmdW5jdGlvbiAobGFuZykge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZGF0YS5rZXlzW2xhbmddKS5sZW5ndGggPiAwICYmIGF2YWlsYWJsZUxhbmd1YWdlcy5pbmRleE9mKGxhbmcpICE9PSAtMSkge1xuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhkYXRhLmtleXNbbGFuZ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHNhdmVLZXlUb1Byb2plY3RNYXAoZGF0YS5wcm9qZWN0LCBsYW5nLCBrZXksIGRhdGEua2V5c1tsYW5nXVtrZXldKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoa2V5VmFsdWVDb3VudGVyLnByb2plY3RNYXBbZGF0YS5wcm9qZWN0XS5sYW5nTWFwW2xhbmddKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3Byb2plY3RNYWluTmF2aWdhdGlvbkNvbnRyb2xsZXI6b25Mb2FkUHJvamVjdCAnLCBrZXlWYWx1ZUNvdW50ZXIucHJvamVjdE1hcFtkYXRhLnByb2plY3RdLmxhbmdNYXBbbGFuZ10pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwcm9qZWN0TWFpbk5hdmlnYXRpb25Db250cm9sbGVyOm9uTG9hZFByb2plY3QgbWF4S2V5cyBhcmUnLCBPYmplY3Qua2V5cyhrZXlWYWx1ZUNvdW50ZXIucHJvamVjdE1hcFtkYXRhLnByb2plY3RdLmtleU1hcCkubGVuZ3RoKTtcblx0XHRcdFx0Ly9jYW5ueS5wcm9qZWN0TWFpbk5hdmlnYXRpb24uc2V0TnVtYmVyT2ZUcmFuc2xhdGlvbk1heEtleXMoT2JqZWN0LmtleXMoa2V5VmFsdWVDb3VudGVyLnByb2plY3RNYXBbcHJvamVjdERhdGEucHJvamVjdF0ua2V5TWFwKS5sZW5ndGgpO1xuXHRcdFx0XHQvL2Nhbm55LnByb2plY3RNYWluTmF2aWdhdGlvbi5zZXROdW1iZXJPZlRyYW5zbGF0ZWRMYW5ndWFnZUtleShPYmplY3Qua2V5cyhrZXlWYWx1ZUNvdW50ZXIucHJvamVjdE1hcFtwcm9qZWN0RGF0YS5wcm9qZWN0XS5sYW5nTWFwW2xhbmddKS5sZW5ndGgsIGxhbmcpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVmYWN0b3IgdGhpcyBhbmQgbWFrZSBvbmUgY2FsbCA7KVxuICAgICAgICAgICAgICAgIGNhbm55LnByb2plY3RNYWluTmF2aWdhdGlvbi5hY3RpdmF0ZUxhbmcobGFuZyk7XG4gICAgICAgICAgICAgICAgY2FubnkucHJvamVjdE1haW5OYXZpZ2F0aW9uLmRlQWN0aXZhdGVMYW5nKGxhbmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncHJvamVjdE1haW5OYXZpZ2F0aW9uQ29udHJvbGxlcjpvbkxvYWRQcm9qZWN0IGdldCBsYW5ndWFnZSB3aXRob3V0IGFueSBrZXlzIGZvciBsb2NhbGU6JywgbGFuZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHJlc2V0IG9yIHJlaW5pdGlhbGl6ZSBvciBpbml0aWFsaXplIHRoZSBrZXkgdmFsdWUgY291bnRlciAob3RoZXJ3aXNlIHRoZSBjb3VudGVyIGNhbid0IGRldGVjdCBkZWxldGVkIGtleXMuIEUuZy4gZnJvbSB0aGUgZWRpdG9yIG1vZGUpXG4gICAga2V5VmFsdWVDb3VudGVyLnByb2plY3RNYXBbZGF0YS5wcm9qZWN0XSA9IGtleVZhbHVlQ291bnRlci5nZXRDb3VudE9iaigpO1xuICAgIC8vIHNob3cgZGVmYXVsdCBsYW5ndWFnZSBhcyBzZWxlY3RlZCBsYW5ndWFnZSBpbiBtZW51XG4gICAgLy8gVE9ETyBjaGVjayB3aG8gZGVjaWRlcyB0byBzaG93IHdoaWNoIGxhbmd1YWdlIGFzIGRlZmF1bHQgLSBhbmQgdGhlbiBjYWxsIHRoaXMgZXZlbnQgZnJvbSB0aGVyZVxuICAgIHVpRXZlbnRzLmNhbGxVaWV2ZW50KCdhY3RpdmF0ZUxhbmd1YWdlJywgZGF0YS5kZWZhdWx0TGFuZ3VhZ2UpO1xufVxuXG4vKipcbiAqIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgY2FsbGJhY2tzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG9uTmV3UHJvamVjdENyZWF0ZWQgOiBhcHBseVByb2plY3REYXRhLFxuICAgIG9uTG9hZFByb2plY3QgOiBhcHBseVByb2plY3REYXRhXG59OyIsInZhciBwcm9qZWN0T3ZlcnZpZXcgPSByZXF1aXJlKCdjYW5ueScpLnByb2plY3RPdmVydmlldyxcbiAgICBkaXNwbGF5TWFuYWdlciA9IHJlcXVpcmUoJ2Nhbm55JykuZGlzcGxheU1hbmFnZXIsXG4gICAgdHJhZGUgPSByZXF1aXJlKCcuLi90cmFkZS5qcycpLFxuICAgIHVpRXZlbnRzID0gcmVxdWlyZSgnLi4vdWlFdmVudE1hbmFnZXIuanMnKSxcbiAgICB0b2FzdCA9IHJlcXVpcmUoJy4uL1RvYXN0LmpzJyksXG4gICAgZXZlbnRzID0gcmVxdWlyZSgnLi4vZXZlbnRzLmpzJyk7XG5cbmNvbnN0IG1vdmVQcm9qZWN0ID0gcmVxdWlyZSgnLi9tb3ZlUHJvamVjdENvbXBvbmVudCcpXG5cbnZhciBwcm9qZWN0T3ZlcnZpZXdDb250cm9sbGVyID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGN1cnJlbnRQYXJlbnREaXJlY3RvcnksXG4gICAgICAgIGN1cnJlbnREaXJlY3RvcnksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXBzIHByb2plY3QgbmFtZXMgdG8gcHJvamVjdHMgSURzXG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0cyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcHMgZGlyZWN0b3J5IG5hbWVzIHRvIGRpcmVjdG9yeSBJRHNcbiAgICAgICAgICovXG4gICAgICAgIGRpcmVjdG9yaWVzO1xuXG4gICAgdWlFdmVudHMuYWRkVWlFdmVudExpc3RlbmVyKHtcbiAgICAgICAgc2hvd092ZXJ2aWV3UGFnZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRpc3BsYXlNYW5hZ2VyLnNob3coJ3Byb2plY3RzT3ZlcnZpZXcnKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcHJvamVjdE92ZXJ2aWV3Lm9uUGFyZW50RGlyZWN0b3J5U2VsZWN0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChjdXJyZW50UGFyZW50RGlyZWN0b3J5ICE9PSBjdXJyZW50RGlyZWN0b3J5KSB7XG4gICAgICAgICAgICB0cmFkZS5nZXREaXJlY3RvcnkoY3VycmVudFBhcmVudERpcmVjdG9yeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTm8gcGFyZW50IGRpcmVjdG9yeScpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBwcm9qZWN0T3ZlcnZpZXcub25Qcm9qZWN0U2VsZWN0ZWQoZnVuY3Rpb24ocHJvamVjdE5hbWUpIHtcbiAgICAgICAgdWlFdmVudHMuY2FsbFVpZXZlbnQoJ3Byb2plY3RTZWxlY3RlZCcsIHByb2plY3RzW3Byb2plY3ROYW1lXS5pZCk7XG4gICAgfSk7XG5cbiAgICBwcm9qZWN0T3ZlcnZpZXcub25EaXJlY3RvcnlTZWxlY3RlZChmdW5jdGlvbihkaXJlY3RvcnlOYW1lKSB7XG4gICAgICAgIHZhciBkaXJlY3RvcnlJZCA9IGRpcmVjdG9yaWVzW2RpcmVjdG9yeU5hbWVdO1xuICAgICAgICB0cmFkZS5nZXREaXJlY3RvcnkoZGlyZWN0b3J5SWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwcm9qZWN0T3ZlcnZpZXdDb250cm9sbGVyOmNhbiBub3QgbG9hZCBwcm9qZWN0IGZvciBkaXJlY3RvcnkgbmFtZTonLCBkaXJlY3RvcnlJZCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcHJvamVjdE92ZXJ2aWV3Lm9uQ3JlYXRlUHJvamVjdFByZXNzZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGRpc3BsYXlNYW5hZ2VyLnNob3coJ2NyZWF0ZU5ld1Byb2plY3RWaWV3Jyk7XG4gICAgfSk7XG5cbiAgICBwcm9qZWN0T3ZlcnZpZXcub25DcmVhdGVEaXJlY3RvcnlQcmVzc2VkKGZ1bmN0aW9uKCkge1xuICAgICAgICBkaXNwbGF5TWFuYWdlci5zaG93KCdjcmVhdGVOZXdEaXJlY3RvcnlWaWV3Jyk7XG4gICAgfSk7XG5cbiAgICBwcm9qZWN0T3ZlcnZpZXcub25EZWxldGVGb2xkZXJQcmVzc2VkKGZ1bmN0aW9uKGRpck5hbWUpIHtcbiAgICAgICAgbGV0IGRpcmVjdG9yeW5hbWUgPSBjdXJyZW50RGlyZWN0b3J5XG4gICAgICAgIGlmIChkaXJlY3RvcnluYW1lW2RpcmVjdG9yeW5hbWUubGVuZ3RoIC0gMV0gIT09ICcvJykge1xuICAgICAgICAgICAgZGlyZWN0b3J5bmFtZSArPSAnLyc7XG4gICAgICAgIH1cbiAgICAgICAgdHJhZGUuZGVsZXRlRm9sZGVyKGRpcmVjdG9yeW5hbWUgKyBkaXJOYW1lLCBmdW5jdGlvbihlcnIsIGRpck5hbWUpIHtcbiAgICAgICAgICAgIHZhciB0b2FzdE1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgIHByb2plY3RPdmVydmlldy5kZWxldGVQcm9qZWN0TGlzdE5vZGUoZGlyTmFtZS5zcGxpdCgnLycpLnNsaWNlKC0xKVswXSk7XG4gICAgICAgICAgICAgICAgdG9hc3RNZXNzYWdlID0gJ0ZvbGRlciBcIicgKyBkaXJOYW1lICsgJ1wiIGhhcyBiZWVuIGRlbGV0ZWQuJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9hc3RNZXNzYWdlID0gJ1RoZXJlIHdhcyBhbiBlcnJvcjogXCInICsgZXJyLm1lc3NhZ2UgKyAnXCInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9hc3Quc2hvd01lc3NhZ2UodG9hc3RNZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgXG4gICAgcHJvamVjdE92ZXJ2aWV3Lm9uTW92ZURpcmVjdG9yeVByZXNzZWQocHJvamVjdE5hbWUgPT4gbW92ZVByb2plY3Quc2hvdyhwcm9qZWN0c1twcm9qZWN0TmFtZV0pKVxuXG4gICAgcHJvamVjdE92ZXJ2aWV3Lm9uRGVsZXRlUHJvamVjdFByZXNzZWQoZnVuY3Rpb24ocHJvamVjdE5hbWUpIHtcbiAgICAgICAgdHJhZGUuZGVsZXRlUHJvamVjdChwcm9qZWN0c1twcm9qZWN0TmFtZV0uaWQsIGZ1bmN0aW9uKGVyciwgcHJvamVjdCkge1xuICAgICAgICAgICAgdmFyIHRvYXN0TWVzc2FnZTtcbiAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgcHJvamVjdE92ZXJ2aWV3LmRlbGV0ZVByb2plY3RMaXN0Tm9kZShwcm9qZWN0Lm5hbWUpO1xuICAgICAgICAgICAgICAgIHRvYXN0TWVzc2FnZSA9ICdQcm9qZWN0IFwiJyArIHByb2plY3QubmFtZSArICdcIiBoYXMgYmVlbiBkZWxldGVkLic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvYXN0TWVzc2FnZSA9ICdUaGVyZSB3YXMgYW4gZXJyb3I6IFwiJyArIGVyci5tZXNzYWdlICsgJ1wiJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKHRvYXN0TWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZXZlbnRzLmFkZFNlcnZlckxpc3RlbmVyKCduZXdEaXJlY3RvcnlDcmVhdGVkJywgZnVuY3Rpb24gKGRpcmVjdG9yeUlkKSB7XG4gICAgICAgIHZhciBsYXN0RGlyU2VwSWR4ID0gZGlyZWN0b3J5SWQubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgICAgdmFyIHBhcmVudERpcmVjdG9yeSA9IGRpcmVjdG9yeUlkLnN1YnN0cmluZygwLCBsYXN0RGlyU2VwSWR4ICsgMSk7XG4gICAgICAgIGlmIChwYXJlbnREaXJlY3RvcnkgPT09IGN1cnJlbnRQYXJlbnREaXJlY3RvcnkpIHtcbiAgICAgICAgICAgIHZhciBkaXJlY3RvcnlOYW1lID0gZGlyZWN0b3J5SWQuc3Vic3RyaW5nKGxhc3REaXJTZXBJZHggKyAxKTtcbiAgICAgICAgICAgIGRpcmVjdG9yaWVzW2RpcmVjdG9yeU5hbWVdID0gZGlyZWN0b3J5SWQ7XG4gICAgICAgICAgICAvLyBUT0RPIHNob3cgbWVzc2FnZSBvbmx5IGlmIHByb2plY3RPdmVydmlldyBpcyBjdXJyZW50bHkgdmlzaWJsZSAtIGJ1dCBjYW5ueS5mbG93Y29udHJvbCBjdXJyZW50bHkgZG9lcyBub3RcbiAgICAgICAgICAgIC8vIGhhdmUgYW55dGhpbmcgdG8gZmluZCBvdXQgd2hpY2ggdmlldyBpcyB0aGUgYWN0aXZlIG9uZVxuICAgICAgICAgICAgdG9hc3Quc2hvd01lc3NhZ2UoJ0EgbmV3IGRpcmVjdG9yeSBcIicgKyBkaXJlY3RvcnlOYW1lICsgJ1wiIGhhcyBiZWVuIGNyZWF0ZWQgYnkgYW5vdGhlciB1c2VyLicpO1xuICAgICAgICAgICAgcHJvamVjdE92ZXJ2aWV3LnNldFByb2plY3RzQW5kRGlyZWN0b3JpZXMoT2JqZWN0LmtleXMocHJvamVjdHMpLCBPYmplY3Qua2V5cyhkaXJlY3RvcmllcykpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2sgZnJvbSB0aGUgc2VydmVyIHdoaWNoIGhhbmRsZXMgYSBmcmVzaCBkaXJlY3RvcnkvcHJvamVjdHMgbGlzdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3tjdXJyZW50RGlyZWN0b3J5OnN0cmluZywgZGlyczpbe25hbWUsIGlkfV0sIHBhcmVudERpcmVjdG9yaWVzOlt7bmFtZSwgaWR9XSwgcGFyZW50RGlyZWN0b3J5OnN0cmluZywgcHJvamVjdHM6W3tuYW1lLCBpZH1dIH19IGRhdGEgLSBhbiBvYmplY3Qgd2l0aCAyIHByb3BlcnRpZXMgXCJwcm9qZWN0c1wiIGFuZCBcImRpcmVjdG9yaWVzXCIsIGVhY2ggbGlzdGluZyBwcm9qZWN0L2RpcmVjdG9yeSBuYW1lcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldERpcmVjdG9yeTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQcm9qZWN0T3ZlcnZpZXdDb250cm9sbGVyLmdldERpcmVjdG9yeTogJywgZGF0YSk7XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiU2VydmVyIGNhbGwgZmFpbGVkXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLmhhc093blByb3BlcnR5KCdwcm9qZWN0cycpICYmIGRhdGEuaGFzT3duUHJvcGVydHkoJ2RpcnMnKSkge1xuXG4gICAgICAgICAgICAgICAgcHJvamVjdHMgPSB7fTtcbiAgICAgICAgICAgICAgICBkYXRhLnByb2plY3RzLmZvckVhY2goZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdHNbZW50cnkubmFtZV0gPSBlbnRyeTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGRpcmVjdG9yaWVzID0ge307XG4gICAgICAgICAgICAgICAgZGF0YS5kaXJzLmZvckVhY2goZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICBkaXJlY3Rvcmllc1tlbnRyeS5uYW1lXSA9IGVudHJ5LmlkO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcHJvamVjdE92ZXJ2aWV3LnNldFByb2plY3RzQW5kRGlyZWN0b3JpZXMoT2JqZWN0LmtleXMocHJvamVjdHMpLCBPYmplY3Qua2V5cyhkaXJlY3RvcmllcykpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnREaXJlY3RvcnkgPSBkYXRhLnBhcmVudERpcmVjdG9yeTtcbiAgICAgICAgICAgICAgICBjdXJyZW50RGlyZWN0b3J5ID0gZGF0YS5jdXJyZW50RGlyZWN0b3J5O1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRGF0YSByY3ZkIGZyb20gc2VydmVyIGlzIG1pc3NpbmcgZXhwZWN0ZWQgcHJvcGVydGllcyAoXCJwcm9qZWN0c1wiLCBcImRpcnNcIiknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25OZXdEaXJlY3RvcnlDcmVhdGVkIDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgZGlzcGxheU1hbmFnZXIuc2hvdygncHJvamVjdHNPdmVydmlldycpO1xuICAgICAgICAgICAgdHJhZGUuZ2V0RGlyZWN0b3J5KGRhdGEuZGlyZWN0b3J5SWQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwcm9qZWN0T3ZlcnZpZXdDb250cm9sbGVyLm9uTmV3RGlyZWN0b3J5Q3JlYXRlZDogdHJhZGUgY2FsbGJhY2snKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvamVjdE92ZXJ2aWV3Q29udHJvbGxlcjtcbiIsImNvbnN0IGNhbm55ID0gcmVxdWlyZShcImNhbm55XCIpO1xuXG52YXIgc2VhcmNoQmFyID0gY2Fubnkuc2VhcmNoQmFyLFxuICAgIGxvYWRpbmdNb2RhbCA9IGNhbm55LmxvYWRpbmdNb2RhbCxcbiAgICB0cmFkZSA9IHJlcXVpcmUoXCIuLi90cmFkZVwiKSxcbiAgICBTZWFyY2hSZXN1bHRzID0gcmVxdWlyZShcIi4uL3VpTW9kdWxlcy9zZWFyY2hSZXN1bHRzXCIpLFxuICAgIHNlYXJjaFJlc3VsdHNVaSA9IFNlYXJjaFJlc3VsdHMoe1xuICAgICAgICBvbkNsb3NlOiAoKSA9PiBzZWFyY2hSZXN1bHRzVWkuZGVzdHJveSgpLFxuICAgIH0pXG5cbmNhbm55LmFkZChcInNlYXJjaFJlc3VsdHNcIiwgU2VhcmNoUmVzdWx0cyk7XG5cbnNlYXJjaEJhci5vblNlYXJjaChmdW5jdGlvbiAoKSB7XG4gICAgbG9hZGluZ01vZGFsLnNob3coKTtcbiAgICBjb25zdCBzZWFyY2hWYWx1ZSA9IHNlYXJjaEJhci5pbnB1dE5vZGUudmFsdWU7XG4gICAgaWYgKHNlYXJjaFZhbHVlLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgdHJhZGUuc2VhcmNoVGVybShzZWFyY2hWYWx1ZSwgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBsb2FkaW5nTW9kYWwuaGlkZSgpO1xuICAgICAgICAgICAgc2VhcmNoUmVzdWx0c1VpLnJlbmRlcihyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwidmFyIHRleHRFZGl0b3IgPSByZXF1aXJlKCdjYW5ueScpLnRleHRFZGl0b3IsXG4gICAgdHJhZGUgPSByZXF1aXJlKCcuLi90cmFkZS5qcycpLFxuICAgIHRvYXN0ID0gcmVxdWlyZSgnLi4vVG9hc3QuanMnKSxcbiAgICBldmVudHMgPSByZXF1aXJlKCcuLi9ldmVudHMuanMnKSxcbiAgICBjdXJyZW50UHJvamVjdElkO1xuLyoqXG4gKiByZXR1cm5zIHRoZSBsYW5ndWFnZSBvciBmYWxzZVxuICogQHBhcmFtIGZpbGVOYW1lXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gZ2V0TGFuZ3VhZ2VGcm9tRmlsZU5hbWUoZmlsZU5hbWUpIHtcbiAgICB2YXIgcmVnID0gL21lc3NhZ2VzXyguKilcXC4uKi4vZy5leGVjKGZpbGVOYW1lKTtcbiAgICBpZiAocmVnICYmIHJlZy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHJlZ1sxXTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIGhhbmRsZSB0aGUgY2hhbmdlIHByb2plY3QgZGVzY3JpcHRpb24gZXZlbnQgaW4gdGhlIHZpZXdcbiAqL1xudGV4dEVkaXRvci5vbkNoYW5nZShmdW5jdGlvbiAoaWQsIHZhbHVlLCBmYykge1xuICAgIGNvbnNvbGUubG9nKCd0ZXh0RWRpdG9yQ29udHJvbGxlcjpvbkNoYW5nZScsIHZhbHVlKTtcbiAgICBpZiAoY3VycmVudFByb2plY3RJZCkge1xuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICAvLyBUT0RPIHRvIGtlZXAgYmFja3dhcmQgZnVuY3Rpb25hbGl0eSB0aGlzIGlzIHRoZSBcIm1haW5cIiBwcm9qZWN0IGRlc2NyaXB0aW9uIC0gd2lsbCBiZSBjaGFuZ2VkIGluIGZ1dHVyZVxuICAgICAgICAgICAgaWQgPSAnX19kZXNjcmlwdGlvbic7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyByZW1vdmUgdGhlIHR2XyBmcm9tIHRoZSBpZFxuICAgICAgICB0cmFkZS5zYXZlUHJvamVjdERlc2NyaXB0aW9uKGN1cnJlbnRQcm9qZWN0SWQsIGlkLCB2YWx1ZSwgZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgZmModHJ1ZSk7XG4gICAgICAgICAgICAgICAgdG9hc3Quc2hvd01lc3NhZ2UoJ1Byb2plY3QgZGVzY3JpcHRpb24gY2hhbmdlZCBmb3IgcHJvamVjdCAnICsgY3VycmVudFByb2plY3RJZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZjKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG4vKipcbiAqIGp1c3QgdGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBjYWxsYmFja3NcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG9uTG9hZFByb2plY3QgOiBmdW5jdGlvbiAoZGF0YSwge2lkLCBuYW1lLCB1cmx9KSB7XG4gICAgICAgIGlmIChpZCkgY3VycmVudFByb2plY3RJZCA9IGlkXG4gICAgfVxufTsiLCJ2YXIgY2FubnkgPSByZXF1aXJlKFwiY2FubnlcIiksXG4gICAgdHJhbnNsYXRpb25WaWV3ID0gcmVxdWlyZSgnLi4vdWlNb2R1bGVzL3RyYW5zbGF0aW9uVmlldycpLFxuICAgIHRyYW5zbGF0aW9uVmlld0ltYWdlVXBsb2FkID0gcmVxdWlyZSgnLi4vdWlNb2R1bGVzL3RyYW5zbGF0aW9uVmlld0ltYWdlVXBsb2FkJyksXG4gICAgd29yZENvdW50ZXIgPSByZXF1aXJlKCcuLi91dGlsL3dvcmRDb3VudGVyJyksXG4gICAgZG9tT3B0cyA9IHJlcXVpcmUoJ2RvbS1vcHRzJyksXG4gICAgdWlFdmVudHMgPSByZXF1aXJlKCcuLi91aUV2ZW50TWFuYWdlci5qcycpLFxuICAgIGV2ZW50cyA9IHJlcXVpcmUoJy4uL2V2ZW50cy5qcycpLFxuICAgIHRyYWRlID0gcmVxdWlyZSgnLi4vdHJhZGUuanMnKSxcbiAgICB1cmwgPSByZXF1aXJlKCcuLi91dGlsL3VybCcpLFxuICAgIHNvcnRCeUtleSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgaWYgKGEua2V5IDwgYi5rZXkpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5rZXkgPiBiLmtleSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICBwcm9qZWN0Q29uZmlnLFxuICAgIHByb2plY3RJbmZvLFxuICAgIGF2YWlsYWJsZUxhbmd1YWdlcyA9IFtdLFxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCAodXNlZCBhcyBhIHNldCBkYXRhc3RydWN0dXJlIGhlcmUpIGhvbGRpbmcgYWxsIGV4aXN0aW5nIGtleXMgb2YgdGhlIHByb2plY3QgKG5vIG1hdHRlciBmb3IgaG93IG1hbnlcbiAgICAgKiBsYW5ndWFnZXMgaXQgaXMgdXNlZCkuIEl0IGlzIG5lZWRlZCB3aGVuIGFkZGluZyBhIG5ldyBsYW5ndWFnZSwgc2VlIHRoZSBmdW5jdGlvbiBmb3IgYWRkTGFuZ3VhZ2Ugd2hpY2ggaXMgYWRkZWRcbiAgICAgKiB0byB1aUV2ZW50cy5cbiAgICAgKiBAdHlwZSB7e319XG4gICAgICovXG4gICAgZXhpc3RpbmdLZXlzID0ge30sXG4gICAgb3JkZXJlZExhbmd1YWdlcyA9IFtdLFxuICAgIHNvcnRMYW5ndWFnZXMgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBvcmRlcmVkTGFuZ3VhZ2VzLmluZGV4T2YoYSkgLSBvcmRlcmVkTGFuZ3VhZ2VzLmluZGV4T2YoYik7XG4gICAgfTtcblxudHJhbnNsYXRpb25WaWV3SW1hZ2VVcGxvYWQub25VcGxvYWRCdXR0b24oZnVuY3Rpb24oaWQpIHtcbiAgICB1aUV2ZW50cy5jYWxsVWlldmVudCgnc2hvd0ZpbGVVcGxvYWQnLCBpZCk7XG59KTtcblxudHJhbnNsYXRpb25WaWV3SW1hZ2VVcGxvYWQub25EZWxldGVCdXR0b24oZnVuY3Rpb24oaWQpIHtcbiAgICBpZiAoY29uZmlybSgnRGVsZXRlIHRoZSBpbWFnZSBmb3IgY2F0ZWdvcnkgwrsgJyArIGlkICsgJyDCqyBmb3JldmVyPycpKSB7XG4gICAgICAgIHRyYWRlLnJlbW92ZUltYWdlKHByb2plY3RJbmZvLmlkLCBpZCk7XG4gICAgfVxufSk7XG5cbnRyYW5zbGF0aW9uVmlldy5vbkNhdGVnb3J5Q2xpY2tlZChmdW5jdGlvbihpZCkge1xuICAgIHVpRXZlbnRzLmNhbGxVaWV2ZW50KCdhbmNob3JGb2N1cycsICcjJyArIGlkKTtcbn0pO1xuLyoqXG4gKiBTZXR1cCB0aGUgVUkgZXZlbnRzIGFuZCBtYW5hZ2UgdGhlIGxvZ2ljIGZvciB0aGVtLlxuICpcbiAqIFRPRE8gcmVwbGFjZSBidW5kbGUgd2l0aCBsb2NhbGUgYW5kIHJlZmFjdG9yIHRoZSBjYWxscyBmcm9tIHRyYW5zbGF0aW9uVmlld1xuICovXG50cmFuc2xhdGlvblZpZXcub25TYXZlS2V5KGZ1bmN0aW9uKGtleSwgbGFuZywgdmFsdWUpIHtcblxuICAgIC8vIFRPRE86IENvdW50IHdvcmRzIGFuZCB0ZWxsIHdvcmQgY291bnQgbGFiZWwgdG8gdXBkYXRlXG5cbiAgICBjb25zb2xlLmxvZygndHJhbnNsYXRpb25WaWV3Q29udHJvbGxlcjpvblNhdmVWYWx1ZScsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgdHJhZGUuc2F2ZUtleShcbiAgICAgICAgcHJvamVjdEluZm8uaWQsXG4gICAgICAgIGxhbmcgfHwgcHJvamVjdENvbmZpZy5kZWZhdWx0TGFuZ3VhZ2UsXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlIHx8IHVuZGVmaW5lZFxuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihwcm9qZWN0SWQsIGxhbmd1YWdlLCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY2F0SWQ7XG5cbiAgICAgICAgICAgIGlmIChwcm9qZWN0SWQgPT09IHByb2plY3RJbmZvLmlkKSB7IC8vIHByZXZlbnQgYXBwbHlpbmcgdGhlIGNhbGxiYWNrIGlmIHByb2plY3QgaGFzIGJlZW4gY2hhbmdlZCBpbiB0aGUgbWVhbnRpbWVcbiAgICAgICAgICAgICAgICBjYXRJZCA9IGtleS5zcGxpdCgnXycpWzBdO1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nS2V5c1trZXldID0gdW5kZWZpbmVkOyAvLyBzYXZlIHRoZSBrZXlcbiAgICAgICAgICAgICAgICBwcm9qZWN0Q29uZmlnLmtleXNbbGFuZ11ba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uVmlldy5wcmludEJ1bmRsZVRlbXBsYXRlKFt7XG4gICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUgfHwgJydcbiAgICAgICAgICAgICAgICB9XSwgbGFuZ3VhZ2UsIGF2YWlsYWJsZUxhbmd1YWdlcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNhdGVnb3J5V29yZENvdW50KGNhdElkLCBsYW5ndWFnZSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0b2FzdC5zaG93TWVzc2FnZSgnQXV0byBzYXZlOiBcIicgKyBrZXkgKyAnXCIgKHN1Y2Nlc3MpJyk7XG5cbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvblZpZXcuc2VuZFN1Y2Nlc3Moa2V5LCAndmFsdWVfJyk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBub3Qgc3VyZSBpZiB0aGlzIGlzIG5lZWRlZFxuICAgICAgICAgICAgICAgIHVpRXZlbnRzLmNhbGxVaWV2ZW50KCd1cGRhdGVLZXknLCBwcm9qZWN0SWQsIGxhbmd1YWdlLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG59KTtcblxuLyoqXG4gKiBTZXR1cCB0aGUgVUkgZXZlbnRzIGFuZCBtYW5hZ2UgdGhlIGxvZ2ljIGZvciB0aGVtLlxuICpcbiAqIFRPRE8gcmVwbGFjZSBidW5kbGUgd2l0aCBsb2NhbGUgYW5kIHJlZmFjdG9yIHRoZSBjYWxscyBmcm9tIHRyYW5zbGF0aW9uVmlld1xuICovXG50cmFuc2xhdGlvblZpZXcub25DcmVhdGVLZXkoZnVuY3Rpb24oa2V5LCBsYW5nLCB2YWx1ZSkge1xuICAgIGNvbnNvbGUubG9nKCd0cmFuc2xhdGlvblZpZXdDb250cm9sbGVyOm9uU2F2ZVZhbHVlJywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB0cmFkZS5jcmVhdGVLZXkoXG4gICAgICAgIHByb2plY3RJbmZvLmlkLFxuICAgICAgICBsYW5nIHx8IHByb2plY3RDb25maWcuZGVmYXVsdExhbmd1YWdlLFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSB8fCB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24ocHJvamVjdElkLCBsYW5ndWFnZSwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNhdElkID0ga2V5LnNwbGl0KCdfJylbMF07XG4gICAgICAgICAgICBpZiAocHJvamVjdElkID09PSBwcm9qZWN0SW5mby5pZCkgeyAvLyBwcmV2ZW50IGFwcGx5aW5nIHRoZSBjYWxsYmFjayBpZiBwcm9qZWN0IGhhcyBiZWVuIGNoYW5nZWQgaW4gdGhlIG1lYW50aW1lXG4gICAgICAgICAgICAgICAgZXhpc3RpbmdLZXlzW2tleV0gPSB1bmRlZmluZWQ7IC8vIHNhdmUgdGhlIGtleVxuICAgICAgICAgICAgICAgIHByb2plY3RDb25maWcua2V5c1tsYW5ndWFnZV0gPSBwcm9qZWN0Q29uZmlnLmtleXNbbGFuZ3VhZ2VdID8gcHJvamVjdENvbmZpZy5rZXlzW2xhbmd1YWdlXSA6IHt9O1xuICAgICAgICAgICAgICAgIHByb2plY3RDb25maWcua2V5c1tsYW5ndWFnZV1ba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uVmlldy5wcmludEJ1bmRsZVRlbXBsYXRlKFt7XG4gICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgIHdvcmRzOiAwXG4gICAgICAgICAgICAgICAgfV0sIGxhbmd1YWdlLCBhdmFpbGFibGVMYW5ndWFnZXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDYXRlZ29yeVdvcmRDb3VudChjYXRJZCwgbGFuZ3VhZ2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKCdBdXRvIHNhdmU6IFwiJyArIGtleSArICdcIiAoc3VjY2VzcyknKTtcblxuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uVmlldy5zZW5kU3VjY2VzcyhrZXksICd2YWx1ZV8nKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIG5vdCBzdXJlIGlmIHRoaXMgaXMgbmVlZGVkXG4gICAgICAgICAgICAgICAgdWlFdmVudHMuY2FsbFVpZXZlbnQoJ3VwZGF0ZUtleScsIHByb2plY3RJZCwgbGFuZ3VhZ2UsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbn0pO1xuXG50cmFuc2xhdGlvblZpZXcub25DbG9uZUtleShmdW5jdGlvbihrZXlJZCwga2V5TmFtZSwgZnJvbUNhdGVnb3J5LCB0b0NhdGVnb3J5KSB7XG4gICAgdHJhZGUuY2xvbmVLZXkoXG4gICAgICAgIHByb2plY3RJbmZvLmlkLFxuICAgICAgICB7XG4gICAgICAgICAgICBpZDoga2V5SWQsXG4gICAgICAgICAgICBrZXk6IGtleU5hbWUsXG4gICAgICAgICAgICBzb3VyY2VDYXRlZ29yeTogZnJvbUNhdGVnb3J5LFxuICAgICAgICAgICAgdGFyZ2V0Q2F0ZWdvcnk6IHRvQ2F0ZWdvcnlcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24oZXJyLCBwcm9qZWN0SWQsIGRhdGEpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0cztcbiAgICAgICAgICAgIGlmIChwcm9qZWN0SWQgPT09IHByb2plY3RJbmZvLmlkKSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdLZXlzW2RhdGEua2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0ZXh0cyA9IGRhdGEudmFsdWVzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGxhbmcgaW4gdGV4dHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRzLmhhc093blByb3BlcnR5KGxhbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9qZWN0Q29uZmlnLmtleXNbbGFuZ11bZGF0YS5rZXldID0gdGV4dHNbbGFuZ107XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvblZpZXcucHJpbnRCdW5kbGVUZW1wbGF0ZShbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogZGF0YS5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRleHRzW2xhbmddIHx8ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XSwgbGFuZywgYXZhaWxhYmxlTGFuZ3VhZ2VzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVDYXRlZ29yeVdvcmRDb3VudCh0b0NhdGVnb3J5LCBsYW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbm55LnRyYW5zbGF0aW9uVmlld0Rlc2NyaXB0aW9uLmFkZERlc2NyaXB0aW9ucyhkYXRhLmtleURlc2NyaXB0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xufSk7XG5cbi8qKlxuICogUmVhZCB0aGUgZnJvbSBwYXJhbSBhcyBkZWZhdWx0IGxhbmd1YWdlIG90aGVyd2lzZSB0YWtlIGl0IGZyb20gdGhlIHByb2plY3QuanNvblxuICogQHBhcmFtIGNvbmZpZ1xuICovXG5mdW5jdGlvbiBzYXZlUHJvamVjdENvbmZpZyhjb25maWcsIHByb2plY3QpIHtcbiAgICB2YXIgaWR4LFxuICAgICAgICAvLyB0aGUgZnJvbSBwYXJhbWV0ZXIgY2FuIG92ZXJ3cml0ZSB0aGUgZGVmYXVsdCBsYW5ndWFnZSAobGVnYWN5KVxuICAgICAgICBkZWZhdWx0TGFuZ3VhZ2UgPSBkb21PcHRzLnBhcmFtcy5mcm9tID8gZG9tT3B0cy5wYXJhbXMuZnJvbSA6IGNvbmZpZy5kZWZhdWx0TGFuZ3VhZ2U7XG4gICAgcHJvamVjdENvbmZpZyA9IGNvbmZpZztcbiAgICBwcm9qZWN0SW5mbyA9IHByb2plY3Q7XG5cbiAgICAvLyBTZXQgJHsgZGVmYXVsdExhbmd1YWdlIH0gYXMgZGVmYXVsdCBpbiBjYXNlIGEgcHJvamVjdCB3YXMganVzdCBjcmVhdGVkIChpLmUuIGRvZXMgbm90IGNvbnRhaW4gYW55IGtleXMgeWV0KVxuICAgIC8vIFRPRE86IEJldHRlciBjcmVhdGUgLyBhZGQgY2hlY2sgb2Ygb2JqZWN0IHRvIGZ1bmN0aW9uYWwgaGVscGVyIG9iamVjdCBpbnN0ZWFkID9cbiAgICBhdmFpbGFibGVMYW5ndWFnZXMgPVxuICAgICAgICBPYmplY3Qua2V5cyhwcm9qZWN0Q29uZmlnLmtleXMpLmxlbmd0aCA9PT0gMCAmJiBKU09OLnN0cmluZ2lmeShwcm9qZWN0Q29uZmlnLmtleXMpID09PSBKU09OLnN0cmluZ2lmeSh7fSkgP1xuICAgICAgICAgICAgW2RlZmF1bHRMYW5ndWFnZV0gOiBPYmplY3Qua2V5cyhwcm9qZWN0Q29uZmlnLmtleXMpO1xuXG4gICAgYXZhaWxhYmxlTGFuZ3VhZ2VzID0gYXZhaWxhYmxlTGFuZ3VhZ2VzLnNvcnQoc29ydExhbmd1YWdlcylcblxuICAgIGlkeCA9IGF2YWlsYWJsZUxhbmd1YWdlcy5pbmRleE9mKGRlZmF1bHRMYW5ndWFnZSk7XG5cbiAgICBpZiAoaWR4ICE9PSAtMSAmJiBpZHggIT09IDApIHtcbiAgICAgICAgLy8gbW92ZSBkZWZhdWx0IHRvIHRoZSBiZWdpbiBvZiB0aGUgbGlzdCAodGhpcyBkZWZpbmVzIHRoZSBvcmRlciBob3cgdGhlIHRyYW5zbGF0aW9uIGxhbmd1YWdlcyBhcmUgc2hvd24pXG4gICAgICAgIGF2YWlsYWJsZUxhbmd1YWdlcy5zcGxpY2UoMCwgMCwgYXZhaWxhYmxlTGFuZ3VhZ2VzLnNwbGljZShpZHgsIDEpWzBdKTtcbiAgICB9XG59XG5cbi8vLyoqXG4vLyAqIFRPRE8gcmVwbGFjZSBidW5kbGUgd2l0aCBsb2NhbGUgYW5kIHJlZmFjdG9yIHRoZSBjYWxscyBmcm9tIHRyYW5zbGF0aW9uVmlld1xuLy8gKiBUT0RPIHRoaXMgY29kZSBpcyBub3QgY2FsbGVkIT9cbi8vICovXG4vL3RyYW5zbGF0aW9uVmlldy5vbkFkZE5ld0tleShmdW5jdGlvbiAobGFuZywga2V5LCB2YWx1ZSwgY2IpIHtcbi8vICAgIGNvbnNvbGUubG9nKCd0cmFuc2xhdGlvblZpZXdDb250cm9sbGVyOm9uQWRkTmV3S2V5JywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbi8vICAgIGFsZXJ0KCdodWh1Jyk7XG4vLyAgICB0cmFkZS5zZW5kUmVzb3VyY2Uoe1xuLy8gICAgICAgIGJ1bmRsZTogcHJvamVjdENvbmZpZy5wcm9qZWN0LFxuLy8gICAgICAgIGxvY2FsZTogbGFuZ1xuLy8gICAgfSwge1xuLy8gICAgICAgIGtleToga2V5LFxuLy8gICAgICAgIHZhbHVlOiB2YWx1ZVxuLy8gICAgfSwgZnVuY3Rpb24gKGtleSkge1xuLy8gICAgICAgIGNiKGtleSlcbi8vICAgIH0pO1xuLy99KTtcblxudHJhbnNsYXRpb25WaWV3Lm9uQ3JlYXRlTmV3UHJvamVjdChmdW5jdGlvbihwcmpOYW1lLCBvYmopIHtcbiAgICB0cmFkZS5jcmVhdGVOZXdQcm9qZWN0KHByak5hbWUsIG9iaik7XG59KTtcblxudHJhbnNsYXRpb25WaWV3Lm9uUmVtb3ZlQ2F0ZWdvcnkoZnVuY3Rpb24ob2JqKSB7XG4gICAgY29uc29sZS5sb2coJ3RyYW5zbGF0aW9uVmlld0NvbnRyb2xsZXI6b25SZW1vdmVDYXRlZ29yeScsIG9iaiwgcHJvamVjdEluZm8uaWQpO1xuICAgIHRyYWRlLnJlbW92ZUNhdGVnb3J5KHByb2plY3RJbmZvLmlkLCBvYmouY2F0ZWdvcnkpO1xufSk7XG5cbnRyYW5zbGF0aW9uVmlldy5vblJlbmFtZUNhdGVnb3J5KGZ1bmN0aW9uKG9iaikge1xuICAgIGNvbnNvbGUubG9nKCd0cmFuc2xhdGlvblZpZXdDb250cm9sbGVyOm9uUmVuYW1lQ2F0ZWdvcnknLCBvYmosIHByb2plY3RJbmZvLmlkKVxuICAgIHRyYWRlLnJlbmFtZUNhdGVnb3J5KHByb2plY3RJbmZvLmlkLCBvYmoub2xkTmFtZSwgb2JqLm5ld05hbWUpO1xufSk7XG5cbnRyYW5zbGF0aW9uVmlldy5vblJlbmFtZUtleShmdW5jdGlvbihvYmopIHtcbiAgICBjb25zb2xlLmxvZygndHJhbnNsYXRpb25WaWV3Q29udHJvbGxlcjpvblJlbmFtZUtleScsIG9iaiwgcHJvamVjdEluZm8uaWQpO1xuICAgIHRyYWRlLnJlbmFtZUtleShwcm9qZWN0SW5mby5pZCwge1xuICAgICAgICBuZXdLZXk6IG9iai5uZXdLZXksXG4gICAgICAgIG9sZEtleTogb2JqLm9sZEtleVxuICAgIH0pO1xufSk7XG5cbnRyYW5zbGF0aW9uVmlldy5vblJlbW92ZUtleShmdW5jdGlvbihvYmopIHtcbiAgICBjb25zb2xlLmxvZygndHJhbnNsYXRpb25WaWV3Q29udHJvbGxlcjpvblJlbW92ZUtleScsIG9iaiwgcHJvamVjdEluZm8uaWQpO1xuICAgIHRyYWRlLnJlbW92ZUtleShwcm9qZWN0SW5mby5pZCwgb2JqLmtleSwgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBjYXROYW1lID0ga2V5LnNwbGl0KCdfJylbMF07XG4gICAgICAgIGZvcih2YXIgbGFuZyBpbiBwcm9qZWN0Q29uZmlnLmtleXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9qZWN0Q29uZmlnLmtleXMuaGFzT3duUHJvcGVydHkobGFuZykpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcHJvamVjdENvbmZpZy5rZXlzW2xhbmddW2tleV07XG4gICAgICAgICAgICAgICAgdXBkYXRlQ2F0ZWdvcnlXb3JkQ291bnQoY2F0TmFtZSwgbGFuZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuXG4vLyByZWdpc3RlciBsaXN0ZW5lciBmdW5jdGlvbiB0byB0aGUgdWkgZXZlbnRzXG51aUV2ZW50cy5hZGRVaUV2ZW50TGlzdGVuZXIoe1xuICAgIGFjdGl2YXRlTGFuZ3VhZ2U6IGZ1bmN0aW9uKGxhbmcpIHtcbi8vICAgICAgICB0cmFuc2xhdGlvblZpZXdIZWFkZXIuc2hvd0xhbmcobGFuZyk7XG4gICAgICAgIHRyYW5zbGF0aW9uVmlldy5zaG93TGFuZyhsYW5nKTtcbiAgICB9LFxuICAgIGRlQWN0aXZhdGVMYW5ndWFnZTogZnVuY3Rpb24obGFuZykge1xuLy8gICAgICAgIHRyYW5zbGF0aW9uVmlld0hlYWRlci5oaWRlTGFuZyhsYW5nKTtcbiAgICAgICAgdHJhbnNsYXRpb25WaWV3LmhpZGVMYW5nKGxhbmcpO1xuICAgIH0sXG4gICAgdG9nZ2xlV29yZENvdW50OiBmdW5jdGlvbihhY3RpdmUpIHtcbiAgICAgICAgdHJhbnNsYXRpb25WaWV3LnRvZ2dsZVdvcmRDb3VudChhY3RpdmUpO1xuICAgIH0sXG4gICAgLy8gVE9ETyAgZG9uJ3QgdHJpZ2dlciBpdCB0d2ljZSBmb3IgdGhlIHNhbWUgbGFuZ3VhZ2VcbiAgICBhZGRMYW5ndWFnZTogZnVuY3Rpb24obGFuZykge1xuICAgICAgICBhdmFpbGFibGVMYW5ndWFnZXMucHVzaChsYW5nKTtcbiAgICAgICAgYXZhaWxhYmxlTGFuZ3VhZ2VzID0gYXZhaWxhYmxlTGFuZ3VhZ2VzLnNvcnQoc29ydExhbmd1YWdlcyk7XG4gICAgICAgIHByb2plY3RDb25maWcua2V5c1tsYW5nXSA9IHt9O1xuICAgICAgICB0cmFuc2xhdGlvblZpZXcuYWRkTGFuZ3VhZ2UoXG4gICAgICAgICAgT2JqZWN0LmtleXMoZXhpc3RpbmdLZXlzKSxcbiAgICAgICAgICBsYW5nLFxuICAgICAgICAgIGF2YWlsYWJsZUxhbmd1YWdlcy5pbmRleE9mKGxhbmcpXG4gICAgICAgICk7XG4vLyAgICAgICAgdHJhbnNsYXRpb25WaWV3SGVhZGVyLnNob3dMYW5nKGxhbmcpO1xuICAgICAgICB0cmFuc2xhdGlvblZpZXcuc2hvd0xhbmcobGFuZyk7XG4gICAgfSxcbiAgICBlbmFibGVFZGl0b3JNb2RlOiBmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgICAgIHRyYW5zbGF0aW9uVmlldy5lbmFibGVFZGl0b3JNb2RlKGVuYWJsZWQpO1xuICAgIH0sXG4gICAgZmlsZVVwbG9hZGVkOiBmdW5jdGlvbihwcm9qZWN0SWQsIGtleSwgdXJsKSB7XG4gICAgICAgIGNhbm55LnRyYW5zbGF0aW9uVmlld0ltYWdlVXBsb2FkLmFwcGVuZEltYWdlKGtleSwgdXJsKVxuICAgIH0sXG4gICAgSk1CRkZpbGVVcGxvYWRlZDogZnVuY3Rpb24ocHJvamVjdElkKSB7XG4gICAgICAgIHRyYWRlLmxvYWRQcm9qZWN0KHByb2plY3RJZCwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigndHJhbnNsYXRpb25WaWV3Q29udHJvbGxlcjpsb2FkUHJvamVjdCBmYWlscyBmb3IgcHJvamVjdElkOicsIHByb2plY3RJbmZvLmlkKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBqc29uSW1wb3J0ZWQ6IGZ1bmN0aW9uKHByb2plY3RJZCkge1xuICAgICAgICB0cmFkZS5sb2FkUHJvamVjdChwcm9qZWN0SWQsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQcm9qZWN0IHdpdGggaWQgJyArIHByb2plY3RJZCArICcgY291bGQgbm90IGJlIGxvYWRlZC4nKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBzZXJ2ZXIgZXZlbnQgbGlzdGVuZXJcbiAqL1xuZXZlbnRzLmFkZFNlcnZlckxpc3RlbmVyKCdrZXlVcGRhdGVkJywgZnVuY3Rpb24oKSB7XG4gICAgLy8gVE9ETyBtb3JlIGNsaWVudCBjaGFuZ2VzIGFyZSBjb21pbmcsIHdlJ2xsIGZpbmlzaCB0aGUgY29kZSBiZWxvdyB0aGVuXG4gICAgLy9pZiAocHJvamVjdElkID09PSBwcm9qZWN0Q29uZmlnLnByb2plY3RJZCkge1xuICAgIC8vICAgIGV4aXN0aW5nS2V5c1trZXlOYW1lXSA9IHVuZGVmaW5lZDsgLy8gc2F2ZSB0aGUga2V5IC8vIHdoYXQncyBoYXBwZW5pbmcgaGVyZT9cbiAgICAvLyAgICB2YXIgZGF0YSA9IHt9O1xuICAgIC8vICAgIGRhdGFba2V5TmFtZV0gPSBrZXlWYWx1ZTtcbiAgICAvLyAgICB0cmFuc2xhdGlvblZpZXcucHJpbnRCdW5kbGVUZW1wbGF0ZShbZGF0YV0sIGxhbmd1YWdlLCBhdmFpbGFibGVMYW5ndWFnZXMsIHByb2plY3RDb25maWcucHJvamVjdCk7XG4gICAgLy99XG59KTtcblxuLyoqXG4gKiBzZXJ2ZXIgZXZlbnQgbGlzdGVuZXJcbiAqIGFsbCB1c2VycyB3aWxsIGJlIG5vdGlmaWVkIG9mIGNoYW5nZXNcbiAqL1xuZXZlbnRzLmFkZFNlcnZlckxpc3RlbmVyKCdvbktleUNsb25lZCcsIGZ1bmN0aW9uKCkge1xuICAgIGNvbnNvbGUubG9nKCdldmVudHMubGlzdGVuZXI6Om9uS2V5Q2xvbmVkJyArIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG59KTtcblxuLyoqXG4gKiBzZXJ2ZXIgZXZlbnQgbGlzdGVuZXJcbiAqL1xuZXZlbnRzLmFkZFNlcnZlckxpc3RlbmVyKCdrZXlEZWxldGVkJywgZnVuY3Rpb24oYnVuZGxlTmFtZSwgb2JqKSB7XG4gICAgLy8gVE9ETyBtb3JlIGNsaWVudCBjaGFuZ2VzIGFyZSBjb21pbmcsIHdlJ2xsIGZpbmlzaCB0aGUgY29kZSBiZWxvdyB0aGVuXG4gICAgLy9pZiAoYnVuZGxlTmFtZSA9PT0gcHJvamVjdENvbmZpZy5wcm9qZWN0KSB7XG4gICAgLy8gICAgY29uc29sZS5sb2coJ3RyYW5zbGF0aW9uVmlld0NvbnRyb2xsZXI6a2V5UmVuYW1lZCcsIGJ1bmRsZU5hbWUsIG9iaik7XG4gICAgLy8gICAgdG9hc3Quc2hvd01lc3NhZ2UoJ0tleSBkZWxldGVkIScgKyBvYmoua2V5KTtcbiAgICAvLyAgICB0cmFuc2xhdGlvblZpZXcubWFya0tleUFzUmVtb3ZlZChvYmoua2V5KTtcbiAgICAvL31cbn0pO1xuXG5ldmVudHMuYWRkU2VydmVyTGlzdGVuZXIoJ2NhdGVnb3J5RGVsZXRlZCcsIGZ1bmN0aW9uKGJ1bmRsZU5hbWUsIG9iaikge1xuICAgIGNvbnNvbGUubG9nKCdldmVudHMubGlzdGVuZXI6OmNhdGVnb3J5RGVsZXRlZCcgKyBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xufSk7XG5cbmV2ZW50cy5hZGRTZXJ2ZXJMaXN0ZW5lcignY2F0ZWdvcnlSZW5hbWVkJywgZnVuY3Rpb24oYnVuZGxlTmFtZSwgb2JqKSB7XG4gICAgY29uc29sZS5sb2coJ2V2ZW50cy5saXN0ZW5lcjo6Y2F0ZWdvcnlSZW5hbWVkJyArIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG59KTtcblxuLyoqXG4gKiBzZXJ2ZXIgZXZlbnQgbGlzdGVuZXJcbiAqL1xuZXZlbnRzLmFkZFNlcnZlckxpc3RlbmVyKCdpbWFnZVJlbW92ZWQnLCBmdW5jdGlvbihidW5kbGVOYW1lLCBjYXRlZ29yeU5hbWUpIHtcbiAgICBpZiAoYnVuZGxlTmFtZSA9PT0gcHJvamVjdEluZm8uaWQpIHtcbiAgICAgICAgdG9hc3Quc2hvd01lc3NhZ2UoJ0ltYWdlIHJlbW92ZWQgZm9yIGNhdGVnb3J5OiAnICsgY2F0ZWdvcnlOYW1lKTtcbiAgICAgICAgdHJhbnNsYXRpb25WaWV3LnJlbW92ZUltYWdlKGNhdGVnb3J5TmFtZSk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogR2V0IHdvcmQgY291bnQgZm9yIGdpdmVuIGNhdGVnb3J5IGFuZCBsYW5ndWFnZVxuICogQHBhcmFtIGNhdGVnb3J5XG4gKiBAcGFyYW0gbGFuZ1xuICogQHJldHVybnMgTnVtYmVyXG4gKi9cbmZ1bmN0aW9uIGNvdW50V29yZHNJbkNhdGVnb3J5KGNhdGVnb3J5LCBsYW5nKSB7XG4gICAgbGV0IHdvcmRDb3VudCA9IDA7XG4gICAgT2JqZWN0LmtleXMocHJvamVjdENvbmZpZy5rZXlzW2xhbmddKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAoa2V5LnNwbGl0KCdfJylbMF0gPT09IGNhdGVnb3J5KSB7XG4gICAgICAgICAgICB3b3JkQ291bnQgKz0gd29yZENvdW50ZXIuY291bnRXb3Jkc0luU3RyaW5nKHByb2plY3RDb25maWcua2V5c1tsYW5nXVtrZXldKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB3b3JkQ291bnQ7XG59XG5cbi8qKlxuICogVXBkYXRlIG92ZXJhbGwgd29yZC1jb3VudCB2aWV3IGZvciBjYXRlZ29yeSBsYW5ndWFnZVxuICogQHBhcmFtIGNhdElkXG4gKiBAcGFyYW0gbGFuZ1xuICovXG5mdW5jdGlvbiB1cGRhdGVDYXRlZ29yeVdvcmRDb3VudChjYXRJZCwgbGFuZykge1xuICAgIHRyYW5zbGF0aW9uVmlldy51cGRhdGVDYXRlZ29yeVdvcmRDb3VudCh7XG4gICAgICAgIGlkOiBjYXRJZCxcbiAgICAgICAgbGFuZ3VhZ2U6IGxhbmcsXG4gICAgICAgIHdvcmRzOiBjb3VudFdvcmRzSW5DYXRlZ29yeShjYXRJZCwgbGFuZylcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBGaWx0ZXIgY2F0ZWdvcnkgbmFtZXMgYnkgaXRlcmF0aW5nIHRocm91Z2ggcHJvamVjdCBrZXlzXG4gKiBAcGFyYW0ga2V5c1xuICogQHJldHVybnMgQXJyYXlcbiAqL1xuZnVuY3Rpb24gZ2V0Q2F0ZWdvcmllc0J5S2V5cyhrZXlzKSB7XG4gICAgdmFyIGN1cnJlbnRDYXROYW1lLFxuICAgICAgICBkZWZhdWx0S2V5cyxcbiAgICAgICAgY2F0ZWdvcmllcyA9IFtdO1xuICAgIGZvciAodmFyIGxhbmcgaW4ga2V5cykge1xuICAgICAgICBpZiAoa2V5cy5oYXNPd25Qcm9wZXJ0eShsYW5nKSkge1xuICAgICAgICAgICAgZGVmYXVsdEtleXMgPSBrZXlzW2xhbmddO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRLZXlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRLZXlzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENhdE5hbWUgPSBrZXkuc3BsaXQoJ18nKVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhdGVnb3JpZXMuaW5kZXhPZihjdXJyZW50Q2F0TmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yaWVzLnB1c2goY3VycmVudENhdE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYXRlZ29yaWVzO1xufVxuXG5cbi8qKlxuICogUmVtb3ZlcyBjYXRlZ29yeSByZWxhdGVkIGtleXMgZnJvbSBcInNlc3Npb25cIiBkYXRhIC0gc3RvcmVkIGluIHByb2plY3RDb25maWcua2V5c1xuICogKG1lbWJlciB2YXIgZGVjbGFyZWQgb24gdG9wIG9mIHRoaXMgZmlsZSlcbiAqIEludm9rZWQgYnkgY2F0ZWdvcnkgd2FzIHJlbW92ZWRcbiAqIEBwYXJhbSBjYXRlZ29yeVxuICovXG5mdW5jdGlvbiByZW1vdmVDYXRlZ29yeURhdGEoY2F0ZWdvcnkpIHtcbiAgICBPYmplY3Qua2V5cyhwcm9qZWN0Q29uZmlnLmtleXMpLmZvckVhY2goZnVuY3Rpb24obGFuZykge1xuICAgICAgICB2YXIgbGFuZ0RhdGEgPSBwcm9qZWN0Q29uZmlnLmtleXNbbGFuZ107XG4gICAgICAgIE9iamVjdC5rZXlzKGxhbmdEYXRhKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleS5zcGxpdCgnXycpWzBdID09PSBjYXRlZ29yeSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBsYW5nRGF0YVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlTmV3UHJvamVjdENvbmZpZyhuZXdQcm9qZWN0Q29uZmlnLCBwcm9qZWN0KSB7XG4gICAgLy8gcHJvamVjdCBzcGVjaWZpYyBjb25maWdcbiAgICBjb25zb2xlLmxvZygndHJhbnNsYXRpb25WaWV3Q29udHJvbGxlciBnZXQgbmV3IGNvbmZpZycsIG5ld1Byb2plY3RDb25maWcpO1xuICAgIC8vIG4uYi4gbm90aGluZyBpcyBzYXZlZCBoZXJlIC0gXCJzYXZpbmdcIiBvbmx5IGhhcHBlbnMgYXMgaW4gXCJzdG9yZSBpbiBvdXIgZGF0YSBzdHJ1Y3R1cmVcIlxuICAgIHNhdmVQcm9qZWN0Q29uZmlnKG5ld1Byb2plY3RDb25maWcsIHByb2plY3QpO1xuICAgIC8vIGJlZm9yZSB0aGVyZSB3YXMgYSBjaGVjayBkbyBub3QgY2xlYXIgdGhlIHZpZXcgaWYgdGhlIGFjdHVhbCBwcm9qZWN0IGlzIHRoZSBzYW1lLlxuICAgIC8vIFRoZSBwcm9ibGVtIGlzIGlmIHlvdSByZW1vdmUgYSBrZXkgaW4gdGhlIGVkaXRvciB2aWV3IHRoYW4gdGhlIHRyYW5zbGF0aW9uIHZpZXcgY2FuJ3RcbiAgICAvLyBkZXRlY3QgdGhpcy5cbiAgICB0cmFuc2xhdGlvblZpZXcuY2xlYXJWaWV3KCk7XG4gICAgY2FubnkuZmxvd0NvbnRyb2wuc2hvdygncmVzb3VyY2VCdW5kbGUnKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyUHJvamVjdChwcm9qZWN0RGF0YSwgcHJvamVjdCwgY2IpIHtcbiAgICB2YXIgY2F0ZWdvcmllcyA9IGdldENhdGVnb3JpZXNCeUtleXMocHJvamVjdERhdGEua2V5cyk7XG5cbiAgICBoYW5kbGVOZXdQcm9qZWN0Q29uZmlnKHByb2plY3REYXRhLCBwcm9qZWN0KTtcblxuICAgIE9iamVjdC5rZXlzKHByb2plY3REYXRhLmtleXMpLmZvckVhY2goZnVuY3Rpb24obGFuZykge1xuICAgICAgICB2YXIgc29ydGVkLCBkYXRhcyA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyhwcm9qZWN0RGF0YS5rZXlzW2xhbmddKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgZGF0YXMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHByb2plY3REYXRhLmtleXNbbGFuZ11ba2V5XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzb3J0ZWQgPSBkYXRhcy5zb3J0KHNvcnRCeUtleSk7XG5cbiAgICAgICAgc29ydGVkLmZvckVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgZXhpc3RpbmdLZXlzW2RhdGEua2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVE9ETyBwcm9qZWN0Q29uZmlnLnByb2plY3Qgd2lsbCBiZSByZW1vdmVkIGlmIHRoZSB0cmFkZSBjYWxsIG1vdmVkIHRvIHRoaXMgY29udHJvbGxlclxuICAgICAgICB0cmFuc2xhdGlvblZpZXcucHJpbnRCdW5kbGVUZW1wbGF0ZShzb3J0ZWQsIGxhbmcsIGF2YWlsYWJsZUxhbmd1YWdlcywgY2IgfHwgZnVuY3Rpb24oKSB7fSk7XG5cbiAgICAgICAgY2F0ZWdvcmllcy5mb3JFYWNoKGZ1bmN0aW9uKGNhdGVnb3J5KSB7XG4gICAgICAgICAgICB1cGRhdGVDYXRlZ29yeVdvcmRDb3VudChjYXRlZ29yeSwgbGFuZyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICByZW5hbWVDYXRlZ29yeTogZnVuY3Rpb24ob2xkTmFtZSwgbmV3TmFtZSkge1xuICAgICAgICB0b2FzdC5zaG93TWVzc2FnZSgnUmVuYW1lZCBjYXRlZ29yeSAnICsgb2xkTmFtZSArICcgdG8gJyArIG5ld05hbWUgKyAnIScpO1xuICAgICAgICB0cmFuc2xhdGlvblZpZXcucmVuYW1lQ2F0ZWdvcnkob2xkTmFtZSwgbmV3TmFtZSwgYXZhaWxhYmxlTGFuZ3VhZ2VzKTtcbiAgICB9LFxuICAgIHJlbW92ZUNhdGVnb3J5OiBmdW5jdGlvbihjYXROYW1lKSB7XG4gICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKCdSZW1vdmVkIGNhdGVnb3J5ICcgKyBjYXROYW1lICsgJyEnKTtcbiAgICAgICAgcmVtb3ZlQ2F0ZWdvcnlEYXRhKGNhdE5hbWUpO1xuICAgICAgICB0cmFuc2xhdGlvblZpZXcucmVtb3ZlQ2F0ZWdvcnkoY2F0TmFtZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBpcyBjYWxsZWQgaWYgdGhlIHVzZXIgcmVuYW1lIGtleSByZXF1ZXN0IHdhcyBzdWNjZXNzZnVsXG4gICAgICogQHBhcmFtIG5ld0tleVxuICAgICAqIEBwYXJhbSBvbGRLZXlcbiAgICAgKi9cbiAgICByZW5hbWVLZXk6IGZ1bmN0aW9uKG9sZEtleSwgbmV3S2V5KSB7XG4gICAgICAgIGlmIChvbGRLZXkpIHtcbiAgICAgICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKCdLZXkgcmVuYW1lZCBzdWNjZXNzZnVsISBGcm9tICcgKyBvbGRLZXkgKyAnIHRvICcgKyBuZXdLZXkpO1xuICAgICAgICAgICAgdHJhbnNsYXRpb25WaWV3LnJlbmFtZUtleShvbGRLZXksIG5ld0tleSwgYXZhaWxhYmxlTGFuZ3VhZ2VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKCdLZXkgcmVuYW1lZCBmYWlsZWQhJyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZUtleTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKCdLZXkgcmVtb3ZlZCBzdWNjZXNzZnVsIScsIGtleSk7XG4gICAgICAgIHRyYW5zbGF0aW9uVmlldy5yZW1vdmVLZXkoa2V5KTtcbiAgICB9LFxuICAgIGltYWdlUmVtb3ZlZDogZnVuY3Rpb24oY2F0ZWdvcnlOYW1lKSB7XG4gICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKCdJbWFnZSByZW1vdmVkIGZvciBjYXRlZ29yeTogJyArIGNhdGVnb3J5TmFtZSk7XG4gICAgICAgIHRyYW5zbGF0aW9uVmlldy5yZW1vdmVJbWFnZShjYXRlZ29yeU5hbWUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogV2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgY29tcGxldGUgSlNPTiBvYmplY3QgZnJvbSBhIHNwZWNpZmljIHByb2plY3RcbiAgICAgKiBAcGFyYW0gcHJvamVjdERhdGFcbiAgICAgKi9cbiAgICBvbkxvYWRQcm9qZWN0OiBmdW5jdGlvbihwcm9qZWN0RGF0YSwgcHJvamVjdCkge1xuICAgICAgICBvcmRlcmVkTGFuZ3VhZ2VzID0gcHJvamVjdERhdGEuYXZhaWxhYmxlTGFuZ3VhZ2VzO1xuICAgICAgICB2YXIgYW5jaG9yID0gdXJsLmhhc0FuY2hvcigpID8gdXJsLmdldEFuY2hvcigpLnJlcGxhY2UoJyMnLCAnJykgOiBmYWxzZTtcbiAgICAgICAgcmVuZGVyUHJvamVjdChwcm9qZWN0RGF0YSwgcHJvamVjdCwgZnVuY3Rpb24odmlld0lkKSB7XG4gICAgICAgICAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZpZXdJZCA9PT0gYW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb20gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0cmFuc2xhdGlvblZpZXcuY29uZmlnLnJvd1ByZWZpeCArIHZpZXdJZCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvIHRoZSBlbGVtZW50IGV4aXN0cz9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdWlFdmVudHMuY2FsbFVpZXZlbnQoJ2FuY2hvckZvY3VzJywgdXJsLmdldEFuY2hvcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHlSZWN0ID0gZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGVsZW1SZWN0LnRvcCAtIGJvZHlSZWN0LnRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gYWRkIHRoZSBkZXNjcmlwdGlvbnNcbiAgICAgICAgY2FubnkudHJhbnNsYXRpb25WaWV3RGVzY3JpcHRpb24uYWRkRGVzY3JpcHRpb25zKHByb2plY3REYXRhLmtleURlc2NyaXB0aW9ucyk7XG4gICAgICAgIE9iamVjdC5rZXlzKHByb2plY3REYXRhLmltYWdlcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIC8vIGltYWdlcyB3aXRob3V0IGEgc2xhc2ggYXQgZnJvbnQgYXJlIG9sZCBpbWFnZSB1cGxvYWQgLSB0aGlzIGlzIG9ubHkgdG8gYmUgYmFja3dhcmQgY29tcGF0aWJsZVxuICAgICAgICAgICAgY29uc3QgdXJsID0gcHJvamVjdERhdGEuaW1hZ2VzW2tleV1bMF0gPT09ICcvJyA/IHByb2plY3REYXRhLmltYWdlc1trZXldIDogYC8ke3Byb2plY3QuaWR9LyR7cHJvamVjdERhdGEuaW1hZ2VzW2tleV19YFxuICAgICAgICAgICAgY2FubnkudHJhbnNsYXRpb25WaWV3SW1hZ2VVcGxvYWQuYXBwZW5kSW1hZ2Uoa2V5LCB1cmwpO1xuICAgICAgICB9KVxuICAgIH0sXG4gICAgb25OZXdQcm9qZWN0Q3JlYXRlZDogZnVuY3Rpb24ocHJvamVjdERhdGEsIHByb2plY3QpIHtcbiAgICAgICAgb3JkZXJlZExhbmd1YWdlcyA9IHByb2plY3REYXRhLmF2YWlsYWJsZUxhbmd1YWdlcztcbiAgICAgICAgcmVuZGVyUHJvamVjdChwcm9qZWN0RGF0YSwgcHJvamVjdCk7XG4gICAgfVxufTsiLCJcbi8qKlxuICogY29udHJvbGxlciBmb3IgdGhlIGltYWdlIHVwbGFvZGVyIHZpZXcgLSBjYWxscyB0aGUgc2VydmVyIHRvIHVwbG9hZCBhIGltYWdlIGFuZCBub3RpZmllciB0aGUgdWkgZXZlbnQgaGFuZGxlclxuICogQHR5cGUge3t9fVxuICovXG52YXIgY2FubnkgPSByZXF1aXJlKCdjYW5ueScpLFxuICAgIHVwbG9hZCA9IGNhbm55LnVwbG9hZCxcbiAgICBkaXNwbGF5TWFuYWdlciA9IGNhbm55LmRpc3BsYXlNYW5hZ2VyLFxuICAgIHVpRXZlbnRzID0gcmVxdWlyZSgnLi4vdWlFdmVudE1hbmFnZXIuanMnKSxcbiAgICB1cGxvYWRJZCxcbiAgICBwcm9qZWN0SW5mbztcbi8qKlxuICogQ2FsbCB0aGlzIGZvciBlYWNoIGZpbGUgLSB3aWxsIGNhbGwgYSBjYWxsIGJhY2sgd2l0aCB0aGUgc2VydmVyIGFuc3dlclxuICogQHBhcmFtIGZpbGVcbiAqL1xuZnVuY3Rpb24gc2VuZEZpbGUoZmlsZSwgZGlyZWN0Q2FsbGJhY2spIHtcbiAgICB2YXIgdXJpID0gJy91cGxvYWRGaWxlP3Byb2plY3RJZD0nICsgcHJvamVjdEluZm8uaWQgKyAnJmtleT0nICsgdXBsb2FkSWQgKyAnJnByb2plY3Q9JyArIHByb2plY3RJbmZvLm5hbWUsXG4gICAgICAgIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLFxuICAgICAgICBmZCA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gICAgeGhyLm9wZW4oXCJQT1NUXCIsIHVyaSwgdHJ1ZSk7XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09IDQgJiYgeGhyLnN0YXR1cyA9PSAyMDApIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSByZXNwb25zZS5cbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgZGlyZWN0Q2FsbGJhY2sgJiYgZGlyZWN0Q2FsbGJhY2soZGF0YSk7IC8vIGhhbmRsZSByZXNwb25zZS5cbiAgICAgICAgICAgIC8vIHtmaWxlOiBcIi8vc3ViL3N1YjEvc3ViMV9ibHVlX2Nva2UuanBnXCIsIG5hbWU6IFwic3ViMV9ibHVlX2Nva2UuanBnXCIsIHR5cGU6IFwiaW1hZ2UvanBnXCJ9XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgICAgIHVpRXZlbnRzLmNhbGxVaWV2ZW50KCdmaWxlVXBsb2FkZWQnLCBwcm9qZWN0SW5mby5pZCwgdXBsb2FkSWQsIGRhdGEuZmlsZSlcbiAgICAgICAgfVxuICAgIH07XG4gICAgZmQuYXBwZW5kKCdteUZpbGUnLCBmaWxlKTtcbiAgICAvLyBJbml0aWF0ZSBhIG11bHRpcGFydC9mb3JtLWRhdGEgdXBsb2FkXG4gICAgeGhyLnNlbmQoZmQpO1xufVxuXG4vKipcbiAqIFNhdmUgZGF0YSBpbiBtZW1iZXIgdmFyaWFibGUgdXNlZCBieSBmdXJ0aGVyIHVwbG9hZCBvcGVyYXRpb25zXG4gKiBAcGFyYW0gZGF0YTogUHJvamVjdCBkYXRhXG4gKi9cbmZ1bmN0aW9uIGFwcGx5UHJvamVjdERhdGEoZGF0YSwgcHJvamVjdCkge1xuICAgIHByb2plY3RJbmZvID0gcHJvamVjdDtcbn1cblxudWlFdmVudHMuYWRkVWlFdmVudExpc3RlbmVyKHtcbiAgICBzaG93RmlsZVVwbG9hZCA6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB1cGxvYWRJZCA9IGlkO1xuICAgICAgICBkaXNwbGF5TWFuYWdlci5zaG93KCd1cGxvYWRWaWV3Jyk7XG4gICAgfVxufSk7XG5cbnVwbG9hZC5vblVwbG9hZChmdW5jdGlvbiAoZmlsZSkge1xuICAgIC8vIFRPRE8gYWRkaXRpb25hbCB0byB0aGUgdXBsb2FkIGlkIHdlIG5lZWQgdGhlIHByb2plY3QgSURcbiAgICBjb25zb2xlLmxvZygndXBsb2FkQ29udHJvbGxlcjp1cGxvYWQgaWQ6IGZpbGU6JywgdXBsb2FkSWQsIGZpbGUpO1xuICAgIHNlbmRGaWxlKGZpbGUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG9uTmV3UHJvamVjdENyZWF0ZWQgOiBhcHBseVByb2plY3REYXRhLFxuICAgIG9uTG9hZFByb2plY3QgOiBhcHBseVByb2plY3REYXRhXG59OyIsInZhciB0cmFkZSA9IHJlcXVpcmUoJy4uL3RyYWRlJyksXG4gICAgdWlFdmVudHMgPSByZXF1aXJlKCcuLi91aUV2ZW50TWFuYWdlcicpLFxuICAgIHVybCA9IHJlcXVpcmUoJy4uL3V0aWwvdXJsJyk7XG4vKipcbiAqIFRPRE8gaGFuZGxlIHRoZSBicm93c2VyIGJhY2sgYW5kIG5leHQgYnV0dG9uIGFuZCBsb2FkIHRoZSBjb3JyZWN0IHZpZXdcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc0FqYXhEYXRhKHJlc3BvbnNlLCB1cmxQYXRoKXtcbiAgICBkb2N1bWVudC50aXRsZSA9IHJlc3BvbnNlLnBhZ2VUaXRsZTtcbiAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoe1xuICAgICAgICBcImh0bWxcIjogcmVzcG9uc2UuaHRtbCxcbiAgICAgICAgXCJwYWdlVGl0bGVcIjogcmVzcG9uc2UucGFnZVRpdGxlLFxuICAgICAgICBpZCA6IHJlc3BvbnNlLmlkLFxuICAgICAgICBpc1Byb2plY3QgOiByZXNwb25zZS5pc1Byb2plY3RcbiAgICB9LFwiXCIsIHVybFBhdGggKyB1cmwuZ2V0QW5jaG9yKCkpO1xufVxuXG4vKipcbiAqIE1hbmlwdWxhdGUgYnJvd3NlciBoaXN0b3J5IC8gbG9jYXRpb24gd2l0aCBnaXZlbiBwcm9qZWN0IGRhdGFcbiAqIEBwYXJhbSBkYXRhOiBQcm9qZWN0IHJlbGF0ZWQgZGF0YVxuICovXG5mdW5jdGlvbiBhcHBseVByb2plY3REYXRhKGRhdGEsIHByb2plY3QpIHtcbiAgICAvLyBhZGQgdGhlIHByb2plY3QgcGF0aCB0byB0aGUgVVJMXG4gICAgaWYgKHByb2plY3QubmFtZSkge1xuICAgICAgICBwcm9jZXNzQWpheERhdGEoe1xuICAgICAgICAgICAgcGFnZVRpdGxlIDogcHJvamVjdC5pZCxcbiAgICAgICAgICAgIGh0bWw6JycsXG4gICAgICAgICAgICBpZCA6IHByb2plY3QuaWQsXG4gICAgICAgICAgICBpc1Byb2plY3QgOiB0cnVlXG4gICAgICAgICAgICAvLyB0byBwZXJzaXN0cyB0aGUgbGlua3Mgd2Ugc2F2ZSB0aGUgaWQgaW4gVVJMIC0gaXQncyBub3QgaHVtYW4gcmVhZGFibGUgYnV0IGxpbmtzIHdpbGwgd29yayBmb3JldmVyXG4gICAgICAgIH0sICcvJyArIHByb2plY3QuaWQgKyAnLnByaicpO1xuICAgIH1cbn1cblxudWlFdmVudHMuYWRkVWlFdmVudExpc3RlbmVyKHtcbiAgICBhbmNob3JGb2N1cyA6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAvLyBzZXQgdGhlIGFuY2hvciB0byB0aGUgVVJMXG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShudWxsLCBudWxsLCBpZClcbiAgICB9XG59KTtcblxud2luZG93Lm9ucG9wc3RhdGUgPSBmdW5jdGlvbiAoZSkge1xuLy8gICAgY29uc29sZS5sb2coJ29ucG9wc3RhdGUnLCBlLnN0YXRlLmlkKTtcbiAgICBpZiAoZS5zdGF0ZSkge1xuICAgICAgICBpZiAoZS5zdGF0ZS5pc1Byb2plY3QpIHtcbiAgICAgICAgICAgIHRyYWRlLmxvYWRQcm9qZWN0KGUuc3RhdGUuaWQsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigndXJsTWFuaXB1bGF0b3I6bG9hZFByb2plY3QgZmFpbHMgZm9yIHByb2plY3RJZDonLCBlLnN0YXRlLmlkKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyYWRlLmdldERpcmVjdG9yeShlLnN0YXRlLmlkLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBjYWxsIHRoZVxuICAgICAgICAgICAgICAgICAgICB1aUV2ZW50cy5jYWxsVWlldmVudCgnc2hvd092ZXJ2aWV3UGFnZScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd1cmxNYW5pcHVsYXRvcjpnZXREaXJlY3RvcnkgY2FuIG5vdCBsb2FkIHByb2plY3QgZm9yIGRpcmVjdG9yeSBuYW1lOicsIGUuc3RhdGUuaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFRPRE8gdGhlcmUgaXMgYSBwcm9ibGVtIHdpdGggYWN0aXZhdGluZyB0aGUgcHJvamVjdCB2aWV3IG9yIHRoZSBvdmVydmlldyBwYWdlLi4uXG4gKlxuICoganVzdCB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIGNhbGxiYWNrc1xuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgb25Mb2FkUHJvamVjdCA6IGFwcGx5UHJvamVjdERhdGEsXG4gICAgb25OZXdQcm9qZWN0Q3JlYXRlZCA6IGFwcGx5UHJvamVjdERhdGEsXG4gICAgZ2V0RGlyZWN0b3J5OiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBwcm9jZXNzQWpheERhdGEoe1xuICAgICAgICAgICAgcGFnZVRpdGxlIDogJ3RyYW5zbGF0cm9uIG92ZXJ2aWV3JyxcbiAgICAgICAgICAgIGh0bWw6JycsXG4gICAgICAgICAgICBpZCA6IGRhdGEuY3VycmVudERpcmVjdG9yeSxcbiAgICAgICAgICAgIGlzUHJvamVjdCA6IGZhbHNlXG4gICAgICAgIH0sIGRhdGEuY3VycmVudERpcmVjdG9yeSk7XG4gICAgfVxufTsiLCIvKipcbiAqIENyZWF0ZWQgYnkgZWlnaHR5Zm91ci5cbiAqXG4gKiBBbGwgc2VydmVyIGV2ZW50cy4gTXVsdGlwbGUgY2xpZW50cyBjYW4gcmVnaXN0ZXIgb24gZWFjaCBldmVudFxuICogYW5kIHdpbGwgYmUgbm90aWZpZWQgaWYgbWV0aG9kIGlzIGNhbGxlZCBmcm9tIHNlcnZlci5cbiAqXG4gKiBUT0RPIFJFTkFNRSBGSUxFXG4gKiBUT0RPIHRvIHdoYXQ/IDopXG4gKiBXaGF0IGFib3V0IFwiZXh0ZXJuYWxDaGFuZ2VOb3RpZmljYXRpb25zXCI/XG4gKlxuICogVEJEIHdoeSBkb24ndCB3ZSBpbnRlZ3JhdGUgdGhpcyBvbmUgd2l0aCB1aSBldmVudHM/IHRoYXQgd291bGQgY3V0IGRvd24gb24gdGhlIG51bWJlciBvZiBjb21wb25lbnRzIHdlIGhhdmUgYW5kIHdlIFwib25seVwiICg/KVxuICogaGF2ZSB0byBkbyBzb21lIHNlbnNpYmxlIHJlbmFtaW5nIG9mIGV2ZW50cywgbGlrZSByZW5hbWluZyBhbGwgZXZlbnRzIGhhbmRsZWQgaGVyZSBieSBhZGRpbmcgXCJleHRlcm5hbFwiIG9yIHNpbWlsYXJcbiAqIChlLmcuIFwia2V5VXBkYXRlZFwiIGJlY29tZXMgXCJrZXlVcGRhdGVkRXh0ZXJuYWxseVwiKS5cbiAqL1xudmFyIGV2ZW50cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGV2ZW50UXVldWUgPSB7fSxcbiAgICAgICAgY2FsbFF1ZXVlID0gZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdnb3Qgbm90aWZpY2F0aW9uIGZvciAnLCBuYW1lLCAnd2l0aCBwYXlsb2FkJywgYXJncyk7XG4gICAgICAgICAgICBpZiAoZXZlbnRRdWV1ZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGV2ZW50UXVldWVbbmFtZV0ubWFwKGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgICAgICAgICBmYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZXJ2ZXJFdmVudHMgOiB7XG4gICAgICAgICAgICAvLyBUQkQgY2FuIGJlIHJlbW92ZWQ/XG4gICAgICAgICAgICBzZW5kRmlsZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjYWxsUXVldWUoJ3NlbmRGaWxlJywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBUQkQgY2FuIGJlIHJlbW92ZWQ/XG4gICAgICAgICAgICBzZW5kUGF0aExpc3QgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2FsbFF1ZXVlKCdzZW5kUGF0aExpc3QnLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtleVVwZGF0ZWQgOiBmdW5jdGlvbiAocHJvamVjdElkLCBsYW5ndWFnZSwga2V5TmFtZSwga2V5VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYWxsUXVldWUoJ2tleVVwZGF0ZWQnLCBbIHByb2plY3RJZCwgbGFuZ3VhZ2UsIGtleU5hbWUsIGtleVZhbHVlIF0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uS2V5Q2xvbmVkIDogZnVuY3Rpb24ocHJvamVjdElkLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgY2FsbFF1ZXVlKCdvbktleUNsb25lZCcsIFtwcm9qZWN0SWQsIGRhdGFdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBrZXlSZW5hbWVkIDogZnVuY3Rpb24ocHJvamVjdElkLCBvbGRLZXlOYW1lLCBuZXdLZXlOYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FsbFF1ZXVlKCdrZXlSZW5hbWVkJywgWyBwcm9qZWN0SWQsIG9sZEtleU5hbWUsIG5ld0tleU5hbWUgXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gYnVuZGxlT2JqIHtsb2NhbGU6IHN0cmluZywgYnVuZGxlOiBzdHJpbmd9XG4gICAgICAgICAgICAgKiBAcGFyYW0gZGF0YSB7b2xkS2V5OnN0cmluZywgbmV3S2V5OiBzdHJpbmd9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGtleURlbGV0ZWQgOiBmdW5jdGlvbiAocHJvamVjdElkLCBrZXlOYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FsbFF1ZXVlKCdrZXlEZWxldGVkJywgWyBwcm9qZWN0SWQsIGtleU5hbWUgXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW1hZ2VSZW1vdmVkIDogZnVuY3Rpb24gKHByb2plY3RJZCwgY2F0ZWdvcnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FsbFF1ZXVlKCdpbWFnZVJlbW92ZWQnLCBbIHByb2plY3RJZCwgY2F0ZWdvcnlOYW1lIF0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5ld1Byb2plY3RXYXNDcmVhdGVkIDogZnVuY3Rpb24gKHByb2plY3RJZCkge1xuICAgICAgICAgICAgICAgIGNhbGxRdWV1ZSgnbmV3UHJvamVjdFdhc0NyZWF0ZWQnLCBbIHByb2plY3RJZCBdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYXRlZ29yeVJlbmFtZWQgOiBmdW5jdGlvbiAocHJvamVjdElkLCBvbGROYW1lLCBuZXdOYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FsbFF1ZXVlKCdjYXRlZ29yeVJlbmFtZWQnLCBbIHByb2plY3RJZCwgb2xkTmFtZSwgbmV3TmFtZSBdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYXRlZ29yeURlbGV0ZWQgOiBmdW5jdGlvbiAocHJvamVjdElkLCBjYXROYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FsbFF1ZXVlKCdjYXRlZ29yeURlbGV0ZWQnLCBbIHByb2plY3RJZCwgY2F0TmFtZSBdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXdEaXJlY3RvcnlDcmVhdGVkIDogZnVuY3Rpb24gKGRpcmVjdG9yeUlkKSB7XG4gICAgICAgICAgICAgICAgY2FsbFF1ZXVlKCduZXdEaXJlY3RvcnlDcmVhdGVkJywgWyBkaXJlY3RvcnlJZCBdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm9qZWN0RGVzY3JpcHRpb25VcGRhdGVkIDogZnVuY3Rpb24gKHByb2plY3RJZCwgaWQsIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgY2FsbFF1ZXVlKCdwcm9qZWN0RGVzY3JpcHRpb25VcGRhdGVkJywgWyBwcm9qZWN0SWQsIGlkLCBkZXNjcmlwdGlvbiBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWRkU2VydmVyTGlzdGVuZXIgOiBmdW5jdGlvbiAobmFtZSwgY2IpIHtcbiAgICAgICAgICAgIGlmIChldmVudFF1ZXVlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRRdWV1ZVtuYW1lXS5wdXNoKGNiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXZlbnRRdWV1ZVtuYW1lXSA9IFtjYl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBldmVudHM7IiwiY29uc3QgQyA9IHJlcXVpcmUoJy4vQ09OU1QnKVxuY29uc3QgY29ubmVjdGlvbkxvc3QgPSByZXF1aXJlKCcuL3VpTW9kdWxlcy9jb25uZWN0aW9uTG9zdCcpXG5cbi8qKlxuICogUmVmcmVzaCB0aGUgdXNlciBzZXNzaW9uIGFuZCBkZXRlY3RzIGlmIHRoZSB1c2VyIGlzIG5vdCBhdXRoZW50aWNhdGVkIGFueW1vcmVcbiAqIHVzZWZ1bCBmb3I6XG4gKiAgKiBzZXNzaW9uIGtlZXAgYWxpdmVcbiAqICAqIGRldGVjdCBpZiB0aGUgdXNlciBpcyBub3QgYXV0aGVudGljYXRlZCBhbnltb3JlXG4gKiAgKiBkZXRlY3RzIHNlcnZlciBzaHV0IGRvd25cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYW5kbGVTZXNzaW9uVGltZU91dCgpIHtcbiAgICBjb25zdCBjb25uZWN0aW9uTG9zdFVpID0gY29ubmVjdGlvbkxvc3Qoe1xuICAgICAgICBvblJlbG9hZCA6ICgpID0+IGxvY2F0aW9uLnJlbG9hZCgpLFxuICAgICAgICBvbkNsb3NlIDogKCkgPT4gY29ubmVjdGlvbkxvc3RVaS5kZXN0cm95KClcbiAgICB9KVxuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZldGNoKGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGxvY2F0aW9uLmhvc3QgKyAnL3RvdWNoU2Vzc2lvbicsIHtcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiBcInNhbWUtb3JpZ2luXCJcbiAgICAgICAgfSkudGhlbihkID0+IHtcbiAgICAgICAgICAgIGlmIChkLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbClcbiAgICAgICAgICAgICAgICAvLyB3aG9vcHMgc2VydmVyIGhhcyBubyBhdXRoZW50aWNhdGlvbiBhbnltb3JlLi4uXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbkxvc3RVaS5yZW5kZXIoJ0FVVEgnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpXG4gICAgICAgICAgICBjb25uZWN0aW9uTG9zdFVpLnJlbmRlcignU0VSVkVSX0RPV04nLCAnTWF5YmUgYSBzZXJ2ZXIgcmVzdGFydCBoYXBwZW5zLiBQbGVhc2UgdHJ5IHRvIGxvZ2luIGFnYWluIGluIGZldyBtaW51dGVzJylcbiAgICAgICAgfSlcbiAgICB9LCBDLlNFU1NJT04ucmVuZXdhbF9pbnRlcnZhbF9pbl9tcylcbn0iLCIvKmdsb2JhbCBkb21PcHRzICovXG4vKmpzbGludCBicm93c2VyOiB0cnVlICovXG5jb25zdCB1bmljb2RlID0gcmVxdWlyZSgnLi91bmljb2RlLmpzJylcbmNvbnN0IHRvYXN0ID0gcmVxdWlyZSgnLi9Ub2FzdC5qcycpXG5jb25zdCBjYW5ueSA9IHJlcXVpcmUoJ2Nhbm55JylcbmNvbnN0IHRyYWRlID0gcmVxdWlyZSgnLi90cmFkZS5qcycpXG5jb25zdCBoYW5kbGVTZXNzaW9uVGltZU91dCA9IHJlcXVpcmUoJy4vaGFuZGxlU2Vzc2lvblRpbWVPdXQnKVxuY29uc3QgYnJlYWRDcnVtYkNvbnRyb2xsZXIgPSByZXF1aXJlKCcuL2NvbnRyb2xsZXIvYnJlYWRjcnVtYkNvbnRyb2xsZXIuanMnKVxuY29uc3QgeyBDb25zb2xlUmVwb3J0ZXIgfSA9IHJlcXVpcmUoJ2phc21pbmUnKVxuXG53aW5kb3cuZG9tT3B0cyA9IHdpbmRvdy5kb21PcHRzIHx8IHJlcXVpcmUoJ2RvbS1vcHRzJyk7XG4vLyBtYWRlIGl0IHB1YmxpYyAtIGp1c3QgZm9yIGRldmVsb3BtZW50XG53aW5kb3cuY2FubnkgPSBjYW5ueTtcblxuY2FubnkuYWRkKCdyZXBlYXQnLCAgICAgICAgIHJlcXVpcmUoJ2Nhbm55L21vZC9yZXBlYXQnKSk7XG5jYW5ueS5hZGQoJ3doaXNrZXInLCAgICAgICAgcmVxdWlyZSgnY2FubnkvbW9kL3doaXNrZXInKSk7XG5jYW5ueS5hZGQoJ2FzeW5jJywgICAgICAgICAgcmVxdWlyZSgnY2FubnkvbW9kL2FzeW5jJykpO1xuY2FubnkuYWRkKCdmbG93Q29udHJvbCcsICAgIHJlcXVpcmUoJ2Nhbm55L21vZC9mbG93Q29udHJvbCcpKCdmbG93Q29udHJvbCcpKTtcbmNhbm55LmFkZCgnZGlzcGxheU1hbmFnZXInLCByZXF1aXJlKCcuL3VpTW9kdWxlcy9kaXNwbGF5TWFuYWdlci5qcycpKTtcbmNhbm55LmFkZCgndGV4dEVkaXRvcicsICAgICByZXF1aXJlKCcuL3RleHRFZGl0b3IuanMnKSk7XG5jYW5ueS5hZGQoJ2Nvb2tpZU1hbmFnZXInLCAgcmVxdWlyZSgnY2FubnktY29va2llTWFuYWdlci1saWInKSk7XG5cbmNhbm55LmFkZCgndGV4dHMnLCAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vdWlNb2R1bGVzL3RleHRzLmpzJykpO1xuY2FubnkuYWRkKCdhdXRoJywgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi91aU1vZHVsZXMvYXV0aC5qcycpKTtcbmNhbm55LmFkZCgncHJvamVjdE1haW5OYXZpZ2F0aW9uJywgIHJlcXVpcmUoJy4vdWlNb2R1bGVzL3Byb2plY3RNYWluTmF2aWdhdGlvbi5qcycpKTtcbmNhbm55LmFkZCgndHJhbnNsYXRpb25WaWV3JywgICAgICAgIHJlcXVpcmUoJy4vdWlNb2R1bGVzL3RyYW5zbGF0aW9uVmlldy5qcycpKTtcbmNhbm55LmFkZCgndHJhbnNsYXRpb25WaWV3SW1hZ2VVcGxvYWQnLCByZXF1aXJlKCcuL3VpTW9kdWxlcy90cmFuc2xhdGlvblZpZXdJbWFnZVVwbG9hZC5qcycpKTtcbi8vY2FubnkuYWRkKCd0cmFuc2xhdGlvblZpZXdIZWFkZXInLCAgcmVxdWlyZSgnLi91aU1vZHVsZXMvdHJhbnNsYXRpb25WaWV3SGVhZGVyLmpzJykpO1xuY2FubnkuYWRkKCdpbWFnZVZpZXdlcicsICAgICAgICAgICAgcmVxdWlyZSgnLi91aU1vZHVsZXMvaW1hZ2VWaWV3ZXIuanMnKSk7XG5jYW5ueS5hZGQoJ3Byb2plY3RPdmVydmlldycsICAgICAgICByZXF1aXJlKCcuL3VpTW9kdWxlcy9wcm9qZWN0T3ZlcnZpZXcuanMnKSk7XG5jYW5ueS5hZGQoJ2NyZWF0ZU5ld1Byb2plY3QnLCAgICAgICByZXF1aXJlKCcuL3VpTW9kdWxlcy9jcmVhdGVOZXdQcm9qZWN0LmpzJykpO1xuY2FubnkuYWRkKCdtZW51UmlnaHQnLCAgICAgICAgICAgICAgcmVxdWlyZSgnLi91aU1vZHVsZXMvbWVudVJpZ2h0LmpzJykpO1xuY2FubnkuYWRkKCdhbmNob3JNZW51JywgICAgICAgICAgICAgcmVxdWlyZSgnLi91aU1vZHVsZXMvYW5jaG9yTWVudS5qcycpKTtcbi8vIFRPRE86IFB1dCBiZWhpbmQgZmxhZyBzZWFyY2hcbmNhbm55LmFkZCgnc2VhcmNoQmFyJywgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vdWlNb2R1bGVzL3NlYXJjaEJhci9pbmRleC5qcycpKTtcblxuY2FubnkuYWRkKCd0cmFuc2xhdGlvblZpZXdEZXNjcmlwdGlvbicsIHJlcXVpcmUoJy4vdWlNb2R1bGVzL3RyYW5zbGF0aW9uVmlld0Rlc2NyaXB0aW9uLmpzJykpO1xuY2FubnkuYWRkKCd1cGxvYWQnLCAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi91aU1vZHVsZXMvdXBsb2FkLmpzJykpO1xuY2FubnkuYWRkKCdKTUJGVXBsb2FkZXInLCAgICAgICAgICAgcmVxdWlyZSgnLi91aU1vZHVsZXMvSk1CRlVwbG9hZGVyLmpzJykpO1xuY2FubnkuYWRkKCdKc29uSW1wb3J0JywgICAgICAgICAgIHJlcXVpcmUoJy4vdWlNb2R1bGVzL0pzb25JbXBvcnQuanMnKSk7XG5jYW5ueS5hZGQoJ2xvYWRpbmdNb2RhbCcsICAgICAgICAgICByZXF1aXJlKCcuL3VpTW9kdWxlcy9sb2FkaW5nTW9kYWwnKSk7XG5cbnRyYWRlLmFkZENvbnRyb2xsZXIocmVxdWlyZSgnLi9jb250cm9sbGVyL3Byb2plY3RNYWluTmF2aWdhdGlvbkNvbnRyb2xsZXIuanMnKSk7XG50cmFkZS5hZGRDb250cm9sbGVyKHJlcXVpcmUoJy4vY29udHJvbGxlci9wYWdlSGVhZGVyQ29udHJvbGxlci5qcycpKTtcbnRyYWRlLmFkZENvbnRyb2xsZXIocmVxdWlyZSgnLi9jb250cm9sbGVyL3RyYW5zbGF0aW9uVmlld0NvbnRyb2xsZXIuanMnKSk7XG50cmFkZS5hZGRDb250cm9sbGVyKHJlcXVpcmUoJy4vY29udHJvbGxlci90ZXh0RWRpdG9yQ29udHJvbGxlci5qcycpKTtcbnRyYWRlLmFkZENvbnRyb2xsZXIocmVxdWlyZSgnLi9jb250cm9sbGVyL3VybE1hbmlwdWxhdG9yLmpzJykpO1xudHJhZGUuYWRkQ29udHJvbGxlcihyZXF1aXJlKCcuL2NvbnRyb2xsZXIvcHJvamVjdE92ZXJ2aWV3Q29udHJvbGxlci5qcycpKTtcbnRyYWRlLmFkZENvbnRyb2xsZXIocmVxdWlyZSgnLi9jb250cm9sbGVyL2NyZWF0ZU5ld1Byb2plY3RDb250cm9sbGVyLmpzJykpO1xudHJhZGUuYWRkQ29udHJvbGxlcihicmVhZENydW1iQ29udHJvbGxlcik7XG50cmFkZS5hZGRDb250cm9sbGVyKHJlcXVpcmUoJy4vY29udHJvbGxlci9hdXRoQ29udHJvbGxlci5qcycpKTtcbnRyYWRlLmFkZENvbnRyb2xsZXIocmVxdWlyZSgnLi9jb250cm9sbGVyL21lbnVSaWdodENvbnRyb2xsZXIuanMnKSk7XG50cmFkZS5hZGRDb250cm9sbGVyKHJlcXVpcmUoJy4vY29udHJvbGxlci91cGxvYWRDb250cm9sbGVyLmpzJykpO1xudHJhZGUuYWRkQ29udHJvbGxlcihyZXF1aXJlKCcuL2NvbnRyb2xsZXIvSk1CRlVwbG9hZGVyQ29udHJvbGxlci5qcycpKTtcbnRyYWRlLmFkZENvbnRyb2xsZXIocmVxdWlyZSgnLi9jb250cm9sbGVyL0pzb25JbXBvcnRDb250cm9sbGVyLmpzJykpO1xuLy8gVE9ETzogUHV0IGJlaGluZCBmbGFnIHNlYXJjaFxudHJhZGUuYWRkQ29udHJvbGxlcihyZXF1aXJlKCcuL2NvbnRyb2xsZXIvc2VhcmNoQ29udHJvbGxlci5qcycpKTtcblxuY2FubnkucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIC8vIGNyZWF0ZSB3ZWJzb2NrZXQgY29ubmVjdGlvbiB2aWEgdHJhZGVcbiAgICB0cmFkZS5pbml0aWFsaXplKGZ1bmN0aW9uICh1c2VyT2JqZWN0LCBzZXNzaW9uc0VuYWJsZWQpIHtcblxuICAgICAgICBpZiAodXNlck9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgYWxlcnQoJ0EgZmF0YWwgZXJyb3IgaGFwcGVucyB3aGlsZSBsb2FkaW5nIHRoZSB2aWV3JylcbiAgICAgICAgICAgIGxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBjYW5ueS50ZXh0cy5zZXRUZXh0cyh7dXNlck5hbWU6IHVzZXJPYmplY3QubmFtZX0pO1xuXG4gICAgICAgIGlmICh1c2VyT2JqZWN0LmlzQWRtaW4pIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnaXNBZG1pbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlc3Npb25zRW5hYmxlZCkge1xuICAgICAgICAgICAgLy8gdHJpZ2dlciBhIFwic2Vzc2lvbiBrZWVwIGFsaXZlXCIgYW5kIGRldGVjdHMgaWYgdGhlIHVzZXIgaXMgbm90IGF1dGhlbnRpY2F0ZWQgYW55bW9yZSBvciB0aGUgc2VydmVyIGlzIGRvd25cbiAgICAgICAgICAgIGhhbmRsZVNlc3Npb25UaW1lT3V0KClcbiAgICAgICAgfVxuXG4gICAgfSk7XG59KTtcblxud2luZG93LmNhbm55ID0gY2Fubnk7XG53aW5kb3cuZG9tT3B0cyA9IHJlcXVpcmUoJ2RvbS1vcHRzJyk7XG53aW5kb3cudW5pY29kZSA9IHVuaWNvZGU7XG53aW5kb3cudG9hc3QgPSB0b2FzdDtcblxuLy8gUVVFU1RJT046IGNhbiBpdCBoYXBwZW4gdGhhdCB0aGUgYWJvdmUgY2FsbCB0byB0cmFkZS5pbml0aWFsaXplIChpbiBjYW5ueS5yZWFkeSkgZmluaXNoZXMgZWFybGllciB0aGFuIHRoZSBuZXh0IGxpbmVzP1xuLy8gaS5lLiB0aGUgY2FsbGJhY2sgZm9yIHRyYWRlLnJlYWR5IHdpbGwgbmV2ZXIgYmUgZXhlY3V0ZWQ/IGlmIHllczogd2h5IG5vdCBwYXNzIHRoZSBjYWxsYmFjayBhbHJlYWR5IHRvIHRyYWRlLmluaXRpYWxpemU/XG50cmFkZS5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGNvbnN0IHByaiA9IChmdW5jdGlvbiBnZXRQcm9qZWN0TmFtZUFuZFBhdGhGcm9tVVJMKCkge1xuICAgICAgICBjb25zdCBzcGxpdCA9IGxvY2F0aW9uLnBhdGhuYW1lLnNwbGl0KCcvJylcbiAgICAgICAgbGV0IHBhdGggPSBsb2NhdGlvbi5wYXRobmFtZVxuICAgICAgICBsZXQgcHJqTmFtZVxuICAgICAgICBcbiAgICAgICAgaWYgKC9cXC5wcmovLnRlc3Qoc3BsaXRbc3BsaXQubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgLnByaiBleHRlbnNpb24gYW5kIGZpcnN0IHNsYXNoXG4gICAgICAgICAgICBwcmpOYW1lID0gcGF0aC5yZXBsYWNlKCcucHJqJywgJycpLnJlcGxhY2UoJy8nLCAnJylcbiAgICAgICAgICAgIHBhdGggPSBzcGxpdC5zbGljZSgwLCAtMSkuam9pbignLycpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChwYXRoWzBdICE9PSAnLycpIHtcbiAgICAgICAgICAgIHBhdGggPSAnLycgKyBwYXRoXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXRoIDogcGF0aCxcbiAgICAgICAgICAgIHByb2plY3RJZCA6IHByak5hbWVcbiAgICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgLy8gUVVFU1RJT046IHNpbmNlIHRoaXMgaXMgd29ya2luZyBvbiB0aGUgVVJMIHRoZSBhcHBsaWNhdGlvbiB3YXMgbG9hZGVkIHdpdGggYW5kIHRoaXMgVVJMIGNhbiBiZSBlaXRoZXIgYSBkaXJlY3RvcnkgVVJMXG4gICAgLy8gb3IgYSBwcm9qZWN0IFVSTDogd2h5IGNhbid0IHdlIGRlY2lkZSBmaXJzdCB3aGF0IHdlIGFjdHVhbGx5IGhhdmUgaW4gdGhlIFVSTCBhbmQgdGhlbiBlaXRoZXIgY2FsbCBnZXREaXJlY3RvcnlcbiAgICAvLyBvciBsb2FkUHJvamVjdD8gQU5TV0VSOiBkZXBlbmRzLiBpZiB0aGUgVVJMIHBvaW50cyB0byBhIGRpcmVjdG9yeSwgd2Ugb25seSBoYXZlIHRvIGRvIHRoZSBnZXREaXJlY3RvcnkgY2FsbC5cbiAgICAvLyBpZiB0aGUgVVJMIGlzIGEgcHJvamVjdCwgdHdvIGNhbGxzIGhhdmUgdG8gYmUgbWFkZTogb25lIGxvYWRQcm9qZWN0IGNhbGwgYW5kIG9uZSBleHRyYSBnZXREaXJlY3RvcnkgY2FsbCBmb3IgdGhlXG4gICAgLy8gcGFyZW50IG9mIHRoZSBwcm9qZWN0IChtYWlubHkgZm9yIG5hdmlnYXRpb24gY29tcG9uZW50IHdoaWNoIG5lZWRzIHRvIGtub3cgdGhlIHNpYmxpbmdzIG9mIHRoZSBwcm9qZWN0KS4gQnV0OiB0YWtlXG4gICAgLy8gY2FyZSB0aGF0IHRoaXMgZXh0cmEgZ2V0RGlyZWN0b3J5IG11c3QgKm5vdCogY2hhbmdlIHRoZSBzdGF0ZSBvZiB0aGUgYnJlYWRjcnVtYiB0cmFpbCAodGhhdCBvbmUgc2hvdWxkIHN0aWxsIHNob3dcbiAgICAvLyB0aGUgc2VsZWN0ZWQgcHJvamVjdClcbiAgICBcbiAgICBcbiAgICBpZiAocHJqLnByb2plY3RJZCkge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBpbml0aWFsIGNhbGwgdG8gdHJpZ2dlciBhIHByb2plY3QgbG9hZCAtIHlvdSB3aWxsIGdldFxuICAgICAgICAvLyB0aGUgcHJvamVjdC5qc29uIGFuZCBhbGwgdHJhbnNsYXRpb25zXG4gICAgICAgIHRyYWRlLmxvYWRQcm9qZWN0KHByai5wcm9qZWN0SWQsIGZ1bmN0aW9uIChlcnIsIGRhdGEsIHByb2plY3QpIHtcbiAgICAgICAgICAgIC8vIGNhbGxiYWNrIGlzIG9ubHkgY2FsbGVkIGlmIGFuIGVycm9yIG9jY3Vyc1xuICAgICAgICAgICAgaWYgKGVyciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKCdMb2FkaW5nIHByb2plY3QgXFwnJyArIHByai5wcm9qZWN0SWQgKyAnXFwnIGZhaWxlZCAtIHByb2plY3QgZG9lc25cXCd0IGV4aXN0cycpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3RyYW5zbGF0aW9uVmlld0NvbnRyb2xsZXI6bG9hZFByb2plY3QgZmFpbHMgZm9yIHByb2plY3RJZDonLCBwcmoucHJvamVjdElkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVxdWlyZWQgZm9yIHRoZSBicmVhZGNydW1iXG4gICAgICAgICAgICAgICAgYnJlYWRDcnVtYkNvbnRyb2xsZXIuc2V0UGF0aChwcm9qZWN0LnVybClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgICB0cmFkZS5nZXREaXJlY3RvcnkocHJqLnBhdGgsIGZ1bmN0aW9uIChvYmopIHsgfSk7XG4gICAgfVxuICAgIFxufSk7IiwiLyoqXG4gKiB0ZXh0RWRpdG9yXG4gKi9cbihmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgdGV4dEVkaXRvciA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIHRleHRzID0ge1xuICAgICAgICAgICAgb3JpZ2luVGV4dCA6ICdEb3VibGUgY2xpY2sgdG8gZWRpdCB0aGlzIHRleHQnLFxuICAgICAgICAgICAgZWRpdEJ0biA6ICdFZGl0JyxcbiAgICAgICAgICAgIGNhbmNlbEJ0biA6ICdDYW5jZWwnLFxuICAgICAgICAgICAgY2hhbmdlQnRuIDogJ1NhdmUgY2hhbmdlcydcbiAgICAgICAgfSxcbiAgICAgICAgb25DaGFuZ2VBbGxMaXN0ID0gW107XG5cbiAgICAgICAgZnVuY3Rpb24gZmluZENsb3Nlc3RBbmNlc3RvcldpdGhJZChlbGVtZW50KSB7XG4gICAgICAgICAgICB3aGlsZSAoKGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQpICYmICFlbGVtZW50LmlkKSB7fVxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjYWxsQ2hhbmdlTGlzdChpZCwgdmFsdWUsIGZjKSB7XG4gICAgICAgICAgICBvbkNoYW5nZUFsbExpc3QuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IoaWQsIHZhbHVlLCBmYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGVkaXRXaXRoVGV4dGFyZWEobm9kZSwgYnV0dG9uV3JhcCwgb2JqKSB7XG4gICAgICAgICAgICB2YXIgb3BlbiA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRpdldyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICAgICAgICBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICAgICAgICBjYW5jZWxCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICAgICAgICBhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKSxcbiAgICAgICAgICAgICAgICBqc1RleHROO1xuXG4gICAgICAgICAgICBpZiAob2JqICYmIG9iai5oYXNPd25Qcm9wZXJ0eSgncGxhY2Vob2xkZXInKSkge1xuICAgICAgICAgICAgICAgIGFyZWEuc2V0QXR0cmlidXRlKCdwbGFjZWhvbGRlcicsIG9iai5wbGFjZWhvbGRlcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgndGV4dEVkaXRvci1oaWRlJyk7XG4gICAgICAgICAgICAgICAgb3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBlZGl0KCkge1xuICAgICAgICAgICAgICAgIGlmICghb3Blbikge1xuICAgICAgICAgICAgICAgICAgICBqc1RleHROID0gbm9kZS5xdWVyeVNlbGVjdG9yKCcuanMtdGV4dCcpO1xuICAgICAgICAgICAgICAgICAgICBvcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXJlYS52YWx1ZSA9IGpzVGV4dE4uaW5uZXJIVE1MO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZSgndGV4dEVkaXRvci1oaWRlJylcbiAgICAgICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNldCBjbGFzc2VzXG4gICAgICAgICAgICBjYW5jZWxCdXR0b24uY2xhc3NOYW1lID0gJ3RleHRFZGl0b3ItYnV0dG9uIHRleHRFZGl0b3ItYnV0dG9uLWNhbmNlbCBvY3RpY29uIG9jdGljb24teCc7XG4gICAgICAgICAgICBidXR0b24uY2xhc3NOYW1lID0gJ3RleHRFZGl0b3ItYnV0dG9uIHRleHRFZGl0b3ItYnV0dG9uLWNoYW5nZSBvY3RpY29uIG9jdGljb24tY2hlY2snO1xuICAgICAgICAgICAgYXJlYS5jbGFzc05hbWUgPSAndGV4dEVkaXRvci1hcmVhJztcbiAgICAgICAgICAgIGRpdldyYXBwZXIuY2xhc3NOYW1lID0gJ3RleHRFZGl0b3Itd3JhcC1hcmVhJztcbiAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgndGV4dEVkaXRvci1oaWRlJyk7XG5cbiAgICAgICAgICAgIC8vIHJlZ2lzdGVyIGxpc3RlbmVyc1xuICAgICAgICAgICAgY2FuY2VsQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xvc2UpO1xuICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBhcmVhLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpZCA9IGZpbmRDbG9zZXN0QW5jZXN0b3JXaXRoSWQodGhpcykuaWQsXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGNhbGxDaGFuZ2VMaXN0KGlkLCB2YWwsIGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzVGV4dE4uaW5uZXJIVE1MID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigndGV4dEVkaXRvcjp0b1RleHRhcmVhTm9kZSB0ZXh0IG5vdCBhY2NlcHRlZCEgSWdub3JlIGNoYW5nZXMuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgZWRpdCk7XG5cbiAgICAgICAgICAgIC8vIHNldCB0aXRsZXNcbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd0aXRsZScsIHRleHRzLm9yaWdpblRleHQpO1xuICAgICAgICAgICAgY2FuY2VsQnV0dG9uLnNldEF0dHJpYnV0ZSgndGl0bGUnLCB0ZXh0cy5jYW5jZWxCdG4pO1xuICAgICAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgndGl0bGUnLCB0ZXh0cy5jaGFuZ2VCdG4pO1xuXG4gICAgICAgICAgICAvLyBhcHBlbmQgdG8gd3JhcHBlciBkaXZcbiAgICAgICAgICAgIGRpdldyYXBwZXIuYXBwZW5kQ2hpbGQoYXJlYSk7XG4gICAgICAgICAgICBidXR0b25XcmFwLmFwcGVuZENoaWxkKGNhbmNlbEJ1dHRvbik7XG4gICAgICAgICAgICBidXR0b25XcmFwLmFwcGVuZENoaWxkKGJ1dHRvbik7XG5cbiAgICAgICAgICAgIC8vIGFwcGVuZCB0byBwYXJlbnRcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoZGl2V3JhcHBlcik7XG5cbiAgICAgICAgICAgIC8vIHJldHVybiBjbGljayBmdW5jdGlvblxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wZW4pIHsgLy8gc2hvdyBpbnB1dFxuICAgICAgICAgICAgICAgICAgICBlZGl0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gc2hvdyB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVnaXN0ZXIgYSBmdW5jdGlvbiB0byBhIHNwZWNpZmljIGVkaXRvci5cbiAgICAgICAgICAgICAqIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIHVuZGVmaW5lZCB0aGFuIHRoZSBlZGl0b3IgZXhwZWN0IHRoYXQgdGhlIHBhc3NlZCBjYWxsYmFja1xuICAgICAgICAgICAgICogaXMgY2FsbGVkIHdpdGggdHJ1ZSBvciBmYWxzZS4gSWYgdGhlIG1ldGhvZCByZXR1cm5zIHRydWUgdGhlIHRleHQgd2lsbCBjaGFuZ2UuXG4gICAgICAgICAgICAgKiBJZiB0aGUgbWV0aG9kIHJldHVybnMgZmFsc2UgdGhlIHRleHQgaXMgbm90IGNoYW5nZWQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIGlkXG4gICAgICAgICAgICAgKiBAcGFyYW0gZmMgPC0gaXMgY2FsbGVkIHdpdGggKHRleHRWYWx1ZSwgY2FsbGJhY2tGdW5jdGlvbikgY2FuIHJldHVybiB1bmRlZmluZWQsIGZhbHNlIGFuZCB0cnVlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG9uQ2hhbmdlIDogZnVuY3Rpb24gKGZjKSB7XG4gICAgICAgICAgICAgICAgb25DaGFuZ2VBbGxMaXN0LnB1c2goZmMpO1xuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSBpZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhZGQgOiBmdW5jdGlvbiAobm9kZSwgb2JqKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ1dHRvbldyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICAgICAgICAgICAgZWRpdEljb25CdXR0b24gPSAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgYnV0dG9uV3JhcC5jbGFzc05hbWUgPSd0ZXh0RWRpdG9yLWJ1dHRvbldyYXAnO1xuICAgICAgICAgICAgICAgIGVkaXRJY29uQnV0dG9uLmNsYXNzTmFtZSA9ICd0ZXh0RWRpdG9yLWJ1dHRvbiB0ZXh0RWRpdG9yLWJ1dHRvbi1lZGl0IG9jdGljb24gb2N0aWNvbi1wZW5jaWwnO1xuICAgICAgICAgICAgICAgIGVkaXRJY29uQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZWRpdFdpdGhUZXh0YXJlYShub2RlLCBidXR0b25XcmFwLCBvYmopKTtcbiAgICAgICAgICAgICAgICBlZGl0SWNvbkJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgdGV4dHMuZWRpdEJ0bik7XG4gICAgICAgICAgICAgICAgLy8gYXBwZW5kIGVkaXRJY29uQnV0dG9uIHRvIHBhcmVudFxuICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgndGV4dEVkaXRvci1tYWluLXdyYXAnKTtcbiAgICAgICAgICAgICAgICBidXR0b25XcmFwLmFwcGVuZENoaWxkKGVkaXRJY29uQnV0dG9uKTtcbiAgICAgICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGJ1dHRvbldyYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSgpKTtcblxuICAgIC8vIGV4cG9ydCBhcyBtb2R1bGUgb3IgYmluZCB0byBnbG9iYWxcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmhhc093blByb3BlcnR5KCdleHBvcnRzJykpIHsgbW9kdWxlLmV4cG9ydHMgPSB0ZXh0RWRpdG9yOyB9IGVsc2Uge2Nhbm55LmFkZCgndGV4dEVkaXRvcicsIHRleHRFZGl0b3IpOyB9XG5cbn0oKSk7IiwiLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSAqL1xuLyoqXG4gKiBoYW5kbGUgdGhlIGNvbm5lY3Rpb24gYmV0d2VlbiBzZXJ2ZXIgYW5kIGNsaWVudFxuICovXG5jb25zdCBjYW5ueSA9IHJlcXVpcmUoJ2Nhbm55JylcbmNvbnN0IGV2ZW50cyA9IHJlcXVpcmUoJy4vZXZlbnRzLmpzJylcbmNvbnN0IHNob2UgPSByZXF1aXJlKCdzaG9lJylcbmNvbnN0IGRub2RlID0gcmVxdWlyZSgnZG5vZGUtd2Vhay1uYXBpJylcbmNvbnN0IGNvbm5lY3Rpb25Mb3N0ID0gcmVxdWlyZSgnLi91aU1vZHVsZXMvY29ubmVjdGlvbkxvc3QvaW5kZXguanMnKVxuXG53aW5kb3cuZG9tT3B0cyA9IHdpbmRvdy5kb21PcHRzIHx8IHJlcXVpcmUoJ2RvbS1vcHRzJyk7XG5cbi8qKlxuICogU29tZSBvZiB0aGUgY2FsbGJhY2tzIGFyZSBoYW5kbGVkIHZpYSB0aGUgcmVnaXN0ZXJlZCBjb250cm9sbGVyIC0gYWRkQ29udHJvbGxlciBtZXRob2QuXG4gKi9cbnZhciB0cmFkZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgLy8gcmVhZHkgcXVldWUgY2FsbCByZWdpc3RlcmVkIGNhbGwgYmFja3Mgd2hlbiB0cmFkZSBpcyByZWFkeVxuICAgIHZhciBjYnMgPSBbXSxcbiAgICAgICAgc2VydmVyLFxuICAgICAgICByZWdpc3RlcmVkQ29udHJvbGxlciA9IFtdLFxuICAgICAgICAvLyB0aGlzIGZsYWcgc2hvdWxkIGJlIHRydWUgaWYgdGhlcmUgaXMgYSBzdGFibGUgc2VydmVyIGNvbm5lY3Rpb25cbiAgICAgICAgaGFzU2VydmVyQ29ubmVjdGlvbiA9IGZhbHNlLFxuICAgICAgICB0cnlUb1JlY29ubmVjdCA9IGZhbHNlLFxuICAgICAgICBjb25uZWN0aW9uTG9zdFVpID0gY29ubmVjdGlvbkxvc3Qoe1xuICAgICAgICAgICAgb25SZWxvYWQgOiAoKSA9PiBsb2NhdGlvbi5yZWxvYWQoKSxcbiAgICAgICAgICAgIG9uUmVjb25uZWN0IDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeVRvUmVjb25uZWN0ID0gdHJ1ZVxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25Mb3N0VWkuc2hvd1Byb2dyZXNzKClcbiAgICAgICAgICAgICAgICBzdHJlYW0gPSBzaG9lKCcvdHJhZGUnKVxuICAgICAgICAgICAgICAgIGNyZWF0ZUNvbm5lY3Rpb24oKHVzZXJPYmplY3QsIHNlc3Npb25zRW5hYmxlZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXNlck9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgY2FzZSB3aGVuIHRoZSBzZXNzaW9uIGVuZHMgb24gc2VydmVyIHNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25Mb3N0VWkucmVuZGVyKCdSRUNPTk5FQ1RfRkFJTCcpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uTG9zdFVpLmRlc3Ryb3koKVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5VG9SZWNvbm5lY3QgPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNsb3NlIDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25Mb3N0VWkuZGVzdHJveSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgbGV0IHN0cmVhbSA9IHNob2UoJy90cmFkZScpXG4gICAgbGV0IGRcblxuICAgIGZ1bmN0aW9uIGluaXQocywgZmMpIHtcbiAgICAgICAgc2VydmVyID0gcztcblxuICAgICAgICBpZiAoc2VydmVyLnNlYXJjaFRlcm0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2Fubnkuc2VhcmNoQmFyLnNob3coKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXJ2ZXIuc2V0VXNlclJpZ2h0cykge1xuICAgICAgICAgICAgc2VydmVyLnNldFVzZXJSaWdodHMoY2FubnkuY29va2llTWFuYWdlci5mb3JTZXNzaW9uQ29va2llKCd0cmFuc2xhdHJvbl9zZXNzaW9uJykuZ2V0VmFsdWVzKCksIGZjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZjKHtuYW1lOidMb2dvdXQnLCBpc0FkbWluOiB0cnVlfSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VydmVyLmF0dGFjaENsaWVudENhbGxiYWNrcyhldmVudHMuc2VydmVyRXZlbnRzKTtcbiAgICAgICAgLy8gY2FsbCByZWFkeSBxdWV1ZVxuICAgICAgICBjYnMubWFwKGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uKGZjKSB7XG4gICAgICAgIGQgPSBkbm9kZSgpXG4gICAgICAgIGQub24oJ3JlbW90ZScsIGZ1bmN0aW9uIChzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGhhc1NlcnZlckNvbm5lY3Rpb24gPSB0cnVlXG4gICAgICAgICAgICBpbml0KHNlcnZlciwgZmMpO1xuICAgICAgICB9KVxuICAgICAgICBkLm9uKCdmYWlsJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKVxuICAgICAgICAgICAgaGFzU2VydmVyQ29ubmVjdGlvbiA9IGZhbHNlXG4gICAgICAgICAgICBjb25uZWN0aW9uTG9zdFVpLnJlbmRlcignQ09OTkVDVElPTl9GQUlMJylcbiAgICAgICAgfSlcbiAgICAgICAgZC5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpXG4gICAgICAgICAgICAvLyBzb21ldGhpbmcgaGFwcGVuc1xuICAgICAgICAgICAgLy8gZS5nLiBhIFVJIHVwZGF0ZSB0aHJvd3MgYW4gZXhjZXB0aW9uXG4gICAgICAgICAgICBoYXNTZXJ2ZXJDb25uZWN0aW9uID0gZmFsc2VcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Mb3N0VWkucmVuZGVyKCdFWENFUFRJT04nLCBlcnIubmFtZSlcbiAgICAgICAgfSlcbiAgICAgICAgZC5vbignZW5kJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBjYWxsZWQgaWYgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VzIGZyb20gc2VydmVyXG4gICAgICAgICAgICBoYXNTZXJ2ZXJDb25uZWN0aW9uID0gZmFsc2VcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3RyYWRlOmVuZCcsIGVycik7XG4gICAgICAgICAgICAvLyB0aGUgc2V0VGltZW91dCBpcyBmb3IgYXZvaWQgZmxpY2tlcmluZyBpZiBwYWdlIHJlbG9hZCB2aWEgZS5nLiBGNVxuICAgICAgICAgICAgaWYgKHRyeVRvUmVjb25uZWN0KVxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25Mb3N0VWkucmVuZGVyKCdSRUNPTk5FQ1RfRkFJTCcpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBjb25uZWN0aW9uTG9zdFVpLnJlbmRlcignQ09OTkVDVElPTl9FTkQnKSwgMTAwMClcbiAgICAgICAgfSlcbiAgICAgICAgZC5waXBlKHN0cmVhbSkucGlwZShkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgY29ubmVjdGlvbiBpcyBhdmFpbGFibGUgLSBvdGhlcndpc2Ugc2VuZCB2aWV3IGVycm9yXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNDb25uZWN0ZWQoKSB7XG4gICAgICAgIGlmIChoYXNTZXJ2ZXJDb25uZWN0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgY29ubmVjdGlvbkxvc3RVaS5yZW5kZXIoJ1JFQ09OTkVDVCcpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGZ1bmN0aW9uTmFtZSB0aGUgZnVuY3Rpb24gdG8gY2FsbFxuICAgICAqIEBwYXJhbSBhcmdzIGFuIGFycmF5IG9mIHBhcmFtZXRlcnMgd2hpY2ggYXJlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWxsQ29udHJvbGxlcihmdW5jdGlvbk5hbWUsIGFyZ3MpIHtcbiAgICAgICAgcmVnaXN0ZXJlZENvbnRyb2xsZXIuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbGxlcikge1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuaGFzT3duUHJvcGVydHkoZnVuY3Rpb25OYW1lKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjb250cm9sbGVyOicsIGZ1bmN0aW9uTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcltmdW5jdGlvbk5hbWVdLmFwcGx5KG51bGwsIGFyZ3MpXG4gICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25Mb3N0VWkucmVuZGVyKCdGQVRBTCcsIGUubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGluaXRpYWxpemUgOiBmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgICAgIGNyZWF0ZUNvbm5lY3Rpb24oZmMpXG4gICAgICAgIH0sXG4gICAgICAgIGFkZENvbnRyb2xsZXIgOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZWdpc3RlcmVkQ29udHJvbGxlci5wdXNoKG9iaik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2FkIHRoZSB3aG9sZSBwcm9qZWN0IGZpbGVzIHdpdGggYWxsIHJlcXVpcmVkIGRhdGEgKHByb2plY3Qgc3BlY2lmaWMganNvbilcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb2plY3RJZFxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYlxuICAgICAgICAgKi9cbiAgICAgICAgbG9hZFByb2plY3QgOiBmdW5jdGlvbiAocHJvamVjdElkLCBjYikge1xuICAgICAgICAgICAgc2VydmVyLmxvYWRQcm9qZWN0KHByb2plY3RJZCwgZnVuY3Rpb24gKGRhdGEsIHtpZCwgbmFtZSwgdXJsfSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG92ZXJ3cml0ZSBwcm9qZWN0IGlkXG4gICAgICAgICAgICAgICAgICAgIGRhdGEucHJvamVjdElkID0gaWRcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wcm9qZWN0ID0gbmFtZVxuICAgICAgICAgICAgICAgICAgICBjYWxsQ29udHJvbGxlcignb25Mb2FkUHJvamVjdCcsIFtkYXRhLCB7aWQsIG5hbWUsIHVybH1dKTtcbiAgICAgICAgICAgICAgICAgICAgY2IgJiYgY2IobnVsbCwgZGF0YSwge2lkLCBuYW1lLCB1cmx9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsYmFjayBhIGVycm9yIHNvIHRoZSBjYWxsZXIgaGFzIHRoZSBjb250cm9sIGFib3V0IGVycm9yIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVmYWN0b3IgY29kZSBhbmQgbWFrZSB1c2Ugb2YgZXJyb3Igb2JqZWN0IGluc3RlYWQgb2YgZmFsc2UgLSBhbmQgcGFzcyBlbXB0eSBvYmplY3QgdG8gb3RoZXIgYXJncyBpbnN0ZWFkIG9mIG5vdGhpbmdcbiAgICAgICAgICAgICAgICAgICAgY2IgJiYgY2IoZmFsc2UpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhY3R1YWxseSBzYW1lIGFzIHNhdmVLZXkgYnV0IHRoZSBpbnRlcm5hbCBjb250cm9sbGVyIGNhbGwgaXMgZGlmZmVyZW50XG4gICAgICAgICAqIEBwYXJhbSBwcm9qZWN0SWRcbiAgICAgICAgICogQHBhcmFtIGxhbmd1YWdlXG4gICAgICAgICAqIEBwYXJhbSBrZXlBbmRWYWx1ZVxuICAgICAgICAgKiBAcGFyYW0gY2JcbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUtleSA6IGZ1bmN0aW9uIChwcm9qZWN0SWQsIGxhbmd1YWdlLCBrZXlBbmRWYWx1ZSwgY2IpIHtcbiAgICAgICAgICAgIGlmIChpc0Nvbm5lY3RlZCgpKVxuICAgICAgICAgICAgICAgIHNlcnZlci5zYXZlS2V5KHByb2plY3RJZCwgbGFuZ3VhZ2UsIGtleUFuZFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlcnIsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gaGFuZGxlIGVycm9yIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IocHJvamVjdElkLCBsYW5ndWFnZSwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbENvbnRyb2xsZXIoJ29uQ3JlYXRlS2V5JywgW3Byb2plY3RJZCwgbGFuZ3VhZ2UsIGtleSwgdmFsdWVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwcm9qZWN0SWRcbiAgICAgICAgICogQHBhcmFtIHt7aWQgOnN0cmluZywgc291cmNlQ2F0ZWdvcnk6c3RyaW5nLCB0YXJnZXRDYXRlZ29yeTpzdHJpbmd9fSBrZXlBbmRWYWx1ZVxuICAgICAgICAgKiBAcGFyYW0gY2JcbiAgICAgICAgICovXG4gICAgICAgIGNsb25lS2V5OiBmdW5jdGlvbihwcm9qZWN0SWQsIGtleUFuZFZhbHVlLCBjYikge1xuICAgICAgICAgICAgaWYgKGlzQ29ubmVjdGVkKCkpXG4gICAgICAgICAgICAgICAgc2VydmVyLmNsb25lS2V5KHByb2plY3RJZCwga2V5QW5kVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGVyciwgcHJvamVjdElkLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYihlcnIsIHByb2plY3RJZCwgZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb250cm9sbGVyKCdvbktleUNsb25lZCcsIFtwcm9qZWN0SWQsIGRhdGFdKVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2F2ZSBjaGFuZ2VzIHRvIGEga2V5J3MgdmFsdWUuIENoYW5nZSB3aWxsIGJlIGJyb2FkY2FzdCB0byBvdGhlciBjbGllbnRzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvamVjdElkXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZVxuICAgICAgICAgKiBAcGFyYW0ge3trZXk6c3RyaW5nLCB2YWx1ZTpzdHJpbmd9fSBrZXlBbmRWYWx1ZVxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiAtIGNhbGxiYWNrIHRvIGV4ZWN1dGUgYWZ0ZXIgc2F2aW5nXG4gICAgICAgICAqL1xuICAgICAgICBzYXZlS2V5IDogZnVuY3Rpb24gKHByb2plY3RJZCwgbGFuZ3VhZ2UsIGtleUFuZFZhbHVlLCBjYikge1xuICAgICAgICAgICAgaWYgKGlzQ29ubmVjdGVkKCkpXG4gICAgICAgICAgICAgICAgc2VydmVyLnNhdmVLZXkocHJvamVjdElkLCBsYW5ndWFnZSwga2V5QW5kVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGVyciwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBoYW5kbGUgZXJyb3IgY2FzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYihwcm9qZWN0SWQsIGxhbmd1YWdlLCBrZXksIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb2plY3ROYW1lXG4gICAgICAgICAqIEBwYXJhbSBjdXJyZW50RGlySWQgaWYgb2YgdGhlIGRpcmVjdG9yeSBpbiB3aGljaCB0aGUgbmV3IHByb2plY3Qgd2lsbCBiZSBjcmVhdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVOZXdQcm9qZWN0IDogZnVuY3Rpb24gKHByb2plY3ROYW1lLCBjdXJyZW50RGlySWQpIHtcbiAgICAgICAgICAgIGlmIChpc0Nvbm5lY3RlZCgpKVxuICAgICAgICAgICAgICAgIHNlcnZlci5jcmVhdGVOZXdQcm9qZWN0KGN1cnJlbnREaXJJZCwgcHJvamVjdE5hbWUsIHt9LFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlcnIsIHByb2plY3REYXRhLCBwcm9qZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGhhbmRsZSBlcnJvciBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb250cm9sbGVyKCdvbk5ld1Byb2plY3RDcmVhdGVkJywgW3Byb2plY3REYXRhLCBwcm9qZWN0XSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3RvcnlOYW1lXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjdXJyZW50RGlyZWN0b3J5XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVOZXdEaXJlY3RvcnkgOiBmdW5jdGlvbihkaXJlY3RvcnlOYW1lLCBjdXJyZW50RGlyZWN0b3J5KSB7XG4gICAgICAgICAgICBpZiAoaXNDb25uZWN0ZWQoKSlcbiAgICAgICAgICAgICAgICBzZXJ2ZXIuY3JlYXRlTmV3RGlyZWN0b3J5KGRpcmVjdG9yeU5hbWUsIGN1cnJlbnREaXJlY3RvcnksXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGVyciwgZGlyZWN0b3J5RGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBoYW5kbGUgZXJyb3IgY2FzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsQ29udHJvbGxlcignb25OZXdEaXJlY3RvcnlDcmVhdGVkJywgW2RpcmVjdG9yeURhdGFdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVuYW1lcyBhIGNhdGVnb3J5LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvamVjdElkXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvbGROYW1lXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdOYW1lXG4gICAgICAgICAqL1xuICAgICAgICByZW5hbWVDYXRlZ29yeSA6IGZ1bmN0aW9uIChwcm9qZWN0SWQsIG9sZE5hbWUsIG5ld05hbWUpIHtcbiAgICAgICAgICAgIGlmIChpc0Nvbm5lY3RlZCgpKVxuICAgICAgICAgICAgICAgIHNlcnZlci5yZW5hbWVDYXRlZ29yeShwcm9qZWN0SWQsIG9sZE5hbWUsIG5ld05hbWUsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIsIG9sZE5hbWUsIG5ld05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbENvbnRyb2xsZXIoJ3JlbmFtZUNhdGVnb3J5JywgW29sZE5hbWUsIG5ld05hbWVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhIGNhdGVnb3J5IHdpdGggYWxsIGl0J3MgY2hpbGQga2V5cy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb2plY3RJZFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2F0TmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQ2F0ZWdvcnkgOiBmdW5jdGlvbiAocHJvamVjdElkLCBjYXROYW1lKSB7XG4gICAgICAgICAgICBpZiAoaXNDb25uZWN0ZWQoKSlcbiAgICAgICAgICAgICAgICBzZXJ2ZXIucmVtb3ZlQ2F0ZWdvcnkocHJvamVjdElkLCBjYXROYW1lLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyLCBjYXROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb250cm9sbGVyKCdyZW1vdmVDYXRlZ29yeScsIFtjYXROYW1lXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbmFtZXMgYSBrZXkgZm9yIGFsbCBsYW5ndWFnZXNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb2plY3RJZFxuICAgICAgICAgKiBAcGFyYW0ge3tuZXdLZXk6IHN0cmluZywgb2xkS2V5OiBzdHJpbmd9fSBvYmpcbiAgICAgICAgICovXG4gICAgICAgIHJlbmFtZUtleSA6IGZ1bmN0aW9uIChwcm9qZWN0SWQsIG9iaikge1xuICAgICAgICAgICAgaWYgKGlzQ29ubmVjdGVkKCkpXG4gICAgICAgICAgICAgICAgc2VydmVyLnJlbmFtZUtleShwcm9qZWN0SWQsIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3S2V5IDogb2JqLm5ld0tleSxcbiAgICAgICAgICAgICAgICAgICAgb2xkS2V5IDogb2JqLm9sZEtleVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIG9sZEtleSwgbmV3S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsQ29udHJvbGxlcigncmVuYW1lS2V5JywgW29sZEtleSwgbmV3S2V5XSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb250cm9sbGVyKCdyZW5hbWVLZXknLCBbZmFsc2VdKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYSBrZXkgZm9yIGFsbCBsYW5ndWFnZXMuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9qZWN0SWRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleU5hbWVcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2JcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUtleSA6IGZ1bmN0aW9uIChwcm9qZWN0SWQsIGtleU5hbWUsIGNiKSB7XG4gICAgICAgICAgICBpZiAoaXNDb25uZWN0ZWQoKSlcbiAgICAgICAgICAgICAgICBzZXJ2ZXIucmVtb3ZlS2V5KHByb2plY3RJZCwga2V5TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVyciwga2V5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYihrZXlOYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb250cm9sbGVyKCdyZW1vdmVLZXknLCBba2V5TmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvamVjdElkXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjYXRlZ29yeU5hbWVcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUltYWdlIDogZnVuY3Rpb24ocHJvamVjdElkLCBjYXRlZ29yeU5hbWUpIHtcbiAgICAgICAgICAgIGlmIChpc0Nvbm5lY3RlZCgpKVxuICAgICAgICAgICAgICAgIHNlcnZlci5yZW1vdmVJbWFnZShwcm9qZWN0SWQsIGNhdGVnb3J5TmFtZSwgZnVuY3Rpb24gKGVyciwgY2F0ZWdvcnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsQ29udHJvbGxlcignaW1hZ2VSZW1vdmVkJywgW2NhdGVnb3J5TmFtZV0pXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2FzdC5zaG93TWVzc2FnZShlcnIubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBHZXQgdGhlIGNvbnRlbnRzIG9mIHRoZSBkaXJlY3RvcnkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkaXIgdGhlIHNlbGVjdGVkIGRpcmVjdG9yeS5cbiAgICAgICAgICogQHBhcmFtIGNiIHtwcm9qZWN0czpbU3RyaW5nXTpkaXJzOltTdHJpbmddfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RGlyZWN0b3J5IDogZnVuY3Rpb24gKGRpciwgY2IpIHtcbiAgICAgICAgICAgIGlmIChpc0Nvbm5lY3RlZCgpKVxuICAgICAgICAgICAgICAgIHNlcnZlci5nZXREaXJlY3RvcnkoZGlyLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9hc3Quc2hvd01lc3NhZ2UoJ0ludGVybmFsIHNlcnZlciBlcnJvciEgUGxlYXNlIHJlcG9ydCB0aGlzIG1lc3NhZ2UgdG8gYSBkZXZlbG9wZXI6ICcgKyBlcnIubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyci5tZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBjYWxsIHRoZSBjb250cm9sbGVyIGlmIG5vdCBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2IgJiYgY2IoYXJncylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb250cm9sbGVyKCdnZXREaXJlY3RvcnknLCBbYXJnc10pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzYXZlIHRoZSBwcm9qZWN0IGRlc2NyaXB0aW9uXG4gICAgICAgICAqIEBwYXJhbSBwcm9qZWN0SWRcbiAgICAgICAgICogQHBhcmFtIGlkXG4gICAgICAgICAqIEBwYXJhbSBkZXNjcmlwdGlvblxuICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgICAgICovXG4gICAgICAgIHNhdmVQcm9qZWN0RGVzY3JpcHRpb24gOiBmdW5jdGlvbihwcm9qZWN0SWQsIGlkLCBkZXNjcmlwdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChpc0Nvbm5lY3RlZCgpKVxuICAgICAgICAgICAgICAgIHNlcnZlci5zYXZlUHJvamVjdERlc2NyaXB0aW9uKHByb2plY3RJZCwgaWQsIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sodHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsQ29udHJvbGxlcignc2F2ZWRQcm9qZWN0RGVzY3JpcHRpb24nLCBbXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb3ZlIGEgcHJvamVjdC4gQ2FuIGJlIHVzZWQgZm9yOlxuICAgICAgICAgKiAgKiBtb3ZlIHByb2plY3RcbiAgICAgICAgICogICogcmVuYW1lIHByb2plY3RcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSB0aGUgbmV3IFVSTCAob3B0aW9uYWwpXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5ldyBuYW1lIChvcHRpb25hbClcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgLSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZFxuICAgICAgICAgKi9cbiAgICAgICAgbW92ZVByb2plY3QgOiBmdW5jdGlvbiAoe2lkLCB1cmwsIG5hbWV9LCBjYikge1xuICAgICAgICAgICAgaWYgKGlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgICBzZXJ2ZXIubW92ZVByb2plY3Qoe2lkLCB1cmwsIG5hbWV9LCAoZXJyLCBwcm9qZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNiKGVyciwgcHJvamVjdCB8fCB7fSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVE9ETyBzdW1tYXJpemUgcHJvamVjdE5hbWUgKyBjdXJyZW50RGlySWQgdG8gb25lIHByb2plY3RJZFxuICAgICAgICAgKiBEZWxldGUgYSBwcm9qZWN0LlxuICAgICAgICAgKiBAcGFyYW0gcHJvamVjdE5hbWVcbiAgICAgICAgICogQHBhcmFtIGN1cnJlbnREaXJJZCAtIEBkZXByZWNhdGVkXG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAgICAgKi9cbiAgICAgICAgZGVsZXRlUHJvamVjdCA6IGZ1bmN0aW9uIChpZCwgY2IpIHtcbiAgICAgICAgICAgIGlmIChpc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgc2VydmVyLmRlbGV0ZVByb2plY3QoaWQsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIsIHByb2plY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBjaGFuZ2UgdG86IHByak5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYiAmJiBjYihudWxsLCBwcm9qZWN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb250cm9sbGVyKCdwcm9qZWN0RGVsZXRlZCcsIFtwcm9qZWN0XSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IgJiYgY2IoZXJyKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlIGEgcHJvamVjdC5cbiAgICAgICAgICogQHBhcmFtIGRpck5hbWVcbiAgICAgICAgICogQHBhcmFtIGN1cnJlbnREaXJJZFxuICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgICAgICovXG4gICAgICAgIGRlbGV0ZUZvbGRlciA6IGZ1bmN0aW9uIChpZCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChpc0Nvbm5lY3RlZCgpKVxuICAgICAgICAgICAgICAgIHNlcnZlci5kZWxldGVGb2xkZXIoaWQsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIsIGRpcklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG51bGwsIGRpcklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb250cm9sbGVyKCdmb2xkZXJEZWxldGVkJywgW2RpcklkXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZXJyKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2VhcmNoIHByb2plY3RzIGZvciBnaXZlbiB0ZXJtXG4gICAgICAgICAqIEBwYXJhbSBzZWFyY2hUZXJtXG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAgICAgKi9cbiAgICAgICAgc2VhcmNoVGVybTogZnVuY3Rpb24gKHNlYXJjaFRlcm0sIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoaXNDb25uZWN0ZWQoKSlcbiAgICAgICAgICAgICAgICBzZXJ2ZXIuc2VhcmNoVGVybShzZWFyY2hUZXJtLCBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhyZXN1bHRzKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbkxvc3RVaS5yZW5kZXIoJ1NFQVJDSF9FUlJPUicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgLy8gTm90IHJlYWxseSB0ZXN0ZWRcbiAgICAgICAgcmVhZHkgOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIGlmIChzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYnMucHVzaChjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSB0cmFkZTsiLCJ2YXIgdWlFdmVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50UXVldWVzID0ge1xuICAgICAgICAgICAgYWN0aXZhdGVMYW5ndWFnZSA6IFtdLFxuICAgICAgICAgICAgZGVBY3RpdmF0ZUxhbmd1YWdlIDogW10sXG4gICAgICAgICAgICBhZGRMYW5ndWFnZTogW10sXG4gICAgICAgICAgICBzaG93RXhwb3J0RGlhbG9nOiBbXSxcbiAgICAgICAgICAgIHByb2plY3RTZWxlY3RlZDogW10sXG4gICAgICAgICAgICBzaG93T3ZlcnZpZXdQYWdlOiBbXSxcbiAgICAgICAgICAgIHVwZGF0ZUtleTogW10sXG4gICAgICAgICAgICBhbmNob3JGb2N1czogW10sXG4gICAgICAgICAgICBlbmFibGVFZGl0b3JNb2RlOiBbXSxcbiAgICAgICAgICAgIHRvZ2dsZVdvcmRDb3VudDogW10sXG4gICAgICAgICAgICBzaG93RmlsZVVwbG9hZDogW10sXG4gICAgICAgICAgICBzaG93Sk1CRlVwbG9hZGVyOiBbXSxcbiAgICAgICAgICAgIHNob3dKU09OSW1wb3J0OiBbXSxcbiAgICAgICAgICAgIEpNQkZGaWxlVXBsb2FkZWQ6IFtdLFxuICAgICAgICAgICAganNvbkltcG9ydGVkOiBbXSxcbiAgICAgICAgICAgIGZpbGVVcGxvYWRlZDogW11cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZFVpRXZlbnRMaXN0ZW5lciA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50UXVldWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRRdWV1ZXNba2V5XS5wdXNoKG9ialtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FsbFVpZXZlbnQgOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgYXJnc0xpc3QgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoZXZlbnRRdWV1ZXMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgICAgIGV2ZW50UXVldWVzW2V2ZW50TmFtZV0uZm9yRWFjaChmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgICAgICAgICAgICBmYy5hcHBseShudWxsLCBhcmdzTGlzdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVpRXZlbnQ7XG4iLCIvKipcbiAqIHNob3dzIHRoZSB1cGxvYWRlciBmb3JtIHRvIHVwbG9hZCBhIGltYWdlIHRvIHRoZSBzZXJ2ZXJcbiAqL1xudmFyIG9uVXBsb2FkID0gZnVuY3Rpb24gKCkge30sXG4gICAgYnJhaW4gPSB7XG4gICAgICAgIGZpbGVJbnB1dCA6IHtcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB1cGxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuZnVuY3Rpb24gdXBsb2FkKCkge1xuICAgIGNvbnNvbGUubG9nKCdjLXVwbG9hZDp0cmlnZ2VyIHVwbG9hZCcpO1xuICAgIHZhciBmaWxlID0gdGhpcy5maWxlc1swXTtcbiAgICBpZiAoZmlsZSkge1xuICAgICAgICAvLyBzZW5kIGl0IGRpcmVjdCBhZnRlciBkcm9wXG4gICAgICAgIFtdLnNsaWNlLmNhbGwodGhpcy5maWxlcykuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICAgICAgLy8gVE9ETyBpbnN0ZWFkIHBhc3MgIGRpcmVjdGx5IGEgYXJyYXkgb2YgZmlsZXMgLSBzbyB3ZSBzYXZlIFBPU1QgY2FsbHNcbiAgICAgICAgICAgIG9uVXBsb2FkKGZpbGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gY2xlYW51cCB2YWx1ZSBvdGhlcndpc2UgZmlsZSB3aXRoIHNhbWUgbmFtZSBjYW4ndCB1cGxvYWRlZCBhZ2FpblxuICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICpcbiAqIEByZXR1cm5zIHt7YWRkOiBGdW5jdGlvbiwgcmVhZHk6IEZ1bmN0aW9ufX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgb25VcGxvYWQgOiBmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgb25VcGxvYWQgPSBmYztcbiAgICB9LFxuICAgIGFkZCA6IGZ1bmN0aW9uIChub2RlLCBhdHRyKSB7XG4gICAgICAgIGlmIChicmFpbi5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgICAgICAgICAgYnJhaW5bYXR0cl0uaW5pdChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn07IiwiLyoqXG4gKiBzaG93cyB0aGUgdXBsb2FkZXIgZm9ybSB0byB1cGxvYWQgYSBpbWFnZSB0byB0aGUgc2VydmVyXG4gKi9cbnZhciBvblVwbG9hZCA9IGZ1bmN0aW9uICgpIHt9LFxuICAgIGJyYWluID0ge1xuICAgICAgICBmaWxlSW5wdXQgOiB7XG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbmZ1bmN0aW9uIHVwbG9hZCgpIHtcbiAgICB2YXIgZmlsZSA9IHRoaXMuZmlsZXNbMF07XG4gICAgaWYgKGZpbGUpIHtcbiAgICAgICAgLy8gc2VuZCBpdCBkaXJlY3QgYWZ0ZXIgZHJvcFxuICAgICAgICBbXS5zbGljZS5jYWxsKHRoaXMuZmlsZXMpLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gaW5zdGVhZCBwYXNzICBkaXJlY3RseSBhIGFycmF5IG9mIGZpbGVzIC0gc28gd2Ugc2F2ZSBQT1NUIGNhbGxzXG4gICAgICAgICAgICBvblVwbG9hZChmaWxlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNsZWFudXAgdmFsdWUgb3RoZXJ3aXNlIGZpbGUgd2l0aCBzYW1lIG5hbWUgY2FuJ3QgdXBsb2FkZWQgYWdhaW5cbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqXG4gKiBAcmV0dXJucyB7e2FkZDogRnVuY3Rpb24sIHJlYWR5OiBGdW5jdGlvbn19XG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG9uVXBsb2FkIDogZnVuY3Rpb24gKGZjKSB7XG4gICAgICAgIG9uVXBsb2FkID0gZmM7XG4gICAgfSxcbiAgICBhZGQgOiBmdW5jdGlvbiAobm9kZSwgYXR0cikge1xuICAgICAgICBpZiAoYnJhaW4uaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgICAgICAgIGJyYWluW2F0dHJdLmluaXQobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG59OyIsIi8qKlxuICogYW5jaG9yTWVudVxuICpcbiAqIFRPRE8gc2hvdyB0aGUgYWN0dWFsIGZyYW1lOlxuICogICogZGV0ZWN0IHdoaWNoIGRvbWUgY2F0ZWdvcmllcyBpbiBkb20gYXJlIGluIHZpZXcgYW5kIGFkZCBhIGNsYXNzZXMgdG8gdGhlIG1lbnUgdWwgY2F0ZWdvcnkuXG4gKiAgICAgICogdGhlIGV4cGVjdGVkIGVmZmVjdCB3aWxsIGJlIGxvb2sgbGlrZSBhIGZyYW1lIHdoaWNoIGNhdGVnb3JpZXMgYXJlIGluIHZpZXdcbiAqICAgICAgKiBmaXJzdC1jaGlsZCBib3JkZXItdG9wIGxhc3QtY2hpbGQgYm9yZGVyIGJvdHRvbSBhbmQgdGhlIHJlc3QgYm9yZGVyIGxlZnQgYW5kIHJpZ2h0IHdpbGwgZ2l2ZSBhIGZyYW1lIGVmZmVjdFxuICpcbiAqICBkbyBpdCBmb3IgYWxsIGMtYW5jaG9yTWVudS1wYXJlbnQgZWxlbWVudCB3aGljaCBjb3VsZCBiZSBmb3VuZCBpbiB2aWV3XG4gKlxuICogVGhlIGFuY2hvciBtZW51IHNob3dzIGFsbCBlbGVtZW50cyB3aGljaCBoYXZlIHRoZSBjbGFzcyBjLWFuY2hvck1lbnUtcGFyZW50IGFzIHBhcmVudCBhbmQgc2VhcmNoZXMgZm9yIGNoaWxkcmVuXG4gKiB3aXRoIGNsYXNzIGMtYW5jaG9yTWVudS1jaGlsZC4gSXQgcmVuZGVycyBhIHVsIGxpIGxpc3QgYW5kIHJlZ2lzdGVyZWQgYSBjbGljayBjYWxsIHRvIHRocm93IGEgY2xpY2sgZXZlbnQgd2l0aCB0aGUgaWQuXG4gKlxuICogQHR5cGUge2V4cG9ydHN9XG4gKi9cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91cmwnKSxcbiAgICB0cmFuc2xhdGlvblZpZXdDb25maWcgPSByZXF1aXJlKCcuL3RyYW5zbGF0aW9uVmlldycpLmNvbmZpZyxcbiAgICByb290Tm9kZSxcbiAgICBwYXJlbnROb2RlTGlzdCA9IFtdLFxuICAgIG9uU2VsZWN0ID0gZnVuY3Rpb24gKCkge30sXG4gICAgc2hyaW5rT2Zmc2V0Rm9yVmlld0RldGVjdGlvbiA9IDEwMCxcbiAgICBoaWdobGlnaHRUb3BNb3N0S2V5ID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBoaWdobGlnaHRlZEl0ZW07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoZWNrIGlmIG5vZGUgaXMgYWxpZ25lZCB0b3AgbW9zdCBpbiB0aGUgYnJvd3NlciB2aWV3XG4gICAgICAgICAqIEBwYXJhbSBvYmpcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgdmFyIGZpcnN0T3BlbkNhdGVnb3J5ID0gcm9vdE5vZGUucXVlcnlTZWxlY3RvcignbGkuYy1pblZpZXcnKSxcbiAgICAgICAgICAgICAgICBjdXJyZW50TWFpblZpZXdDYXRlZ29yeU5vZGUsXG4gICAgICAgICAgICAgICAgY3VycmVudE1haW5WaWV3Q2F0ZWdvcnlDaGlsZE5vZGVzLFxuICAgICAgICAgICAgICAgIG1haW5WaWV3VG9wTW9zdEtleU5vZGU7XG5cbiAgICAgICAgICAgIGlmICghZmlyc3RPcGVuQ2F0ZWdvcnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlc2V0IHByZXZpb3VzIGhpZ2hsaWdodGVkIGl0ZW1cbiAgICAgICAgICAgIGlmIChoaWdobGlnaHRlZEl0ZW0pIHtcbiAgICAgICAgICAgICAgICBoaWdobGlnaHRlZEl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgnYy1rZXktaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhpZ2hsaWdodCB0b3Btb3N0IGl0ZW1cbiAgICAgICAgICAgIGN1cnJlbnRNYWluVmlld0NhdGVnb3J5Tm9kZSA9IGRvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvcignIycgKyB0cmFuc2xhdGlvblZpZXdDb25maWcucm93UHJlZml4ICsgZmlyc3RPcGVuQ2F0ZWdvcnkuYXR0cmlidXRlcy5kYXRhLm5vZGVWYWx1ZS5yZXBsYWNlKCdhbmNob3JfJywgJycpKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50TWFpblZpZXdDYXRlZ29yeU5vZGUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWFpblZpZXdDYXRlZ29yeUNoaWxkTm9kZXMgPSBjdXJyZW50TWFpblZpZXdDYXRlZ29yeU5vZGUucXVlcnlTZWxlY3RvckFsbCgnLmMtYW5jaG9yTWVudS1jaGlsZCcpO1xuICAgICAgICAgICAgICAgIG1haW5WaWV3VG9wTW9zdEtleU5vZGUgPSBnZXRGaXJzdEVsZW1lbnRJblZpZXdwb3J0KGN1cnJlbnRNYWluVmlld0NhdGVnb3J5Q2hpbGROb2Rlcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2FuY2hvck1lbnU6Q2FuXFwndCBmaW5kIHRoZSBjYXRlZ29yeSBub2RlIHdpdGggaWQnLCB0cmFuc2xhdGlvblZpZXdDb25maWcucm93UHJlZml4ICsgZmlyc3RPcGVuQ2F0ZWdvcnkuYXR0cmlidXRlcy5kYXRhLm5vZGVWYWx1ZS5yZXBsYWNlKCdhbmNob3JfJywgJycpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1haW5WaWV3VG9wTW9zdEtleU5vZGUpIHtcbiAgICAgICAgICAgICAgICBoaWdobGlnaHRlZEl0ZW0gPSByb290Tm9kZS5xdWVyeVNlbGVjdG9yKCdbZGF0YT1hbmNob3JfJyArIG1haW5WaWV3VG9wTW9zdEtleU5vZGUuaWQucmVwbGFjZSh0cmFuc2xhdGlvblZpZXdDb25maWcucm93UHJlZml4LCAnJykgKyAnXScpO1xuICAgICAgICAgICAgICAgIGlmIChoaWdobGlnaHRlZEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0ZWRJdGVtLmNsYXNzTGlzdC5hZGQoJ2Mta2V5LWhpZ2hsaWdodCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pKCk7XG5cbmZ1bmN0aW9uIGZvY3VzRWxlbWVudChpZCwgZWxlbSkge1xuICAgIHZhciBkb207XG4gICAgLy8gaGFuZGxlIHRoZSBhY3RpdmUgY2xhc3MgZnJvbSBtZW51XG4gICAgW10uc2xpY2UuY2FsbChyb290Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKCcuYy1hY3RpdmUnKSkuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICBuLmNsYXNzTGlzdC5yZW1vdmUoJ2MtYWN0aXZlJyk7XG4gICAgfSk7XG4gICAgZWxlbS5jbGFzc0xpc3QuYWRkKCdjLWFjdGl2ZScpO1xuICAgIGVsZW0ucGFyZW50Tm9kZS5wYXJlbnROb2RlLmNsYXNzTGlzdC5hZGQoJ2MtYWN0aXZlJyk7XG4gICAgLy8gaGFuZGxlIHRoZSBjb21tb24gZG9tIGFjdGl2ZSBjbGFzc1xuICAgIFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmMtYW5jaG9yTWVudS1mb2N1cycpKS5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIG4uY2xhc3NMaXN0LnJlbW92ZSgnYy1hbmNob3JNZW51LWZvY3VzJyk7XG4gICAgfSk7XG4gICAgZG9tID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodHJhbnNsYXRpb25WaWV3Q29uZmlnLnJvd1ByZWZpeCArIGlkKTtcbiAgICBpZiAoZG9tKSB7XG4gICAgICAgIGRvbS5jbGFzc0xpc3QuYWRkKCdjLWFuY2hvck1lbnUtZm9jdXMnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnYW5jaG9yTWVudTpmb2N1c0VsZW1lbnQgY2FuXFwndCBmaW5kIGVsZW1lbnQgZm9yIGEgYW5jaG9yJywgaWQpO1xuICAgIH1cbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBpdGVtcyBbe2lkIDogc3RyaW5nLCBjaGlsZHJlbiA6IFtzdHJpbmddfV1cbiAqL1xuZnVuY3Rpb24gYWRkSXRlbXMocm9vdCwgaXRlbXMpIHtcbiAgICB2YXIgdWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpLFxuICAgICAgICBhbmNob3IgPSB1dGlsLmdldEFuY2hvcigpO1xuICAgIHJvb3QuYXBwZW5kQ2hpbGQodWwpO1xuICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGNhdE9iaikge1xuICAgICAgICB2YXIgbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpLFxuICAgICAgICAgICAgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgLy8gVE9ETyBjaGVjayB3aXRoIGxvZ1xuICAgICAgICBpZiAodHlwZW9mIGNhdE9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2FuY2hvck1lbnU6Y2F0ZWdvcnkgbmVlZHMgdG8gYmUgYW4gb2JqZWN0JywgY2F0T2JqKTtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNhdE9iai5pZCkpO1xuICAgICAgICBsaS5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgICAgbGkuc2V0QXR0cmlidXRlKCdkYXRhJywgJ2FuY2hvcl8nICsgY2F0T2JqLmlkKTtcbiAgICAgICAgc3Bhbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9uU2VsZWN0KGNhdE9iai5pZCk7XG4gICAgICAgICAgICBmb2N1c0VsZW1lbnQoY2F0T2JqLmlkLCBsaSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjYXRPYmouY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGFkZEl0ZW1zKGxpLCBjYXRPYmouY2hpbGRyZW4pXG4gICAgICAgIH1cbiAgICAgICAgdWwuYXBwZW5kQ2hpbGQobGkpO1xuICAgICAgICBpZiAoJyMnICsgY2F0T2JqLmlkID09PSBhbmNob3IpIHtcbiAgICAgICAgICAgIGZvY3VzRWxlbWVudChjYXRPYmouaWQsIGxpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vKipcbiAqIGNoZWNrIGlzIHRoZSBub2RlIGlzIGluIHRoZSB2aWV3XG4gKiBAcGFyYW0gbm9kZVxuICovXG5mdW5jdGlvbiBpc05vZGVJblZpZXcobm9kZSkge1xuICAgIHZhciB5T2Zmc2V0ID0gd2luZG93LnNjcm9sbFkgfHwgd2luZG93LnBhZ2VZT2Zmc2V0LFxuICAgICAgICB3ID0ge1xuICAgICAgICAgICAgdG9wOiB5T2Zmc2V0LFxuICAgICAgICAgICAgYm90dG9tIDogeU9mZnNldCArIHdpbmRvdy5pbm5lckhlaWdodFxuICAgICAgICB9LFxuICAgICAgICBib2R5UmVjdCA9IGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIGVsZW1SZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgb2Zmc2V0ID0gZWxlbVJlY3QudG9wIC0gYm9keVJlY3QudG9wICsgc2hyaW5rT2Zmc2V0Rm9yVmlld0RldGVjdGlvbixcbiAgICAgICAgbm9kZUhlaWdodCA9IG9mZnNldCArIG5vZGUub2Zmc2V0SGVpZ2h0IC0gKHNocmlua09mZnNldEZvclZpZXdEZXRlY3Rpb24gKiAyKTtcbiAgICByZXR1cm4gb2Zmc2V0ID4gdy50b3AgJiYgb2Zmc2V0IDwgdy5ib3R0b20gfHwgICAgLy8gaXMgdG9wIGZyYW1lIGluIHZpZXdcbiAgICAgICAgbm9kZUhlaWdodCA+IHcudG9wICYmIG5vZGVIZWlnaHQgPCB3LmJvdHRvbSB8fCAgLy8gaXMgYm90dG9tIGZyYW1lIGluIHZpZXdcbiAgICAgICAgb2Zmc2V0IDwgdy50b3AgJiYgbm9kZUhlaWdodCA+IHcuYm90dG9tOyAgICAvLyBpcyB0b3AgZnJhbWUgYWJvdmUgdmlldyBhbmQgYm90dG9tIGZyYW1lIGJlbG93IHZpZXdcbn1cblxuZnVuY3Rpb24gY3V0Q2F0ZWdvcmllcyh2YWwpIHtcbiAgICB2YXIgc3BsaXQgPSB2YWwuc3BsaXQoJ18nKTtcbiAgICBpZiAoc3BsaXQubGVuZ3RoID4gMSkge1xuICAgICAgICBzcGxpdC5zcGxpY2UoMCwgMSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGlkIDogdmFsLFxuICAgICAgICB2YWx1ZSA6IHNwbGl0LmpvaW4oJ18nKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZXhwYW5kQ2F0ZWdvcmllc0luVmlldygpICAgICB7XG4gICAgcGFyZW50Tm9kZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBsaSA9IHJvb3ROb2RlLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhPWFuY2hvcl8nICsgb2JqLmlkICsgJ10nKTtcbiAgICAgICAgaWYgKGlzTm9kZUluVmlldyhvYmoubm9kZSkpIHtcbiAgICAgICAgICAgIGxpLmNsYXNzTGlzdC5hZGQoJ2MtaW5WaWV3Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaS5jbGFzc0xpc3QucmVtb3ZlKCdjLWluVmlldycpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEZpcnN0RWxlbWVudEluVmlld3BvcnQobm9kZXMpIHtcbiAgICB2YXIga2V5Tm9kZSxcbiAgICAgICAgcGFnZVNjcm9sbE9mZnNldCA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wIHx8IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCksXG4gICAgICAgIGkgPSBub2Rlcy5sZW5ndGgsXG4gICAgICAgIG5vZGVNYXJnaW47XG5cbiAgICB3aGlsZShpLS0pIHtcbiAgICAgICAga2V5Tm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBub2RlTWFyZ2luID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoa2V5Tm9kZSwgbnVsbCkubWFyZ2luQm90dG9tLCAxMCk7XG4gICAgICAgIGlmKGdldFBhZ2VPZmZzZXRGb3JFbGVtZW50KGtleU5vZGUpIC0gbm9kZU1hcmdpbiAqIDIgPD0gcGFnZVNjcm9sbE9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIGtleU5vZGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gZmlyc3Qga2V5IG5vZGUgZm9yIGN1cnJlbnQgYWN0aXZlIGNhdGVnb3J5XG4gICAgcmV0dXJuIG5vZGVzWzBdO1xufVxuXG5mdW5jdGlvbiBnZXRQYWdlT2Zmc2V0Rm9yRWxlbWVudChlbGVtKSB7XG4gICAgdmFyIGJvZHlSZWN0ID0gZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgZWxlbVJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiBlbGVtUmVjdC50b3AgLSBib2R5UmVjdC50b3A7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGZvY3VzRWxlbWVudCA6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgbGkgPSByb290Tm9kZS5xdWVyeVNlbGVjdG9yKCdbZGF0YT1hbmNob3JfJyArIGlkICsgJ10nKTtcbiAgICAgICAgaWYgKGxpKSB7XG4gICAgICAgICAgICBmb2N1c0VsZW1lbnQoaWQsbGkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBvblNlbGVjdCA6IGZ1bmN0aW9uIChmYykge1xuICAgICAgICBvblNlbGVjdCA9IGZjO1xuICAgIH0sXG4gICAgcmVuZGVyTWVudSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhdE9iaiA9IFtdO1xuICAgICAgICAvLyBjbGVhciBwYXJlbnQgbm9kZSBsaXN0XG4gICAgICAgIHBhcmVudE5vZGVMaXN0ID0gW107XG5cbiAgICAgICAgW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuYy1hbmNob3JNZW51LXBhcmVudCcpKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IHBhcmVudC5nZXRBdHRyaWJ1dGUoJ2lkJyksXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgIGlkID0gaWQucmVwbGFjZSh0cmFuc2xhdGlvblZpZXdDb25maWcucm93UHJlZml4LCAnJyk7XG4gICAgICAgICAgICAgICAgLy8gY29sbGVjdCBwYXJlbnRzXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZUxpc3QucHVzaCh7bm9kZSA6IHBhcmVudCwgaWQgOiBpZH0pO1xuXG4gICAgICAgICAgICAgICAgW10uc2xpY2UuY2FsbChwYXJlbnQucXVlcnlTZWxlY3RvckFsbCgnLmMtYW5jaG9yTWVudS1jaGlsZCcpKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjdXRDYXRlZ29yaWVzKGlkLnJlcGxhY2UodHJhbnNsYXRpb25WaWV3Q29uZmlnLnJvd1ByZWZpeCwgJycpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjYXRPYmoucHVzaCh7aWQgOiBpZCwgY2hpbGRyZW4gOiBjaGlsZHJlbn0pO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBbXS5zbGljZS5jYWxsKHJvb3ROb2RlLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBhZGRJdGVtcyhyb290Tm9kZSwgY2F0T2JqKTtcbiAgICAgICAgcm9vdE5vZGUuY2hpbGRyZW5bMF0uc3R5bGUuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC0gMTI1ICsgJ3B4JztcbiAgICAgICAgXG4gICAgICAgIC8vIHRpbWUgZGVsYXllZCB0cmlnZ2VyIHRoZSBpbml0IHZpZXdcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBleHBhbmRDYXRlZ29yaWVzSW5WaWV3KCk7XG4gICAgICAgICAgICBoaWdobGlnaHRUb3BNb3N0S2V5KCk7XG4gICAgICAgIH0sIDEwMDApXG4gICAgfSxcbiAgICBhZGQgOiBmdW5jdGlvbiAobm9kZSwgYXR0cikge1xuICAgICAgICByb290Tm9kZSA9IG5vZGU7XG4gICAgfSxcbiAgICByZWFkeSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBleHBhbmRDYXRlZ29yaWVzSW5WaWV3KCk7XG4gICAgICAgICAgICBoaWdobGlnaHRUb3BNb3N0S2V5KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHJvb3ROb2RlLmNoaWxkcmVuWzBdKSB7XG4gICAgICAgICAgICAgICAgcm9vdE5vZGUuY2hpbGRyZW5bMF0uc3R5bGUuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC0gMTI1ICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGluaXQgdGhlIG1lbnUgd2l0aCBhIHRpbWUgZGVsYXlcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBleHBhbmRDYXRlZ29yaWVzSW5WaWV3KCk7XG4gICAgICAgICAgICBoaWdobGlnaHRUb3BNb3N0S2V5KCk7XG4gICAgICAgIH0sIDE1MDApXG5cbiAgICB9XG59OyIsInZhciBvbkxvZ291dCA9IGZ1bmN0aW9uICgpIHtjb25zb2xlLmxvZygnYXV0aDpvbkxvZ291dCBpcyBub3QgaGFuZGxlZCcpfSxcbiAgICBicmFpbiA9IHtcbiAgICAgICAgbG9nb3V0QnV0dG9uIDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbkxvZ291dCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBvbkxvZ291dCA6IGZ1bmN0aW9uIChmYykge1xuICAgICAgICBvbkxvZ291dCA9IGZjO1xuICAgIH0sXG4gICAgYWRkIDogZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHtcbiAgICAgICAgaWYgKGJyYWluLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgICAgICBicmFpblthdHRyXShub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn07IiwidmFyIHJlcGVhdEZjUG9pbnRlcixcbiAgICBvbkNsaWNrID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdicmVhZGNydW1iOmNsaWNrIGhhbmRsZXIgbm90IHJlZ2lzdGVyZWQnLCBpdGVtKTtcbiAgICB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBvbkNsaWNrIDogZnVuY3Rpb24gKGZjKSB7XG4gICAgICAgIG9uQ2xpY2sgPSBmYztcbiAgICB9LFxuICAgIGFkZCA6IGZ1bmN0aW9uIChub2RlLCBhdHRyKSB7fSxcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJlbnREaXJlY3RvcmllcyBbU3RyaW5nXVxuICAgICAqL1xuICAgIHVwZGF0ZUZvbGRlcnMgOiBmdW5jdGlvbiAocGFyZW50RGlyZWN0b3JpZXMpIHtcbiAgICAgICAgcmVwZWF0RmNQb2ludGVyKHBhcmVudERpcmVjdG9yaWVzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHtuYW1lIDogaXRlbS5uYW1lLCBvbkNsaWNrIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG9uQ2xpY2soaXRlbS5pZCk7XG4gICAgICAgICAgICB9fVxuICAgICAgICB9KSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBmb3IgY2FubnkgcmVwZWF0IHRvIGdldFxuICAgICAqL1xuICAgIHJlZ2lzdGVyQ2FubnlSZXBlYXQgOiBmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgcmVwZWF0RmNQb2ludGVyID0gZmM7XG4gICAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImNvbm5lY3Rpb25Mb3N0XFxcIj5cXG4gIDxzZWN0aW9uPlxcbiAgICA8aSBjbGFzcz1cXFwib2N0aWNvbiBvY3RpY29uLXBsdWdcXFwiPjwvaT5cXG4gICAgPGgyPnt7aXRlbS50aXRsZX19PC9oMj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiZXJyb3JDb2RlXFxcIj48cD5FcnJvciBjb2RlOiA8c3Ryb25nPnt7aXRlbS5lcnJvckNvZGV9fTwvc3Ryb25nPjxzcGFuIGNsYXNzPVxcXCJlcnJvck1lc3NhZ2VcXFwiIHdrLWJpbmQ9XFxcIml0ZW0uZXJyb3JNZXNzYWdlXFxcIj48L3NwYW4+PC9wPjwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJidXR0b24tc2VjdGlvblxcXCI+XFxuICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwicmVjb25uZWN0XFxcIiB3ay1iaW5kPVxcXCJpdGVtLnJlY29ubmVjdFxcXCIgdGl0bGU9XFxcIlRyeSB0byByZWNvbm5lY3QgeW91ciBjaGFuZ2VzIHdpbGwgYmUgb3ZlcndyaXR0ZW5cXFwiPnJlY29ubmVjdDwvYnV0dG9uPlxcbiAgICAgIDxidXR0b24gY2xhc3M9XFxcImNsb3NlXFxcIiB3ay1iaW5kPVxcXCJpdGVtLmNsb3NlXFxcIiB0aXRsZT1cXFwiWW91IGNhbiBjbG9zZSB0aGlzIHZpZXcgdG8gcmVzY3VyZSB5b3UgY2hhbmdlcyBtYW51YWxseVxcXCI+Y2xvc2U8L2J1dHRvbj5cXG4gICAgICA8YnV0dG9uIGNsYXNzPVxcXCJyZWxvYWRcXFwiIHdrLWJpbmQ9XFxcIml0ZW0ucmVsb2FkXFxcIiB0aXRsZT1cXFwiSWYgeW91IGRvIGEgcGFnZSByZWxvYWQgYWxsIHlvdXIgdW5zYXZlZCBjaGFuZ2VzIHdpbGwgYmUgbG9zdFxcXCI+cmVsb2FkIHBhZ2U8L2J1dHRvbj5cXG4gICAgPC9kaXY+XFxuICA8L3NlY3Rpb24+XFxuICA8ZGl2IGNsYXNzPVxcXCJwcm9ncmVzc1VpXFxcIj48L2Rpdj5cXG48L2Rpdj5cIjtcbiIsImNvbnN0IHdoaXNrZXIgPSByZXF1aXJlKCdjYW5ueS9tb2Qvd2hpc2tlcicpXG5jb25zdCB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vaW5kZXguaHRtbCcpXG5jb25zdCBURVhUUyA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgc3dpdGNoKGNvZGUpIHtcbiAgICAgICAgY2FzZSAnRVhDRVBUSU9OJzpcbiAgICAgICAgICAgIHJldHVybiAnd293Li4uIG5vdCBnb29kIC0gcGxlYXNlIHJlcG9ydCB0aGlzIHByb2JsZW0gdG8gYSBkZXZlbG9wZXInXG4gICAgICAgIGNhc2UgJ0ZBVEFMJzpcbiAgICAgICAgICAgIHJldHVybiAnZGFtbWVkLi4uIHRoaXMgc2hvdWxkIG5vdCBoYXBwZW4gLSBwbGVhc2UgY29uc3VsdCBkZXYgb2YgdHJ1c3QnXG4gICAgICAgIGNhc2UgJ0FVVEgnOlxuICAgICAgICAgICAgcmV0dXJuICdTZXNzaW9uIHRpbWVvdXQgcGxlYXNlIGxvZ2luIGFnYWluJ1xuICAgICAgICBjYXNlICdSRUNPTk5FQ1RfRkFJTCc6XG4gICAgICAgICAgICByZXR1cm4gJ2NhblxcJ3QgY3JlYXRlIGEgY29ubmVjdGlvbidcbiAgICAgICAgY2FzZSAnU0VBUkNIX0VSUk9SJzpcbiAgICAgICAgICAgIHJldHVybiAnU2VhcmNoIHNlcnZpY2UgdW5hdmFpbGFibGUnXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gJ3dob29vcHMuLi4gc2VydmVyIGNvbm5lY3Rpb24gbG9zdCdcbiAgICB9XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gb25SZWxvYWRcbiAqIEBwYXJhbSBvblJlY29ubmVjdFxuICogQHJldHVybnMge3tyZW5kZXI6IChmdW5jdGlvbihzdHJpbmcpKSwgZGVzdHJveTogKGZ1bmN0aW9uKCkpfX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoe29uUmVsb2FkLCBvblJlY29ubmVjdCwgb25DbG9zZX0pIHtcbiAgICAvLyBzYXZlcyB0aGUgYWN0aXZlIG5vZGVcbiAgICBsZXQgdWk7XG5cbiAgICBmdW5jdGlvbiByZW5kZXIoe2Vycm9yQ29kZSwgZXJyb3JNZXNzYWdlfSkge1xuICAgICAgICBpZiAodWkpIHVpLnJlbW92ZSgpXG4gICAgICAgIGNvbnN0IGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgICBkLmlubmVySFRNTCA9IHRlbXBsYXRlXG4gICAgICAgIHdoaXNrZXIuYWRkKGQuY2hpbGRyZW5bMF0sIHtcbiAgICAgICAgICAgIHJlY29ubmVjdCA6IG4gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvckNvZGUgPT09ICdSRUNPTk5FQ1RfRkFJTCcgfHwgZXJyb3JDb2RlID09PSAnRkFUQUwnIHx8IGVycm9yQ29kZSA9PT0gJ0FVVEgnIHx8IGVycm9yQ29kZSA9PT0gJ1NFUlZFUl9ET1dOJyB8fCBlcnJvckNvZGUgPT09ICdFWENFUFRJT04nIHx8IGVycm9yQ29kZSA9PT0gJ1NFQVJDSF9FUlJPUicpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvblJlY29ubmVjdClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZSA6IG4gPT4gbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xvc2UpLFxuICAgICAgICAgICAgcmVsb2FkIDogbiA9PiBuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25SZWxvYWQpLFxuICAgICAgICAgICAgZXJyb3JDb2RlLFxuICAgICAgICAgICAgdGl0bGUgOiBURVhUUyhlcnJvckNvZGUpLFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlIDogbiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBuLmlubmVySFRNTCA9IGAgJHtlcnJvck1lc3NhZ2V9YFxuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh1aSA9IGQuY2hpbGRyZW5bMF0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgdGhlIG1vZHVsZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXJyIC0gZXJyb3IgY29kZSB0byBwcmludCBvbiB0aGUgdmlld1xuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyIDogKGVyciwgbXNnKSA9PiByZW5kZXIoe2Vycm9yQ29kZSA6IGVyciwgZXJyb3JNZXNzYWdlOiBtc2d9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSB0aGUgbW9kdWxlIGZyb20gdWlcbiAgICAgICAgICovXG4gICAgICAgIGRlc3Ryb3kgOiAoKSA9PiB7XG4gICAgICAgICAgICB1aS5yZW1vdmUoKVxuICAgICAgICAgICAgdWkgPSB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGluZGljYXRlcyB0aGF0IHRoZSB2aWV3IGlzIGJ1c3lcbiAgICAgICAgICovXG4gICAgICAgIHNob3dQcm9ncmVzcyA6ICgpID0+IHtcbiAgICAgICAgICAgIHVpLmNsYXNzTGlzdC5hZGQoJ3Byb2dyZXNzJylcbiAgICAgICAgfVxuICAgIH1cbn0iLCJ2YXIgb25DcmVhdGVOZXdQcm9qZWN0ID0gZnVuY3Rpb24oKSB7IGNvbnNvbGUud2FybignY3JlYXRlTmV3UHJvamVjdC5vbkNyZWF0ZU5ld1Byb2plY3Qgbm90IHNldCcpfSxcbiAgICBvbkNyZWF0ZU5ld0RpcmVjdG9yeSA9IGZ1bmN0aW9uKCkgeyBjb25zb2xlLndhcm4oJ2NyZWF0ZU5ld1Byb2plY3Qub25DcmVhdGVOZXdEaXJlY3Rvcnkgbm90IHNldCcpfTtcblxudmFyIHByb2plY3ROYW1lSW5wdXROb2RlLFxuICAgIGRpcmVjdG9yeU5hbWVJbnB1dE5vZGU7XG5cbmZ1bmN0aW9uIG5vU3BhY2VzKG5vZGUpIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZS5rZXlDb2RlIHx8IGUud2hpY2hcbiAgICAgICAgaWYgKGtleSA9PT0gMzIpIGUucmV0dXJuVmFsdWUgPSBmYWxzZVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pXG4gICAgcmV0dXJuIG5vZGVcbn1cblxuZnVuY3Rpb24gaXNWYWxpZFByb2plY3ROYW1lKHByb2plY3ROYW1lKSB7XG4gICAgcmV0dXJuIChwcm9qZWN0TmFtZS5sZW5ndGggPiAwICYmIHByb2plY3ROYW1lLnNlYXJjaCgnXFxcXC58LHwgJykgPT09IC0xKSA/IHRydWUgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZERpcmVjdG9yeU5hbWUoZGlyZWN0b3J5TmFtZSkge1xuICAgIC8vIFRCRCBtb3JlIGZvcmJpZGRlbiBjaGFyYWN0ZXJzP1xuICAgIHJldHVybiAoZGlyZWN0b3J5TmFtZS5sZW5ndGggPiAwICYmIGRpcmVjdG9yeU5hbWUuc2VhcmNoKCcvJykgPT09IC0xKSA/IHRydWUgOiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYWRkIDogZnVuY3Rpb24obm9kZSwgYXR0cmlidXRlKSB7XG4gICAgICAgIHN3aXRjaCAoYXR0cmlidXRlKSB7XG4gICAgICAgICAgICBjYXNlICdjcmVhdGVOZXdQcm9qZWN0SW5wdXRQcm9qZWN0JyA6XG4gICAgICAgICAgICAgICAgcHJvamVjdE5hbWVJbnB1dE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbmV3RGlyZWN0b3J5TmFtZUlucHV0JyA6XG4gICAgICAgICAgICAgICAgZGlyZWN0b3J5TmFtZUlucHV0Tm9kZSA9IG5vU3BhY2VzKG5vZGUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjcmVhdGVOZXdQcm9qZWN0U3VibWl0JyA6XG4gICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvamVjdE5hbWUgPSBwcm9qZWN0TmFtZUlucHV0Tm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRQcm9qZWN0TmFtZShwcm9qZWN0TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ3JlYXRlTmV3UHJvamVjdChwcm9qZWN0TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9qZWN0TmFtZUlucHV0Tm9kZS5jbGFzc0xpc3QuYWRkKCdlcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjcmVhdGVOZXdEaXJlY3RvcnlTdWJtaXQnIDpcbiAgICAgICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXJlY3RvcnlOYW1lID0gZGlyZWN0b3J5TmFtZUlucHV0Tm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWREaXJlY3RvcnlOYW1lKGRpcmVjdG9yeU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNyZWF0ZU5ld0RpcmVjdG9yeShkaXJlY3RvcnlOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdG9yeU5hbWVJbnB1dE5vZGUuY2xhc3NMaXN0LmFkZCgnZXJyb3InKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2FuY2VsJzpcbiAgICAgICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbm55LmRpc3BsYXlNYW5hZ2VyLmhpZGUodGhpcy5kYXRhc2V0LnZpZXcpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUGFzcyBpbiBsaXN0ZW5lciBmb3IgZXhlY3V0aW9uIG9mIGNyZWF0aW5nIG5ldyBwcm9qZWN0LlxuICAgICAqIEBwYXJhbSBmdW5jXG4gICAgICovXG4gICAgb25DcmVhdGVOZXdQcm9qZWN0IDogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICBvbkNyZWF0ZU5ld1Byb2plY3QgPSBmdW5jO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUGFzcyBpbiBsaXN0ZW5lciBmb3IgZXhlY3V0aW9uIG9mIGNyZWF0aW5nIGEgbmV3IGRpcmVjdG9yeS5cbiAgICAgKiBAcGFyYW0gZnVuY1xuICAgICAqL1xuICAgIG9uQ3JlYXRlTmV3RGlyZWN0b3kgOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgIG9uQ3JlYXRlTmV3RGlyZWN0b3J5ID0gZnVuYztcbiAgICB9XG59O1xuIiwidmFyIE92ZXJsYXkgPSByZXF1aXJlKCcuL292ZXJsYXknKSxcblx0ZGlzcGxheU1hbmFnZXIgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBtYWluQ29udHJvbGxlciA9IGNhbm55LmZsb3dDb250cm9sLFxuXHRcdFx0b3ZlcmxheUNvbnRyb2xsZXIgPSBjYW5ueS5mbG93Q29udHJvbC5jcmVhdGVOZXdJbnN0YW5jZSgnb3ZlcmxheXMnKSxcblx0XHRcdGNoaWxkcmVuID0ge1xuXHRcdFx0XHRvdmVybGF5OiB7XG5cdFx0XHRcdFx0aWRzOiBbXSxcblx0XHRcdFx0XHRjb250cm9sbGVyOiBvdmVybGF5Q29udHJvbGxlcixcblx0XHRcdFx0XHRhZGQ6IGZ1bmN0aW9uKG5vZGUsIGlkKSB7XG5cblx0XHRcdFx0XHRcdHZhciBvdmVybGF5ID0gbmV3IE92ZXJsYXkobm9kZSwgaWQpO1xuXHRcdFx0XHRcdFx0b3ZlcmxheS5vbkNsaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRzZXREaXNwbGF5U3RhdGVCeUlkKGlkLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0dGhpcy5jb250cm9sbGVyLmFkZChvdmVybGF5Lm5vZGUsIHtcblx0XHRcdFx0XHRcdFx0J3ZpZXcnOiBvdmVybGF5LmlkXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdHRoaXMuaWRzLnB1c2gob3ZlcmxheS5pZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHR2aWV3OiB7XG5cdFx0XHRcdFx0aWRzOiBbXSxcblx0XHRcdFx0XHRjb250cm9sbGVyOiBtYWluQ29udHJvbGxlcixcblx0XHRcdFx0XHRhZGQ6IGZ1bmN0aW9uKG5vZGUsIGlkKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmNvbnRyb2xsZXIuYWRkKG5vZGUsIHtcblx0XHRcdFx0XHRcdFx0J3ZpZXcnOiBpZFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR0aGlzLmlkcy5wdXNoKGlkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRmdW5jdGlvbiBzZXREaXNwbGF5U3RhdGVCeUlkKGlkLCBzaG93KSB7XG5cdFx0XHRPYmplY3Qua2V5cyhjaGlsZHJlbikubWFwKGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdFx0dmFyIHBvb2wgPSBjaGlsZHJlblt0eXBlXSxcblx0XHRcdFx0XHRpZHMgPSBwb29sLmlkcyxcblx0XHRcdFx0XHRjdXJyZW50SWQ7XG5cblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjdXJyZW50SWQgPSBpZHNbaV07XG5cdFx0XHRcdFx0aWYgKGlkID09PSBjdXJyZW50SWQpIHtcblx0XHRcdFx0XHRcdGlmIChzaG93KSB7XG5cdFx0XHRcdFx0XHRcdHBvb2wuY29udHJvbGxlci5zaG93KGN1cnJlbnRJZCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmIChwb29sLmNvbnRyb2xsZXIubW9kW2lkXSkge1xuXHRcdFx0XHRcdFx0XHRwb29sLmNvbnRyb2xsZXIubW9kW2lkXS5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0XHRcdFx0XHRcdG9iai5oaWRlKCk7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YWRkOiBmdW5jdGlvbihub2RlLCBkZXNjcmlwdG9yKSB7XG5cdFx0XHRcdHZhciBrZXlzLCBrZXk7XG5cdFx0XHRcdGlmICh0eXBlb2YgZGVzY3JpcHRvciA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRrZXlzID0gT2JqZWN0LmtleXMoZGVzY3JpcHRvcik7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0XHRcdFx0aWYgKGNoaWxkcmVuLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRcdFx0Y2hpbGRyZW5ba2V5XS5hZGQobm9kZSwgZGVzY3JpcHRvcltrZXldKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdQYXJhbWV0ZXIgdG8gYWRkIGNoaWxkIHRvIGRpc3BsYXlNYW5hZ2VyIGlzIG5vdCB2YWxpZDogJyArIGRlc2NyaXB0b3IpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c2hvdzogZnVuY3Rpb24oaWQpIHtcblx0XHRcdFx0c2V0RGlzcGxheVN0YXRlQnlJZChpZCwgdHJ1ZSk7XG5cdFx0XHR9LFxuXHRcdFx0aGlkZTogZnVuY3Rpb24oaWQpIHtcblx0XHRcdFx0c2V0RGlzcGxheVN0YXRlQnlJZChpZCwgZmFsc2UpO1xuXHRcdFx0fVxuXG5cdFx0fTtcblx0fTtcblxubW9kdWxlLmV4cG9ydHMgPSBkaXNwbGF5TWFuYWdlcjsiLCIvKipcbiAqIGhhbmRsZXMgYWxsIHRleHRzXG4gKi9cbnZhciBkb21PcHRzID0gcmVxdWlyZSgnZG9tLW9wdHMnKSxcbiAgICBmbGFnTWFwID0ge1xuICAgICAgICBkYTogJ2RrJyxcbiAgICAgICAgZGU6ICdkZScsXG4gICAgICAgIGZyOiAnZnInLFxuICAgICAgICBubDogJ25sJyxcbiAgICAgICAgZW46ICd1cycsXG4gICAgICAgIGVuX0dCOiAnZ2InLFxuICAgICAgICBzdjogJ3NlJyxcbiAgICAgICAgZXM6ICdlcydcbiAgICB9O1xuXG5mdW5jdGlvbiBnZXRMYW5nKGxhbmcpIHtcbiAgICB2YXIgZmxhZ0xhbmcgPSBsYW5nO1xuICAgIGlmIChmbGFnTWFwLmhhc093blByb3BlcnR5KGxhbmcpKSB7XG4gICAgICAgIGZsYWdMYW5nID0gZmxhZ01hcFtsYW5nXTtcbiAgICB9XG4gICAgcmV0dXJuIGZsYWdMYW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnZXRGbGFnIDogZnVuY3Rpb24gKGxhbmcpIHtcbiAgICAgICAgcmV0dXJuIGRvbU9wdHMuY3JlYXRlRWxlbWVudCgnc3BhbicsIG51bGwsICdmbGFnLWljb24gZmxhZy1pY29uLScgKyBnZXRMYW5nKGxhbmcpKTtcbiAgICB9LFxuICAgIGdldEZsYWdDbGFzc2VzIDogZnVuY3Rpb24gKGxhbmcpIHtcbiAgICAgICAgcmV0dXJuIFsnZmxhZy1pY29uJywgJ2ZsYWctaWNvbi0nICsgZ2V0TGFuZyhsYW5nKV07XG4gICAgfSxcbiAgICBnZXRGbGFnTWFwOiBmbGFnTWFwLFxuICAgIGdldExhbmc6IGdldExhbmdcbn07IiwiLypnbG9iYWwgYWNlICovXG4vKmpzbGludCBicm93c2VyOiB0cnVlICovXG5jb25zdCBldmVudHMgPSByZXF1aXJlKCcuLi9ldmVudHMuanMnKVxuY29uc3QgQyA9IHJlcXVpcmUoJy4uL0NPTlNULmpzJylcblxud2luZG93LmRvbU9wdHMgPSB3aW5kb3cuZG9tT3B0cyB8fCByZXF1aXJlKCdkb20tb3B0cycpO1xuXG52YXIgaW1hZ2VWaWV3ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIG5vZGVUb0FwcGVuZCxcbiAgICAgICAgaW5pdCA9IGZhbHNlLFxuICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICBpZFByZWZpeCA6ICdpbWFnZVZpZXdlcl8nXG4gICAgICAgIH0sXG4gICAgICAgIHNldHVwQ29udGFpbmVyQ1NTID0gZnVuY3Rpb24gKG5vZGUsIGNzcykge1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBjc3MpIHtcbiAgICAgICAgICAgICAgICBub2RlLnN0eWxlW3Byb3BdID0gIGNzc1twcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICBtYXhXaWR0aCA6IDMwMCxcbiAgICAgICAgICAgIG1heEhlaWdodDogMzAwXG4gICAgICAgIH0sXG4gICAgICAgIGZjID0ge1xuICAgICAgICAgICAgaGlkZUltYWdlVmlld2VyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBwcmVzID0gbm9kZVRvQXBwZW5kLmRvbUNoaWxkVGFncygnaW1nJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAocHJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZXJlIGFyZSBvdGhlciBvcGVuIGltYWdlc1xuICAgICAgICAgICAgICAgICAgICBwcmVzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZG9tQWRkQ2xhc3MoJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvd0ltYWdlIDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHZhciBpbWcsIGlkID0gY29uZmlnLmlkUHJlZml4ICsgb2JqLmlkLFxuICAgICAgICAgICAgICAgICAgICBhY3R1YWxJbWcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYWN0dWFsSW1nICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdHVhbEltZy5kb21SZW1vdmVDbGFzcygnaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRE9ORSBJTUFHRScpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpbWcuc3JjID0gIFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LFwiICsgb2JqLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHNldHVwQ29udGFpbmVyQ1NTKGltZywge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGggOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQgOiAnMTAwJSdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGltZy5zZXRBdHRyaWJ1dGUoJ2lkJywgaWQpO1xuICAgICAgICAgICAgICAgICAgICBpbWcuZG9tQXBwZW5kVG8obm9kZVRvQXBwZW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZXZlbnRzLmFkZFNlcnZlckxpc3RlbmVyKCdzZW5kRmlsZScsIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIGlmIChpbml0KSB7XG4gICAgICAgICAgICAgICAgZmMuaGlkZUltYWdlVmlld2VyKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAob2JqLmZpbGVUeXBlID09PSBDLkZJTEVfTUFOQUdFUi5GSUxFX1RZUEVTLklNQUdFKSB7XG4gICAgICAgICAgICAgICAgICAgIGZjLnNob3dJbWFnZShvYmopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cblxuICAgIHJldHVybiB7XG4gICAgICAgIGFkZCA6IGZ1bmN0aW9uIChub2RlLCBhdHRyKSB7XG4gICAgICAgICAgICBpbml0ID0gdHJ1ZTtcbiAgICAgICAgICAgIG5vZGVUb0FwcGVuZCA9IG5vZGU7XG4gICAgICAgICAgICBub2RlVG9BcHBlbmQuc2V0QXR0cmlidXRlKCdpZCcsICdpbWFnZVZpZXdlcicpO1xuXG4gICAgICAgICAgICBzZXR1cENvbnRhaW5lckNTUyhub2RlVG9BcHBlbmQsIHtcbiAgICAgICAgICAgICAgICB3aWR0aCA6IHNldHRpbmdzLm1heFdpZHRoICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHNldHRpbmdzLm1heEhlaWdodCArICdweCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXR1cCA6IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIHZhciBvYmo7XG4gICAgICAgICAgICBmb3IgKG9iaiBpbiBjb25maWcpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5nc1tvYmpdID0gY29uZmlnW29ial07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbWFnZVZpZXdlcjsiLCJcbmZ1bmN0aW9uIGFkZEVkaXQobm9kZSwgZmMpIHtcbiAgIHZhciBkaXYgPSBkb21PcHRzLmNyZWF0ZUVsZW1lbnQoJ2RpdicsIG51bGwsICdpbnB1dEVkaXRNYW5hZ2VyLWJ1dHRvbiBlZGl0IG9jdGljb24gb2N0aWNvbi1wZW5jaWwnKTtcbiAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKCdjLWVkaXQnKTtcbiAgICAgICAgZmMoZXZlbnQpO1xuICAgIH0pO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ2VkaXQnKTtcbiAgICBub2RlLmFwcGVuZENoaWxkKGRpdik7XG59XG5mdW5jdGlvbiBhZGRDYW5jZWwobm9kZSwgZmMpIHtcbiAgICB2YXIgZGl2ID0gZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdkaXYnLCBudWxsLCAnaW5wdXRFZGl0TWFuYWdlci1idXR0b24gY2FuY2VsIG9jdGljb24gb2N0aWNvbi14Jyk7XG4gICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnYy1lZGl0Jyk7XG4gICAgICAgIGZjKGV2ZW50KTtcbiAgICB9KTtcbiAgICBkaXYuc2V0QXR0cmlidXRlKCd0aXRsZScsICdjYW5jZWwnKTtcbiAgICBub2RlLmFwcGVuZENoaWxkKGRpdik7XG59XG5cbmZ1bmN0aW9uIGFkZFNhdmUobm9kZSwgZmMpIHtcbiAgICB2YXIgZGl2ID0gZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdkaXYnLCBudWxsLCAnaW5wdXRFZGl0TWFuYWdlci1idXR0b24gc2F2ZSBvY3RpY29uIG9jdGljb24tY2hlY2snKTtcbiAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZmMoZXZlbnQpO1xuICAgIH0pO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ3NhdmUgY2hhbmdlcycpO1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQoZGl2KTtcbn1cblxuZnVuY3Rpb24gYWRkQ2xvbmUobm9kZSwgZmMpIHtcbiAgICB2YXIgZGl2ID0gZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdkaXYnLCBudWxsLCAnaW5wdXRFZGl0TWFuYWdlci1idXR0b24gc2F2ZSBvY3RpY29uIG9jdGljb24tZmlsZS1zeW1saW5rLWZpbGUnKTtcbiAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZmMoZXZlbnQpO1xuICAgIH0pO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ21vdmUga2V5IGludG8gb3RoZXIgY2F0ZWdvcnknKTtcbiAgICBub2RlLmFwcGVuZENoaWxkKGRpdik7XG59XG5cbmZ1bmN0aW9uIGFkZERlbGV0ZShub2RlLCBmYykge1xuICAgIHZhciBkaXYgPSBkb21PcHRzLmNyZWF0ZUVsZW1lbnQoJ2RpdicsIG51bGwsICdpbnB1dEVkaXRNYW5hZ2VyLWJ1dHRvbiBkZWxldGUgb2N0aWNvbiBvY3RpY29uLXRyYXNoY2FuJyk7XG4gICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGZjKGV2ZW50KTtcbiAgICB9KTtcbiAgICBkaXYuc2V0QXR0cmlidXRlKCd0aXRsZScsICdyZW1vdmUgdGhpcyBrZXknKTtcbiAgICBub2RlLmFwcGVuZENoaWxkKGRpdik7XG59XG5cbmZ1bmN0aW9uIGNsb3NlRWRpdG9yVmlldyhrZXlJbnB1dE5vZGUpIHtcbiAgICB2YXIgZWRpdG9yUGFuZWxOb2RlID0ga2V5SW5wdXROb2RlLnBhcmVudE5vZGUucXVlcnlTZWxlY3RvcignLmlucHV0RWRpdE1hbmFnZXIud3JhcCcpO1xuICAgIGlmIChlZGl0b3JQYW5lbE5vZGUpIHtcbiAgICAgICAgZWRpdG9yUGFuZWxOb2RlLmNsYXNzTGlzdC5yZW1vdmUoJ2MtZWRpdCcpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLyoqXG4gICAgICogZWFjaCBrZXkgaW5wdXQgbm9kZSBoYXN0XG4gICAgICogQHBhcmFtIGtleUlucHV0Tm9kZVxuICAgICAqL1xuICAgIGNsb3NlRWRpdFZpZXcgOiBmdW5jdGlvbiAoa2V5SW5wdXROb2RlKSB7XG4gICAgICAgIGlmIChrZXlJbnB1dE5vZGUpIHtcbiAgICAgICAgICAgIGNsb3NlRWRpdG9yVmlldyhrZXlJbnB1dE5vZGUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBhZGRFZGl0b3JQYW5lbCA6IGZ1bmN0aW9uIChrZXlOb2RlLCBsaXN0ZW5lcnMpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lck5vZGUgPSBkb21PcHRzLmNyZWF0ZUVsZW1lbnQoJ2RpdicsIG51bGwsICdpbnB1dEVkaXRNYW5hZ2VyIHdyYXAnKTtcblxuICAgICAgICBpZiAobGlzdGVuZXJzLmhhc093blByb3BlcnR5KCdvbkVkaXQnKSkge1xuICAgICAgICAgICAgYWRkRWRpdChjb250YWluZXJOb2RlLCBsaXN0ZW5lcnMub25FZGl0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXJzLmhhc093blByb3BlcnR5KCdvbkRlbGV0ZScpKSB7XG4gICAgICAgICAgICBhZGREZWxldGUoY29udGFpbmVyTm9kZSwgbGlzdGVuZXJzLm9uRGVsZXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXJzLmhhc093blByb3BlcnR5KCdvblNhdmUnKSkge1xuICAgICAgICAgICAgYWRkU2F2ZShjb250YWluZXJOb2RlLCBsaXN0ZW5lcnMub25TYXZlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXJzLmhhc093blByb3BlcnR5KCdvbkNsb25lJykpIHtcbiAgICAgICAgICAgIGFkZENsb25lKGNvbnRhaW5lck5vZGUsIGxpc3RlbmVycy5vbkNsb25lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXJzLmhhc093blByb3BlcnR5KCdvbkNhbmNlbCcpKSB7XG4gICAgICAgICAgICBhZGRDYW5jZWwoY29udGFpbmVyTm9kZSwgbGlzdGVuZXJzLm9uQ2FuY2VsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRhaW5lck5vZGUuZG9tQXBwZW5kVG8oa2V5Tm9kZSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lck5vZGU7XG4gICAgfSxcbiAgICByZW1vdmVQYW5lbCA6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIG5vZGUucXVlcnlTZWxlY3RvcignLmlucHV0RWRpdE1hbmFnZXIud3JhcCcpLmRvbVJlbW92ZSgpO1xuICAgIH1cbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IG5vZGU7XG5cbiAgcmV0dXJuIHtcbiAgICBhZGQ6IChuKSA9PiB7XG4gICAgICBub2RlID0gblxuICAgIH0sXG4gICAgc2hvdzogKCkgPT4ge1xuICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XG4gICAgfSxcbiAgICBoaWRlOiAoKSA9PiB7XG4gICAgICBub2RlLmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKTtcbiAgICB9LFxuICB9O1xufTtcbiIsIlxudmFyIHJvb3ROb2RlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzaG93IDogZnVuY3Rpb24gKCkge1xuICAgICAgICByb290Tm9kZS5jbGFzc0xpc3QuYWRkKCdjLXNob3cnKTtcbiAgICB9LFxuICAgIGhpZGUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJvb3ROb2RlLmNsYXNzTGlzdC5yZW1vdmUoJ2Mtc2hvdycpO1xuICAgIH0sXG4gICAgYWRkIDogZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHtcbiAgICAgICAgaWYgKGF0dHIgPT09ICdidXR0b24nKSB7XG4gICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgaWYgKHJvb3ROb2RlLmNsYXNzTGlzdC5jb250YWlucygnYy1zaG93JykpIHtcbiAgICAgICAgICAgICAgICAgICByb290Tm9kZS5jbGFzc0xpc3QucmVtb3ZlKCdjLXNob3cnKTtcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgcm9vdE5vZGUuY2xhc3NMaXN0LmFkZCgnYy1zaG93Jyk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvb3ROb2RlID0gbm9kZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIE92ZXJsYXkobm9kZSwgaWQpIHtcblxuXHR2YXIgaWQgPSBpZCxcblx0XHRub2RlID0gbm9kZSxcblx0XHRjbGlja0hhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdGNvbnNvbGUud2FybignQ2xpY2sgbGlzdGVuZXIgbm90IGF0dGFjaGVkIGZvciBvdmVybGF5IHdpdGggaWQ6ICcgKyBpZCk7XG5cdFx0fTtcblxuXHRub2RlLmNsYXNzTGlzdC5hZGQoJ2Rpc3BsYXlNYW5hZ2VyLW92ZXJsYXknKTtcblx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKG5vZGUgPT09IGUudGFyZ2V0KSB7XG5cdFx0XHRjbGlja0hhbmRsZXIoKTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiB7XG5cdFx0aWQ6IGlkLFxuXHRcdG5vZGU6IG5vZGUsXG5cdFx0b25DbGljazogZnVuY3Rpb24oY2IpIHtcblx0XHRcdGNsaWNrSGFuZGxlciA9IGNiO1xuXHRcdH1cblx0fVxufTsiLCIvKmdsb2JhbCAqL1xuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSovXG5cbnZhciBjYW5ueSA9IHJlcXVpcmUoJ2Nhbm55JyksXG4gICAgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpLFxuICAgIHRleHRzID0gcmVxdWlyZSgnLi90ZXh0cycpO1xuXG4vKipcbiAqIEUuZy46IGNhbm55LW1vZD1cImZsb3dDb250cm9sXCIgY2FubnktdmFyPVwieyd2aWV3JyA6ICd2aWV3VG9TaG93J31cIlxuICpcbiAqIHlvdSBjYW4gYWN0aXZhdGUgYSBpbml0aWFsIHZpZXcgd2l0aCBhIGFuY2hvciBpbiB0aGUgVVJMIGUuZy46IHlvdXJkb21haW4uaHRtbCN2aWV3VG9TaG93XG4gKiBPciBwYXNzIGEgY29tbWEgc2VwYXJhdGVkIG1vZHVsZSBsaXN0IGZvciBhY3RpdmF0ZSBtb3JlIG1vZHVsZSAjdmlld1RvU2hvdyxvdGhlclZpZXdcbiAqXG4gKiBUT0RPIG1hZGUgaXQgcG9zc2libGUgdG8gc3VtbWFyaXplIHZpZXdzIHdpdGggb25lIGlkZW50aWZpZXIuXG4gKiBJbnN0ZWFkIG9mIGNhbGw6IGdkb20uZmxvd0NvbnRyb2wuc2hvdygndmlldzEnLCAndmlldzInLCAndmlldzMnKSBjYWxsIGdkb20uZmxvd0NvbnRyb2wuc2hvdygndmlldycpLlxuICovXG52YXIgcHJvamVjdE1haW5OYXZpZ2F0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBtYWluTm9kZSxcbiAgICAgICAgc2VsZWN0TGFuZ3VhZ2VRdWV1ZSA9IFtdLFxuICAgICAgICBvblNob3dKU09OUXVldWUgPSBbXSxcbiAgICAgICAgb25FbmFibGVFZGl0b3JNb2RlUXVldWUgPSBbXSxcbiAgICAgICAgb25Ub2dnbGVXb3JkQ291bnRRdWV1ZSA9IFtdLFxuICAgICAgICBvblNob3dKTUJGUXVldWUgPSBbXSxcbiAgICAgICAgb25TaG93Sk1CRlVwbG9hZGVyUXVldWUgPSBbXSxcbiAgICAgICAgb25TaG93SlNPTkltcG9ydFF1ZXVlID0gW10sXG4gICAgICAgIGJ1bmRsZU5hbWUgPSB3aW5kb3cuZG9tT3B0cy5wYXJhbXMuYnVuZGxlLFxuICAgICAgICBtb2RWaWV3cyA9IHtcbiAgICAgICAgICAgIG1haW4gOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIG1haW5Ob2RlID0gbm9kZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZW51VG9nZ2xlQnV0dG9uIDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBuZXcgc3ZnSWNvbihub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgIGhhbWJ1cmdlckNyb3NzIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsIDogJy9kaXN0L2FuaW1hdGVkU1ZHL3N2Zy9oYW1idXJnZXIuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbiA6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsIDogJ3BhdGg6bnRoLWNoaWxkKDEpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbVByb3BlcnRpZXMgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIDogeyB2YWwgOiAne1wicGF0aFwiIDogXCJtIDUuMDkxNjc4OSwyMC44MTg5OTQgNTMuODE2NjQyMSwwXCJ9JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gOiB7IHZhbCA6ICd7XCJwYXRoXCIgOiBcIk0gMTIuOTcyOTQ0LDUwLjkzNjE0NyA1MS4wMjcwNTYsMTIuODgyMDM1XCJ9JyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwgOiAncGF0aDpudGgtY2hpbGQoMiknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltUHJvcGVydGllcyA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gOiB7IHZhbCA6ICd7XCJ0cmFuc2Zvcm1cIiA6IFwiczEgMVwiLCBcIm9wYWNpdHlcIiA6IDF9JywgYmVmb3JlIDogJ3tcInRyYW5zZm9ybVwiIDogXCJzMCAwXCJ9JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gOiB7IHZhbCA6ICd7XCJvcGFjaXR5XCIgOiAwfScgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsIDogJ3BhdGg6bnRoLWNoaWxkKDMpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbVByb3BlcnRpZXMgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIDogeyB2YWwgOiAne1wicGF0aFwiIDogXCJtIDUuMDkxNjc4OCw0Mi45NTY5OCA1My44MTY2NDIyLDBcIn0nIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byA6IHsgdmFsIDogJ3tcInBhdGhcIiA6IFwiTSAxMi45NzI5NDQsMTIuODgyMDM1IDUxLjAyNzA1Niw1MC45MzYxNDdcIn0nIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgZWFzaW5nIDogbWluYS5lbGFzdGljLCBzcGVlZDogMTIwMCwgc2l6ZSA6IHt3IDogJzRlbScsIGggOiAnM2VtJ31cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFpbk5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdjLW9wZW4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbk5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnYy1vcGVuJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluTm9kZS5jbGFzc0xpc3QuYWRkKCdjLW9wZW4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvd1Jlc291cmNlQnVuZGxlRWRpdG9yIDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyByZWxvYWQgdGhlIHBhZ2UgYmVjYXVzZSB0aGUgZmlsZXMgYXJlIG5vdCBzeW5jZWRcbiAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsICcjJyk7XG4gICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvd01lc3NhZ2VCdW5kbGVGb3JtYXQgOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uU2hvd0pNQkZRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvd0pTT05CdW5kbGUgOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBvblNob3dKU09OUXVldWUuZm9yRWFjaChmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNob3dKTUJGVXBsb2FkZXIgOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBvblNob3dKTUJGVXBsb2FkZXJRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvd0pTT05JbXBvcnQgOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBvblNob3dKU09OSW1wb3J0UXVldWUuZm9yRWFjaChmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuYWJsZUVkaXRvck1vZGUgOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBvbkVuYWJsZUVkaXRvck1vZGVRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9nZ2xlV29yZENvdW50IDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Ub2dnbGVXb3JkQ291bnRRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJvbSA6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tLm5vZGUgPSBub2RlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvIDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvLm5vZGUgPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9jYWxlcyBbXVxuICAgICAqIEBwYXJhbSBub2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0TG9jYWxlKGxvY2FsZXMsIG5vZGUpIHtcbiAgICAgICAgdmFyIHVsID0gbm9kZS5xdWVyeVNlbGVjdG9yKCcubGFuZ3VhZ2VzJyksIGxpLCBsYW5ndWFnZU5hbWVOb2RlLCBwcm9ncmVzc05vZGUsIGZsYWdJQztcbiAgICAgICAgaWYgKHVsKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgYWxsIGV4aXN0aW5nIGNoaWxkcmVuIGZpcnN0XG4gICAgICAgICAgICBbXS5zbGljZS5jYWxsKHVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpJykpLmZvckVhY2goZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICB1bC5yZW1vdmVDaGlsZChlbGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdWwgPSB3aW5kb3cuZG9tT3B0cy5jcmVhdGVFbGVtZW50KCd1bCcsIG51bGwsICduYXZpZ2F0aW9uTWVudSBsYW5ndWFnZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBsb2NhbGVzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIG51bU9mVHJhbnNLZXlzID0gd2luZG93LmRvbU9wdHMuY3JlYXRlRWxlbWVudCgnc3BhbicsIG51bGwsICdudW1PZlRyYW5zS2V5cycpLFxuICAgICAgICAgICAgICAgIG1heEtleU5vZGUgPSB3aW5kb3cuZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdzcGFuJywgbnVsbCwgJ21heEtleScpO1xuICAgICAgICAgICAgbGkgPSB3aW5kb3cuZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICAgICAgbGFuZ3VhZ2VOYW1lTm9kZSA9IHdpbmRvdy5kb21PcHRzLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIHByb2dyZXNzTm9kZSA9IHdpbmRvdy5kb21PcHRzLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCBudWxsLCAncHJvZ3Jlc3MnKTtcbiAgICAgICAgICAgIG51bU9mVHJhbnNLZXlzLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCctJykpO1xuICAgICAgICAgICAgbnVtT2ZUcmFuc0tleXMuZG9tQXBwZW5kVG8ocHJvZ3Jlc3NOb2RlKTtcbiAgICAgICAgICAgIHByb2dyZXNzTm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnLycpKTtcbiAgICAgICAgICAgIG1heEtleU5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJy0nKSk7XG4gICAgICAgICAgICBtYXhLZXlOb2RlLmRvbUFwcGVuZFRvKHByb2dyZXNzTm9kZSk7XG5cbiAgICAgICAgICAgIGxpLmNsYXNzTGlzdC5hZGQoJ2xhbmcnKTtcbiAgICAgICAgICAgIGxpLmNsYXNzTGlzdC5hZGQoa2V5KTtcblxuICAgICAgICAgICAgbGkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzSW5hY3RpdmUgPSB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpc0FjdGl2ZSA9IHRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKCdjLWFjdGl2ZScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnRvZ2dsZSgnYy1pbmFjdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICBpc0luYWN0aXZlID0gdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoJ2MtaW5hY3RpdmUnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBoYXMgbm8gc3RhdGVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxlY3RMYW5ndWFnZVF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKGZjKSB7XG4gICAgICAgICAgICAgICAgICAgIGZjKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQWN0aXZlIDogaXNBY3RpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0luYWN0aXZlIDogaXNJbmFjdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2plY3QgOiBidW5kbGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2U6IGtleVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsYW5ndWFnZU5hbWVOb2RlLmlubmVySFRNTCA9IHRleHRzLmdldExhbmd1YWdlTmFtZXMoa2V5KTtcbiAgICAgICAgICAgIGxhbmd1YWdlTmFtZU5vZGUuY2xhc3NOYW1lID0gJ2xhbmdOYW1lJztcbiAgICAgICAgICAgIGxhbmd1YWdlTmFtZU5vZGUuZG9tQXBwZW5kVG8obGkpO1xuICAgICAgICAgICAgcHJvZ3Jlc3NOb2RlLmRvbUFwcGVuZFRvKGxpKTtcbiAgICAgICAgICAgIGZsYWdJQyA9IGZsYWcuZ2V0RmxhZyhrZXkpO1xuICAgICAgICAgICAgZmxhZ0lDLmNsYXNzTGlzdC5hZGQoJ2ljb24nLCAnb2N0aWNvbicsICdvY3RpY29uLXBsdXMnKTtcbiAgICAgICAgICAgIGZsYWdJQy5kb21BcHBlbmRUbyhsaSk7XG4gICAgICAgICAgICBsaS5kb21BcHBlbmRUbyh1bCk7XG4gICAgICAgIH0pO1xuICAgICAgICB1bC5kb21BcHBlbmRUbyhub2RlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1cGRhdGUgYWxsIGxhbmd1YWdlIG1heCBrZXlzIGZvciBhbGwgbGFuZ3VhZ2VzXG4gICAgICogQHBhcmFtIGtleXNcbiAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZU1heEtleXMoa2V5cywgbm9kZSkge1xuICAgICAgICBbXS5zbGljZS5jYWxsKG5vZGUucXVlcnlTZWxlY3RvckFsbCgnLmxhbmd1YWdlcyAubGFuZycpKS5mb3JFYWNoKGZ1bmN0aW9uKGxhbmdOb2RlKSB7XG4gICAgICAgICAgICBsYW5nTm9kZS5xdWVyeVNlbGVjdG9yKCcubWF4S2V5JykuaW5uZXJIVE1MID0ga2V5cztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdXBkYXRlIGEgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAgICAgKiBAcGFyYW0ga2V5XG4gICAgICogQHBhcmFtIGxhbmdcbiAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZU51bWJlck9mTGFuZ0tleXMoa2V5LCBsYW5nLCBub2RlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdwcm9qZWN0TWFpbk5hdmlnYXRpb246dXBkYXRlTnVtYmVyT2ZMYW5nS2V5cycsIGtleSwgbGFuZyk7XG4gICAgICAgIG5vZGUucXVlcnlTZWxlY3RvcignLmxhbmd1YWdlcyAubGFuZy4nICsgbGFuZyArICcgLm51bU9mVHJhbnNLZXlzJykuaW5uZXJIVE1MID0ga2V5O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHNldE51bWJlck9mVHJhbnNsYXRpb25NYXhLZXlzIDogZnVuY3Rpb24gKG1heEtleXMpIHtcbiAgICAgICAgICAgIHVwZGF0ZU1heEtleXMobWF4S2V5cywgbW9kVmlld3MuZnJvbS5ub2RlKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0TnVtYmVyT2ZUcmFuc2xhdGVkTGFuZ3VhZ2VLZXkgOiBmdW5jdGlvbiAobnVtYmVyT2ZLZXlzLCBsYW5nKSB7XG4gICAgICAgICAgICB1cGRhdGVOdW1iZXJPZkxhbmdLZXlzKG51bWJlck9mS2V5cywgbGFuZywgbW9kVmlld3MuZnJvbS5ub2RlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25MYW5ndWFnZVNlbGVjdCA6IGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgc2VsZWN0TGFuZ3VhZ2VRdWV1ZS5wdXNoKGZjKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TaG93SlNPTiA6IGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgb25TaG93SlNPTlF1ZXVlLnB1c2goZmMpO1xuICAgICAgICB9LFxuICAgICAgICBvblNob3dKTUJGIDogZnVuY3Rpb24gKGZjKSB7XG4gICAgICAgICAgICBvblNob3dKTUJGUXVldWUucHVzaChmYyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU2hvd0pNQkZVcGxvYWRlciA6IGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgb25TaG93Sk1CRlVwbG9hZGVyUXVldWUucHVzaChmYyk7IFxuICAgICAgICB9LFxuICAgICAgICBvblNob3dKU09OSW1wb3J0IDogZnVuY3Rpb24gKGZjKSB7XG4gICAgICAgICAgICBvblNob3dKU09OSW1wb3J0UXVldWUucHVzaChmYyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRW5hYmxlRWRpdG9yTW9kZSA6IGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgb25FbmFibGVFZGl0b3JNb2RlUXVldWUucHVzaChmYyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVG9nZ2xlV29yZENvdW50IDogZnVuY3Rpb24gKGZjKSB7XG4gICAgICAgICAgICBvblRvZ2dsZVdvcmRDb3VudFF1ZXVlLnB1c2goZmMpO1xuICAgICAgICB9LFxuICAgICAgICBhY3RpdmF0ZUxhbmcgOiBmdW5jdGlvbiAobGFuZykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBtYWluTm9kZS5xdWVyeVNlbGVjdG9yKCdsaS4nICsgbGFuZyk7XG4gICAgICAgICAgICBub2RlLmNsYXNzTGlzdC5yZW1vdmUoJ2MtaW5hY3RpdmUnKTtcbiAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgnYy1hY3RpdmUnKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVBY3RpdmF0ZUxhbmcgOiBmdW5jdGlvbiAobGFuZykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBtYWluTm9kZS5xdWVyeVNlbGVjdG9yKCdsaS4nICsgbGFuZyk7XG4gICAgICAgICAgICBub2RlLmNsYXNzTGlzdC5hZGQoJ2MtaW5hY3RpdmUnKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGx5IHRoZSBjdXJyZW50IHByb2plY3QncyBudW1iZXIgdG8gdGhlIGZsYWdzOiBhY3RpdmF0ZSBmbGFnIHdoZXJlIHRyYW5zbGF0aW9ucyBleGlzdCBhbmQgc2hvdyBudW1iZXIgb2ZcbiAgICAgICAgICogdHJhbnNsYXRlZCBrZXlzLlxuICAgICAgICAgKiBAcGFyYW0ga2V5c1RvdGFsIHRoZSB0b3RhbCBudW1iZXIgb2Yga2V5c1xuICAgICAgICAgKiBAcGFyYW0gdHJhbnNsYXRlZEtleXNQZXJMYW5nIHRoZSBudW1iZXIgb2YgdHJhbnNsYXRlZCBrZXlzIHBlciBsYW5ndWFnZVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0QWN0aXZhdGVkUHJvamVjdExhbmd1YWdlcyA6IGZ1bmN0aW9uIChrZXlzVG90YWwsIHRyYW5zbGF0ZWRLZXlzUGVyTGFuZykge1xuICAgICAgICAgICAgW10uc2xpY2UuY2FsbChtYWluTm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdsaScpKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzTm9kZSA9IG5vZGUucXVlcnlTZWxlY3RvcignLnByb2dyZXNzJyk7XG4gICAgICAgICAgICAgICAgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKCdjLWFjdGl2ZScpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzc05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NOb2RlLmNoaWxkcmVuWzBdLmlubmVySFRNTCA9IFwiLVwiO1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc05vZGUuY2hpbGRyZW5bMV0uaW5uZXJIVE1MID0gXCItXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRyYW5zbGF0ZWRLZXlzUGVyTGFuZykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgW10uc2xpY2UuY2FsbChtYWluTm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdsaS4nICsga2V5KSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvZ3Jlc3NOb2RlID0gbm9kZS5xdWVyeVNlbGVjdG9yKCcucHJvZ3Jlc3MnKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKCdjLWFjdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3NOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzTm9kZS5jaGlsZHJlblswXS5pbm5lckhUTUwgPSB0cmFuc2xhdGVkS2V5c1Blckxhbmdba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NOb2RlLmNoaWxkcmVuWzFdLmlubmVySFRNTCA9IGtleXNUb3RhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgc2V0QXZhaWxhYmxlTGFuZ3VhZ2VzIDogZnVuY3Rpb24gKGxhbmd1YWdlcykge1xuICAgICAgICAgICAgc2V0TG9jYWxlKGxhbmd1YWdlcywgbW9kVmlld3MuZnJvbS5ub2RlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZHkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnbmF2LWNvbnRyb2xsZXIgcmVhZHkgZXZlbnQnKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkIDogZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHsgICAgLy8gcGFydCBvZiBhcGlcbiAgICAgICAgICAgIGlmIChtb2RWaWV3cy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgICAgICAgICAgICAgIG1vZFZpZXdzW2F0dHJdKG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTElOSyBOT1QgSU1QTEVNRU5URUQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICBwcm9qZWN0TWFpbk5hdmlnYXRpb247IiwidmFyIHByb2plY3RPdmVydmlldyA9IChmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgY29tcG9uZW50Um9vdE5vZGUsXG4gICAgICAgIHJlbmRlclByb2plY3RzQW5kRGlyZWN0b3JpZXNMaXN0LFxuICAgICAgICBvbkNyZWF0ZVByb2plY3RQcmVzc2VkID0gZnVuY3Rpb24oKSB7IGNvbnNvbGUud2FybigncHJvamVjdE92ZXJ2aWV3Lm9uQ3JlYXRlUHJvamVjdFByZXNzZWQgbm90IHNldCcpfSxcbiAgICAgICAgb25QYXJlbnREaXJlY3RvcnlTZWxlY3RlZCA9IGZ1bmN0aW9uKCkge2NvbnNvbGUud2FybigncHJvamVjdE92ZXJ2aWV3Lm9uUGFyZW50RGlyZWN0b3J5U2VsZWN0ZWQgbm90IHNldCcpfSxcbiAgICAgICAgb25Qcm9qZWN0U2VsZWN0ZWQgPSBmdW5jdGlvbigpIHsgY29uc29sZS53YXJuKCdwcm9qZWN0T3ZlcnZpZXcub25Qcm9qZWN0U2VsZWN0ZWQgbm90IHNldCcpfSxcbiAgICAgICAgb25EZWxldGVQcm9qZWN0UHJlc3NlZCA9IGZ1bmN0aW9uKCkgeyBjb25zb2xlLndhcm4oJ3Byb2plY3RPdmVydmlldy5vbkRlbGV0ZVByb2plY3RQcmVzc2VkIG5vdCBzZXQnKX0sXG4gICAgICAgIG9uTW92ZWRQcm9qZWN0UHJlc3NlZCA9IGZ1bmN0aW9uKCkgeyBjb25zb2xlLndhcm4oJ3Byb2plY3RPdmVydmlldy5vbk1vdmVkUHJvamVjdFByZXNzZWQgbm90IHNldCcpfSxcbiAgICAgICAgb25EZWxldGVGb2xkZXJQcmVzc2VkID0gZnVuY3Rpb24oKSB7IGNvbnNvbGUud2FybigncHJvamVjdE92ZXJ2aWV3Lm9uRGVsZXRlRm9sZGVyUHJlc3NlZCBub3Qgc2V0Jyl9LFxuICAgICAgICBvbkRpcmVjdG9yeVNlbGVjdGVkID0gZnVuY3Rpb24oKSB7IGNvbnNvbGUud2FybigncHJvamVjdE92ZXJ2aWV3Lm9uRGlyZWN0b3J5U2VsZWN0ZWQgbm90IHNldCcpfSxcbiAgICAgICAgb25DcmVhdGVEaXJlY3RvcnlQcmVzc2VkID0gZnVuY3Rpb24oKSB7IGNvbnNvbGUud2FybigncHJvamVjdE92ZXJ2aWV3Lm9uQ3JlYXRlRGlyZWN0b3J5UHJlc3NlZCBub3Qgc2V0Jyl9LFxuICAgICAgICBlZGl0TW9kZUVuYWJsZWQgPSBmYWxzZTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgZnJvbSBjYW5ueSB3aGVuIHJlZ2lzdGVyaW5nIGNvbXBvbmVudHMuIFRoZSBvbmx5IGNvbXBvbmVudCB3aGljaCB3ZSBleHBlY3QgdG8gYmUgcmVnaXN0ZXJlZCBpc1xuICAgICAgICAgKiBcInByb2plY3RPdmVydmlld0NvbnRhaW5lclwiICh0aGUgcm9vdCBub2RlIG9mIHRoZSBjb21wb25lbnQpLlxuICAgICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICAgKiBAcGFyYW0gdmFyc1xuICAgICAgICAgKi9cbiAgICAgICAgYWRkOiBmdW5jdGlvbiAobm9kZSwgYXR0cikge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudFJvb3ROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRSb290Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigncHJvamVjdE92ZXJ2aWV3OmFkZCBtdWx0aXBsZSB2aWV3cyBkZXRlY3RlZCAtIGl0IHNob3VsZCBiZSByZWdpc3RlcmVkIG9ubHkgb25lcyBpbiB0aGUgRE9NIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIGZyb20gY2Fubnkgb24gZG9jdW1lbnRSZWFkeSBldmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHJlYWR5OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgdmFyIGNyZWF0ZVByb2plY3RCdXR0b25Ob2RlID0gY29tcG9uZW50Um9vdE5vZGUucXVlcnlTZWxlY3RvcignLmpzLWNyZWF0ZVByb2plY3RCdXR0b24nKTtcbiAgICAgICAgICAgIGlmICghY3JlYXRlUHJvamVjdEJ1dHRvbk5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdObyBjaGlsZCBub2RlIHdpdGggY2xhc3MgXCJjcmVhdGVQcm9qZWN0QnV0dG9uIGZvdW5kIGluc2lkZSBcInByb2plY3RPdmVydmlld0NvbnRhaW5lclwiJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNyZWF0ZVByb2plY3RCdXR0b25Ob2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25DcmVhdGVQcm9qZWN0UHJlc3NlZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3JlYXRlRm9sZGVyQnV0dG9uTm9kZSA9IGNvbXBvbmVudFJvb3ROb2RlLnF1ZXJ5U2VsZWN0b3IoJy5qcy1jcmVhdGVGb2xkZXJCdXR0b24nKTtcbiAgICAgICAgICAgIGlmICghY3JlYXRlRm9sZGVyQnV0dG9uTm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIGNoaWxkIG5vZGUgd2l0aCBjbGFzcyBcImNyZWF0ZUZvbGRlckJ1dHRvbiBmb3VuZCBpbnNpZGUgXCJwcm9qZWN0T3ZlcnZpZXdDb250YWluZXJcIicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVGb2xkZXJCdXR0b25Ob2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25DcmVhdGVEaXJlY3RvcnlQcmVzc2VkKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0b2dnbGVFZGl0TW9kZUJ1dHRvbk5vZGUgPSBjb21wb25lbnRSb290Tm9kZS5xdWVyeVNlbGVjdG9yKCcuanMtdG9nZ2xlRWRpdE1vZGVCdXR0b24nKTtcbiAgICAgICAgICAgIGlmICghdG9nZ2xlRWRpdE1vZGVCdXR0b25Ob2RlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTm8gY2hpbGQgbm9kZSB3aXRoIGNsYXNzIFwiY3JlYXRlRm9sZGVyQnV0dG9uIGZvdW5kIGluc2lkZSBcInByb2plY3RPdmVydmlld0NvbnRhaW5lclwiJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvZ2dsZUVkaXRNb2RlQnV0dG9uTm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRNb2RlRW5hYmxlZCA9ICFlZGl0TW9kZUVuYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFJvb3ROb2RlLmNsYXNzTGlzdC50b2dnbGUoJ2VkaXRNb2RlLWVuYWJsZWQnLCBlZGl0TW9kZUVuYWJsZWQpO1xuICAgICAgICAgICAgICAgICAgICB0b2dnbGVFZGl0TW9kZUJ1dHRvbk5vZGUuY2xhc3NMaXN0LnRvZ2dsZSgnYWN0aXZlJywgZWRpdE1vZGVFbmFibGVkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNlbGVjdFBhcmVudERpcmVjdG9yeUJ1dHRvbiA9IGNvbXBvbmVudFJvb3ROb2RlLnF1ZXJ5U2VsZWN0b3IoJy5qcy1zZWxlY3RQYXJlbnREaXJlY3RvcnlCdXR0b24nKTtcbiAgICAgICAgICAgIGlmICghc2VsZWN0UGFyZW50RGlyZWN0b3J5QnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTm8gY2hpbGQgbm9kZSB3aXRoIGNsYXNzIFwic2VsZWN0UGFyZW50RGlyZWN0b3J5QnV0dG9uXCIgZm91bmQgaW5zaWRlIFwicHJvamVjdE92ZXJ2aWV3Q29udGFpbmVyXCInKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0UGFyZW50RGlyZWN0b3J5QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25QYXJlbnREaXJlY3RvcnlTZWxlY3RlZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW5mb3JtIHRoZSB1aSBtb2R1bGUgYWJvdXQgdGhlIG5ldyBjdXJyZW50IHNldCBvZiBkaXJlY3RvcmllcyBhbmQgcHJvamVjdHMgdG8gbGlzdC4gVGhpcyB3aWxsIGFsc28gdHJpZ2dlclxuICAgICAgICAgKiBhIG5ldyByZW5kZXJpbmcgb2YgdGhlIHByb2plY3RzIGxpc3Qgd2l0aCB0aGUgbmV3IGNvbnRlbnQuXG4gICAgICAgICAqIEBwYXJhbSBwcm9qZWN0TmFtZXNcbiAgICAgICAgICogQHBhcmFtIGRpcmVjdG9yeU5hbWVzXG4gICAgICAgICAqL1xuICAgICAgICBzZXRQcm9qZWN0c0FuZERpcmVjdG9yaWVzOiBmdW5jdGlvbiAocHJvamVjdE5hbWVzLCBkaXJlY3RvcnlOYW1lcykge1xuICAgICAgICAgICAgdmFyIHByb2plY3RzQW5kRGlyZWN0b3JpZXMgPSBbXTtcblxuICAgICAgICAgICAgaWYgKCFwcm9qZWN0TmFtZXMgfHwgIWRpcmVjdG9yeU5hbWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghcmVuZGVyUHJvamVjdHNBbmREaXJlY3Rvcmllc0xpc3QpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdyZW5kZXJQcm9qZWN0c0FuZERpcmVjdG9yaWVzTGlzdCBmdW5jdGlvbiBoYXMgbm90IGJlZW4gc2V0LCBuZXcgbGlzdCBjYW5ub3QgYmUgc2hvd24nKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdnb3QgcHJvamVjdHMnLCBwcm9qZWN0TmFtZXMpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2dvdCBkaXJlY3RvcmllcycsIGRpcmVjdG9yeU5hbWVzKTtcblxuICAgICAgICAgICAgcHJvamVjdE5hbWVzLmZvckVhY2goZnVuY3Rpb24ocHJvamVjdE5hbWUpIHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0c0FuZERpcmVjdG9yaWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lIDogcHJvamVjdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRpciA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBvcGVuUHJvamVjdExpc3RJdGVtIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3Byb2plY3Qgc2VsZWN0ZWQ6JywgcHJvamVjdE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uUHJvamVjdFNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Qcm9qZWN0U2VsZWN0ZWQocHJvamVjdE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVQcm9qZWN0TGlzdEl0ZW0gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWxldGlvbkNvbmZpcm1lZCA9IHdpbmRvdy5jb25maXJtKCdSZWFsbHkgZGVsZXRlIHByb2plY3QgJyArIHByb2plY3ROYW1lICsgJz8nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbkRlbGV0ZVByb2plY3RQcmVzc2VkICYmIGRlbGV0aW9uQ29uZmlybWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25EZWxldGVQcm9qZWN0UHJlc3NlZChwcm9qZWN0TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG1vdmVQcm9qZWN0IDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3ZlZFByb2plY3RQcmVzc2VkKHByb2plY3ROYW1lKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpcmVjdG9yeU5hbWVzLmZvckVhY2goZnVuY3Rpb24oZGlyZWN0b3J5TmFtZSkge1xuICAgICAgICAgICAgICAgIHByb2plY3RzQW5kRGlyZWN0b3JpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgOiBkaXJlY3RvcnlOYW1lLFxuICAgICAgICAgICAgICAgICAgICBkaXIgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBvcGVuUHJvamVjdExpc3RJdGVtIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZGlyZWN0b3J5IHNlbGVjdGVkOicsIGRpcmVjdG9yeU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uRGlyZWN0b3J5U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkRpcmVjdG9yeVNlbGVjdGVkKGRpcmVjdG9yeU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVQcm9qZWN0TGlzdEl0ZW0gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWxldGlvbkNvbmZpcm1lZCA9IHdpbmRvdy5jb25maXJtKCdSZWFsbHkgZGVsZXRlIGZvbGRlciAnICsgZGlyZWN0b3J5TmFtZSArICc/Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25EZWxldGVGb2xkZXJQcmVzc2VkICYmIGRlbGV0aW9uQ29uZmlybWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25EZWxldGVGb2xkZXJQcmVzc2VkKGRpcmVjdG9yeU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmVuZGVyUHJvamVjdHNBbmREaXJlY3Rvcmllc0xpc3QocHJvamVjdHNBbmREaXJlY3Rvcmllcyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3IgY2FubnktcmVwZWF0IHJlZ2lzdGVyZWQgb24gdGhlIHByb2plY3RzIGxpc3QsIHByb3ZpZGUgdGhlIGZ1bmN0aW9uIGZvciByZW5kZXJpbmcgdGhlIGxpc3QuXG4gICAgICAgICAqIEBwYXJhbSBmdW5jIGEgZnVuY3Rpb24gd2hpY2ggd2lsbCBzZXQgdGhlIGxpc3Qgb2YgcHJvamVjdHMgYW5kIGRpcmVjdG9yaWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0UmVuZGVyUHJvamVjdHNBbmREaXJlY3Rvcmllc0xpc3RGdW5jdGlvbiA6IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgICAgIHJlbmRlclByb2plY3RzQW5kRGlyZWN0b3JpZXNMaXN0ID0gZnVuYztcbiAgICAgICAgfSxcbiAgICAgICAgZGVsZXRlUHJvamVjdExpc3ROb2RlIDogZnVuY3Rpb24oaXRlbU5hbWUpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gY29tcG9uZW50Um9vdE5vZGUucXVlcnlTZWxlY3RvcigndHJbZGF0YS1saXN0SXRlbT0nICsgaXRlbU5hbWUgKyAnXScpO1xuICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgYSBsaXN0ZW5lciBjYWxsYmFjayB3aGljaCB3aWxsIHJlYWN0IHRvIFwidG8gcGFyZW50IGRpcmVjdG9yeVwiIGV2ZW50LlxuICAgICAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgICAgICovXG4gICAgICAgIG9uUGFyZW50RGlyZWN0b3J5U2VsZWN0ZWQgOiBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICAgICAgb25QYXJlbnREaXJlY3RvcnlTZWxlY3RlZCA9IGxpc3RlbmVyO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgYSBsaXN0ZW5lciBjYWxsYmFjayB3aGljaCB3aWxsIHJlYWN0IHRvIGNsaWNrcyBvbiBhIHByb2plY3QuIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBzaG91bGQgZXhwZWN0XG4gICAgICAgICAqIG9uZSBwYXJhbWV0ZXIgd2hpY2ggaXMgdGhlIHByb2plY3QgbmFtZS5cbiAgICAgICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICAgICAqL1xuICAgICAgICBvblByb2plY3RTZWxlY3RlZCA6IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvblByb2plY3RTZWxlY3RlZCA9IGxpc3RlbmVyO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgYSBsaXN0ZW5lciBjYWxsYmFjayB3aGljaCB3aWxsIHJlYWN0IHRvIGNsaWNrcyBvbiBhIGRpcmVjdG9yeS4gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHNob3VsZCBleHBlY3RcbiAgICAgICAgICogb25lIHBhcmFtZXRlciB3aGljaCBpcyB0aGUgZGlyZWN0b3J5IG5hbWUuXG4gICAgICAgICAqIEBwYXJhbSBsaXN0ZW5lclxuICAgICAgICAgKi9cbiAgICAgICAgb25EaXJlY3RvcnlTZWxlY3RlZCA6IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvbkRpcmVjdG9yeVNlbGVjdGVkID0gbGlzdGVuZXI7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ3JlYXRlUHJvamVjdFByZXNzZWQgOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgICBvbkNyZWF0ZVByb2plY3RQcmVzc2VkID0gZnVuYztcbiAgICAgICAgfSxcbiAgICAgICAgb25EZWxldGVQcm9qZWN0UHJlc3NlZCA6IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgICAgIG9uRGVsZXRlUHJvamVjdFByZXNzZWQgPSBmdW5jO1xuICAgICAgICB9LFxuICAgICAgICBvbkRlbGV0ZUZvbGRlclByZXNzZWQgOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgICBvbkRlbGV0ZUZvbGRlclByZXNzZWQgPSBmdW5jO1xuICAgICAgICB9LFxuICAgICAgICBvbkNyZWF0ZURpcmVjdG9yeVByZXNzZWQgOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgICBvbkNyZWF0ZURpcmVjdG9yeVByZXNzZWQgPSBmdW5jO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdmVEaXJlY3RvcnlQcmVzc2VkIDogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgICAgb25Nb3ZlZFByb2plY3RQcmVzc2VkID0gZnVuYztcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHByb2plY3RPdmVydmlldztcbiIsInZhciBvblNlYXJjaCA9IGZ1bmN0aW9uICgpIHtjb25zb2xlLmxvZygnc2VhcmNoOm9uU2VhcmNoIGlzIG5vdCBoYW5kbGVkJyl9LFxuICAgIGFjdGl2ZSA9IGZhbHNlLFxuICAgIHJvb3ROb2RlLFxuICAgIGlucHV0Tm9kZSxcbiAgICBicmFpbiA9IHtcbiAgICAgICAgcm9vdDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgcm9vdE5vZGUgPSBub2RlO1xuICAgICAgICB9LFxuICAgICAgICBpbnB1dCA6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpbnB1dE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlICYmIGV2ZW50LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uU2VhcmNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGJ1dHRvbiA6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uU2VhcmNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBvblNlYXJjaCA6IGZ1bmN0aW9uKGZjKSB7XG4gICAgICAgIG9uU2VhcmNoID0gZmM7XG4gICAgfSxcbiAgICBnZXQgaW5wdXROb2RlKCkge1xuICAgICAgICByZXR1cm4gaW5wdXROb2RlO1xuICAgIH0sXG4gICAgYWRkIDogZnVuY3Rpb24obm9kZSwgYXR0cikge1xuICAgICAgICBpZiAoYnJhaW4uaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgICAgICAgIGJyYWluW2F0dHJdKG5vZGUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzaG93IDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJvb3ROb2RlLmNsYXNzTGlzdC5hZGQoJ3Nob3cnKTtcbiAgICAgICAgYWN0aXZlID0gdHJ1ZTtcbiAgICB9LFxuICAgIGhpZGUgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHJvb3ROb2RlLmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKTtcbiAgICB9XG59OyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJjaGVja2JveGVzXFxcIj5cXG4gICAgPGxhYmVsIGZvcj1cXFwiZmlsdGVyLWNhc2VzZW5zaXRpdmVcXFwiPmNhc2Utc2Vuc2l0aXZlPC9sYWJlbD5cXG4gICAgPGlucHV0IHR5cGU9XFxcImNoZWNrYm94XFxcIiBpZD1cXFwiZmlsdGVyLWNhc2VzZW5zaXRpdmVcXFwiIG5hbWU9XFxcImZpbHRlci1jYXNlc2Vuc2l0aXZlXFxcIj5cXG48L2Rpdj5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8aDI+Rm91bmQgPHNwYW4gY2xhc3M9XFxcInRlcm1cXFwiPnt7aXRlbS50aXRsZX19PC9zcGFuPiBpbiA8c3Bhbj57e2l0ZW0ucmVzdWx0c0NvdW50ZWR9fTwvc3Bhbj4gdGV4dCBpdGVtcy48L2gyPlwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxsaSBjbGFzcz1cXFwia2V5LWl0ZW1cXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJsYW5nXFxcIj48c3BhbiBjbGFzcz1cXFwiZmxhZy1pY29uIGZsYWctaWNvbi17e2l0ZW0ubGFuZ319IGljb24gb2N0aWNvblxcXCI+PC9zcGFuPjwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJrZXlcXFwiPjxhIGhyZWY9XFxcInt7aXRlbS51cmx9fVxcXCI+e3tpdGVtLmtleX19PC9hPjwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ0ZXh0XFxcIj57e2l0ZW0udGV4dH19PC9kaXY+XFxuPC9saT5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJsYW5nLWJ1dHRvblxcXCIgdGl0bGU9XFxcInt7aXRlbS5sYW5nfX1cXFwiPlxcbiAgICA8c3BhbiBjbGFzcz1cXFwiZmxhZy1pY29uIGZsYWctaWNvbi17e2l0ZW0ubGFuZ319IGljb24gb2N0aWNvblxcXCI+PC9zcGFuPlxcbjwvZGl2PlwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxsaSBjbGFzcz1cXFwicHJvamVjdC1pdGVtXFxcIj5cXG4gIDxoMz5ObyBtYXRjaGVzIGZvdW5kLjwvaDM+XFxuPC9saT5cXG5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJwYWdlLWJ1dHRvblxcXCI+XFxuICAgIHt7aXRlbS5wYWdlTnVtYmVyfX1cXG48L2Rpdj5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8bGkgY2xhc3M9XFxcInByb2plY3QtaXRlbVxcXCI+XFxuICAgIDxoMz57e2l0ZW0ucHJvamVjdF9pZH19PC9oMz5cXG4gICAgPHVsIGNsYXNzPVxcXCJrZXktbGlzdFxcXCI+XFxuICAgICAgICA8IS0tIEtleUl0ZW0uaHRtbCBpbnNlcnRlZCBkeW5taWNhbGx5IC0tPlxcbiAgICA8L3VsPlxcbjwvbGk+XCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwic2VhcmNoUmVzdWx0c1xcXCI+XFxuICA8c2VjdGlvbj5cXG4gICAgPGkgY2xhc3M9XFxcIm9jdGljb24gb2N0aWNvbi1zZWFyY2hcXFwiPjwvaT5cXG4gICAgPGRpdiBjbGFzcz1cXFwiaGVhZGxpbmVcXFwiPlxcbiAgICAgIDwhLS0gSGVhZGxpbmUuaHRtbCAtLT5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNlYXJjaC1vcHRpb25zXFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJsYW5ndWFnZXNcXFwiPlxcbiAgICAgICAgPHNwYW4+U2VhcmNoIHRlcm0gd2FzIGZvdW5kIGluIGZvbGxvd2luZyBsYW5ndWFnZXM6PC9zcGFuPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwibGFuZ3VhZ2Utc3dpdGNoXFxcIj5cXG4gICAgICAgICAgPCEtLSBMYW5nQnV0dG9uLmh0bWwgaW5zZXJ0ZWQgZHlubWljYWxseSAtLT5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImZpbHRlcnNcXFwiPlxcbiAgICAgICAgPCEtLSBGaWx0ZXJzLmh0bWwgaW5zZXJ0ZWQgZHlubWljYWxseSAtLT5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDx1bCBjbGFzcz1cXFwicmVzdWx0cy1saXN0XFxcIj5cXG4gICAgICA8IS0tIFByb2plY3RJdGVtLmh0bWwgaW5zZXJ0ZWQgZHlubWljYWxseSAtLT5cXG4gICAgPC91bD5cXG4gICAgPHVsIGNsYXNzPVxcXCJwYWdpbmF0aW9uXFxcIj5cXG4gICAgICA8IS0tIFBhZ2VCdXR0b24uaHRtbCBpbnNlcnRlZCBkeW5taWNhbGx5IC0tPlxcbiAgICA8L3VsPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJidXR0b24tc2VjdGlvblxcXCI+XFxuICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiY2xvc2VcXFwiIHdrLWJpbmQ9XFxcIml0ZW0uY2xvc2VcXFwiIHRpdGxlPVxcXCJDbG9zZSBtb2RhbFxcXCI+Y2xvc2U8L2J1dHRvbj5cXG4gICAgPC9kaXY+XFxuICA8L3NlY3Rpb24+XFxuPC9kaXY+XCI7XG4iLCJjb25zdCB3aGlza2VyID0gcmVxdWlyZShcImNhbm55L21vZC93aGlza2VyXCIpO1xuY29uc3QgZmxhZ3MgPSByZXF1aXJlKFwiLi4vZmxhZ1wiKTtcbmNvbnN0IHRlbXBsYXRlID0gcmVxdWlyZShcIi4vaW5kZXguaHRtbFwiKTtcbmNvbnN0IEhlYWRsaW5lID0gcmVxdWlyZShcIi4vSGVhZGxpbmUuaHRtbFwiKTtcbmNvbnN0IEZpbHRlcnMgPSByZXF1aXJlKFwiLi9GaWx0ZXJzLmh0bWxcIik7XG5jb25zdCBQcm9qZWN0SXRlbSA9IHJlcXVpcmUoXCIuL1Byb2plY3RJdGVtLmh0bWxcIik7XG5jb25zdCBLZXlJdGVtID0gcmVxdWlyZShcIi4vS2V5SXRlbS5odG1sXCIpO1xuY29uc3QgTm9NYXRjaGVzID0gcmVxdWlyZShcIi4vTm9NYXRjaGVzLmh0bWxcIik7XG5jb25zdCBMYW5nQnV0dG9uID0gcmVxdWlyZShcIi4vTGFuZ0J1dHRvbi5odG1sXCIpO1xuY29uc3QgUGFnZUJ1dHRvbiA9IHJlcXVpcmUoXCIuL1BhZ2VCdXR0b24uaHRtbFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoeyBvbkNsb3NlIH0pIHtcbiAgbGV0IHJlc3VsdHM7XG5cbiAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIG5vZGUuaW5uZXJIVE1MID0gdGVtcGxhdGU7XG5cbiAgY29uc3QgY29udGVudCA9IG5vZGUuY2hpbGRyZW5bMF07XG4gIGNvbnN0IGhlYWRsaW5lID0gY29udGVudC5xdWVyeVNlbGVjdG9yKFwiLmhlYWRsaW5lXCIpO1xuICBjb25zdCBsYW5nU3dpdGNoID0gY29udGVudC5xdWVyeVNlbGVjdG9yKFwiLmxhbmd1YWdlLXN3aXRjaFwiKTtcbiAgY29uc3QgbGlzdCA9IGNvbnRlbnQucXVlcnlTZWxlY3RvcihcIi5yZXN1bHRzLWxpc3RcIik7XG4gIGNvbnN0IGZpbHRlcnMgPSBjb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCIuZmlsdGVyc1wiKTtcbiAgZmlsdGVycy5pbm5lckhUTUwgPSBGaWx0ZXJzO1xuXG4gIGNvbnN0IGNoZWNrYm94Q2FzZSA9IGZpbHRlcnMucXVlcnlTZWxlY3RvcihcIiNmaWx0ZXItY2FzZXNlbnNpdGl2ZVwiKTtcbiAgY2hlY2tib3hDYXNlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgY3VycmVudFBhZ2UgPSAwO1xuICAgIHJlc3VsdHMgJiYgcmVuZGVyUGFnZShyZXN1bHRzKTtcbiAgfSk7XG5cbiAgY29uc3QgcGFnaW5hdGlvbiA9IGNvbnRlbnQucXVlcnlTZWxlY3RvcihcIi5wYWdpbmF0aW9uXCIpO1xuICBjb25zdCBFTlRSSUVTX1BFUl9QQUdFID0gMTA7XG4gIGxldCBjdXJyZW50UGFnZSA9IDA7XG5cbiAgZnVuY3Rpb24gZmlsdGVyQ2FzZVNlbnNpdGl2ZShwcm9qZWN0cywgc2VhcmNoVGVybSwgaXNTZW5zaXRpdmUpIHtcbiAgICByZXR1cm4gcHJvamVjdHNcbiAgICAgIC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgaXRlbS5yZXN1bHRzID0gaXRlbS5yZXN1bHRzLmZpbHRlcihcbiAgICAgICAgICAocmVzdWx0KSA9PlxuICAgICAgICAgICAgIWlzU2Vuc2l0aXZlIHx8XG4gICAgICAgICAgICAoaXNTZW5zaXRpdmUgJiYgcmVzdWx0LnRleHQuaW5kZXhPZihzZWFyY2hUZXJtKSAhPT0gLTEpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0ucmVzdWx0cy5sZW5ndGggPiAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1ldGFEYXRhKGVudHJpZXMpIHtcbiAgICBsZXQgcmVzdWx0c0NvdW50ZWQgPSAwO1xuICAgIGxldCBsYW5ndWFnZXMgPSBbXTtcbiAgICBlbnRyaWVzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGl0ZW0ucmVzdWx0cy5mb3JFYWNoKChyZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgbGFuZyA9IGZsYWdzLmdldExhbmcocmVzdWx0LmxhbmcpO1xuICAgICAgICBpZiAobGFuZ3VhZ2VzLmluZGV4T2YobGFuZykgPT09IC0xKSB7XG4gICAgICAgICAgbGFuZ3VhZ2VzLnB1c2gobGFuZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0c0NvdW50ZWQrKztcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICByZXN1bHRzQ291bnRlZCxcbiAgICAgIGxhbmd1YWdlcyxcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVySGVhZGVyKGRhdGEsIGh0bWxFbGVtZW50KSB7XG4gICAgd2hpc2tlci5hZGQoaHRtbEVsZW1lbnQsIHtcbiAgICAgIHRpdGxlOiBkYXRhLnNlYXJjaFRlcm0sXG4gICAgICByZXN1bHRzQ291bnRlZDogZGF0YS5yZXN1bHRzQ291bnRlZCxcbiAgICAgIGNsb3NlOiAobikgPT4gbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgb25DbG9zZSksXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJGbGFncyhsYW5ndWFnZXMsIGh0bWxFbGVtZW50KSB7XG4gICAgLy8gUmVuZGVyIGZsYWdzIG9uIHRvcCBvZiByZXN1bHRzLWxpc3RcbiAgICBsYW5ndWFnZXNcbiAgICAgIC5zb3J0KChhLCBiKSA9PiAoYSA8IGIgPyAtMSA6IDEpKVxuICAgICAgLmZvckVhY2goKGxhbmcpID0+IHtcbiAgICAgICAgbGFuZyA9IGZsYWdzLmdldExhbmcobGFuZyk7XG4gICAgICAgIGxldCBsYW5nQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgbGFuZ0J1dHRvbi5pbm5lckhUTUwgPSBMYW5nQnV0dG9uO1xuICAgICAgICB3aGlza2VyLmFkZChsYW5nQnV0dG9uLCB7XG4gICAgICAgICAgbGFuZzogbGFuZyxcbiAgICAgICAgfSk7XG4gICAgICAgIGh0bWxFbGVtZW50LmFwcGVuZENoaWxkKGxhbmdCdXR0b24uY2hpbGRyZW5bMF0pO1xuICAgICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJSZXN1bHRzKGl0ZW1zLCByYW5nZVN0YXJ0LCByYW5nZUVuZCwgaHRtbExpc3QpIHtcbiAgICBpdGVtc1xuICAgICAgLmZpbHRlcigoaXRlbSwgaW5kZXgpID0+IGluZGV4ID49IHJhbmdlU3RhcnQgJiYgaW5kZXggPCByYW5nZUVuZClcbiAgICAgIC5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIGxldCBodG1sUHJvamVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGh0bWxQcm9qZWN0LmlubmVySFRNTCA9IFByb2plY3RJdGVtO1xuICAgICAgICB3aGlza2VyLmFkZChodG1sUHJvamVjdCwge1xuICAgICAgICAgIHByb2plY3RfaWQ6IGl0ZW0ucHJvamVjdF9pZCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qga2V5TGlzdCA9IGh0bWxQcm9qZWN0LnF1ZXJ5U2VsZWN0b3IoXCIua2V5LWxpc3RcIik7XG5cbiAgICAgICAgaXRlbS5yZXN1bHRzLmZvckVhY2goKHJlc3VsdCkgPT4ge1xuICAgICAgICAgIGxldCBodG1sS2V5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICBodG1sS2V5LmlubmVySFRNTCA9IEtleUl0ZW07XG4gICAgICAgICAgY29uc3QgbGFuZyA9IGZsYWdzLmdldExhbmcocmVzdWx0LmxhbmcpO1xuICAgICAgICAgIHdoaXNrZXIuYWRkKGh0bWxLZXksIHtcbiAgICAgICAgICAgIGtleTogcmVzdWx0LmtleSxcbiAgICAgICAgICAgIHVybDogcmVzdWx0LnVybCxcbiAgICAgICAgICAgIGxhbmc6IGxhbmcsXG4gICAgICAgICAgICB0ZXh0OiByZXN1bHQudGV4dCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBrZXlMaXN0LmFwcGVuZENoaWxkKGh0bWxLZXkuY2hpbGRyZW5bMF0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoa2V5TGlzdC5jaGlsZEVsZW1lbnRDb3VudCA+IDApIHtcbiAgICAgICAgICBodG1sTGlzdC5hcHBlbmRDaGlsZChodG1sUHJvamVjdC5jaGlsZHJlblswXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyUGFnaW5hdGlvbihudW1QYWdlcywgaHRtbEVsZW1lbnQpIHtcbiAgICBmb3IgKGxldCBwYWdlTnVtYmVyID0gMDsgcGFnZU51bWJlciA8PSBudW1QYWdlczsgcGFnZU51bWJlcisrKSB7XG4gICAgICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHdyYXBwZXIuaW5uZXJIVE1MID0gUGFnZUJ1dHRvbjtcblxuICAgICAgY29uc3QgYnV0dG9uID0gd3JhcHBlci5jaGlsZHJlblswXTtcblxuICAgICAgd2hpc2tlci5hZGQoYnV0dG9uLCB7XG4gICAgICAgIHBhZ2VOdW1iZXI6IHBhZ2VOdW1iZXIgKyAxLFxuICAgICAgfSk7XG5cbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50UGFnZSA9IHBhZ2VOdW1iZXI7XG4gICAgICAgIHJlc3VsdHMgJiYgcmVuZGVyUGFnZShyZXN1bHRzKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoY3VycmVudFBhZ2UgPT09IHBhZ2VOdW1iZXIpIHtcbiAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7XG4gICAgICB9XG5cbiAgICAgIGh0bWxFbGVtZW50LmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyUGFnZShkYXRhKSB7XG4gICAgcmVzdWx0cyA9IGRhdGE7XG5cbiAgICBsZXQgY2xvbmVkRGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVzdWx0cykpO1xuICAgIGxldCBwcm9qZWN0RW50cmllcyA9IGNsb25lZERhdGEuZGF0YTtcbiAgICBjb25zdCBzZWFyY2hUZXJtID0gY2xvbmVkRGF0YS5zZWFyY2hfdGVybTtcblxuICAgIGhlYWRsaW5lLmlubmVySFRNTCA9IEhlYWRsaW5lO1xuICAgIGxhbmdTd2l0Y2guaW5uZXJIVE1MID0gXCJcIjtcbiAgICBsaXN0LmlubmVySFRNTCA9IFwiXCI7XG4gICAgcGFnaW5hdGlvbi5pbm5lckhUTUwgPSBcIlwiO1xuXG4gICAgaWYgKHByb2plY3RFbnRyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJhbmdlU3RhcnQgPSBjdXJyZW50UGFnZSAqIEVOVFJJRVNfUEVSX1BBR0U7XG4gICAgICBjb25zdCByYW5nZUVuZCA9IChjdXJyZW50UGFnZSArIDEpICogRU5UUklFU19QRVJfUEFHRTtcblxuICAgICAgcHJvamVjdEVudHJpZXMgPSBmaWx0ZXJDYXNlU2Vuc2l0aXZlKFxuICAgICAgICBjbG9uZWREYXRhLmRhdGEsXG4gICAgICAgIHNlYXJjaFRlcm0sXG4gICAgICAgIGNoZWNrYm94Q2FzZS5jaGVja2VkXG4gICAgICApO1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSBnZXRNZXRhRGF0YShwcm9qZWN0RW50cmllcyk7XG5cbiAgICAgIHJlbmRlckhlYWRlcihcbiAgICAgICAgeyBzZWFyY2hUZXJtLCByZXN1bHRzQ291bnRlZDogbWV0YWRhdGEucmVzdWx0c0NvdW50ZWQgfSxcbiAgICAgICAgY29udGVudFxuICAgICAgKTtcbiAgICAgIHJlbmRlckZsYWdzKG1ldGFkYXRhLmxhbmd1YWdlcywgbGFuZ1N3aXRjaCk7XG4gICAgICByZW5kZXJSZXN1bHRzKHByb2plY3RFbnRyaWVzLCByYW5nZVN0YXJ0LCByYW5nZUVuZCwgbGlzdCk7XG4gICAgICBjb25zdCBudW1QYWdlcyA9IE1hdGguZmxvb3IocHJvamVjdEVudHJpZXMubGVuZ3RoIC8gRU5UUklFU19QRVJfUEFHRSk7XG4gICAgICBpZiAobnVtUGFnZXMgPiAwKSB7XG4gICAgICAgIHJlbmRlclBhZ2luYXRpb24obnVtUGFnZXMsIHBhZ2luYXRpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW5kZXJIZWFkZXIoeyBzZWFyY2hUZXJtLCByZXN1bHRzQ291bnRlZDogMCB9LCBjb250ZW50KTtcbiAgICAgIGNvbnN0IGh0bWxQcm9qZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGh0bWxQcm9qZWN0LmlubmVySFRNTCA9IE5vTWF0Y2hlcztcbiAgICAgIGxpc3QuYXBwZW5kQ2hpbGQoaHRtbFByb2plY3QuY2hpbGRyZW5bMF0pO1xuICAgIH1cblxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFNob3cgdGhlIG1vZHVsZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlcnIgLSBlcnJvciBjb2RlIHRvIHByaW50IG9uIHRoZSB2aWV3XG4gICAgICovXG4gICAgcmVuZGVyOiByZW5kZXJQYWdlLFxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgbW9kdWxlIGZyb20gdWlcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICBwYWdpbmF0aW9uLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGNvbnRlbnQpO1xuICAgICAgY3VycmVudFBhZ2UgPSAwO1xuICAgIH0sXG4gIH07XG59O1xuIiwiLyoqXG4gKiBoYW5kbGVzIGFsbCB0ZXh0c1xuICovXG52YXIgdGV4dHMgPSAoZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgbm9kZSxcbiAgICAgICAgbGFuZ3VhZ2VOYW1lcyA9IHtcbiAgICAgICAgICAgIGRhOiAnRGFubWFyaycsXG4gICAgICAgICAgICBkZTogJ0RldXRzY2hsYW5kJyxcbiAgICAgICAgICAgIGZyOiAnRnJhbmNlJyxcbiAgICAgICAgICAgIG5sOiAnTmVkZXJsYW5kJyxcbiAgICAgICAgICAgIGVuOiAnVW5pdGVkIFN0YXRlcyAoRGVmYXVsdCknLFxuICAgICAgICAgICAgZW5fR0I6ICdVbml0ZWQgS2luZ2RvbScsXG4gICAgICAgICAgICBzdjogJ1N2ZXJpZ2UnLFxuICAgICAgICAgICAgZXM6ICdFc3Bhbm9sJ1xuICAgICAgICB9LFxuICAgICAgICB0ZXh0cyA9IHtcbiAgICAgICAgICAgIGNoYW5nZVRleHRzIDogIGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICAgICAgZGF0YSA6IHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0TmFtZTogJycsXG4gICAgICAgICAgICAgICAgcHJvamVjdERlc2NyaXB0aW9uOiAnJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0TGFuZ3VhZ2VOYW1lcyA6IGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4gbGFuZ3VhZ2VOYW1lc1trZXldfSxcbiAgICAgICAgc2V0VGV4dHMgOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdGV4dHMuY2hhbmdlVGV4dHMoJ21zZycsIGRhdGEpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRUZXh0cyA6IGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3RleHRzOnllcyB0ZXh0IGlzIHRyaWdnZXJlZCcpO1xuICAgICAgICAgICAgdGV4dHMuY2hhbmdlVGV4dHMgPSBmYztcbiAgICAgICAgICAgIHRleHRzLmNoYW5nZVRleHRzKCdtc2cnLCB0ZXh0cy5kYXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkIDogZnVuY3Rpb24gKGVsZW0sIGF0dHIpIHtcbiAgICAgICAgICAgIG5vZGUgPSBlbGVtO1xuICAgICAgICB9LFxuICAgICAgICByZWFkeSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCd0ZXh0cyByZWFkeSEnKTtcbiAgICAgICAgfVxuICAgIH07XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRleHRzOyIsInZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnLmpzJyksXG4gICAgaW5wdXRFZGl0TWFuYWdlciA9IHJlcXVpcmUoJy4vaW5wdXRFZGl0TWFuYWdlci5qcycpLFxuICAgIHdvcmRDb3VudGVyID0gcmVxdWlyZSgnLi4vdXRpbC93b3JkQ291bnRlcicpLFxuICAgIGRpc3BsYXlNYW5hZ2VyID0gcmVxdWlyZSgnY2FubnknKS5kaXNwbGF5TWFuYWdlcixcbiAgICBjb25mID0ge1xuICAgICAgICByb3dQcmVmaXg6IFwidHZfXCIsXG4gICAgICAgIGlucHV0UHJlZml4OiBcImtleVZhbHVlX1wiLFxuICAgICAgICBpbnB1dFRyYW5zUHJlZml4OiBcInRyYW5zX1wiXG4gICAgfSxcbiAgICBjYXRQcmVmaXggPSAndHZfJztcbi8qKlxuICogUmVuYW1lIGFsbCBET00gaWQgYXR0cmlidXRlcyBmcm9tIG9sZCB0byBuZXcga2V5XG4gKiBAcGFyYW0gb2xkS2V5XG4gKiBAcGFyYW0gbmV3S2V5XG4gKi9cbmZ1bmN0aW9uIHJlbmFtZURPTUlkcyhvbGRLZXksIG5ld0tleSwgYXZhaWxhYmxlTGFuZ3VhZ2VzKSB7XG4gICAgT2JqZWN0LmtleXMoY29uZikuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBpZiAocHJvcCA9PT0gJ2lucHV0VHJhbnNQcmVmaXgnKSB7XG4gICAgICAgICAgICBhdmFpbGFibGVMYW5ndWFnZXMuZm9yRWFjaChmdW5jdGlvbihsYW5nKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGdldExhbmd1YWdlVGV4dElkKG9sZEtleSwgbGFuZykpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdpZCcsIGdldExhbmd1YWdlVGV4dElkKG5ld0tleSwgbGFuZykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3RyYW5zbGF0aW9uVmlldzpyZW5hbWVJZHMgY2FuIG5vdCBmaW5kIGRvbSBub2RlIGZvciBpZCcsIGdldExhbmd1YWdlVGV4dElkKG5ld0tleSwgbGFuZykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29uZltwcm9wXSArIG9sZEtleSk7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdpZCcsIGNvbmZbcHJvcF0gKyBuZXdLZXkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCd0cmFuc2xhdGlvblZpZXc6cmVuYW1lSWRzIGNhbiBub3QgZmluZCBkb20gbm9kZSBmb3IgaWQnLCBjb25mW3Byb3BdICsgb2xkS2V5LCAncHJvcGVydHk6JywgcHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24ga2V5S2V5UHJlc3NMaXN0ZW5lcihlKSB7XG4gICAgdmFyIGtleSA9IGUua2V5Q29kZSB8fCBlLndoaWNoO1xuICAgIGlmIChrZXkgPT09IDMyKSB7XG4gICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTmV3S2V5KHN0cmluZykge1xuICAgIHJldHVybiAoc3RyaW5nLmxlbmd0aCA+IDAgJiYgc3RyaW5nLnNlYXJjaCgnXFxcXC58LHwgJykgPT09IC0xKSA/IHRydWUgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0TGFuZ3VhZ2VUZXh0SWQoa2V5LCBsYW5nKSB7XG4gICAgcmV0dXJuIGNvbmYuaW5wdXRUcmFuc1ByZWZpeCArIFtrZXksIGxhbmddLmpvaW4oJ18nKTtcbn1cblxuZnVuY3Rpb24gZ2V0V29yZENvdW50VGV4dChjb3VudCkge1xuICAgIHJldHVybiAnV29yZHM6ICcgKyBjb3VudDtcbn1cblxuLyoqXG4gKiBDb3VudHMgdGhlIGNoYXJhY3RlcnMgb2YgdGhlIGdpdmVuIHBhcmFtZXRlci5cbiAqXG4gKiBOb3cgY291bnRzOlxuICogcHVuY3R1YXRpb24sIFdoaXRlc3BhY2VzIGFuZCBXb3Jkcy9sZXR0ZXJzXG4gKlxuICogQnV0IGRvZXMgbm90IGNvdW50OlxuICogY3VybHkgYnJhY2VzICggezB9ICksIGh0bWwgdGFncyAoIDxici8+ICkgYW5kIG51bWJlcnMgKDMgZWdncylcbiAqIEBwYXJhbSB2YWx1ZVxuICovXG5mdW5jdGlvbiBnZXRDaGFyYWN0ZXJDb3VudCh2YWx1ZSkge1xuICAgIHdoaWxlICgvey4qP30vLnRlc3QodmFsdWUpKXsvL3JlbW92ZSBwbGFjZWhvbGRlcnNcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC97Lio/fS8sICcnKVxuICAgIH1cbiAgICB3aGlsZSAoLzwuKj8+Ly50ZXN0KHZhbHVlKSl7Ly9yZW1vdmUgaHRtbCB0YWdzXG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvPC4qPz4vLCAnJylcbiAgICB9XG4gICAgd2hpbGUgKC9cXFxcIS8udGVzdCh2YWx1ZSkpey8vcmVtb3ZlIGxlYWRpbmcgc2xhc2hlcyBpbiBmcm9udCBvZiAhXG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxcXCEvLCAnIScpXG4gICAgfVxuICAgIHJldHVybiBbLi4udmFsdWVdLmZpbHRlcigoY2hhcikgPT4gL1tcXERdLy50ZXN0KGNoYXIpKS5sZW5ndGhcbn1cblxuZnVuY3Rpb24gZ2V0V29yZENvdW50SGVhZGxpbmUoY2F0ZWdvcnkpIHtcbiAgICByZXR1cm4gJ092ZXJhbGwgd29yZHMgaW4gJyArIGNhdGVnb3J5O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVXb3JkQ291bnRGb3JMYW5ndWFnZShsYW5nKSB7XG4gICAgdmFyIGNvdW50V3JhcHBlciA9IGRvbU9wdHMuY3JlYXRlRWxlbWVudCgnZGl2JywgbnVsbCwgJ2RhdGEganNfJyArIGxhbmcpLFxuICAgICAgICBmbGFnQ2xhc3MgPSBmbGFnLmdldEZsYWdDbGFzc2VzKGxhbmcpLnBvcCgpLFxuICAgICAgICB3b3JkQ291bnRMYWJlbCA9IGRvbU9wdHMuY3JlYXRlRWxlbWVudCgnc3BhbicsIG51bGwsICd3b3JkQ291bnRMYWJlbCAnLmNvbmNhdChmbGFnQ2xhc3MpKTtcbiAgICB3b3JkQ291bnRMYWJlbC5pbm5lckhUTUwgPSBnZXRXb3JkQ291bnRUZXh0KDApO1xuICAgIGNvdW50V3JhcHBlci5hcHBlbmRDaGlsZCh3b3JkQ291bnRMYWJlbCk7XG4gICAgcmV0dXJuIGNvdW50V3JhcHBlcjtcbn1cblxuLyoqXG4gKiBoYW5kbGUgdGhlIHRyYW5zbGF0aW9uIG92ZXJ2aWV3XG4gKiBUT0RPIHJlZmFjdG9yIGJhc2UuY29ubmVjdGlvblxuICovXG52YXIgdHJhbnNsYXRpb25WaWV3ID0gKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIFRPRE8gcmVtb3ZlIHByb2plY3QgbmFtZSAtIG9ubHkgdGhlIGNvbnRyb2xsZXIgbmVlZHMgdG8ga25vdyB0aGlzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIEBkZXByZWNhdGVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqXG4gICAgICogQGNsYXNzXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2F2ZU9uTGVhdmUobm9kZSwga2V5LCBsYW5nLCB0ZXh0KSB7XG4gICAgICAgIHZhciB0ZXh0TGlzdCA9IFt0ZXh0XSxcbiAgICAgICAgICAgIHRleHRJZHggPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBrZXkgaWRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGdldElkRnJvbVJvdyhub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlLnBhcmVudE5vZGUucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ2lkJykucmVwbGFjZShjb25mLnJvd1ByZWZpeCwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk9sZDogXCIgKyB0ZXh0TGlzdFt0ZXh0SWR4XSk7XG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHRleHRMaXN0W3RleHRJZHhdICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRleHRMaXN0LnB1c2gobmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIHRleHRJZHgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRleHRMaXN0KTtcbiAgICAgICAgICAgIG9uU2F2ZUtleSAmJiBvblNhdmVLZXkoZ2V0SWRGcm9tUm93KG5vZGUpLCBsYW5nLCBuZXdWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFuIHVwIHRoZSBhdHRhY2hlZCBldmVudCBsaXN0ZW5lcnMgYW5kIHJlbW92ZXMgdGhlbSBmcm9tIHRoZSBub2RlLlxuICAgICAqIEl0IHJlbW92ZXMgdGhlICdjaGFuZ2UnIGFuZCAna2V5cHJlc3MnIGV2ZW50IGZyb20gYWxsIHRleHRBcmVhJ3MgYW5kIGlucHV0IGZpZWxkcyBhbmRcbiAgICAgKiBzZXQgaXQgdG8gXCJyZWFkIG9ubHlcIlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcm93Tm9kZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzRnJvbVJvdyhyb3dOb2RlKSB7XG4gICAgICAgIFtdLnNsaWNlLmNhbGwocm93Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKCd0ZXh0YXJlYScpKS5mb3JFYWNoKGZ1bmN0aW9uKHRhcmVhKSB7XG4gICAgICAgICAgICB0YXJlYS5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmYWxzZSk7XG4gICAgICAgICAgICB0YXJlYS5zZXRBdHRyaWJ1dGUoJ3JlYWRvbmx5JywgJ3RydWUnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgW10uc2xpY2UuY2FsbChyb3dOb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0JykpLmZvckVhY2goZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICAgIGlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgZmFsc2UpO1xuICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdyZWFkb25seScsICd0cnVlJyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY2F0Tm9kZVRvSW5zZXJ0XG4gICAgICogQHBhcmFtIHtBcnJheTxIVE1MRWxlbWVudD59IGNhdE5vZGVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zZXJ0Q2F0ZWdvcnkoY2F0Tm9kZVRvSW5zZXJ0LCBjYXROb2Rlcykge1xuICAgICAgICB2YXIgY2F0VG9BcHBlbmRJRCA9IGNhdE5vZGVUb0luc2VydC5pZC50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgc2hvd25DYXROb2RlLFxuICAgICAgICAgICAgc2hvd25DYXRJRDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhdE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzaG93bkNhdE5vZGUgPSBjYXROb2Rlc1tpXTtcbiAgICAgICAgICAgIHNob3duQ2F0SUQgPSBjYXROb2Rlc1tpXS5pZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKGNhdFRvQXBwZW5kSUQgPCBzaG93bkNhdElEKSB7XG4gICAgICAgICAgICAgICAgcm9vdE5vZGUuaW5zZXJ0QmVmb3JlKGNhdE5vZGVUb0luc2VydCwgc2hvd25DYXROb2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjYXROb2Rlcy5sZW5ndGggPT09IDAgfHwgY2F0VG9BcHBlbmRJRCA+IHNob3duQ2F0SUQpIHtcbiAgICAgICAgICAgIHJvb3ROb2RlLmFwcGVuZENoaWxkKGNhdE5vZGVUb0luc2VydCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcm9vdE5vZGUsIC8vIG1haW4gbm9kZSBhbGwgY29udGVudCBhcmUgYWRkZWQgdG8gaGVyZVxuICAgICAgICByZW5kZXJUZXh0RmMsXG4gICAgICAgIHNlbGVjdG9ycyA9IHtcbiAgICAgICAgICAgIHJvb3Q6IFwicmVzb3VyY2VCdW5kbGVUYWJsZVwiLFxuICAgICAgICAgICAgZGVidWc6IFwiZGVidWdJbmNvbW1pbmdcIixcbiAgICAgICAgICAgIHRwbDoge1xuICAgICAgICAgICAgICAgIHRhYmxlQm9keTogJ3RhYmxlQm9keSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gUVVFU1RJT046IGFyZSB0aGVzZSByZWFsIHF1ZXVlcz9cbiAgICAgICAgb25RdWV1ZXMgPSB7XG4gICAgICAgICAgICBhZGROZXdLZXk6IFtdLFxuICAgICAgICAgICAgY3JlYXRlTmV3UHJvamVjdDogW10sXG4gICAgICAgICAgICByZW1vdmVLZXk6IFtdLFxuICAgICAgICAgICAgcmVuYW1lS2V5OiBbXSxcbiAgICAgICAgICAgIGNhdGVnb3J5Q2xpY2tlZDogW10sXG4gICAgICAgICAgICByZW1vdmVDYXRlZ29yeTogW10sXG4gICAgICAgICAgICByZW5hbWVDYXRlZ29yeTogW11cbiAgICAgICAgfSxcbiAgICAgICAgdWkgPSB7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICBzZW5kU3VjY2VzczogJ3NlbmRTdWNjZXNzJyxcbiAgICAgICAgICAgICAgICB1cGRhdGVLZXk6ICd1cGRhdGVLZXknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIGtleVxuICAgICAgICAgICAgICogQHBhcmFtIGlucHV0UHJlZml4XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNlbmRTdWNjZXNzOiBmdW5jdGlvbihrZXksIGlucHV0UHJlZml4KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUxID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29uZi5yb3dQcmVmaXggKyBrZXkpLFxuICAgICAgICAgICAgICAgICAgICBub2RlMiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlucHV0UHJlZml4ICsga2V5KTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdWkucmVtb3ZlU3RhdGVDbGFzc2VzKG5vZGUxKS5jbGFzc0xpc3QucmVtb3ZlKHVpLmNzcy5zZW5kU3VjY2Vzcyk7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1aS5yZW1vdmVTdGF0ZUNsYXNzZXMobm9kZTEpLmNsYXNzTGlzdC5hZGQodWkuY3NzLnNlbmRTdWNjZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMTAwKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9kZTIpIHtcbiAgICAgICAgICAgICAgICAgICAgdWkucmVtb3ZlU3RhdGVDbGFzc2VzKG5vZGUyKS5jbGFzc0xpc3QucmVtb3ZlKHVpLmNzcy5zZW5kU3VjY2Vzcyk7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1aS5yZW1vdmVTdGF0ZUNsYXNzZXMobm9kZTIpLmNsYXNzTGlzdC5hZGQodWkuY3NzLnNlbmRTdWNjZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMTAwKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVJbnB1dEZpZWxkczogZnVuY3Rpb24oa2V5LCBpbnB1dFByZWZpeCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3RyYW5zbGF0aW9uVmlldzp1cGRhdGVJbnB1dEZpZWxkcycsICdpcyB0aGlzIHN0aWxsIGluIHVzZT8/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/PycpO1xuICAgICAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaW5wdXRQcmVmaXggKyBrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHVpLnJlbW92ZVN0YXRlQ2xhc3Nlcyhub2RlKS5kb21BZGRDbGFzcyh1aS5jc3MudXBkYXRlS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlU3RhdGVDbGFzc2VzOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNzc1N0YXRlLCBjbGFzc2VzID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETyByZWZhY3RvciBPYmplY3Qua2V5cygpXG4gICAgICAgICAgICAgICAgZm9yIChjc3NTdGF0ZSBpbiB1aS5jc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NlcyArPSBjc3NTdGF0ZSArICcgJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS5kb21SZW1vdmVDbGFzcyhjbGFzc2VzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIChyZWdpc3RlcmVkIGZyb20gY29udHJvbGxlcikgdG8gYmUgY2FsbGVkIHdoZW4gY2hhbmdlcyB0byBhIGtleSBtdXN0IGJlIHNhdmVkXG4gICAgICAgICAqL1xuICAgICAgICBvblNhdmVLZXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndHJhbnNsYXRpb25WaWV3Om9uU2F2ZUtleSBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25DcmVhdGVLZXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndHJhbnNsYXRpb25WaWV3Om9uQ3JlYXRlS2V5IG5vdCBpbml0aWFsaXplZCcpO1xuICAgICAgICB9LFxuICAgICAgICBvbkNsb25lS2V5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3RyYW5zbGF0aW9uVmlldzpvbkNsb25lS2V5IG5vdCBpbml0aWFsaXplZCcpO1xuICAgICAgICB9LFxuICAgICAgICBicmFpbiA9IHtcbiAgICAgICAgICAgIGNsb25lS2V5T3ZlcmxheToge1xuICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldERhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyVGV4dEZjKCdjbG9uZUtleU92ZXJsYXlUZXh0Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5TmFtZTogZGF0YS5rZXlOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnlOYW1lOiBkYXRhLmNvbnRleHROYW1lXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb25lS2V5SW5wdXRDYXRlZ29yeToge1xuICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvbmVLZXlCdXR0b25TdWJtaXQ6IHtcbiAgICAgICAgICAgICAgICBpbml0OiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChicmFpbi5jbG9uZUtleUlucHV0Q2F0ZWdvcnkubm9kZS52YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmFpbi5jbG9uZUtleUlucHV0Q2F0ZWdvcnkubm9kZS5jbGFzc0xpc3QuYWRkKCdlcnJvcicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYnJhaW4uY2xvbmVLZXlPdmVybGF5LmdldERhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xvbmVLZXkoZGF0YS5rZXksIGRhdGEua2V5TmFtZSwgZGF0YS5jb250ZXh0TmFtZSwgYnJhaW4uY2xvbmVLZXlJbnB1dENhdGVnb3J5Lm5vZGUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3JlYXRlTmV3UHJvamVjdElucHV0UHJvamVjdDoge1xuICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3JlYXRlTmV3UHJvamVjdFByb2plY3REZXNjcmlwdGlvbjoge1xuICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3JlYXRlTmV3UHJvamVjdFN1Ym1pdDogKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBlbGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9qZWN0VmFsdWUgPSBicmFpbi5jcmVhdGVOZXdQcm9qZWN0SW5wdXRQcm9qZWN0Lm5vZGUudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVOZXdLZXkocHJvamVjdFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHJlYWQgZGVzY3JpcHRpb24gZmllbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25RdWV1ZXMuY3JlYXRlTmV3UHJvamVjdC5mb3JFYWNoKGZ1bmN0aW9uKGZjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYyhwcm9qZWN0VmFsdWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYnJhaW4uY3JlYXRlTmV3UHJvamVjdFByb2plY3REZXNjcmlwdGlvbi5ub2RlLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gY2hlY2sgaWYgY2xvc2VkIGlzIG5lZWRlZD9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU1hbmFnZXIuaGlkZSgnY3JlYXRlTmV3UHJvamVjdFZpZXcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHJlcGxhY2Ugd2l0aCBjbGFzc2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyYWluLmNyZWF0ZU5ld1Byb2plY3RJbnB1dFByb2plY3Qubm9kZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI2ZmNDQ0NCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KCkpLFxuICAgICAgICAgICAgcHJvamVjdFNob3c6IHtcbiAgICAgICAgICAgICAgICBpbml0OiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlNYW5hZ2VyLnNob3coJ3RyYW5zbGF0aW9uVmlld1Byb2plY3RDYXRlZ29yeUtleScpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvamVjdElucHV0Q2F0ZWdvcnk6IHtcbiAgICAgICAgICAgICAgICBpbml0OiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb2plY3RJbnB1dEtleToge1xuICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FuY2VsIDogKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpbml0IDogKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5ueS5kaXNwbGF5TWFuYWdlci5oaWRlKHRoaXMuZGF0YXNldC52aWV3KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCksXG4gICAgICAgICAgICBwcm9qZWN0U3VibWl0OiAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW07XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhdGVnb3J5S2V5ID0gYnJhaW4ucHJvamVjdElucHV0Q2F0ZWdvcnkubm9kZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gYnJhaW4ucHJvamVjdElucHV0S2V5Lm5vZGUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0tleTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZU5ld0tleShjYXRlZ29yeUtleSkgJiYgdmFsaWRhdGVOZXdLZXkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGRlZmF1bHQgbGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3S2V5ID0gY2F0ZWdvcnlLZXkgKyAnXycgKyBrZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ3JlYXRlS2V5KG5ld0tleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyByZXBsYWNlIHdpdGggY2xhc3Nlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmFpbi5wcm9qZWN0SW5wdXRDYXRlZ29yeS5ub2RlLmNsYXNzTGlzdC5hZGQoJ2Vycm9yJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJhaW4ucHJvamVjdElucHV0S2V5Lm5vZGUuY2xhc3NMaXN0LmFkZCgnZXJyb3InKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSgpKVxuICAgICAgICB9LFxuICAgICAgICBmYyA9IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHt7cm93UHJlZml4OiBzdHJpbmcsIGlucHV0UHJlZml4OiBzdHJpbmcsIGlucHV0VHJhbnNQcmVmaXg6IHN0cmluZ319XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldCBjb25maWcgKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25mO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuYWJsZUVkaXRvck1vZGU6IGZ1bmN0aW9uKGVuYWJsZSkge1xuICAgICAgICAgICAgICAgIGlmIChlbmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdE5vZGUuY2xhc3NMaXN0LmFkZCgnYy1lbmFibGVFZGl0b3JNb2RlJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdE5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnYy1lbmFibGVFZGl0b3JNb2RlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvZ2dsZVdvcmRDb3VudDogZnVuY3Rpb24oZW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgcm9vdE5vZGUuY2xhc3NMaXN0LnRvZ2dsZSgnYy13b3JkQ291bnRFbmFibGVkJywgZW5hYmxlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZW5kU3VjY2VzczogdWkuc2VuZFN1Y2Nlc3MsXG4gICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uKG5vZGUsIGF0dHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ciA9PT0gJ21haW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3ROb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJyYWluLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyYWluW2F0dHJdLmluaXQobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFZpZXdLZXlPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHZhciBuZXdLZXksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHROYW1lID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyID0gJ18nO1xuICAgICAgICAgICAgICAgIGlmICgvXFwuLy50ZXN0KG9iai5rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGltaXRlciA9ICcuJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuZXdLZXkgPSBvYmoua2V5LnNwbGl0KGRlbGltaXRlcik7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV3S2V5Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIHNsaWNlIGlmIHdlIG5lZWQgdGhlIGNvbXBsZXRlIGtleSBpbiB0aGUgdmlld1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0TmFtZSA9IG5ld0tleS5zcGxpY2UoMCwgMSlbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBvYmoua2V5LCAgLy8gZGVwcmVjYXRlZFxuICAgICAgICAgICAgICAgICAgICBrZXk6IG9iai5rZXksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHROYW1lOiBjb250ZXh0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAga2V5TmFtZTogbmV3S2V5LmpvaW4oZGVsaW1pdGVyKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9iai52YWx1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNCdW5kbGVFcXVhbDogZnVuY3Rpb24oYnVuZGxlMSwgYnVuZGxlMikge1xuICAgICAgICAgICAgICAgIGlmIChidW5kbGUxLmJ1bmRsZSA9PT0gYnVuZGxlMi5idW5kbGUgJiYgYnVuZGxlMS5sb2NhbGUgPT09IGJ1bmRsZTIubG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0QnVuZGxlTmFtZUZyb206IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYnVuZGxlOiBkb21PcHRzLnBhcmFtcy5idW5kbGUgfHwgJ21lc3NhZ2VzJyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmdldEZyb21QYXJhbSgpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRGcm9tUGFyYW06IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb21PcHRzLnBhcmFtcy5mcm9tIHx8ICdkZSc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0QnVuZGxlTmFtZVRvOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJ1bmRsZTogZG9tT3B0cy5wYXJhbXMuYnVuZGxlIHx8ICdtZXNzYWdlcycsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZTogZG9tT3B0cy5wYXJhbXMudG8gfHwgbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0QnVuZGxlTmFtZTogZnVuY3Rpb24obG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ1bmRsZSA9IGRvbU9wdHMucGFyYW1zLmJ1bmRsZSB8fCAnbWVzc2FnZXMnO1xuICAgICAgICAgICAgICAgIHJldHVybiBidW5kbGUgKyAnXycgKyBsb2NhbGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZW5kZXIgdGhlIGkxOG4gaW5wdXQgZmllbGQgZm9yIGtleXMgZnJvbSBhIHNpbmdsZSBsYW5ndWFnZS4gVGhlIHJvdyBoZWFkZXIgKGkuZS4gdGhlIGFjdHVhbCBrZXkgZmllbGQpIGlzXG4gICAgICAgICAgICAgKiByZW5kZXJlZCwgdG9vIGlmIGl0IGRvZXMgbm90IGV4aXN0IHlldC5cbiAgICAgICAgICAgICAqIEBwYXJhbSBidW5kbGVzIHtrZXk6IHN0cmluZywgZGF0YTogc3RyaW5nfVxuICAgICAgICAgICAgICogQHBhcmFtIGFjdHVhbExhbmd1YWdlXG4gICAgICAgICAgICAgKiBAcGFyYW0gYXZhaWxhYmxlUHJvamVjdExhbmd1YWdlc1xuICAgICAgICAgICAgICogQHBhcmFtIHByb2plY3ROYW1lXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHByaW50QnVuZGxlVGVtcGxhdGU6IGZ1bmN0aW9uKGJ1bmRsZXMsIGFjdHVhbExhbmd1YWdlLCBhdmFpbGFibGVQcm9qZWN0TGFuZ3VhZ2VzLCBjYikge1xuICAgICAgICAgICAgICAgIHZhciBrZXlPYmosXG4gICAgICAgICAgICAgICAgICAgIHByb2plY3ROb2RlLFxuICAgICAgICAgICAgICAgICAgICBzaG93bkNhdGVnb3JpZXMgPSBbXS5zbGljZS5jYWxsKHJvb3ROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXRlZ29yeU5vZGUnKSk7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBTZXR1cCBoZWFkZXIgYW5kIGhhbmRsZSB0aGUgY2F0ZWdvcnlcbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHROYW1lXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHByZXBhcmVDYXRlZ29yeU5vZGUoY29udGV4dE5hbWUsIGxhbmd1YWdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhdGVnb3J5Tm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbmYucm93UHJlZml4ICsgY29udGV4dE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYXRlZ29yeU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeU5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVtcGxhdGVzIC5jYXRlZ29yeU5vZGUnKS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnlOb2RlLmNsYXNzTGlzdC5hZGQoJ2MtYW5jaG9yTWVudS1wYXJlbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2F0ZWdvcnlOYW1lID0gY29udGV4dE5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhdGVnb3J5Tm9kZUlkID0gY2F0ZWdvcnlOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5Tm9kZS5zZXRBdHRyaWJ1dGUoJ2lkJywgY29uZi5yb3dQcmVmaXggKyBjYXRlZ29yeU5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhdGVnb3J5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd3JhcHBlciA9IGNhdGVnb3J5Tm9kZS5xdWVyeVNlbGVjdG9yKCcuaGVhZGxpbmVXcmFwcGVyJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoMiA9IGNhdGVnb3J5Tm9kZS5xdWVyeVNlbGVjdG9yKCdoMicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIG1ha2UgYSBzcGFuIGZvciBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoMi5hcHBlbmRDaGlsZCgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNhdGVnb3J5TmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSAna2V5TmFtZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3BhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaDIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25RdWV1ZXMuY2F0ZWdvcnlDbGlja2VkLmZvckVhY2goZnVuY3Rpb24oZmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYyhjYXRlZ29yeU5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVkaXRQYW5lbCA9IGlucHV0RWRpdE1hbmFnZXIuYWRkRWRpdG9yUGFuZWwoY2F0ZWdvcnlOb2RlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVkaXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5SW5wdXROb2RlLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0TmFtZSA9IGtleUlucHV0Tm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlJbnB1dE5vZGUuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNhbmNlbDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlJbnB1dE5vZGUuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5SW5wdXROb2RlLnZhbHVlID0gY29udGV4dE5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25TYXZlOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUXVldWVzLnJlbmFtZUNhdGVnb3J5LmZvckVhY2goZnVuY3Rpb24oZmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkTmFtZTogY29udGV4dE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdOYW1lOiBrZXlJbnB1dE5vZGUudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25EZWxldGU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHllcyA9IHdpbmRvdy5jb25maXJtKCdEZWxldGUgdGhpcyBjYXRlZ29yeT9cXG5BbGwga2V5cyB3aXRoaW4gd2l0aCB3aWxsIGJlIGxvc3QuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblF1ZXVlcy5yZW1vdmVDYXRlZ29yeS5mb3JFYWNoKGZ1bmN0aW9uKGZjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnk6IGNhdGVnb3J5TmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoZWRpdFBhbmVsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5SW5wdXROb2RlID0gZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIGNvbmYucm93UHJlZml4ICsgY2F0ZWdvcnlOYW1lICsgJ19pbnB1dCcsICdjYXRlZ29yeUZpZWxkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleUlucHV0Tm9kZS5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ3RydWUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5SW5wdXROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5SW5wdXROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywga2V5S2V5UHJlc3NMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgyLmFwcGVuZENoaWxkKGtleUlucHV0Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleUlucHV0Tm9kZS52YWx1ZSA9IGNhdGVnb3J5TmFtZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIGRlc2NyaXB0aW9uIGZ1bmN0aW9uYWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhdERlc2NOb2RlID0gY2F0ZWdvcnlOb2RlLnF1ZXJ5U2VsZWN0b3IoJy5qcy1jYXQtZGVzY3JpcHRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gJ2pzLXRleHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXREZXNjTm9kZS5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhdERlc2NOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5ueS50ZXh0RWRpdG9yLmFkZChjYXREZXNjTm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjYXRlZ29yeU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICdBZGQgaGVyZSB0aGUgY2F0ZWdvcnkgZGVzY3JpcHRpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbm55LnRyYW5zbGF0aW9uVmlld0ltYWdlVXBsb2FkLmFkZChjYXRlZ29yeU5vZGUucXVlcnlTZWxlY3RvcignLmpzLWltYWdlVXBsb2FkLWVkaXRCdXR0b24nKSwgY2F0ZWdvcnlOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgYWRkIGtleSBpbnB1dCBmaWVsZCBhbmQgYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlOYW1lSW5wdXQgPSBjYXRlZ29yeU5vZGUucXVlcnlTZWxlY3RvcignLmFkZE5ld0tleXJvdyBpbnB1dCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlOYW1lSW5wdXQuc2V0QXR0cmlidXRlKCdjYXRlZ29yeScsIGNhdGVnb3J5TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleU5hbWVJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGtleUtleVByZXNzTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeU5vZGUucXVlcnlTZWxlY3RvcignbGFiZWwnKS5pbm5lclRleHQgPSBjYXRlZ29yeU5hbWUgKyBcIl9cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbiA9IGNhdGVnb3J5Tm9kZS5xdWVyeVNlbGVjdG9yKCdidXR0b24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVOZXdLZXkoa2V5TmFtZUlucHV0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdLZXkgPSBrZXlOYW1lSW5wdXQuZ2V0QXR0cmlidXRlKCdjYXRlZ29yeScpICsgJ18nICsga2V5TmFtZUlucHV0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVmYWN0b3IgdGhpcyAtIHNlcnZlciBzaG91bGQgYWRkIHRoZSBrZXkgZm9yIGFsbCBhdmFpbGFibGUgbGFuZ3VhZ2VzIC0gb3IgcGFzcyBkZWZhdWx0IGxhbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNyZWF0ZUtleShuZXdLZXksIGFjdHVhbExhbmd1YWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLnN0eWxlLmNvbG9yID0gJyNmZjAwMDAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleU5hbWVJbnB1dC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIiNmZjQ0NDRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIG92ZXJhbGwgd29yZCBjb3VudCBmb3IgZWFjaCBsYW5ndWFnZSBvZiBhIGNhdGVnb3J5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJhbGxXb3Jkc1dyYXBwZXIgPSBjYXRlZ29yeU5vZGUucXVlcnlTZWxlY3RvcignLm92ZXJhbGxXb3JkQ291bnRXcmFwcGVyJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJhbGxIZWFkbGluZSA9IG92ZXJhbGxXb3Jkc1dyYXBwZXIucXVlcnlTZWxlY3RvcignLm92ZXJhbGxXb3Jkc0hlYWRsaW5lJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzV3JhcHBlciA9IG92ZXJhbGxXb3Jkc1dyYXBwZXIucXVlcnlTZWxlY3RvcignLnRyYW5zbGF0aW9uQ29udGFpbmVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmFsbEhlYWRsaW5lLmlubmVySFRNTCA9IGdldFdvcmRDb3VudEhlYWRsaW5lKGNhdGVnb3J5TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2VzLmZvckVhY2goZnVuY3Rpb24obGFuZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1dyYXBwZXIuYXBwZW5kQ2hpbGQoY3JlYXRlV29yZENvdW50Rm9yTGFuZ3VhZ2UobGFuZykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhdGVnb3J5Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGJ1bmRsZXMuZm9yRWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleU9iaiA9IGZjLmdldFZpZXdLZXlPYmplY3QoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gd2hpY2ggd2hvIGNhbGMgdGhlIGNhdGUuLi5cbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdE5vZGUgPSBwcmVwYXJlQ2F0ZWdvcnlOb2RlKGtleU9iai5jb250ZXh0TmFtZSwgYXZhaWxhYmxlUHJvamVjdExhbmd1YWdlcyk7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydENhdGVnb3J5KHByb2plY3ROb2RlLCBzaG93bkNhdGVnb3JpZXMpO1xuICAgICAgICAgICAgICAgICAgICBmYy5hZGRSb3dXaXRoTGFuZ3VhZ2VzKHByb2plY3ROb2RlLCBrZXlPYmosIGFjdHVhbExhbmd1YWdlLCBhdmFpbGFibGVQcm9qZWN0TGFuZ3VhZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgY2IocHJvamVjdE5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpLnJlcGxhY2UoY29uZi5yb3dQcmVmaXgsICcnKSk7XG4gICAgICAgICAgICAgICAgICAgIGNiKGtleU9iai5rZXkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXBkYXRlIHRoZSB3b3JkIGNvdW50IGZvciBhIGdpdmVuIGNhdGVnb3J5XG4gICAgICAgICAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB1cGRhdGVDYXRlZ29yeVdvcmRDb3VudDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnICsgY29uZi5yb3dQcmVmaXggKyBkYXRhLmlkICsgJyAub3ZlcmFsbFdvcmRDb3VudFdyYXBwZXIgLmpzXycgKyBkYXRhLmxhbmd1YWdlICsgJyAud29yZENvdW50TGFiZWwnKTtcbiAgICAgICAgICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuaW5uZXJIVE1MID0gZ2V0V29yZENvdW50VGV4dChkYXRhLndvcmRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBjcmVhdGVzIGEga2V5IGZpZWxkXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFkZEtleUZpZWxkOiBmdW5jdGlvbihub2RlLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleUlucHV0Tm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbmYuaW5wdXRQcmVmaXggKyBkYXRhLmtleSksXG4gICAgICAgICAgICAgICAgICAgIGtleU5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKCFrZXlJbnB1dE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5SW5wdXROb2RlID0gZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIGNvbmYuaW5wdXRQcmVmaXggKyBkYXRhLmtleSwgJ2tleUZpZWxkJyk7XG4gICAgICAgICAgICAgICAgICAgIGtleU5vZGUgPSBkb21PcHRzLmNyZWF0ZUVsZW1lbnQoJ2RpdicsIG51bGwsICdkYXRhIGtleSBvY3RpY29uIG9jdGljb24ta2V5Jyk7XG4gICAgICAgICAgICAgICAgICAgIGtleUlucHV0Tm9kZS5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ3RydWUnKTtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRFZGl0TWFuYWdlci5hZGRFZGl0b3JQYW5lbChrZXlOb2RlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkRlbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHllcyA9IHdpbmRvdy5jb25maXJtKCdEZWxldGUgdGhpcyBrZXk/XFxuVGhpcyBrZXkgd2l0aCBhbGwgdHJhbnNsYXRpb25zIHdpbGwgcmVtb3ZlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUXVldWVzLnJlbW92ZUtleS5mb3JFYWNoKGZ1bmN0aW9uKGZjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBkYXRhLmtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVkaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleUlucHV0Tm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBhY3R1YWwga2V5IGZvciByZXN0b3JpbmcgaWYgY2FuY2VsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5rZXlOYW1lID0ga2V5SW5wdXROb2RlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aGUga2V5OiB0YWtlIGlkIGF0dHJpYnV0ZSBhbmQgcmVtb3ZlIHRoZSB2YWx1ZSBmcm9tIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5rZXkgPSBrZXlJbnB1dE5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpLnJlcGxhY2UoY29uZi5pbnB1dFByZWZpeCwgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY29udGV4dE5hbWUgPSBkYXRhLmtleS5zcGxpdCgnXycpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleUlucHV0Tm9kZS5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlJbnB1dE5vZGUuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5SW5wdXROb2RlLnZhbHVlID0gZGF0YS5rZXlOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2F2ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3RyYW5zbGF0aW9uVmlldzphZGRLZXlGaWVsZCBzYXZlIG5ldyBrZXknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBkYXRhLmNvbnRleHROYW1lID8gZGF0YS5jb250ZXh0TmFtZSArICdfJyArIGtleUlucHV0Tm9kZS52YWx1ZSA6IGtleUlucHV0Tm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5SW5wdXROb2RlLnZhbHVlICE9ICcnICYmIHZhbHVlICE9IGRhdGEua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUXVldWVzLnJlbmFtZUtleS5mb3JFYWNoKGZ1bmN0aW9uKGZjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3S2V5OiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRLZXk6IGRhdGEua2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyYWluLmNsb25lS2V5T3ZlcmxheS5zZXREYXRhKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlNYW5hZ2VyLnNob3coJ3RyYW5zbGF0aW9uVmlld0Nsb25lS2V5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyByZWdpc3RlciB0aGUgaW5wdXQga2V5IGxpc3RlbmVyIHRvIGNhcHR1cmUgd3JvbmcgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgIGtleUlucHV0Tm9kZS5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGtleUtleVByZXNzTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICBrZXlOb2RlLmFwcGVuZENoaWxkKChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YS5rZXlOYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuLmNsYXNzTmFtZSA9ICdrZXlOYW1lJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzcGFuXG4gICAgICAgICAgICAgICAgICAgIH0oKSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGtleU5vZGUuYXBwZW5kQ2hpbGQoa2V5SW5wdXROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pbnNlcnRCZWZvcmUoa2V5Tm9kZSwgbm9kZS5jaGlsZHJlblswXSk7XG4gICAgICAgICAgICAgICAgICAgIGtleUlucHV0Tm9kZS52YWx1ZSA9IGRhdGEua2V5TmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDYWxsIHRoaXMgdG8gdXBkYXRlL2NyZWF0ZSBhIGxhbmd1YWdlIGZpZWxkXG4gICAgICAgICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICAgICAgICogQHBhcmFtIGtleVxuICAgICAgICAgICAgICogQHBhcmFtIHZhbHVlXG4gICAgICAgICAgICAgKiBAcGFyYW0gbGFuZ1xuICAgICAgICAgICAgICogQHBhcmFtIHdvcmRDb3VudFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhZGRMYW5ndWFnZUZpZWxkOiBmdW5jdGlvbihub2RlLCBrZXksIHZhbHVlLCBsYW5nLCB3b3JkQ291bnQsIHBvc0luZGV4KSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChnZXRMYW5ndWFnZVRleHRJZChrZXksIGxhbmcpKSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YU5vZGUsXG4gICAgICAgICAgICAgICAgICAgIHdvcmRDb3VudE5vZGUsXG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb3VudE5vZGUsXG4gICAgICAgICAgICAgICAgICAgIG5ic3BOb2RlLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0SW5mb3JtYXRpb25Ob2RlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0ZXh0Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZSA9IGRvbU9wdHMuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnLCBnZXRMYW5ndWFnZVRleHRJZChrZXksIGxhbmcpLCAndGV4dEZpZWxkJyk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFOb2RlID0gZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdkaXYnLCBudWxsLCAnZGF0YSB0cGwganNfJyArIGxhbmcpO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0SW5mb3JtYXRpb25Ob2RlID0gZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdkaXYnLCBudWxsLCAndGV4dEluZm9ybWF0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIHdvcmRDb3VudE5vZGUgPSBkb21PcHRzLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCBudWxsLCAndGV4dEluZm9ybWF0aW9uLXdvcmRDb3VudExhYmVsJyk7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb3VudE5vZGUgPSBkb21PcHRzLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCBudWxsLCAndGV4dEluZm9ybWF0aW9uLWNoYXJDb3VudExhYmVsJyk7XG4gICAgICAgICAgICAgICAgICAgIHdvcmRDb3VudE5vZGUuaW5uZXJIVE1MID0gZ2V0V29yZENvdW50VGV4dCgwKTtcbiAgICAgICAgICAgICAgICAgICAgbmJzcE5vZGUgPSBkb21PcHRzLmNyZWF0ZUVsZW1lbnQoJ2RpdicsIG51bGwsICd0ZXh0SW5mb3JtYXRpb24tbmJzcFN3aXRjaCBvY3RpY29uIG9jdGljb24taXNzdWUtb3BlbmVkJyk7XG4gICAgICAgICAgICAgICAgICAgIG5ic3BOb2RlLnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnVGhlcmUgaXMgYXQgbGVhc3Qgb25lIG5vbi1icmVha2luZyBzcGFjZSBpbiB0aGlzIHRyYW5zbGF0aW9uLiBDbGljayB0byBoaWdobGlnaHQuJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGV4dEluZm9ybWF0aW9uTm9kZS5hcHBlbmRDaGlsZChmbGFnLmdldEZsYWcobGFuZykpO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0SW5mb3JtYXRpb25Ob2RlLmFwcGVuZENoaWxkKHdvcmRDb3VudE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0SW5mb3JtYXRpb25Ob2RlLmFwcGVuZENoaWxkKG5ic3BOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEluZm9ybWF0aW9uTm9kZS5hcHBlbmRDaGlsZChjaGFyQ291bnROb2RlKTtcblxuICAgICAgICAgICAgICAgICAgICBuYnNwTm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdGV4dE5vZGUudmFsdWUuaW5kZXhPZignXFx1MDBBMCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE5vZGUuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHROb2RlLnNldFNlbGVjdGlvblJhbmdlKHN0YXJ0LCBzdGFydCsxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHRleHROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ic3BOb2RlLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgICAgIHRleHROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvdW50Tm9kZS5pbm5lckhUTUwgPSBnZXRDaGFyYWN0ZXJDb3VudCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRDb3VudE5vZGUuaW5uZXJIVE1MID0gZ2V0V29yZENvdW50VGV4dCh3b3JkQ291bnRlci5jb3VudFdvcmRzSW5TdHJpbmcodGhpcy52YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrT25OQlNQKHRoaXMudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmJzcE5vZGUuY2xhc3NMaXN0LmFkZCgnc2hvdycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHROb2RlLnBhcmVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnaGFzLW5ic3AnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmJzcE5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHROb2RlLnBhcmVudEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnaGFzLW5ic3AnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIG5ldyBTYXZlT25MZWF2ZSh0ZXh0Tm9kZSwga2V5LCBsYW5nLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YU5vZGUuYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhTm9kZS5hcHBlbmRDaGlsZCh0ZXh0SW5mb3JtYXRpb25Ob2RlKTtcblxuICAgICAgICAgICAgICAgICAgICBub2RlLmluc2VydEJlZm9yZShcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuW3Bvc0luZGV4XVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd29yZENvdW50Tm9kZSA9IHRleHROb2RlLnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvcignLnRleHRJbmZvcm1hdGlvbi13b3JkQ291bnRMYWJlbCcpO1xuICAgICAgICAgICAgICAgICAgICBjaGFyQ291bnROb2RlID0gdGV4dE5vZGUucGFyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yKCcudGV4dEluZm9ybWF0aW9uLWNoYXJDb3VudExhYmVsJyk7XG4gICAgICAgICAgICAgICAgICAgIG5ic3BOb2RlID0gdGV4dE5vZGUucGFyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yKCcudGV4dEluZm9ybWF0aW9uLW5ic3BTd2l0Y2gnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHROb2RlLnZhbHVlID0gdmFsdWUgPyB1bmljb2RlLmVuY29kZSh2YWx1ZSkgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgd29yZENvdW50Tm9kZS5pbm5lckhUTUwgPSBnZXRXb3JkQ291bnRUZXh0KHdvcmRDb3VudGVyLmNvdW50V29yZHNJblN0cmluZyh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICBjaGFyQ291bnROb2RlLmlubmVySFRNTCA9IGdldENoYXJhY3RlckNvdW50KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tPbk5CU1AodGV4dE5vZGUudmFsdWUpID8gdGV4dE5vZGUucGFyZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdoYXMtbmJzcCcpIDogdGV4dE5vZGUucGFyZW50RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdoYXMtbmJzcCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrT25OQlNQKHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC9cXHUwMEEwLy50ZXN0KHRleHQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogY3JlYXRlcyBhIHJvd1xuICAgICAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAgICAgICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSB0aGUgZXhpc3Rpbmcgcm93IG9yIGluIGNhc2UgaWYgbm90IGV4aXN0cyBhIG5ldyBjcmVhdGVkIHJvd1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXRSb3c6IGZ1bmN0aW9uKG5vZGUsIGtleSkge1xuICAgICAgICAgICAgICAgIC8vIHRyeSB0byBnZXQgdGhlIHJvd1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb25mLnJvd1ByZWZpeCArIGtleSksXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uQ29udGFpbmVyID0gcm93ICE9PSBudWxsID8gcm93LnF1ZXJ5U2VsZWN0b3IoJy50cmFuc2xhdGlvbkNvbnRhaW5lcicpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbkNvbnRhaW5lci5jbGFzc05hbWUgPSBcInRyYW5zbGF0aW9uQ29udGFpbmVyXCI7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHJvdyBidXQgaXQgaXMgbWFya2VkIGFzIHJlbW92ZWQgdGhhbiByZW1vdmVkIGl0XG4gICAgICAgICAgICAgICAgaWYgKHJvdyAmJiByb3cuY2xhc3NMaXN0LmNvbnRhaW5zKCdjLXJlbW92ZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICByb3cuZG9tUmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgcm93IGlmIHRoZSByb3cgaXMgbm90IGV4aXN0c1xuICAgICAgICAgICAgICAgIGlmICghcm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IGRvbU9wdHMuY3JlYXRlRWxlbWVudCgnZGl2JywgY29uZi5yb3dQcmVmaXggKyBrZXksICdyb3cgYy1yb3cgYy1hbmNob3JNZW51LWNoaWxkJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgZGVzY3JpcHRpb24gZnVuY3Rpb25hbGl0eVxuICAgICAgICAgICAgICAgICAgICB2YXIgY2F0RGVzY05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gJ2pzLXRleHQnO1xuICAgICAgICAgICAgICAgICAgICBjYXREZXNjTm9kZS5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgY2F0RGVzY05vZGUuY2xhc3NOYW1lID0gJ2pzLXJvdy1kZXNjcmlwdGlvbic7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZChjYXREZXNjTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGNhbm55LnRleHRFZGl0b3IuYWRkKGNhdERlc2NOb2RlLCB7aWQ6IGtleSwgcGxhY2Vob2xkZXI6ICdBZGQgaGVyZSB0aGUga2V5IGRlc2NyaXB0aW9uJ30pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgdHJhbnNsYXRpb24gYXJlYSBmaWVsZCBjb250YWluZXJcbiAgICAgICAgICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKHRyYW5zbGF0aW9uQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5xdWVyeVNlbGVjdG9yKCcua2V5c1dyYXBwZXInKS5hcHBlbmRDaGlsZChyb3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZFJvd1dpdGhMYW5ndWFnZXM6IGZ1bmN0aW9uKG5vZGUsIGRhdGEsIGFjdHVhbExhbmd1YWdlLCBhbGxQcm9qZWN0TGFuZ3VhZ2VzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IGZjLmdldFJvdyhub2RlLCBkYXRhLmtleSk7XG5cbiAgICAgICAgICAgICAgICBmYy5hZGRLZXlGaWVsZChyb3csIGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgYWxsUHJvamVjdExhbmd1YWdlcy5mb3JFYWNoKGZ1bmN0aW9uKGxhbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZmMuYWRkTGFuZ3VhZ2VGaWVsZChyb3cucXVlcnlTZWxlY3RvcignLnRyYW5zbGF0aW9uQ29udGFpbmVyJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbExhbmd1YWdlID09PSBsYW5nID8gZGF0YS52YWx1ZSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5nKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRMYW5ndWFnZTogZnVuY3Rpb24oa2V5cywgbGFuZywgcG9zSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93LFxuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yaWVzID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDYXRlZ29yeTtcbiAgICAgICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbmYucm93UHJlZml4ICsga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmMuYWRkTGFuZ3VhZ2VGaWVsZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcm93LnF1ZXJ5U2VsZWN0b3IoXCIudHJhbnNsYXRpb25Db250YWluZXJcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENhdGVnb3J5ID0ga2V5LnNwbGl0KCdfJylbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2F0ZWdvcmllcy5pbmRleE9mKGN1cnJlbnRDYXRlZ29yeSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcmllcy5wdXNoKGN1cnJlbnRDYXRlZ29yeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd0cmFuc2xhdGlvblZpZXc6YWRkTGFuZ3VhZ2UgZm91bmQga2V5IHdoaWNoIGlzIG5vdCBhdmFpbGFibGUgaW4gdmlldzonLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjYXRlZ29yaWVzLmZvckVhY2goZnVuY3Rpb24oY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmFsbFdvcmRDb3VudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnICsgY29uZi5yb3dQcmVmaXggKyBjYXRlZ29yeSArICcgLm92ZXJhbGxXb3JkQ291bnRXcmFwcGVyIC50cmFuc2xhdGlvbkNvbnRhaW5lcicpXG4gICAgICAgICAgICAgICAgICAgIG92ZXJhbGxXb3JkQ291bnQuYXBwZW5kQ2hpbGQoY3JlYXRlV29yZENvdW50Rm9yTGFuZ3VhZ2UobGFuZykpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xlYXJWaWV3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBqdXN0IHJlc2V0IGFsbCBmb3Igbm93XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBkbyBpdCBiZXR0ZXIgOylcbiAgICAgICAgICAgICAgICBbXS5zbGljZS5jYWxsKHJvb3ROb2RlLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3ROb2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaG93TGFuZzogZnVuY3Rpb24obGFuZykge1xuICAgICAgICAgICAgICAgIC8vIHNob3cgdGhlIGxhbmcgdGFiXG4gICAgICAgICAgICAgICAgcm9vdE5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnYy1oaWRlXycgKyBsYW5nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHJlbW92ZSBhIGNhdGVnb3J5XG4gICAgICAgICAgICAgKiBUT0RPIGl0J3Mgbm90IGNhbGxlZCBpZiBvd24gdXNlciByZW5hbWVzIGEgY2F0ZWdvcnlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmVuYW1lQ2F0ZWdvcnk6IGZ1bmN0aW9uKG9sZE5hbWUsIG5ld05hbWUsIGF2YWlsYWJsZVByb2plY3RMYW5ndWFnZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2F0ZWdvcnlOb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29uZi5yb3dQcmVmaXggKyBvbGROYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgcm93cyA9IGNhdGVnb3J5Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKCcuYy1yb3cnKSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGxpbmUgPSBjYXRlZ29yeU5vZGUucXVlcnlTZWxlY3RvcignaDInKSxcbiAgICAgICAgICAgICAgICAgICAgYWRkS2V5Tm9kZSA9IGNhdGVnb3J5Tm9kZS5xdWVyeVNlbGVjdG9yKCcuYWRkTmV3S2V5cm93Jyk7XG5cbiAgICAgICAgICAgICAgICBjYXRlZ29yeU5vZGUuaWQgPSBjb25mLnJvd1ByZWZpeCArIG5ld05hbWU7XG5cbiAgICAgICAgICAgICAgICBoZWFkbGluZS5xdWVyeVNlbGVjdG9yKCcua2V5TmFtZScpLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlID0gbmV3TmFtZTtcblxuICAgICAgICAgICAgICAgIGFkZEtleU5vZGUucXVlcnlTZWxlY3RvcignbGFiZWwnKS5pbm5lckhUTUwgPSBuZXdOYW1lICsgJ18nO1xuICAgICAgICAgICAgICAgIGFkZEtleU5vZGUucXVlcnlTZWxlY3RvcignaW5wdXQnKS5zZXRBdHRyaWJ1dGUoJ2NhdGVnb3J5JywgbmV3TmFtZSk7XG5cbiAgICAgICAgICAgICAgICBbXS5zbGljZS5jYWxsKHJvd3MpLmZvckVhY2goZnVuY3Rpb24ocm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IHJvdy5pZC5yZXBsYWNlKGNvbmYucm93UHJlZml4LCAnJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpdE5hbWUgPSBpZC5zcGxpdCgnXycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3S2V5TmFtZTtcblxuICAgICAgICAgICAgICAgICAgICBzcGxpdE5hbWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3S2V5TmFtZSA9IG5ld05hbWUgKyAnXycgKyBzcGxpdE5hbWUuam9pbignXycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWQgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5hbWVET01JZHMoaWQsIG5ld0tleU5hbWUsIGF2YWlsYWJsZVByb2plY3RMYW5ndWFnZXMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigndHJhbnNsYXRpb25WaWV3OnJlbmFtZUNhdGVnb3J5IHNob3VsZCBub3QgaGF2IGFuIGVtcHR5IGlkJywgcm93KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlucHV0RWRpdE1hbmFnZXIuY2xvc2VFZGl0VmlldyhoZWFkbGluZSk7XG4gICAgICAgICAgICAgICAgaGVhZGxpbmUucXVlcnlTZWxlY3RvcignLmNhdGVnb3J5RmllbGQnKS5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ3RydWUnKTtcblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogcmVtb3ZlIGEgY2F0ZWdvcnlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmVtb3ZlQ2F0ZWdvcnk6IGZ1bmN0aW9uKGNhdCkge1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb25mLnJvd1ByZWZpeCArIGNhdCk7XG4gICAgICAgICAgICAgICAgaWYgKHJvdykge1xuICAgICAgICAgICAgICAgICAgICByb3cuZG9tUmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogc2hvdyBhIGtleSBhcyBkZWxldGVkXG4gICAgICAgICAgICAgKiBAcGFyYW0ga2V5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG1hcmtLZXlBc1JlbW92ZWQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb25mLnJvd1ByZWZpeCArIGtleSksXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUljO1xuICAgICAgICAgICAgICAgIGlmIChyb3cgJiYgIXJvdy5jbGFzc0xpc3QuY29udGFpbnMoJ2MtcmVtb3ZlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5jbGFzc0xpc3QuYWRkKCdjLXJlbW92ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlSWMgPSBkb21PcHRzLmNyZWF0ZUVsZW1lbnQoJ2RpdicsIG51bGwsICdyZW1vdmUtYnV0dG9uIG9jdGljb24gb2N0aWNvbi14Jyk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUljLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3cuZG9tUmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVJYy5kb21BcHBlbmRUbyhyb3cpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyc0Zyb21Sb3cocm93KTtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRFZGl0TWFuYWdlci5yZW1vdmVQYW5lbChyb3cpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3RyYW5zbGF0aW9uVmlldzptYXJra2V5QXNSZW1vdmVkIG5vIG5vZGUgZm91bmQgZm9yIGtleScsIGtleSwgcm93KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiByZW1vdmUgYSBrZXlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmVtb3ZlS2V5OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29uZi5yb3dQcmVmaXggKyBrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93LmRvbVJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHJlbmFtZSBhIGtleVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBvbGRLZXlcbiAgICAgICAgICAgICAqIEBwYXJhbSBuZXdLZXlcbiAgICAgICAgICAgICAqIEBwYXJhbSBhdmFpbGFibGVQcm9qZWN0TGFuZ3VhZ2VzIFtdXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJlbmFtZUtleTogZnVuY3Rpb24ob2xkS2V5LCBuZXdLZXksIGF2YWlsYWJsZVByb2plY3RMYW5ndWFnZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5SW5wdXROb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29uZi5pbnB1dFByZWZpeCArIG9sZEtleSksXG4gICAgICAgICAgICAgICAgICAgIGtleU5hbWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5SW5wdXROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleU5hbWUgPSBmYy5nZXRWaWV3S2V5T2JqZWN0KHtrZXk6IG5ld0tleX0pLmtleU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHJlbmFtZURPTUlkcyhvbGRLZXksIG5ld0tleSwgYXZhaWxhYmxlUHJvamVjdExhbmd1YWdlcyk7XG4gICAgICAgICAgICAgICAgICAgIGtleUlucHV0Tm9kZS52YWx1ZSA9IGtleU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsb3NlIHRoZSBlZGl0IHZpZXdcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRFZGl0TWFuYWdlci5jbG9zZUVkaXRWaWV3KGtleUlucHV0Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGVkIHRoZSBpbnB1dCBmaWVsZFxuICAgICAgICAgICAgICAgICAgICBrZXlJbnB1dE5vZGUuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgICAgIGtleUlucHV0Tm9kZS5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3IoJy5rZXlOYW1lJykuY2hpbGROb2Rlc1swXS5ub2RlVmFsdWUgPSBrZXlOYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmVJbWFnZTogZnVuY3Rpb24oY2F0ZWdvcnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGltYWdlQm94ID0gcm9vdE5vZGUucXVlcnlTZWxlY3RvcignIycgKyBjb25mLnJvd1ByZWZpeCArIGNhdGVnb3J5TmFtZSArICcgLmltYWdlVXBsb2FkLWltYWdlQm94Jyk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGltYWdlQm94LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VCb3gucmVtb3ZlQ2hpbGQoaW1hZ2VCb3guZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGltYWdlQm94LmNsYXNzTGlzdC5yZW1vdmUoJ2Mtc2hvdycpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhpZGVMYW5nOiBmdW5jdGlvbihsYW5nKSB7XG4gICAgICAgICAgICAgICAgcm9vdE5vZGUuY2xhc3NMaXN0LmFkZCgnYy1oaWRlXycgKyBsYW5nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNyZWF0ZU5ld1Byb2plY3Q6IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgICAgICAgb25RdWV1ZXMuY3JlYXRlTmV3UHJvamVjdC5wdXNoKGNiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNhdGVnb3J5Q2xpY2tlZDogZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgICAgICAgICBvblF1ZXVlcy5jYXRlZ29yeUNsaWNrZWQucHVzaChjYik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25BZGROZXdLZXk6IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgICAgICAgb25RdWV1ZXMuYWRkTmV3S2V5LnB1c2goY2IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVuYW1lS2V5OiBmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgICAgIG9uUXVldWVzLnJlbmFtZUtleS5wdXNoKGNiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlbW92ZUtleTogZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgICAgICAgICBvblF1ZXVlcy5yZW1vdmVLZXkucHVzaChjYik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZW1vdmVDYXRlZ29yeTogZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgICAgICAgICBvblF1ZXVlcy5yZW1vdmVDYXRlZ29yeS5wdXNoKGNiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlbmFtZUNhdGVnb3J5OiBmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgICAgIG9uUXVldWVzLnJlbmFtZUNhdGVnb3J5LnB1c2goY2IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IGxvZ2ljIGZvciBoYW5kbGluZyBzYXZpbmcgY2hhbmdlcyB0byBhIGtleS5cbiAgICAgICAgICAgICAqIEBwYXJhbSBmdW5jXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG9uU2F2ZUtleTogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgICAgICAgIG9uU2F2ZUtleSA9IGZ1bmM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXQgbG9naWMgZm9yIGhhbmRsaW5nIHNhdmluZyBjaGFuZ2VzIHRvIGEga2V5LlxuICAgICAgICAgICAgICogQHBhcmFtIGZ1bmNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgb25DcmVhdGVLZXk6IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgICAgICAgICBvbkNyZWF0ZUtleSA9IGZ1bmM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DbG9uZUtleTogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgICAgICAgIG9uQ2xvbmVLZXkgPSBmdW5jO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZ2lzdGVyV2hpc2tlcjogZnVuY3Rpb24oZmMpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJUZXh0RmMgPSBmYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICByZXR1cm4gZmM7XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYW5zbGF0aW9uVmlldztcbiIsInZhciBub2RlO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYWRkIDogZnVuY3Rpb24gKGVsZW0gLGF0dHIpIHtcbiAgICAgICAgbm9kZSA9IGVsZW07XG4gICAgfSxcbiAgICBhZGREZXNjcmlwdGlvbnMgOiBmdW5jdGlvbiAoa2V5RGVzY3JpcHRpb25zKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGtleURlc2NyaXB0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoa2V5KSxcbiAgICAgICAgICAgICAgICBjaGlsZDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IHBhcmVudC5xdWVyeVNlbGVjdG9yKCcuanMtdGV4dCcpO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5pbm5lckhUTUwgPSBrZXlEZXNjcmlwdGlvbnNba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxufSIsIi8qKlxuICogaXMgZm9yIHRoZSB0cmFuc2xhdGlvbiB2aWV3IHRvIGFkZCB0aGUgaW1hZ2UgdXBsb2FkIGJ1dHRvbiBhbmQgc2hvdyB0aGUgaW1hZ2VzXG4gKi9cbnZhciByb290Tm9kZSxcbiAgICBvblVwbG9hZEJ1dHRvbiA9IGZ1bmN0aW9uICgpIHsgY29uc29sZS53YXJuKCd0cmFuc2xhdGlvblZpZXdJbWFnZVVwbG9hZDo6b25VcGxvYWRCdXR0b24oKSBub3QgaW1wbGVtZW50ZWQuJyk7IH0sXG4gICAgb25EZWxldGVCdXR0b24gPSBmdW5jdGlvbiAoKSB7IGNvbnNvbGUud2FybigndHJhbnNsYXRpb25WaWV3SW1hZ2VVcGxvYWQ6Om9uRGVsZXRlQnV0dG9uKCkgbm90IGltcGxlbWVudGVkLicpOyB9O1xuXG5mdW5jdGlvbiB1cGxvYWRCdXR0b24oaWQpIHtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIG5vZGUuY2xhc3NOYW1lID0gJ3VwbG9hZC1idG4gb2N0aWNvbiBvY3RpY29uLWNsb3VkLXVwbG9hZCc7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb25VcGxvYWRCdXR0b24oaWQpO1xuICAgIH0pO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKCd0aXRsZScsICd1cGxvYWQgYSBpbWFnZSBmaWxlJyk7XG4gICAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGVkaXRQYW5lbChpZCkge1xuICAgIHZhciBkZWxldGVCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgZWRpdEJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICBjYW5jZWxCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgcGFuZWxXcmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBwYW5lbFdyYXAuY2xhc3NOYW1lID0gJ2ltYWdlVXBsb2FkLWltYWdlQm94LWVkaXRQYW5lbCc7XG4gICAgZWRpdEJ0bi5jbGFzc05hbWUgPSAnZWRpdC1idG4gb2N0aWNvbiBvY3RpY29uLXBlbmNpbCc7XG4gICAgZWRpdEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGFuZWxXcmFwLmNsYXNzTGlzdC5hZGQoJ2MtZWRpdCcpO1xuICAgIH0pO1xuICAgIGNhbmNlbEJ0bi5jbGFzc05hbWUgPSAnY2FuY2VsLWJ0biBvY3RpY29uIG9jdGljb24teCc7XG4gICAgY2FuY2VsQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBwYW5lbFdyYXAuY2xhc3NMaXN0LnJlbW92ZSgnYy1lZGl0Jyk7XG4gICAgfSk7XG4gICAgZGVsZXRlQnRuLmNsYXNzTmFtZSA9ICdkZWxldGUtYnRuIG9jdGljb24gb2N0aWNvbi10cmFzaGNhbic7XG4gICAgZGVsZXRlQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBvbkRlbGV0ZUJ1dHRvbihpZCk7XG4gICAgfSk7XG4gICAgXG4gICAgZGVsZXRlQnRuLnNldEF0dHJpYnV0ZSgndGl0bGUnLCAncmVtb3ZlIGltYWdlJyk7XG4gICAgY2FuY2VsQnRuLnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnY2FuY2VsJyk7XG4gICAgZWRpdEJ0bi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ2VkaXQnKTtcblxuICAgIHBhbmVsV3JhcC5hcHBlbmRDaGlsZChlZGl0QnRuKTtcbiAgICBwYW5lbFdyYXAuYXBwZW5kQ2hpbGQoY2FuY2VsQnRuKTtcbiAgICBwYW5lbFdyYXAuYXBwZW5kQ2hpbGQoZGVsZXRlQnRuKTtcbiAgICByZXR1cm4gcGFuZWxXcmFwO1xufVxuXG5mdW5jdGlvbiBnZXRJbWFnZShmaWxlKSB7XG4gICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5zcmMgPSBmaWxlO1xuICAgIGltZy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdpbiA9IHdpbmRvdy5vcGVuKGZpbGUsICdfYmxhbmsnKTtcbiAgICAgICAgd2luLmZvY3VzKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGltZztcbn1cblxuZnVuY3Rpb24gYWRkSW1hZ2VDb250ZW50KGlkLCBpbWcpIHtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICByZXNpemVBYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmVzaXplQWJsZS5jbGFzc05hbWUgPSAnaW1hZ2VVcGxvYWQtaW1hZ2VCb3gtcmVzaXplYWJsZSc7IFxuICAgIG5vZGUuY2xhc3NOYW1lID0gJ2ltYWdlVXBsb2FkLWltYWdlQm94LWNvbnRlbnQnO1xuICAgIHJlc2l6ZUFibGUuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICBub2RlLmFwcGVuZENoaWxkKHJlc2l6ZUFibGUpO1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQoZWRpdFBhbmVsKGlkKSk7XG4gICAgcmV0dXJuIG5vZGU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG9uVXBsb2FkQnV0dG9uIDogZnVuY3Rpb24gKGZjKSB7XG4gICAgICAgIG9uVXBsb2FkQnV0dG9uID0gZmM7XG4gICAgfSxcbiAgICBvbkRlbGV0ZUJ1dHRvbjogZnVuY3Rpb24gKGZjKSB7XG4gICAgICAgIG9uRGVsZXRlQnV0dG9uID0gZmM7XG4gICAgfSxcbiAgICBhZGQgOiBmdW5jdGlvbiAobm9kZSwgYXR0cikge1xuICAgICAgICBub2RlLmFwcGVuZENoaWxkKHVwbG9hZEJ1dHRvbihhdHRyKSlcbiAgICB9LFxuICAgIGFwcGVuZEltYWdlIDogZnVuY3Rpb24gKGlkLCB1cmwpIHtcbiAgICAgICAgdmFyIGRvbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0dl8nICsgaWQpLFxuICAgICAgICAgICAgaW1nQ29udGFpbmVyO1xuICAgICAgICBpZiAoZG9tKSB7XG4gICAgICAgICAgICBpbWdDb250YWluZXIgPSBkb20ucXVlcnlTZWxlY3RvcignLmpzLWltYWdlVXBsb2FkLWJveCcpO1xuICAgICAgICAgICAgaWYgKGltZ0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwoaW1nQ29udGFpbmVyLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgICAgICAgIG4ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaW1nQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2Mtc2hvdycpO1xuICAgICAgICAgICAgICAgIGltZ0NvbnRhaW5lci5hcHBlbmRDaGlsZChhZGRJbWFnZUNvbnRlbnQoaWQsIGdldEltYWdlKGAvaW1hZ2VzJHt1cmx9YCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0iLCIvKipcbiAqIHNob3dzIHRoZSB1cGxvYWRlciBmb3JtIHRvIHVwbG9hZCBhIGltYWdlIHRvIHRoZSBzZXJ2ZXJcbiAqL1xudmFyIG9uVXBsb2FkID0gZnVuY3Rpb24gKCkge30sXG4gICAgYnJhaW4gPSB7XG4gICAgICAgIGZpbGVJbnB1dCA6IHtcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB1cGxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuZnVuY3Rpb24gdXBsb2FkKCkge1xuICAgIGNvbnNvbGUubG9nKCdjLXVwbG9hZDp0cmlnZ2VyIHVwbG9hZCcpO1xuICAgIHZhciBmaWxlID0gdGhpcy5maWxlc1swXTtcbiAgICBpZiAoZmlsZSkge1xuICAgICAgICAvLyBzZW5kIGl0IGRpcmVjdCBhZnRlciBkcm9wXG4gICAgICAgIFtdLnNsaWNlLmNhbGwodGhpcy5maWxlcykuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICAgICAgLy8gVE9ETyBpbnN0ZWFkIHBhc3MgIGRpcmVjdGx5IGEgYXJyYXkgb2YgZmlsZXMgLSBzbyB3ZSBzYXZlIFBPU1QgY2FsbHNcbiAgICAgICAgICAgIG9uVXBsb2FkKGZpbGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gY2xlYW51cCB2YWx1ZSBvdGhlcndpc2UgZmlsZSB3aXRoIHNhbWUgbmFtZSBjYW4ndCB1cGxvYWRlZCBhZ2FpblxuICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICpcbiAqIEByZXR1cm5zIHt7YWRkOiBGdW5jdGlvbiwgcmVhZHk6IEZ1bmN0aW9ufX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgb25VcGxvYWQgOiBmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgb25VcGxvYWQgPSBmYztcbiAgICB9LFxuICAgIGFkZCA6IGZ1bmN0aW9uIChub2RlLCBhdHRyKSB7XG4gICAgICAgIGlmIChicmFpbi5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgICAgICAgICAgYnJhaW5bYXR0cl0uaW5pdChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn07IiwiXG52YXIgdW5pY29kZSA9IChmdW5jdGlvbigpe1xuXG4gICAgU3RyaW5nLnByb3RvdHlwZS5nZXRFYWNoQ2hhciA9IGZ1bmN0aW9uKGNiKXtcbiAgICAgICAgdmFyIG5ld1N0cmluZyA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3U3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBuZXdTdHJpbmdbaV0gPSBjYihuZXdTdHJpbmdbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTdHJpbmcudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgdmFyIHJlZyA9IG5ldyBSZWdFeHAoJ1xcXFxcXFxcdShbMC05YS1mQS1GXXs0fSknLFwiZ1wiKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUgOiBmdW5jdGlvbihzdHJpbmcpe1xuICAgICAgICAgICAgaWYoIXN0cmluZyl7cmV0dXJuICcnO31cbiAgICAgICAgICAgIHZhciBuZXdzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWcsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKG1hdGNoLCBzdWJtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChzdWJtYXRjaCwgMTYpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXdzdHJpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZSA6IGZ1bmN0aW9uKHN0cmluZyl7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLmdldEVhY2hDaGFyKGZ1bmN0aW9uKGMpe1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFibGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYodGFibGVbaV0gPT0gYyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZm91bmQ6Jyt0YWJsZVtpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICB9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaWNvZGU7XG5cbnZhciB0YWJsZSA9IFtcbiAgICAnXFx1MDBDMCcsXG4gICAgJ1xcdTAwQzEnLFxuICAgICdcXHUwMEMyJyxcbiAgICAnXFx1MDBDMycsXG4gICAgJ1xcdTAwQzQnLFxuICAgICdcXHUwMEM1JyxcbiAgICAnXFx1MDBDNicsXG4gICAgJ1xcdTAwQzcnLFxuICAgICdcXHUwMEM4JyxcbiAgICAnXFx1MDBDOScsXG4gICAgJ1xcdTAwQ0EnLFxuICAgICdcXHUwMENCJyxcbiAgICAnXFx1MDBDQycsXG4gICAgJ1xcdTAwQ0QnLFxuICAgICdcXHUwMENFJyxcbiAgICAnXFx1MDBDRicsXG4gICAgJ1xcdTAwRDAnLFxuICAgICdcXHUwMEQxJyxcbiAgICAnXFx1MDBEMicsXG4gICAgJ1xcdTAwRDMnLFxuICAgICdcXHUwMEQ0JyxcbiAgICAnXFx1MDBENScsXG4gICAgJ1xcdTAwRDYnLFxuICAgICdcXHUwMEQ4JyxcbiAgICAnXFx1MDBEOScsXG4gICAgJ1xcdTAwREEnLFxuICAgICdcXHUwMERCJyxcbiAgICAnXFx1MDBEQycsXG4gICAgJ1xcdTAwREQnLFxuICAgICdcXHUwMERFJyxcbiAgICAnXFx1MDBERicsXG4gICAgJ1xcdTAwRTAnLFxuICAgICdcXHUwMEUxJyxcbiAgICAnXFx1MDBFMicsXG4gICAgJ1xcdTAwRTMnLFxuICAgICdcXHUwMEU0JyxcbiAgICAnXFx1MDBFNScsXG4gICAgJ1xcdTAwRTYnLFxuICAgICdcXHUwMEU3JyxcbiAgICAnXFx1MDBFOCcsXG4gICAgJ1xcdTAwRTknLFxuICAgICdcXHUwMEVBJyxcbiAgICAnXFx1MDBFQicsXG4gICAgJ1xcdTAwRUMnLFxuICAgICdcXHUwMEVEJyxcbiAgICAnXFx1MDBFRScsXG4gICAgJ1xcdTAwRUYnLFxuICAgICdcXHUwMEYwJyxcbiAgICAnXFx1MDBGMScsXG4gICAgJ1xcdTAwRjInLFxuICAgICdcXHUwMEYzJyxcbiAgICAnXFx1MDBGNCcsXG4gICAgJ1xcdTAwRjUnLFxuICAgICdcXHUwMEY2JyxcbiAgICAnXFx1MDBGOCcsXG4gICAgJ1xcdTAwRjknLFxuICAgICdcXHUwMEZBJyxcbiAgICAnXFx1MDBGQicsXG4gICAgJ1xcdTAwRkMnLFxuICAgICdcXHUwMEZEJyxcbiAgICAnXFx1MDBGRScsXG4gICAgJ1xcdTAwRkYnXG5dOyIsImZ1bmN0aW9uIGdldEFuY2hvcigpIHtcbiAgICB2YXIgaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG4gICAgaWYgKC8jLy50ZXN0KGhyZWYpKSB7XG4gICAgICAgIHJldHVybiAnIycgKyBsb2NhdGlvbi5ocmVmLnJlcGxhY2UoLy4qIy8sICcnKTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnZXRBbmNob3IgOiBnZXRBbmNob3IsXG4gICAgaGFzQW5jaG9yIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZ2V0QW5jaG9yKCkgIT09ICcnO1xuICAgIH1cbn0iLCJjb25zdCByZWdFeFB1bmMgPSBuZXcgUmVnRXhwKC8oW1xcLixcXHMhOz86XFxcIl18XFx7KC4qPylcXH0pKy9naSlcblxuLyoqXG4gKiBDb3VudCBhbW91bnQgb2Ygd29yZHMgaW4gYSBnaXZlbiBTdHJpbmdcbiAqIEBwYXJhbSBzdHJcbiAqIEByZXR1cm5zIE51bWJlclxuICovXG5tb2R1bGUuZXhwb3J0cy5jb3VudFdvcmRzSW5TdHJpbmcgPSBmdW5jdGlvbiBjb3VudFdvcmRzSW5TdHJpbmcoc3RyKSB7XG4gICAgaWYgKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UocmVnRXhQdW5jLCAnICcpLnRyaW0oKS5zcGxpdCgnICcpLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG4vLyBjb21wYXJlIGFuZCBpc0J1ZmZlciB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2Jsb2IvNjgwZTllNWU0ODhmMjJhYWMyNzU5OWE1N2RjODQ0YTYzMTU5MjhkZC9pbmRleC5qc1xuLy8gb3JpZ2luYWwgbm90aWNlOlxuXG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciB4ID0gYS5sZW5ndGg7XG4gIHZhciB5ID0gYi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV07XG4gICAgICB5ID0gYltpXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAoeSA8IHgpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGlzQnVmZmVyKGIpIHtcbiAgaWYgKGdsb2JhbC5CdWZmZXIgJiYgdHlwZW9mIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihiKTtcbiAgfVxuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKTtcbn1cblxuLy8gYmFzZWQgb24gbm9kZSBhc3NlcnQsIG9yaWdpbmFsIG5vdGljZTpcbi8vIE5COiBUaGUgVVJMIHRvIHRoZSBDb21tb25KUyBzcGVjIGlzIGtlcHQganVzdCBmb3IgdHJhZGl0aW9uLlxuLy8gICAgIG5vZGUtYXNzZXJ0IGhhcyBldm9sdmVkIGEgbG90IHNpbmNlIHRoZW4sIGJvdGggaW4gQVBJIGFuZCBiZWhhdmlvci5cblxuLy8gaHR0cDovL3dpa2kuY29tbW9uanMub3JnL3dpa2kvVW5pdF9UZXN0aW5nLzEuMFxuLy9cbi8vIFRISVMgSVMgTk9UIFRFU1RFRCBOT1IgTElLRUxZIFRPIFdPUksgT1VUU0lERSBWOCFcbi8vXG4vLyBPcmlnaW5hbGx5IGZyb20gbmFyd2hhbC5qcyAoaHR0cDovL25hcndoYWxqcy5vcmcpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDkgVGhvbWFzIFJvYmluc29uIDwyODBub3J0aC5jb20+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgJ1NvZnR3YXJlJyksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuLy8gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbC8nKTtcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBmdW5jdGlvbnNIYXZlTmFtZXMgPSAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZm9vKCkge30ubmFtZSA9PT0gJ2Zvbyc7XG59KCkpO1xuZnVuY3Rpb24gcFRvU3RyaW5nIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xufVxuZnVuY3Rpb24gaXNWaWV3KGFycmJ1Zikge1xuICBpZiAoaXNCdWZmZXIoYXJyYnVmKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGdsb2JhbC5BcnJheUJ1ZmZlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJyYnVmKTtcbiAgfVxuICBpZiAoIWFycmJ1Zikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYXJyYnVmIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoYXJyYnVmLmJ1ZmZlciAmJiBhcnJidWYuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4vLyAxLiBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxudmFyIGFzc2VydCA9IG1vZHVsZS5leHBvcnRzID0gb2s7XG5cbi8vIDIuIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGFzc2VydC5cbi8vIG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IoeyBtZXNzYWdlOiBtZXNzYWdlLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCB9KVxuXG52YXIgcmVnZXggPSAvXFxzKmZ1bmN0aW9uXFxzKyhbXlxcKFxcc10qKVxccyovO1xuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9mdW5jdGlvbi5wcm90b3R5cGUubmFtZS9ibG9iL2FkZWVlZWM4YmZjYzYwNjhiMTg3ZDdkOWZiM2Q1YmIxZDNhMzA4OTkvaW1wbGVtZW50YXRpb24uanNcbmZ1bmN0aW9uIGdldE5hbWUoZnVuYykge1xuICBpZiAoIXV0aWwuaXNGdW5jdGlvbihmdW5jKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZnVuY3Rpb25zSGF2ZU5hbWVzKSB7XG4gICAgcmV0dXJuIGZ1bmMubmFtZTtcbiAgfVxuICB2YXIgc3RyID0gZnVuYy50b1N0cmluZygpO1xuICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2gocmVnZXgpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV07XG59XG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gIHRoaXMuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICB0aGlzLm9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjtcbiAgaWYgKG9wdGlvbnMubWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNZXNzYWdlKHRoaXMpO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH1cbiAgdmFyIHN0YWNrU3RhcnRGdW5jdGlvbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZ1bmN0aW9uIHx8IGZhaWw7XG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gbm9uIHY4IGJyb3dzZXJzIHNvIHdlIGNhbiBoYXZlIGEgc3RhY2t0cmFjZVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICB2YXIgb3V0ID0gZXJyLnN0YWNrO1xuXG4gICAgICAvLyB0cnkgdG8gc3RyaXAgdXNlbGVzcyBmcmFtZXNcbiAgICAgIHZhciBmbl9uYW1lID0gZ2V0TmFtZShzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICAgICAgdmFyIGlkeCA9IG91dC5pbmRleE9mKCdcXG4nICsgZm5fbmFtZSk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgLy8gb25jZSB3ZSBoYXZlIGxvY2F0ZWQgdGhlIGZ1bmN0aW9uIGZyYW1lXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gc3RyaXAgb3V0IGV2ZXJ5dGhpbmcgYmVmb3JlIGl0IChhbmQgaXRzIGxpbmUpXG4gICAgICAgIHZhciBuZXh0X2xpbmUgPSBvdXQuaW5kZXhPZignXFxuJywgaWR4ICsgMSk7XG4gICAgICAgIG91dCA9IG91dC5zdWJzdHJpbmcobmV4dF9saW5lICsgMSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhY2sgPSBvdXQ7XG4gICAgfVxuICB9XG59O1xuXG4vLyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxudXRpbC5pbmhlcml0cyhhc3NlcnQuQXNzZXJ0aW9uRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gdHJ1bmNhdGUocywgbikge1xuICBpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoIDwgbiA/IHMgOiBzLnNsaWNlKDAsIG4pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzO1xuICB9XG59XG5mdW5jdGlvbiBpbnNwZWN0KHNvbWV0aGluZykge1xuICBpZiAoZnVuY3Rpb25zSGF2ZU5hbWVzIHx8ICF1dGlsLmlzRnVuY3Rpb24oc29tZXRoaW5nKSkge1xuICAgIHJldHVybiB1dGlsLmluc3BlY3Qoc29tZXRoaW5nKTtcbiAgfVxuICB2YXIgcmF3bmFtZSA9IGdldE5hbWUoc29tZXRoaW5nKTtcbiAgdmFyIG5hbWUgPSByYXduYW1lID8gJzogJyArIHJhd25hbWUgOiAnJztcbiAgcmV0dXJuICdbRnVuY3Rpb24nICsgIG5hbWUgKyAnXSc7XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlKHNlbGYpIHtcbiAgcmV0dXJuIHRydW5jYXRlKGluc3BlY3Qoc2VsZi5hY3R1YWwpLCAxMjgpICsgJyAnICtcbiAgICAgICAgIHNlbGYub3BlcmF0b3IgKyAnICcgK1xuICAgICAgICAgdHJ1bmNhdGUoaW5zcGVjdChzZWxmLmV4cGVjdGVkKSwgMTI4KTtcbn1cblxuLy8gQXQgcHJlc2VudCBvbmx5IHRoZSB0aHJlZSBrZXlzIG1lbnRpb25lZCBhYm92ZSBhcmUgdXNlZCBhbmRcbi8vIHVuZGVyc3Rvb2QgYnkgdGhlIHNwZWMuIEltcGxlbWVudGF0aW9ucyBvciBzdWIgbW9kdWxlcyBjYW4gcGFzc1xuLy8gb3RoZXIga2V5cyB0byB0aGUgQXNzZXJ0aW9uRXJyb3IncyBjb25zdHJ1Y3RvciAtIHRoZXkgd2lsbCBiZVxuLy8gaWdub3JlZC5cblxuLy8gMy4gQWxsIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG11c3QgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3Jcbi8vIHdoZW4gYSBjb3JyZXNwb25kaW5nIGNvbmRpdGlvbiBpcyBub3QgbWV0LCB3aXRoIGEgbWVzc2FnZSB0aGF0XG4vLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gIEFsbCBhc3NlcnRpb24gbWV0aG9kcyBwcm92aWRlXG4vLyBib3RoIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyB0byB0aGUgYXNzZXJ0aW9uIGVycm9yIGZvclxuLy8gZGlzcGxheSBwdXJwb3Nlcy5cblxuZnVuY3Rpb24gZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvciwgc3RhY2tTdGFydEZ1bmN0aW9uKSB7XG4gIHRocm93IG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3Ioe1xuICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgIG9wZXJhdG9yOiBvcGVyYXRvcixcbiAgICBzdGFja1N0YXJ0RnVuY3Rpb246IHN0YWNrU3RhcnRGdW5jdGlvblxuICB9KTtcbn1cblxuLy8gRVhURU5TSU9OISBhbGxvd3MgZm9yIHdlbGwgYmVoYXZlZCBlcnJvcnMgZGVmaW5lZCBlbHNld2hlcmUuXG5hc3NlcnQuZmFpbCA9IGZhaWw7XG5cbi8vIDQuIFB1cmUgYXNzZXJ0aW9uIHRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyB0cnV0aHksIGFzIGRldGVybWluZWRcbi8vIGJ5ICEhZ3VhcmQuXG4vLyBhc3NlcnQub2soZ3VhcmQsIG1lc3NhZ2Vfb3B0KTtcbi8vIFRoaXMgc3RhdGVtZW50IGlzIGVxdWl2YWxlbnQgdG8gYXNzZXJ0LmVxdWFsKHRydWUsICEhZ3VhcmQsXG4vLyBtZXNzYWdlX29wdCk7LiBUbyB0ZXN0IHN0cmljdGx5IGZvciB0aGUgdmFsdWUgdHJ1ZSwgdXNlXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwodHJ1ZSwgZ3VhcmQsIG1lc3NhZ2Vfb3B0KTsuXG5cbmZ1bmN0aW9uIG9rKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIGZhaWwodmFsdWUsIHRydWUsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5vayk7XG59XG5hc3NlcnQub2sgPSBvaztcblxuLy8gNS4gVGhlIGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzaGFsbG93LCBjb2VyY2l2ZSBlcXVhbGl0eSB3aXRoXG4vLyA9PS5cbi8vIGFzc2VydC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPSBleHBlY3RlZCkgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQuZXF1YWwpO1xufTtcblxuLy8gNi4gVGhlIG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIG5vdCBlcXVhbFxuLy8gd2l0aCAhPSBhc3NlcnQubm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiBub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPScsIGFzc2VydC5ub3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDcuIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxuLy8gYXNzZXJ0LmRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgZmFsc2UpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcEVxdWFsJywgYXNzZXJ0LmRlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmFzc2VydC5kZWVwU3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBkZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgdHJ1ZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwU3RyaWN0RXF1YWwnLCBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3QsIG1lbW9zKSB7XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzQnVmZmVyKGFjdHVhbCkgJiYgaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUoYWN0dWFsLCBleHBlY3RlZCkgPT09IDA7XG5cbiAgLy8gNy4yLiBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBEYXRlIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBEYXRlIG9iamVjdCB0aGF0IHJlZmVycyB0byB0aGUgc2FtZSB0aW1lLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNEYXRlKGFjdHVhbCkgJiYgdXRpbC5pc0RhdGUoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMgSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBSZWdFeHAgb2JqZWN0IHdpdGggdGhlIHNhbWUgc291cmNlIGFuZFxuICAvLyBwcm9wZXJ0aWVzIChgZ2xvYmFsYCwgYG11bHRpbGluZWAsIGBsYXN0SW5kZXhgLCBgaWdub3JlQ2FzZWApLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNSZWdFeHAoYWN0dWFsKSAmJiB1dGlsLmlzUmVnRXhwKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuc291cmNlID09PSBleHBlY3RlZC5zb3VyY2UgJiZcbiAgICAgICAgICAgYWN0dWFsLmdsb2JhbCA9PT0gZXhwZWN0ZWQuZ2xvYmFsICYmXG4gICAgICAgICAgIGFjdHVhbC5tdWx0aWxpbmUgPT09IGV4cGVjdGVkLm11bHRpbGluZSAmJlxuICAgICAgICAgICBhY3R1YWwubGFzdEluZGV4ID09PSBleHBlY3RlZC5sYXN0SW5kZXggJiZcbiAgICAgICAgICAgYWN0dWFsLmlnbm9yZUNhc2UgPT09IGV4cGVjdGVkLmlnbm9yZUNhc2U7XG5cbiAgLy8gNy40LiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKChhY3R1YWwgPT09IG51bGwgfHwgdHlwZW9mIGFjdHVhbCAhPT0gJ29iamVjdCcpICYmXG4gICAgICAgICAgICAgKGV4cGVjdGVkID09PSBudWxsIHx8IHR5cGVvZiBleHBlY3RlZCAhPT0gJ29iamVjdCcpKSB7XG4gICAgcmV0dXJuIHN0cmljdCA/IGFjdHVhbCA9PT0gZXhwZWN0ZWQgOiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gSWYgYm90aCB2YWx1ZXMgYXJlIGluc3RhbmNlcyBvZiB0eXBlZCBhcnJheXMsIHdyYXAgdGhlaXIgdW5kZXJseWluZ1xuICAvLyBBcnJheUJ1ZmZlcnMgaW4gYSBCdWZmZXIgZWFjaCB0byBpbmNyZWFzZSBwZXJmb3JtYW5jZVxuICAvLyBUaGlzIG9wdGltaXphdGlvbiByZXF1aXJlcyB0aGUgYXJyYXlzIHRvIGhhdmUgdGhlIHNhbWUgdHlwZSBhcyBjaGVja2VkIGJ5XG4gIC8vIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgKGFrYSBwVG9TdHJpbmcpLiBOZXZlciBwZXJmb3JtIGJpbmFyeVxuICAvLyBjb21wYXJpc29ucyBmb3IgRmxvYXQqQXJyYXlzLCB0aG91Z2gsIHNpbmNlIGUuZy4gKzAgPT09IC0wIGJ1dCB0aGVpclxuICAvLyBiaXQgcGF0dGVybnMgYXJlIG5vdCBpZGVudGljYWwuXG4gIH0gZWxzZSBpZiAoaXNWaWV3KGFjdHVhbCkgJiYgaXNWaWV3KGV4cGVjdGVkKSAmJlxuICAgICAgICAgICAgIHBUb1N0cmluZyhhY3R1YWwpID09PSBwVG9TdHJpbmcoZXhwZWN0ZWQpICYmXG4gICAgICAgICAgICAgIShhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHxcbiAgICAgICAgICAgICAgIGFjdHVhbCBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkpIHtcbiAgICByZXR1cm4gY29tcGFyZShuZXcgVWludDhBcnJheShhY3R1YWwuYnVmZmVyKSxcbiAgICAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShleHBlY3RlZC5idWZmZXIpKSA9PT0gMDtcblxuICAvLyA3LjUgRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2UgaWYgKGlzQnVmZmVyKGFjdHVhbCkgIT09IGlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBtZW1vcyA9IG1lbW9zIHx8IHthY3R1YWw6IFtdLCBleHBlY3RlZDogW119O1xuXG4gICAgdmFyIGFjdHVhbEluZGV4ID0gbWVtb3MuYWN0dWFsLmluZGV4T2YoYWN0dWFsKTtcbiAgICBpZiAoYWN0dWFsSW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAoYWN0dWFsSW5kZXggPT09IG1lbW9zLmV4cGVjdGVkLmluZGV4T2YoZXhwZWN0ZWQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lbW9zLmFjdHVhbC5wdXNoKGFjdHVhbCk7XG4gICAgbWVtb3MuZXhwZWN0ZWQucHVzaChleHBlY3RlZCk7XG5cbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0LCBtZW1vcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYiwgc3RyaWN0LCBhY3R1YWxWaXNpdGVkT2JqZWN0cykge1xuICBpZiAoYSA9PT0gbnVsbCB8fCBhID09PSB1bmRlZmluZWQgfHwgYiA9PT0gbnVsbCB8fCBiID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvLyBpZiBvbmUgaXMgYSBwcmltaXRpdmUsIHRoZSBvdGhlciBtdXN0IGJlIHNhbWVcbiAgaWYgKHV0aWwuaXNQcmltaXRpdmUoYSkgfHwgdXRpbC5pc1ByaW1pdGl2ZShiKSlcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgaWYgKHN0cmljdCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYSkgIT09IE9iamVjdC5nZXRQcm90b3R5cGVPZihiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHZhciBhSXNBcmdzID0gaXNBcmd1bWVudHMoYSk7XG4gIHZhciBiSXNBcmdzID0gaXNBcmd1bWVudHMoYik7XG4gIGlmICgoYUlzQXJncyAmJiAhYklzQXJncykgfHwgKCFhSXNBcmdzICYmIGJJc0FyZ3MpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGFJc0FyZ3MpIHtcbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBfZGVlcEVxdWFsKGEsIGIsIHN0cmljdCk7XG4gIH1cbiAgdmFyIGthID0gb2JqZWN0S2V5cyhhKTtcbiAgdmFyIGtiID0gb2JqZWN0S2V5cyhiKTtcbiAgdmFyIGtleSwgaTtcbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT09IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFfZGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBzdHJpY3QsIGFjdHVhbFZpc2l0ZWRPYmplY3RzKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG4vLyBhc3NlcnQubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZhbHNlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBFcXVhbCcsIGFzc2VydC5ub3REZWVwRXF1YWwpO1xuICB9XG59O1xuXG5hc3NlcnQubm90RGVlcFN0cmljdEVxdWFsID0gbm90RGVlcFN0cmljdEVxdWFsO1xuZnVuY3Rpb24gbm90RGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgdHJ1ZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwU3RyaWN0RXF1YWwnLCBub3REZWVwU3RyaWN0RXF1YWwpO1xuICB9XG59XG5cblxuLy8gOS4gVGhlIHN0cmljdCBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc3RyaWN0IGVxdWFsaXR5LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbi8vIGFzc2VydC5zdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIHN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PT0nLCBhc3NlcnQuc3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG4vLyAxMC4gVGhlIHN0cmljdCBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciBzdHJpY3QgaW5lcXVhbGl0eSwgYXNcbi8vIGRldGVybWluZWQgYnkgIT09LiAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gZnVuY3Rpb24gbm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9PScsIGFzc2VydC5ub3RTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgaWYgKCFhY3R1YWwgfHwgIWV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChleHBlY3RlZCkgPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAoYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElnbm9yZS4gIFRoZSBpbnN0YW5jZW9mIGNoZWNrIGRvZXNuJ3Qgd29yayBmb3IgYXJyb3cgZnVuY3Rpb25zLlxuICB9XG5cbiAgaWYgKEVycm9yLmlzUHJvdG90eXBlT2YoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWU7XG59XG5cbmZ1bmN0aW9uIF90cnlCbG9jayhibG9jaykge1xuICB2YXIgZXJyb3I7XG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVycm9yID0gZTtcbiAgfVxuICByZXR1cm4gZXJyb3I7XG59XG5cbmZ1bmN0aW9uIF90aHJvd3Moc2hvdWxkVGhyb3csIGJsb2NrLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICB2YXIgYWN0dWFsO1xuXG4gIGlmICh0eXBlb2YgYmxvY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJsb2NrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBleHBlY3RlZDtcbiAgICBleHBlY3RlZCA9IG51bGw7XG4gIH1cblxuICBhY3R1YWwgPSBfdHJ5QmxvY2soYmxvY2spO1xuXG4gIG1lc3NhZ2UgPSAoZXhwZWN0ZWQgJiYgZXhwZWN0ZWQubmFtZSA/ICcgKCcgKyBleHBlY3RlZC5uYW1lICsgJykuJyA6ICcuJykgK1xuICAgICAgICAgICAgKG1lc3NhZ2UgPyAnICcgKyBtZXNzYWdlIDogJy4nKTtcblxuICBpZiAoc2hvdWxkVGhyb3cgJiYgIWFjdHVhbCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ01pc3NpbmcgZXhwZWN0ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgdmFyIHVzZXJQcm92aWRlZE1lc3NhZ2UgPSB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZyc7XG4gIHZhciBpc1Vud2FudGVkRXhjZXB0aW9uID0gIXNob3VsZFRocm93ICYmIHV0aWwuaXNFcnJvcihhY3R1YWwpO1xuICB2YXIgaXNVbmV4cGVjdGVkRXhjZXB0aW9uID0gIXNob3VsZFRocm93ICYmIGFjdHVhbCAmJiAhZXhwZWN0ZWQ7XG5cbiAgaWYgKChpc1Vud2FudGVkRXhjZXB0aW9uICYmXG4gICAgICB1c2VyUHJvdmlkZWRNZXNzYWdlICYmXG4gICAgICBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHxcbiAgICAgIGlzVW5leHBlY3RlZEV4Y2VwdGlvbikge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ0dvdCB1bndhbnRlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoKHNob3VsZFRocm93ICYmIGFjdHVhbCAmJiBleHBlY3RlZCAmJlxuICAgICAgIWV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fCAoIXNob3VsZFRocm93ICYmIGFjdHVhbCkpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH1cbn1cblxuLy8gMTEuIEV4cGVjdGVkIHRvIHRocm93IGFuIGVycm9yOlxuLy8gYXNzZXJ0LnRocm93cyhibG9jaywgRXJyb3Jfb3B0LCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC50aHJvd3MgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cyh0cnVlLCBibG9jaywgZXJyb3IsIG1lc3NhZ2UpO1xufTtcblxuLy8gRVhURU5TSU9OISBUaGlzIGlzIGFubm95aW5nIHRvIHdyaXRlIG91dHNpZGUgdGhpcyBtb2R1bGUuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MoZmFsc2UsIGJsb2NrLCBlcnJvciwgbWVzc2FnZSk7XG59O1xuXG5hc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uKGVycikgeyBpZiAoZXJyKSB0aHJvdyBlcnI7IH07XG5cbi8vIEV4cG9zZSBhIHN0cmljdCBvbmx5IHZhcmlhbnQgb2YgYXNzZXJ0XG5mdW5jdGlvbiBzdHJpY3QodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09Jywgc3RyaWN0KTtcbn1cbmFzc2VydC5zdHJpY3QgPSBvYmplY3RBc3NpZ24oc3RyaWN0LCBhc3NlcnQsIHtcbiAgZXF1YWw6IGFzc2VydC5zdHJpY3RFcXVhbCxcbiAgZGVlcEVxdWFsOiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsLFxuICBub3RFcXVhbDogYXNzZXJ0Lm5vdFN0cmljdEVxdWFsLFxuICBub3REZWVwRXF1YWw6IGFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWxcbn0pO1xuYXNzZXJ0LnN0cmljdC5zdHJpY3QgPSBhc3NlcnQuc3RyaWN0O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXNPd24uY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufTtcbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gYmFsYW5jZWQ7XG5mdW5jdGlvbiBiYWxhbmNlZChhLCBiLCBzdHIpIHtcbiAgaWYgKGEgaW5zdGFuY2VvZiBSZWdFeHApIGEgPSBtYXliZU1hdGNoKGEsIHN0cik7XG4gIGlmIChiIGluc3RhbmNlb2YgUmVnRXhwKSBiID0gbWF5YmVNYXRjaChiLCBzdHIpO1xuXG4gIHZhciByID0gcmFuZ2UoYSwgYiwgc3RyKTtcblxuICByZXR1cm4gciAmJiB7XG4gICAgc3RhcnQ6IHJbMF0sXG4gICAgZW5kOiByWzFdLFxuICAgIHByZTogc3RyLnNsaWNlKDAsIHJbMF0pLFxuICAgIGJvZHk6IHN0ci5zbGljZShyWzBdICsgYS5sZW5ndGgsIHJbMV0pLFxuICAgIHBvc3Q6IHN0ci5zbGljZShyWzFdICsgYi5sZW5ndGgpXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1heWJlTWF0Y2gocmVnLCBzdHIpIHtcbiAgdmFyIG0gPSBzdHIubWF0Y2gocmVnKTtcbiAgcmV0dXJuIG0gPyBtWzBdIDogbnVsbDtcbn1cblxuYmFsYW5jZWQucmFuZ2UgPSByYW5nZTtcbmZ1bmN0aW9uIHJhbmdlKGEsIGIsIHN0cikge1xuICB2YXIgYmVncywgYmVnLCBsZWZ0LCByaWdodCwgcmVzdWx0O1xuICB2YXIgYWkgPSBzdHIuaW5kZXhPZihhKTtcbiAgdmFyIGJpID0gc3RyLmluZGV4T2YoYiwgYWkgKyAxKTtcbiAgdmFyIGkgPSBhaTtcblxuICBpZiAoYWkgPj0gMCAmJiBiaSA+IDApIHtcbiAgICBpZihhPT09Yikge1xuICAgICAgcmV0dXJuIFthaSwgYmldO1xuICAgIH1cbiAgICBiZWdzID0gW107XG4gICAgbGVmdCA9IHN0ci5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaSA+PSAwICYmICFyZXN1bHQpIHtcbiAgICAgIGlmIChpID09IGFpKSB7XG4gICAgICAgIGJlZ3MucHVzaChpKTtcbiAgICAgICAgYWkgPSBzdHIuaW5kZXhPZihhLCBpICsgMSk7XG4gICAgICB9IGVsc2UgaWYgKGJlZ3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcmVzdWx0ID0gWyBiZWdzLnBvcCgpLCBiaSBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmVnID0gYmVncy5wb3AoKTtcbiAgICAgICAgaWYgKGJlZyA8IGxlZnQpIHtcbiAgICAgICAgICBsZWZ0ID0gYmVnO1xuICAgICAgICAgIHJpZ2h0ID0gYmk7XG4gICAgICAgIH1cblxuICAgICAgICBiaSA9IHN0ci5pbmRleE9mKGIsIGkgKyAxKTtcbiAgICAgIH1cblxuICAgICAgaSA9IGFpIDwgYmkgJiYgYWkgPj0gMCA/IGFpIDogYmk7XG4gICAgfVxuXG4gICAgaWYgKGJlZ3MubGVuZ3RoKSB7XG4gICAgICByZXN1bHQgPSBbIGxlZnQsIHJpZ2h0IF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwidmFyIGNvbmNhdE1hcCA9IHJlcXVpcmUoJ2NvbmNhdC1tYXAnKTtcbnZhciBiYWxhbmNlZCA9IHJlcXVpcmUoJ2JhbGFuY2VkLW1hdGNoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwYW5kVG9wO1xuXG52YXIgZXNjU2xhc2ggPSAnXFwwU0xBU0gnK01hdGgucmFuZG9tKCkrJ1xcMCc7XG52YXIgZXNjT3BlbiA9ICdcXDBPUEVOJytNYXRoLnJhbmRvbSgpKydcXDAnO1xudmFyIGVzY0Nsb3NlID0gJ1xcMENMT1NFJytNYXRoLnJhbmRvbSgpKydcXDAnO1xudmFyIGVzY0NvbW1hID0gJ1xcMENPTU1BJytNYXRoLnJhbmRvbSgpKydcXDAnO1xudmFyIGVzY1BlcmlvZCA9ICdcXDBQRVJJT0QnK01hdGgucmFuZG9tKCkrJ1xcMCc7XG5cbmZ1bmN0aW9uIG51bWVyaWMoc3RyKSB7XG4gIHJldHVybiBwYXJzZUludChzdHIsIDEwKSA9PSBzdHJcbiAgICA/IHBhcnNlSW50KHN0ciwgMTApXG4gICAgOiBzdHIuY2hhckNvZGVBdCgwKTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlQnJhY2VzKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KCdcXFxcXFxcXCcpLmpvaW4oZXNjU2xhc2gpXG4gICAgICAgICAgICAuc3BsaXQoJ1xcXFx7Jykuam9pbihlc2NPcGVuKVxuICAgICAgICAgICAgLnNwbGl0KCdcXFxcfScpLmpvaW4oZXNjQ2xvc2UpXG4gICAgICAgICAgICAuc3BsaXQoJ1xcXFwsJykuam9pbihlc2NDb21tYSlcbiAgICAgICAgICAgIC5zcGxpdCgnXFxcXC4nKS5qb2luKGVzY1BlcmlvZCk7XG59XG5cbmZ1bmN0aW9uIHVuZXNjYXBlQnJhY2VzKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KGVzY1NsYXNoKS5qb2luKCdcXFxcJylcbiAgICAgICAgICAgIC5zcGxpdChlc2NPcGVuKS5qb2luKCd7JylcbiAgICAgICAgICAgIC5zcGxpdChlc2NDbG9zZSkuam9pbignfScpXG4gICAgICAgICAgICAuc3BsaXQoZXNjQ29tbWEpLmpvaW4oJywnKVxuICAgICAgICAgICAgLnNwbGl0KGVzY1BlcmlvZCkuam9pbignLicpO1xufVxuXG5cbi8vIEJhc2ljYWxseSBqdXN0IHN0ci5zcGxpdChcIixcIiksIGJ1dCBoYW5kbGluZyBjYXNlc1xuLy8gd2hlcmUgd2UgaGF2ZSBuZXN0ZWQgYnJhY2VkIHNlY3Rpb25zLCB3aGljaCBzaG91bGQgYmVcbi8vIHRyZWF0ZWQgYXMgaW5kaXZpZHVhbCBtZW1iZXJzLCBsaWtlIHthLHtiLGN9LGR9XG5mdW5jdGlvbiBwYXJzZUNvbW1hUGFydHMoc3RyKSB7XG4gIGlmICghc3RyKVxuICAgIHJldHVybiBbJyddO1xuXG4gIHZhciBwYXJ0cyA9IFtdO1xuICB2YXIgbSA9IGJhbGFuY2VkKCd7JywgJ30nLCBzdHIpO1xuXG4gIGlmICghbSlcbiAgICByZXR1cm4gc3RyLnNwbGl0KCcsJyk7XG5cbiAgdmFyIHByZSA9IG0ucHJlO1xuICB2YXIgYm9keSA9IG0uYm9keTtcbiAgdmFyIHBvc3QgPSBtLnBvc3Q7XG4gIHZhciBwID0gcHJlLnNwbGl0KCcsJyk7XG5cbiAgcFtwLmxlbmd0aC0xXSArPSAneycgKyBib2R5ICsgJ30nO1xuICB2YXIgcG9zdFBhcnRzID0gcGFyc2VDb21tYVBhcnRzKHBvc3QpO1xuICBpZiAocG9zdC5sZW5ndGgpIHtcbiAgICBwW3AubGVuZ3RoLTFdICs9IHBvc3RQYXJ0cy5zaGlmdCgpO1xuICAgIHAucHVzaC5hcHBseShwLCBwb3N0UGFydHMpO1xuICB9XG5cbiAgcGFydHMucHVzaC5hcHBseShwYXJ0cywgcCk7XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG5mdW5jdGlvbiBleHBhbmRUb3Aoc3RyKSB7XG4gIGlmICghc3RyKVxuICAgIHJldHVybiBbXTtcblxuICAvLyBJIGRvbid0IGtub3cgd2h5IEJhc2ggNC4zIGRvZXMgdGhpcywgYnV0IGl0IGRvZXMuXG4gIC8vIEFueXRoaW5nIHN0YXJ0aW5nIHdpdGgge30gd2lsbCBoYXZlIHRoZSBmaXJzdCB0d28gYnl0ZXMgcHJlc2VydmVkXG4gIC8vIGJ1dCAqb25seSogYXQgdGhlIHRvcCBsZXZlbCwgc28ge30sYX1iIHdpbGwgbm90IGV4cGFuZCB0byBhbnl0aGluZyxcbiAgLy8gYnV0IGF7fSxifWMgd2lsbCBiZSBleHBhbmRlZCB0byBbYX1jLGFiY10uXG4gIC8vIE9uZSBjb3VsZCBhcmd1ZSB0aGF0IHRoaXMgaXMgYSBidWcgaW4gQmFzaCwgYnV0IHNpbmNlIHRoZSBnb2FsIG9mXG4gIC8vIHRoaXMgbW9kdWxlIGlzIHRvIG1hdGNoIEJhc2gncyBydWxlcywgd2UgZXNjYXBlIGEgbGVhZGluZyB7fVxuICBpZiAoc3RyLnN1YnN0cigwLCAyKSA9PT0gJ3t9Jykge1xuICAgIHN0ciA9ICdcXFxce1xcXFx9JyArIHN0ci5zdWJzdHIoMik7XG4gIH1cblxuICByZXR1cm4gZXhwYW5kKGVzY2FwZUJyYWNlcyhzdHIpLCB0cnVlKS5tYXAodW5lc2NhcGVCcmFjZXMpO1xufVxuXG5mdW5jdGlvbiBpZGVudGl0eShlKSB7XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBlbWJyYWNlKHN0cikge1xuICByZXR1cm4gJ3snICsgc3RyICsgJ30nO1xufVxuZnVuY3Rpb24gaXNQYWRkZWQoZWwpIHtcbiAgcmV0dXJuIC9eLT8wXFxkLy50ZXN0KGVsKTtcbn1cblxuZnVuY3Rpb24gbHRlKGksIHkpIHtcbiAgcmV0dXJuIGkgPD0geTtcbn1cbmZ1bmN0aW9uIGd0ZShpLCB5KSB7XG4gIHJldHVybiBpID49IHk7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZChzdHIsIGlzVG9wKSB7XG4gIHZhciBleHBhbnNpb25zID0gW107XG5cbiAgdmFyIG0gPSBiYWxhbmNlZCgneycsICd9Jywgc3RyKTtcbiAgaWYgKCFtIHx8IC9cXCQkLy50ZXN0KG0ucHJlKSkgcmV0dXJuIFtzdHJdO1xuXG4gIHZhciBpc051bWVyaWNTZXF1ZW5jZSA9IC9eLT9cXGQrXFwuXFwuLT9cXGQrKD86XFwuXFwuLT9cXGQrKT8kLy50ZXN0KG0uYm9keSk7XG4gIHZhciBpc0FscGhhU2VxdWVuY2UgPSAvXlthLXpBLVpdXFwuXFwuW2EtekEtWl0oPzpcXC5cXC4tP1xcZCspPyQvLnRlc3QobS5ib2R5KTtcbiAgdmFyIGlzU2VxdWVuY2UgPSBpc051bWVyaWNTZXF1ZW5jZSB8fCBpc0FscGhhU2VxdWVuY2U7XG4gIHZhciBpc09wdGlvbnMgPSBtLmJvZHkuaW5kZXhPZignLCcpID49IDA7XG4gIGlmICghaXNTZXF1ZW5jZSAmJiAhaXNPcHRpb25zKSB7XG4gICAgLy8ge2F9LGJ9XG4gICAgaWYgKG0ucG9zdC5tYXRjaCgvLC4qXFx9LykpIHtcbiAgICAgIHN0ciA9IG0ucHJlICsgJ3snICsgbS5ib2R5ICsgZXNjQ2xvc2UgKyBtLnBvc3Q7XG4gICAgICByZXR1cm4gZXhwYW5kKHN0cik7XG4gICAgfVxuICAgIHJldHVybiBbc3RyXTtcbiAgfVxuXG4gIHZhciBuO1xuICBpZiAoaXNTZXF1ZW5jZSkge1xuICAgIG4gPSBtLmJvZHkuc3BsaXQoL1xcLlxcLi8pO1xuICB9IGVsc2Uge1xuICAgIG4gPSBwYXJzZUNvbW1hUGFydHMobS5ib2R5KTtcbiAgICBpZiAobi5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIHh7e2EsYn19eSA9PT4geHthfXkgeHtifXlcbiAgICAgIG4gPSBleHBhbmQoblswXSwgZmFsc2UpLm1hcChlbWJyYWNlKTtcbiAgICAgIGlmIChuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIgcG9zdCA9IG0ucG9zdC5sZW5ndGhcbiAgICAgICAgICA/IGV4cGFuZChtLnBvc3QsIGZhbHNlKVxuICAgICAgICAgIDogWycnXTtcbiAgICAgICAgcmV0dXJuIHBvc3QubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICByZXR1cm4gbS5wcmUgKyBuWzBdICsgcDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gYXQgdGhpcyBwb2ludCwgbiBpcyB0aGUgcGFydHMsIGFuZCB3ZSBrbm93IGl0J3Mgbm90IGEgY29tbWEgc2V0XG4gIC8vIHdpdGggYSBzaW5nbGUgZW50cnkuXG5cbiAgLy8gbm8gbmVlZCB0byBleHBhbmQgcHJlLCBzaW5jZSBpdCBpcyBndWFyYW50ZWVkIHRvIGJlIGZyZWUgb2YgYnJhY2Utc2V0c1xuICB2YXIgcHJlID0gbS5wcmU7XG4gIHZhciBwb3N0ID0gbS5wb3N0Lmxlbmd0aFxuICAgID8gZXhwYW5kKG0ucG9zdCwgZmFsc2UpXG4gICAgOiBbJyddO1xuXG4gIHZhciBOO1xuXG4gIGlmIChpc1NlcXVlbmNlKSB7XG4gICAgdmFyIHggPSBudW1lcmljKG5bMF0pO1xuICAgIHZhciB5ID0gbnVtZXJpYyhuWzFdKTtcbiAgICB2YXIgd2lkdGggPSBNYXRoLm1heChuWzBdLmxlbmd0aCwgblsxXS5sZW5ndGgpXG4gICAgdmFyIGluY3IgPSBuLmxlbmd0aCA9PSAzXG4gICAgICA/IE1hdGguYWJzKG51bWVyaWMoblsyXSkpXG4gICAgICA6IDE7XG4gICAgdmFyIHRlc3QgPSBsdGU7XG4gICAgdmFyIHJldmVyc2UgPSB5IDwgeDtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgaW5jciAqPSAtMTtcbiAgICAgIHRlc3QgPSBndGU7XG4gICAgfVxuICAgIHZhciBwYWQgPSBuLnNvbWUoaXNQYWRkZWQpO1xuXG4gICAgTiA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IHg7IHRlc3QoaSwgeSk7IGkgKz0gaW5jcikge1xuICAgICAgdmFyIGM7XG4gICAgICBpZiAoaXNBbHBoYVNlcXVlbmNlKSB7XG4gICAgICAgIGMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuICAgICAgICBpZiAoYyA9PT0gJ1xcXFwnKVxuICAgICAgICAgIGMgPSAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGMgPSBTdHJpbmcoaSk7XG4gICAgICAgIGlmIChwYWQpIHtcbiAgICAgICAgICB2YXIgbmVlZCA9IHdpZHRoIC0gYy5sZW5ndGg7XG4gICAgICAgICAgaWYgKG5lZWQgPiAwKSB7XG4gICAgICAgICAgICB2YXIgeiA9IG5ldyBBcnJheShuZWVkICsgMSkuam9pbignMCcpO1xuICAgICAgICAgICAgaWYgKGkgPCAwKVxuICAgICAgICAgICAgICBjID0gJy0nICsgeiArIGMuc2xpY2UoMSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGMgPSB6ICsgYztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIE4ucHVzaChjKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgTiA9IGNvbmNhdE1hcChuLCBmdW5jdGlvbihlbCkgeyByZXR1cm4gZXhwYW5kKGVsLCBmYWxzZSkgfSk7XG4gIH1cblxuICBmb3IgKHZhciBqID0gMDsgaiA8IE4ubGVuZ3RoOyBqKyspIHtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHBvc3QubGVuZ3RoOyBrKyspIHtcbiAgICAgIHZhciBleHBhbnNpb24gPSBwcmUgKyBOW2pdICsgcG9zdFtrXTtcbiAgICAgIGlmICghaXNUb3AgfHwgaXNTZXF1ZW5jZSB8fCBleHBhbnNpb24pXG4gICAgICAgIGV4cGFuc2lvbnMucHVzaChleHBhbnNpb24pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHBhbnNpb25zO1xufVxuXG4iLCIiLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgY3VzdG9tSW5zcGVjdFN5bWJvbCA9XG4gICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2xbJ2ZvciddID09PSAnZnVuY3Rpb24nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgID8gU3ltYm9sWydmb3InXSgnbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgIDogbnVsbFxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICB2YXIgcHJvdG8gPSB7IGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb3RvLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJyLCBwcm90bylcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheVZpZXcodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIChpc0luc3RhbmNlKHZhbHVlLCBTaGFyZWRBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIpKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHZhciBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShcbiAgICAgIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGhcbiAgICApXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlciwgVWludDhBcnJheSlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5VmlldyAoYXJyYXlWaWV3KSB7XG4gIGlmIChpc0luc3RhbmNlKGFycmF5VmlldywgVWludDhBcnJheSkpIHtcbiAgICB2YXIgY29weSA9IG5ldyBVaW50OEFycmF5KGFycmF5VmlldylcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKGNvcHkuYnVmZmVyLCBjb3B5LmJ5dGVPZmZzZXQsIGNvcHkuYnl0ZUxlbmd0aClcbiAgfVxuICByZXR1cm4gZnJvbUFycmF5TGlrZShhcnJheVZpZXcpXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgaWYgKHBvcyArIGJ1Zi5sZW5ndGggPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIEJ1ZmZlci5mcm9tKGJ1ZikuY29weShidWZmZXIsIHBvcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICBidWYsXG4gICAgICAgICAgcG9zXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgfVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2VyY2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuaWYgKGN1c3RvbUluc3BlY3RTeW1ib2wpIHtcbiAgQnVmZmVyLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IEJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFt2YWxdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpXG4gICAgICA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpXG4gICAgICAgICAgPyAzXG4gICAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRilcbiAgICAgICAgICAgICAgPyAyXG4gICAgICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSBoZXhTbGljZUxvb2t1cFRhYmxlW2J1ZltpXV1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgLy8gSWYgYnl0ZXMubGVuZ3RoIGlzIG9kZCwgdGhlIGxhc3QgOCBiaXRzIG11c3QgYmUgaWdub3JlZCAoc2FtZSBhcyBub2RlLmpzKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld0J1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICB2YWwgPSBOdW1iZXIodmFsKVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG4vLyBDcmVhdGUgbG9va3VwIHRhYmxlIGZvciBgdG9TdHJpbmcoJ2hleCcpYFxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMjE5XG52YXIgaGV4U2xpY2VMb29rdXBUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5YWJjZGVmJ1xuICB2YXIgdGFibGUgPSBuZXcgQXJyYXkoMjU2KVxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICB2YXIgaTE2ID0gaSAqIDE2XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICB0YWJsZVtpMTYgKyBqXSA9IGFscGhhYmV0W2ldICsgYWxwaGFiZXRbal1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhYmxlXG59KSgpXG4iLCIvKmdsb2JhbCBiYXNlLmNvb2tpZUhhbmRsZXIsIGNhbm55ICovXG5cbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIERFRkFVTFRfTElGRVRJTUVfQVNfREFZUyA9IDM2NSAqIDUsXG4gICAgICAgIERFRkFVTFRfUEFUSCA9ICcvJztcblxuICAgIHZhciBjb29raWVNYW5hZ2VyID0ge307XG5cbiAgICAvKipcbiAgICAgKiBBIGNvb2tpZSBtYW5hZ2VyIGZvciBoYW5kbGluZyBjb29raWVzIHdoZXJlIHRoZSBjb29raWUgdmFsdWUgaXMgYSBKU09OLXN0cmluZ2lmaWVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEZvciBjcmVhdGluZyBhIHNlc3Npb24gY29va2llIChpLmUuIGRlbGV0ZWQgd2hlbiBicm93c2VyIGNsb3NlcyksIGFkZCBhIG51bGwtdmFsdWVkIGRvbWFpbiBwcm9wZXJ0eSB0b1xuICAgICAqIGNvb2tpZUF0dHJpYnV0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29va2llTmFtZVxuICAgICAqIEBwYXJhbSBjb29raWVBdHRyaWJ1dGVzOiBhbiBvcHRpb25hbCBvYmplY3Qgd2hlcmUgdGhlIHByb3BlcnRpZXMgYXJlIGF0dHJpYnV0ZXMgb2YgdGhlIGNvb2tpZSAtIGV4cGlyZURheXMsXG4gICAgICogZG9tYWluLCBwYXRoIChpZiBhbnkgb2YgdGhvc2UgaXMgbGVmdCBvdXQgZGVmYXVsdHMgd2lsbCBiZSB1c2VkKS5cbiAgICAgKiBAcmV0dXJucyB7e2Nvb2tpZU5hbWUsIHN0b3JlOiBzdG9yZSwgc3RvcmVBbGw6IHN0b3JlQWxsLCBnZXRWYWx1ZTogZ2V0VmFsdWUsIGdldFZhbHVlczogZ2V0VmFsdWVzfX1cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgQ29va2llTWFuYWdlciA9IGZ1bmN0aW9uKGNvb2tpZU5hbWUsIGNvb2tpZUF0dHJpYnV0ZXMpIHtcblxuICAgICAgICB2YXIgbGlmZXRpbWVBc0RheXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoY29va2llQXR0cmlidXRlcyAmJiBjb29raWVBdHRyaWJ1dGVzLmV4cGlyZURheXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29va2llQXR0cmlidXRlcy5leHBpcmVEYXlzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb29raWVBdHRyaWJ1dGVzICYmIGNvb2tpZUF0dHJpYnV0ZXMuZXhwaXJlRGF5cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gREVGQVVMVF9MSUZFVElNRV9BU19EQVlTO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgICB2YXIgZG9tYWluID0gY29va2llQXR0cmlidXRlcyAmJiBjb29raWVBdHRyaWJ1dGVzLmRvbWFpbiA/XG4gICAgICAgICAgICBjb29raWVBdHRyaWJ1dGVzLmRvbWFpbiA6IGNvb2tpZU1hbmFnZXIuY29tcHV0ZUNvb2tpZURvbWFpbihkb2N1bWVudC5sb2NhdGlvbi5ob3N0bmFtZSwgZmFsc2UpO1xuICAgICAgICB2YXIgcGF0aCA9IGNvb2tpZUF0dHJpYnV0ZXMgJiYgY29va2llQXR0cmlidXRlcy5wYXRoID9cbiAgICAgICAgICAgIGNvb2tpZUF0dHJpYnV0ZXMucGF0aCA6IERFRkFVTFRfUEFUSDtcblxuICAgICAgICBmdW5jdGlvbiBnZXRDb29raWVWYWx1ZXMoY29va2llTmFtZSkge1xuICAgICAgICAgICAgdmFyIGksIGN1cnJlbnROYW1lLCBjdXJyZW50VmFsdWUsIGRlY29kZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICBhbGxDb29raWVzID0gd2luZG93LmRvY3VtZW50LmNvb2tpZS5zcGxpdChcIjtcIiksXG4gICAgICAgICAgICAgICAgY29va2llVmFsdWUgPSB7fTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhbGxDb29raWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE5hbWUgPSBhbGxDb29raWVzW2ldLnN1YnN0cigwLCBhbGxDb29raWVzW2ldLmluZGV4T2YoXCI9XCIpKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50TmFtZSA9IGN1cnJlbnROYW1lLnJlcGxhY2UoL15cXHMrfFxccyskL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TmFtZSA9PT0gY29va2llTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBhbGxDb29raWVzW2ldLnN1YnN0cihhbGxDb29raWVzW2ldLmluZGV4T2YoXCI9XCIpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29va2llVmFsdWUgPSBKU09OLnBhcnNlKGRlY29kZVVSSUNvbXBvbmVudChjdXJyZW50VmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29va2llVmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQoY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvb2tpZVZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZU5ld0V4cGlyeURhdGVTdHJpbmcoKSB7XG4gICAgICAgICAgICB2YXIgZXhwaXJ5RGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBleHBpcnlEYXRlLnNldERhdGUoZXhwaXJ5RGF0ZS5nZXREYXRlKCkgKyBsaWZldGltZUFzRGF5cyk7XG4gICAgICAgICAgICByZXR1cm4gZXhwaXJ5RGF0ZS50b1VUQ1N0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgKmZ1bGwqIHZhbHVlIG9mIHRoZSBjb29raWUsIGluY2wuIHdyaXRpbmcgYWxsIG90aGVyIGNvb2tpZSBhdHRyaWJ1dGVzIGFjY29yZGluZyB0b1xuICAgICAgICAgKiBjb25maWd1cmF0aW9uIG9mIGNvb2tpZSBtYW5hZ2VyLlxuICAgICAgICAgKiBAcGFyYW0gY29va2llVmFsdWUgYW4gb2JqZWN0IHdoZXJlIGVhY2ggb3duIHByb3BlcnR5IGlzIGFuIGVudHJ5IGluIHRoZSBjb29raWUgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB1cGRhdGVDb29raWUoY29va2llVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjb29raWVQYXJ0cyA9IFtcbiAgICAgICAgICAgICAgICBjb29raWVOYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGNvb2tpZVZhbHVlKSksXG4gICAgICAgICAgICAgICAgJ3BhdGg9JyArIHBhdGgsXG4gICAgICAgICAgICAgICAgJ2RvbWFpbj0nICsgZG9tYWluXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgaWYgKGxpZmV0aW1lQXNEYXlzKSB7XG4gICAgICAgICAgICAgICAgY29va2llUGFydHMucHVzaCgnZXhwaXJlcz0nICsgY29tcHV0ZU5ld0V4cGlyeURhdGVTdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPSBjb29raWVQYXJ0cy5qb2luKCc7Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogTWVyZ2UgbmV3IHZhbHVlcyBpbnRvIGV4aXN0aW5nL29sZCB2YWx1ZXMuXG4gICAgICAgICAqIEBwYXJhbSBuZXdDb29raWVWYWx1ZXMgYW4gb2JqZWN0IGhvbGRpbmcgYWxsIG5ldyBjb29raWUgdmFsdWUgZW50cmllcyAoZW50cmllcyBtYXkgYWxyZWFkeSBleGlzdFxuICAgICAgICAgKiBpbiBleGlzdGluZ0Nvb2tpZVZhbHVlcylcbiAgICAgICAgICogQHBhcmFtIGV4aXN0aW5nQ29va2llVmFsdWVzIGFuIG9iamVjdCBob2xkaW5nIGFsbCBleGlzdGluZyBjb29raWUgdmFsdWUgZW50cmllcy5cbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBtZXJnZU5ld0ludG9PbGRWYWx1ZXMobmV3Q29va2llVmFsdWVzLCBleGlzdGluZ0Nvb2tpZVZhbHVlcykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobmV3Q29va2llVmFsdWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ0Nvb2tpZVZhbHVlc1trZXldID0gbmV3Q29va2llVmFsdWVzW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0Nvb2tpZVZhbHVlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUNvb2tpZVZhbHVlcyhjb29raWVWYWx1ZXMpIHtcbiAgICAgICAgICAgIHZhciBvbGRDb29raWVWYWx1ZSA9IGdldENvb2tpZVZhbHVlcyhjb29raWVOYW1lKTtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhvbGRDb29raWVWYWx1ZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ29va2llKGNvb2tpZVZhbHVlcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUNvb2tpZShtZXJnZU5ld0ludG9PbGRWYWx1ZXMoY29va2llVmFsdWVzLCBvbGRDb29raWVWYWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNWYWxpZENvb2tpZVZhbHVlRW50cmllcyhlbnRyaWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGVudHJpZXMgPT09ICdvYmplY3QnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCggZW50cmllcyApICE9PSAnW29iamVjdCBBcnJheV0nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldCBjb29raWVOYW1lKCkgeyByZXR1cm4gY29va2llTmFtZTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBrZXkgYSBrZXkgKFN0cmluZylcbiAgICAgICAgICAgICAqIEBwYXJhbSB2YWx1ZSBhIHZhbHVlLCBjYW4gYmUgYW55IHR5cGUgb2Ygb2JqZWN0IChpbmNsLiBuZXN0ZWQpLiB2YWx1ZSBjYW4gYmUgYSBKU09OIHN0cmluZyBidXQgd2lsbFxuICAgICAgICAgICAgICogICAgICpub3QqICBiZSBwYXJzZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHN0b3JlIDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHt9O1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB1cGRhdGVDb29raWVWYWx1ZXMobmV3VmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBlbnRyaWVzIGFuIG9iamVjdCB3aGVyZSBhbGwgb3duIHByb3BlcnRpZXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgY29va2llIHZhbHVlIChydWxlcyBmb3IgdmFsdWVzXG4gICAgICAgICAgICAgKiBmcm9tIHN0b3JlIGZ1bmN0aW9uIGFwcGx5IGhlcmUgYXMgd2VsbCkuIEV4aXN0aW5nIGVudHJpZXMgd2lsbCBiZSBvdmVyd3JpdHRlbi4gTm8gb2JqZWN0IGVuY29kZWQgYXNcbiAgICAgICAgICAgICAqIEpzb24gc3RyaW5nIGFjY2VwdGVkLCBubyBBcnJheXMgZWl0aGVyLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzdG9yZUFsbCA6IGZ1bmN0aW9uKGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRDb29raWVWYWx1ZUVudHJpZXMoZW50cmllcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY29va2llTWFuYWdlci5zdG9yZUFsbCBhY2NlcHRzIG9ubHkgb2JqZWN0cyAoaW5jbC4gbm8gYXJyYXlzKSwgcGFyYW1ldGVyIHdhcyBcIidcbiAgICAgICAgICAgICAgICAgICAgICAgICsgZW50cmllcyArICdcIicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cGRhdGVDb29raWVWYWx1ZXMoZW50cmllcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIGEgc2luZ2xlIGVudHJ5IGZyb20gdGhlIGNvb2tpZS5cbiAgICAgICAgICAgICAqIEBwYXJhbSBrZXlcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXRWYWx1ZSA6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRDb29raWVWYWx1ZXMoY29va2llTmFtZSlba2V5XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBhbGwgZW50cmllcyAoYXMgYW4gb2JqZWN0KSBmcm9tIHRoZSBjb29raWUuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0VmFsdWVzIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldENvb2tpZVZhbHVlcyhjb29raWVOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIG5lZWRlZCwgYWRkIHJlbW92ZShrZXkpIGFuZCByZW1vdmVBbGwoa2V5cykgZnVuY3Rpb25zIHRvIHRoZSBhcGlcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmFjdG9yeSBmdW5jdGlvbiB3aGljaCBwcm9kdWNlcyBhIGNvb2tpZSBtYW5hZ2VyIGZvciB0aGUgZ2l2ZW4gY29va2llIG5hbWUgYW5kIGNvbmZpZy5cbiAgICAgKiBAcGFyYW0gY29va2llTmFtZVxuICAgICAqIEBwYXJhbSBjb29raWVBdHRyaWJ1dGVzOiBzZWUgY29uc3RydWN0b3IgZG9jdW1lbnRhdGlvblxuICAgICAqIEByZXR1cm5zIHtDb29raWVNYW5hZ2VyfVxuICAgICAqL1xuICAgIGNvb2tpZU1hbmFnZXIuZm9yQ29va2llID0gZnVuY3Rpb24oY29va2llTmFtZSwgY29va2llQXR0cmlidXRlcykge1xuICAgICAgICByZXR1cm4gbmV3IENvb2tpZU1hbmFnZXIoY29va2llTmFtZSwgY29va2llQXR0cmlidXRlcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvb2tpZU5hbWUgdGhlIG5hbWUgb2YgdGhlIGNvb2tpZVxuICAgICAqIEBwYXJhbSBjb29raWVBdHRyaWJ1dGVzIGF0dHJpYnV0ZXMgb2YgdGhlIGNvb2tpZSAoYnV0IG5vdGUgdGhhdCBleHBpcmVzIGF0dHJpYnV0ZXMgY2Fubm90IGJlIG92ZXJ3cml0dGVuLCBpdCB3aWxsXG4gICAgICogYmUgYWRkZWQgdG8gdGhhdCBvYmplY3QpXG4gICAgICogQHJldHVybnMge0Nvb2tpZU1hbmFnZXJ9XG4gICAgICovXG4gICAgY29va2llTWFuYWdlci5mb3JTZXNzaW9uQ29va2llID0gZnVuY3Rpb24oY29va2llTmFtZSwgY29va2llQXR0cmlidXRlcykge1xuICAgICAgICBjb29raWVBdHRyaWJ1dGVzID0gY29va2llQXR0cmlidXRlcyB8fCB7fTtcbiAgICAgICAgY29va2llQXR0cmlidXRlc1snZXhwaXJlRGF5cyddID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBDb29raWVNYW5hZ2VyKGNvb2tpZU5hbWUsIGNvb2tpZUF0dHJpYnV0ZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBmYWN0b3J5IGZ1bmN0aW9uIHdoaWNoIHByb2R1Y2VzIGEgY29va2llIG1hbmFnZXIgZm9yIHRoZSBzdGFuZGFyZCBHRCBjb29raWUuXG4gICAgICogQHBhcmFtIGNvb2tpZUF0dHJpYnV0ZXM6IHNlZSBjb25zdHJ1Y3RvciBkb2N1bWVudGF0aW9uXG4gICAgICogQHJldHVybnMge0Nvb2tpZU1hbmFnZXJ9XG4gICAgICovXG4gICAgY29va2llTWFuYWdlci5mb3JHRFN0YW5kYXJkQ29va2llID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUT0RPIHdoYXQgaXMgdGhlIG5hbWUgb2YgdGhlIHN0YW5kYXJkIGNvb2tpZT9cbiAgICAgICAgcmV0dXJuIG5ldyBDb29raWVNYW5hZ2VyKCdHRCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgY29va2llIGRvbWFpbiBmcm9tIHRoZSBnaXZlbiBob3N0bmFtZS5cbiAgICAgKiBAcGFyYW0gaG9zdG5hbWVcbiAgICAgKiBAcGFyYW0gaW5jbHVkZVN1YkRvbWFpbnMgaWYgdHJ1ZSBhbGwgc3ViZG9tYWlucyB3aWxsIGJlIG9taXR0ZWRcbiAgICAgKi9cbiAgICBjb29raWVNYW5hZ2VyLmNvbXB1dGVDb29raWVEb21haW4gPSBmdW5jdGlvbihob3N0bmFtZSwgaW5jbHVkZVN1YkRvbWFpbnMpIHtcbiAgICAgICAgaWYgKGhvc3RuYW1lLmluZGV4T2YoJ2dhbWVkdWVsbCcpICE9PSAtMSAmJiAhaW5jbHVkZVN1YkRvbWFpbnMpIHtcbiAgICAgICAgICAgIHZhciBob3N0bmFtZVBhcnRzID0gaG9zdG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdG5hbWVQYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChob3N0bmFtZVBhcnRzW2ldID09PSBcImdhbWVkdWVsbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNvbWUgaW5mb3MgYWJvdXQgdGhlIGxlYWRpbmcgZG90OlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk2MTgyMTcvd2hhdC1kb2VzLXRoZS1kb3QtcHJlZml4LWluLXRoZS1jb29raWUtZG9tYWluLW1lYW5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGw7ZHI6IGFuIG9ic29sZXRlIFJGQyBkZWZpbmVkIHRoYXQgYSBkb21haW4gd2l0aCBhIGxlYWRpbmcgZG90IHdvdWxkIG1lYW4gXCJhbGxvdyBmb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gc3ViZG9tYWlucywgdG9vXCIgSUU4LzkgYXJlIHN0aWxsIGFmZmVjdGVkLiBPdGhlcnMgc2hvdWxkIGp1c3QgZGlzcmVnYXJkIHRoZSBkb3QgKGFzIHBlciBuZXdlclxuICAgICAgICAgICAgICAgICAgICAvLyBSRkMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnLicgKyBob3N0bmFtZVBhcnRzLnNwbGljZShpKS5qb2luKCcuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhvc3RuYW1lO1xuICAgIH07XG5cbiAgICAvLyBleHBvcnQgYXMgbW9kdWxlIG9yIGJpbmQgdG8gZ2xvYmFsXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5oYXNPd25Qcm9wZXJ0eSgnZXhwb3J0cycpKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gY29va2llTWFuYWdlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjYW5ueS5hZGQoJ2Nvb2tpZU1hbmFnZXInLCBjb29raWVNYW5hZ2VyKTtcbiAgICB9XG5cbn0oKSk7XG4iLCIvKmdsb2JhbCAqL1xuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSovXG4vKipcbiAqXG4gKiBFLmcuOlxuICogIGNhbm55LW1vZD1cIm1vZHVsZU9ialwiIGNhbm55LXZhcj1cInsncHJvcGVydHlLZXknOid2YWx1ZSd9XCJcbiAqICBjYW5ueS1tb2Q9XCJtb2R1bGVTdHJpbmdcIiBjYW5ueS12YXI9XCJidXR0b25cIlxuICpcbiAqIEluc3RlYWQgb2YgY2FubnktdmFyIHlvdSBjYW4gdXNlIHRoZSBtb2R1bGUgbmFtZSB0byBhdm9pZCBjb25mbGljdHMgbGlrZTpcbiAqIEUuZy46IGNhbm55LW1vZD1cIm1vZDEgbW9kMlwiIGNhbm55LW1vZDE9eydmb28nOicxMjM0NTYnLCAnYmFyJzonNjU0MzIxJ30gY2FubnktbW9kMj1cIm1vZDJQcm9wZXJ0eVwiXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBlaWdodHlmb3VyXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGNhbm55ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlYWR5UXVldWUgPSBbXSxcbiAgICAgICAgICAgIHJlYWR5UXVldWVJbml0ID0gZmFsc2UsXG4gICAgICAgICAgICBtb2R1bGVRdWV1ZSA9IFtdOyAvLyBzYXZlIG1vZHVsZXMgdG8gY2FsbCB0aGUgcmVhZHkgbWV0aG9kIG9uY2VcblxuICAgICAgICAvKipcbiAgICAgICAgICogRmluZCB0aGUgc2luZ2xlIHF1b3RlcyBhbmQgcmVwbGFjZSB0aGVtIHdpdGggZG91YmxlIHF1b3RlcyBleGNlcHQgc3RyaW5nIHdoaWNoXG4gICAgICAgICAqIGFyZSBwYXJ0IG9mIHRoZSBwcm9wZXJ0eSBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzdHJpbmdcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0ZvckpTT04oc3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHN0cmluZ1xuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHtcXHMqXFwnL2csJ3tcIicpLnJlcGxhY2UoL1xcJ1xccypcXH0vZywnXCJ9JylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvOlxccypcXCcvZywnOlwiJykucmVwbGFjZSgvXFwnXFxzKjovZywnXCI6JylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvLFxccypcXCcvZywnLFwiJykucmVwbGFjZSgvXFwnXFxzKiwvZywnXCIsJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxbXFxzKlxcJy9nLCdbXCInKS5yZXBsYWNlKC9cXCdcXHMqXFxdL2csJ1wiXScpO1xuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBlc2NhcGVTdHJpbmdGb3JKU09OQXJyYXkoc3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHN0cmluZ1xuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8sXFxzKlxcJy9nLCcsXCInKS5yZXBsYWNlKC9cXCdcXHMqLC9nLCdcIiwnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFtcXHMqXFwnL2csJ1tcIicpLnJlcGxhY2UoL1xcJ1xccypcXF0vZywnXCJdJyk7XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNhbGxNZXRob2RRdWV1ZShxdWV1ZSkge1xuICAgICAgICAgICAgKGZ1bmN0aW9uIHJlZHVjZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmMgPSBxdWV1ZS5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAoZmMpIHtcbiAgICAgICAgICAgICAgICAgICAgZmMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVkdWNlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VOb2RlKG5vZGUsIG5hbWUsIGNiKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsIGdkTW9kdWxlQ2hpbGRyZW4gPSBbXS5zbGljZS5jYWxsKG5vZGUucXVlcnlTZWxlY3RvckFsbCgnWycgKyBuYW1lICsgJy1tb2RdJykpLCBwcmVwYXJlUmVhZHlRdWV1ZSA9IHt9O1xuXG4gICAgICAgICAgICBnZE1vZHVsZUNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSArICctbW9kJyksIGF0dHIsIHZpZXdQYXJ0LCBhdHRyaWJ1dGVzLCBjYW5ueVZhcjtcblxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGUuc3BsaXQoJyAnKTtcblxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhhdFttb2R1bGVOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUgKyAnLW1vZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUgKyAnLScgKyBtb2R1bGVOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5ueVZhciA9IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUgKyAnLScgKyBtb2R1bGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5ueVZhciA9IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUgKyAnLXZhcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FubnlWYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2ltcGxlIEpTT04gdGVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoL1xce1xccypcXCd8XFxcIi4qOi4qXFx9Ly50ZXN0KGNhbm55VmFyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ciA9IGVzY2FwZVN0cmluZ0ZvckpTT04oY2FubnlWYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY291bGQgYmUgYSBKU09OXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdQYXJ0ID0gSlNPTi5wYXJzZShhdHRyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImNhbm55IGNhbid0IHBhcnNlIHBhc3NlZCBKU09OIGZvciBtb2R1bGU6IFwiICsgbW9kdWxlTmFtZSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoL1xcW1xccypcXCd8XFxcIi4qXFwnfFxcXCJcXF0vLnRlc3QoY2FubnlWYXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyID0gZXNjYXBlU3RyaW5nRm9ySlNPTkFycmF5KGNhbm55VmFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld1BhcnQgPSBKU09OLnBhcnNlKGF0dHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiY2FubnkgY2FuJ3QgcGFyc2UgcGFzc2VkIEpTT04gZm9yIG1vZHVsZTogXCIgKyBtb2R1bGVOYW1lLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdQYXJ0ID0gY2FubnlWYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoYXMgbW9kdWxlIGEgcmVhZHkgZnVuY3Rpb24gdGhhbiBzYXZlIGl0IGZvciBjYWxsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdFttb2R1bGVOYW1lXS5oYXNPd25Qcm9wZXJ0eSgncmVhZHknKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gb3IgY2FsbCBpdCBpbW1lZGlhdGVseT9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVwYXJlUmVhZHlRdWV1ZVttb2R1bGVOYW1lXSA9IHRoYXRbbW9kdWxlTmFtZV0ucmVhZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5oYXNPd25Qcm9wZXJ0eShtb2R1bGVOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXRbbW9kdWxlTmFtZV0uYWRkKG5vZGUsIHZpZXdQYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignY2FubnkgcGFyc2U6IG1vZHVsZSB3aXRoIG5hbWUgwrQnICsgbW9kdWxlTmFtZSArICfCtCBpcyBub3QgcmVnaXN0ZXJlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGFkZCByZWFkeSBjYWxsYmFjayB0byBtb2R1bGVRdWV1ZVxuICAgICAgICAgICAgT2JqZWN0LmtleXMocHJlcGFyZVJlYWR5UXVldWUpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVRdWV1ZS5wdXNoKHByZXBhcmVSZWFkeVF1ZXVlW25hbWVdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiBjYW5ueURvbUxvYWQoKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgY2FubnlEb21Mb2FkKTtcblxuICAgICAgICAgICAgcGFyc2VOb2RlLmFwcGx5KGNhbm55LCBbZG9jdW1lbnQsICdjYW5ueSddKTtcblxuICAgICAgICAgICAgY2FsbE1ldGhvZFF1ZXVlKG1vZHVsZVF1ZXVlKTtcbiAgICAgICAgICAgIC8vIGNhbGwgcmVnaXN0ZXJlZCByZWFkeSBmdW5jdGlvbnNcbiAgICAgICAgICAgIHJlYWR5UXVldWVJbml0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNhbGxNZXRob2RRdWV1ZShyZWFkeVF1ZXVlKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGQgOiBmdW5jdGlvbiAobmFtZSwgbW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vZHVsZUFwaSA9IG1vZHVsZTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZUFwaSA9IG1vZHVsZSh0aGlzKTsgLy8gaW5pdGlhbGl6ZSB0aGUgbW9kdWxlIHdpdGggdGhlIGFjdHVhbCBjYW5ueSBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbbmFtZV0gPSBtb2R1bGVBcGk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignY2Fubnk6IFRyeSB0byByZWdpc3RlciBtb2R1bGUgd2l0aCBuYW1lICcgKyBuYW1lICsgJyB0d2ljZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWFkeSA6IGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgICAgIGlmICghcmVhZHlRdWV1ZUluaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZHlRdWV1ZS5wdXNoKGZjKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmYygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW5ueVBhcnNlIDogZnVuY3Rpb24gKG5vZGUsIG5hbWUsIGNiKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBuZWVkcyBhIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFwiY2FubnlcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyc2VOb2RlLmFwcGx5KHRoaXMgfHwgY2FubnksIFtub2RlLCBuYW1lIHx8ICdjYW5ueScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbE1ldGhvZFF1ZXVlKG1vZHVsZVF1ZXVlKTtcbiAgICAgICAgICAgICAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgICAgICAgICAgICB9XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSgpKTtcbiAgICAvLyBleHBvcnQgYXMgbW9kdWxlIG9yIGJpbmQgdG8gZ2xvYmFsXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5oYXNPd25Qcm9wZXJ0eSgnZXhwb3J0cycpKSB7IG1vZHVsZS5leHBvcnRzID0gY2Fubnk7IH0gZWxzZSB7Z2xvYmFsLmNhbm55ID0gY2Fubnk7IH1cbn0odGhpcykpOyIsIi8qZ2xvYmFsIGNhbm55ICovXG4vKmpzbGludCBicm93c2VyOiB0cnVlKi9cblxuLyoqXG4gKiBSZXF1aXJlZDogJ2Nhbm55JyBpbiBnbG9iYWwgc2NvcGVcbiAqXG4gKiBFLmcuOlxuICogY2FubnkuYXN5bmMubG9hZChVUkwsIGZ1bmN0aW9uIChzcmMpIHtcbiAqICAgICBub2RlLmlubmVySFRNTCA9IHNyYztcbiAqICAgICAvLyB0cmlnZ2VyIGNhbm55IHBhcnNlIHRvIHJlZ2lzdGVyIGNhbm55IG9uIG91ciBuZXcgbW9kdWxlc1xuICogICAgIGNhbm55LmNhbm55UGFyc2Uobm9kZSwgZnVuY3Rpb24gKCkge1xuICogICAgICAgICBjb25zb2xlLmxvZygnQ0FOTlkgUEFSU0UgRE9ORScpO1xuICogICAgIH0pO1xuICogfSk7XG4gKlxuICogQWx0ZXJuYXRpdmUgeW91IGNhbiBqdXN0IHVzZSBsb2FkSFRNTCAoc2NyaXB0cyB3aWxsIGF1dG9tYXRpY2FsbHkgYWRkZWQgYW5kIHBhcnNlZCBieSBjYW5ueSk6XG4gKiBjYW5ueS5hc3luYy5sb2FkSFRNTChub2RlLCB7dXJsIDogVVJMfSwgZnVuY3Rpb24gKCkge1xuICogICAgIGNvbnNvbGUubG9nKCdrb2Rvc19sb2FkIFJFQURZJyk7XG4gKiB9KTtcbiAqXG4gKiBPciBkaXJlY3RseSBhcyBjYW5ueSBtb2R1bGU6XG4gKiA8ZGl2IGNhbm55LW1vZD1cImFzeW5jXCIgY2FubnktdmFyPVwieyd1cmwnOicveW91L0hUTUwvZmlsZS5odG1sJ31cIj48L2Rpdj5cbiAqXG4gKiBUT0RPIHNvbHZlIGRlcGVuZGVuY3kgcHJvYmxlbSB0byBjYW5ueS5cbiAqXG4gKi9cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBhc3luYyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmaWxlc1RvTG9hZCA9IFtdLFxuICAgICAgICAgICAgcHVzaExvYWRDQnMgPSBbXSxcbiAgICAgICAgICAgIHJlYWR5ID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzY3JpcHRcbiAgICAgICAgICogQHBhcmFtIG1lZGlhVVJMXG4gICAgICAgICAqIEBwYXJhbSBjYlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gYXBwZW5kU2NyaXB0KHNjcmlwdCwgbWVkaWFVUkwsIGNiKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpLFxuICAgICAgICAgICAgICAgIHNyYyA9IHNjcmlwdC5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICAgICAgLy8gaGFuZGxlIG1lZGlhVVJMIGFuZCBhbGwgcmVsYXRpdmUgc2NyaXB0IGFyZSBsb2FkZWQgZnJvbSB0aGUgbWVkaWEgVVJMIHN0cmluZ1xuICAgICAgICAgICAgaWYgKG1lZGlhVVJMICYmIHNyY1swXSAhPT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lZGlhVVJMW21lZGlhVVJMLmxlbmd0aCAtIDFdICE9PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVkaWFVUkwgKz0gJy8nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcmMgPSBtZWRpYVVSTCArIHNyYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XG4gICAgICAgICAgICBub2RlLmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdjcm9zc29yaWdpbicsICdhbm9ueW1vdXMnKTtcbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdzcmMnLCBzcmMpO1xuICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgY2IsIGZhbHNlKTtcbiAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBjYiwgdHJ1ZSk7XG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzY3JpcHRzXG4gICAgICAgICAqIEBwYXJhbSBtZWRpYVVSTFxuICAgICAgICAgKiBAcGFyYW0gY2JcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGFwcGVuZFNjcmlwdHNUb0hlYWQoc2NyaXB0cywgbWVkaWFVUkwsIGNiKSB7XG4gICAgICAgICAgICB2YXIgc2NyaXB0LCBpLCBpbmNsdWRlc1NjcmlwdHMgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBzY3JpcHRDb3VudGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwIDogZnVuY3Rpb24gKCkge2NvdW50Kys7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkeSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3VudCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0oKSk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gc2NyaXB0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoc2NyaXB0LmdldEF0dHJpYnV0ZSgnc3JjJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZXNTY3JpcHRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0Q291bnRlci51cCgpO1xuICAgICAgICAgICAgICAgICAgICBhcHBlbmRTY3JpcHQoc2NyaXB0LCBtZWRpYVVSTCwgc2NyaXB0Q291bnRlci5yZWFkeSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdhc3luYzogZm91bmQgaW5saW5lIHNjcmlwdCB0YWchISEnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY3JpcHRzLmxlbmd0aCA9PT0gMCB8fCBpbmNsdWRlc1NjcmlwdHMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlIHRoZSBjb21wbGV0ZSBnaXZlbiBET00gYW5kIHByZWZpeCBhbGwgcmVsYXRpdmUgaHJlZiBVUkwncyB3aXRoIHRoZSBnaXZlbiBVUkxcbiAgICAgICAgICogQWxsIFVSTCdzIGFyZSBoYW5kbGVkIGFzIHJlbGF0aXZlIGlmIHRoZXJlIHN0YXJ0cyBub3Qgd2l0aCBhIC8gb3IgaHR0cDovLyBvciBodHRwczovL1xuICAgICAgICAgKiBUT0RPIGFkZCBzdXBwb3J0IGZvciBVUkwncyB3aXRoIGEgLi8gb3IgLi4vIGFuZCBzbyBvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbm9kZSBwYXJlbnQgZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gbWVkaWFVUkwgbWVkaWFQYXRoIHRvIGFub3RoZXIgc2VydmVyXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVMaW5rcyhub2RlLCBtZWRpYVVSTCkge1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdsaW5rJykpLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICAgICAgICB2YXIgaHJlZiA9IGxpbmsuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmsuZ2V0QXR0cmlidXRlKCd0eXBlJykgPT09ICd0ZXh0L2NzcycgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmICE9PSB1bmRlZmluZWQgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmWzBdICE9PSAnLycgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICEvXmh0dHA6XFwvXFwvLiovLnRlc3QoaHJlZikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICEvXmh0dHBzOlxcL1xcLy4qLy50ZXN0KGhyZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZWRpYVVSTFttZWRpYVVSTC5sZW5ndGggLSAxXSAhPT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZWRpYVVSTCArPSAnLyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaHJlZiA9IG1lZGlhVVJMICsgaHJlZjtcbiAgICAgICAgICAgICAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgICAqIEBwYXJhbSBhdHRyIHt7dXJsOnN0cmluZywgbWVkaWFVUkw6IHN0cmluZ319XG4gICAgICAgICAqIEBwYXJhbSBjYlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gbG9hZEhUTUwobm9kZSwgYXR0ciwgY2IpIHtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyksXG4gICAgICAgICAgICAgICAgZGl2ID0gKCdjb250ZW50JyBpbiB0ZW1wbGF0ZSA/IHRlbXBsYXRlIDogZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCdtYWluJykuYm9keSksXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICBzY3JpcHRzLFxuICAgICAgICAgICAgICAgIC8vIG9ubHkgcGFyc2UgaWYgaHRtbCBhbmQgc2NyaXB0cyBhcmUgbG9hZGVkIChzY3JpcHRzIGhhcyBjYWxsYmFja3MgYmVjYXVzZSB0aGVyZSBhcmUgbmVlZHMgdG8gbG9hZGVkIGFzeW5jaHJvbm91cylcbiAgICAgICAgICAgICAgICBoYW5kbGVDYW5ueVBhcnNlID0gKGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2FpdEZvclNjcmlwdHMgPSB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2FpdEZvckhUTUwgPSB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF3YWl0Rm9yU2NyaXB0cyAmJiAhd2FpdEZvckhUTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FubnkuY2FubnlQYXJzZShub2RlLCBjYik7IC8vIGluaXQgb25seSBjYW5ueSBvd24gbW9kdWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHRSZWFkeSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWl0Rm9yU2NyaXB0cyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZ2VyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbFJlYWR5IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhaXRGb3JIVE1MID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dnZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IoYXR0cik7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICBsb2FkKGF0dHIudXJsLCBmdW5jdGlvbiAoc3JjKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcztcbiAgICAgICAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBzcmM7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0IGlzIGEgdGVtcGxhdGUgd2UgbmVlZCB0aGUgY29udGVudFxuICAgICAgICAgICAgICAgICAgICBib2R5ID0gJ2NvbnRlbnQnIGluIGRpdiA/IGRpdi5jb250ZW50IDogZGl2O1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHRzID0gYm9keS5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHQnKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRzID0gW10uc2xpY2UuY2FsbChib2R5LmNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICBhcHBlbmRTY3JpcHRzVG9IZWFkKHNjcmlwdHMsIGF0dHIubWVkaWFVUkwsIGhhbmRsZUNhbm55UGFyc2Uuc2NyaXB0UmVhZHkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyLm1lZGlhVVJMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVMaW5rcyhib2R5LCBhdHRyLm1lZGlhVVJMKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGlsZHMuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNoaWxkLnRhZ05hbWUgPT09ICdTQ1JJUFQnICYmIGNoaWxkLmdldEF0dHJpYnV0ZSgnc3JjJykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVDYW5ueVBhcnNlLmh0bWxSZWFkeSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignYXN5bmM6IExvYWRpbmcgYXN5bmMgSFRNTCBmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogc2ltcGxlIHdyYXBwZXIgdG8gbG9hZCBIVE1MIGZpbGVzIHdpdGggR0VUXG4gICAgICAgICAqIEBwYXJhbSBwYXRoXG4gICAgICAgICAqIEBwYXJhbSBjYlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gbG9hZChwYXRoLCBjYikge1xuICAgICAgICAgICAgZG9BamF4KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IocmVzcG9uc2UucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyB7e1xuICAgICAgICAgKiAgIG5vQ2FjaGU6Ym9vbGVhbixcbiAgICAgICAgICogICBtZXRob2Q6c3RyaW5nfFBPU1QoZGVmYXVsdCksXG4gICAgICAgICAqICAgZGF0YTpvYmplY3R8c3RyaW5nLFxuICAgICAgICAgKiAgIHBhdGg6c3RyaW5nLFxuICAgICAgICAgKiAgIGFzeW5jOmJvb2xlYW58dHJ1ZShkZWZhdWx0KSxcbiAgICAgICAgICogICBvblJlcXVlc3Q6ZnVuY3Rpb24gKHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHhtbEhUVFBSZXF1ZXN0IG9iamVjdCBxdWl0ZSBjbG9zZSBiZWZvcmUgdGhlIHNlbmQgbWV0aG9kIGlzIGNhbGxlZCksXG4gICAgICAgICAqICAgb25GYWlsdXJlOmZ1bmN0aW9uLFxuICAgICAgICAgKiAgIG9uU3VjY2VzczpmdW5jdGlvbixcbiAgICAgICAgICogICBjb250ZW50VHlwZTpzdHJpbmd8Q29udGVudC1UeXBlKGRlZmF1bHQpLFxuICAgICAgICAgKiAgIG1pbWVUeXBlOnN0cmluZ3x0ZXh0IHBsYWluKGRlZmF1bHQpXG4gICAgICAgICAqIH19XG4gICAgICAgICAqL1xuICAgICAgICAgZnVuY3Rpb24gZG9BamF4KHBhcmFtcykge1xuICAgICAgICAgICAgdmFyIGNhbGwgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHZhciB1cmwgPSBwYXJhbXMucGF0aDtcbiAgICAgICAgICAgIGlmIChwYXJhbXMubWV0aG9kID09PSAnR0VUJyAmJiB0eXBlb2YgcGFyYW1zLmRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYXR0ciBpbiBwYXJhbXMuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSB1cmwgKyAoKC9cXD8vKS50ZXN0KHVybCkgPyBcIiZcIiA6IFwiP1wiKSArIGF0dHIgKyBcIj1cIiArIHBhcmFtcy5kYXRhW2F0dHJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMubm9DYWNoZSkge1xuICAgICAgICAgICAgICAgIHVybCA9IHVybCArICgoL1xcPy8pLnRlc3QodXJsKSA/IFwiJlwiIDogXCI/XCIpICsgXCJ0cz1cIiArIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJhbXMubWV0aG9kID0gcGFyYW1zLm1ldGhvZCB8fCAnUE9TVCc7XG4gICAgICAgICAgICBjYWxsLm9wZW4ocGFyYW1zLm1ldGhvZCwgdXJsLCBwYXJhbXMuYXN5bmMgIT09IGZhbHNlKTtcblxuICAgICAgICAgICAgaWYgKHBhcmFtcy5vblN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICBjYWxsLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5vblN1Y2Nlc3Mocy50YXJnZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyYW1zLm9uRmFpbHVyZSkge1xuICAgICAgICAgICAgICAgIGNhbGwuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5vbkZhaWx1cmUocy50YXJnZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWxsLnNldFJlcXVlc3RIZWFkZXIocGFyYW1zLmNvbnRlbnRUeXBlIHx8IFwiQ29udGVudC1UeXBlXCIsIHBhcmFtcy5taW1lVHlwZSB8fCBcInRleHQvcGxhaW5cIik7XG5cbiAgICAgICAgICAgIC8vIGFsbG93IHRoZSBjYWxsZXIgdG8gZG8gc29tZSBleHRyYSBzdHVmZiBvbiB0aGUgcmVxdWVzdCBvYmplY3RcbiAgICAgICAgICAgIGlmIChwYXJhbXMub25SZXF1ZXN0ICYmIHR5cGVvZiBwYXJhbXMub25SZXF1ZXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLm9uUmVxdWVzdChjYWxsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhcmFtcy5tZXRob2QgPT09ICdQT1NUJykge1xuICAgICAgICAgICAgICAgIGNhbGwuc2VuZChwYXJhbXMuZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGwuc2VuZChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGFkZCBhIGNhbGxiYWNrLiBTbyB5b3Ugd2lsbCBiZSBub3RpZmllZCB3aGVuIGZpbGVzIGFyZSBsb2FkZWQgYXN5bmNocm9ub3VzLlxuICAgICAgICAgICAgICogWW91IHdpbGwgYmUgY2FsbGVkIG9ubHkgb25jZSBleGNlcHQgeW91ciByZXR1cm4gdHJ1ZSB0aGVuIGFzeW5jIHdpbGwga2VlcFxuICAgICAgICAgICAgICogeW91ciBjYWxsYmFjayBpbiB0aGUgbm90aWZpZXIgbGlzdCBhbmQgeW91IHdpbGwgYmUgaW5mb3JtZWQgZm9yIGVhY2ggYXN5bmMgcmVxdWVzdC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGUgYXN5bmMgbW9kdWxlIHdpbGwgY2FsbCBlYWNoIGNhbGxiYWNrIHdpdGggdGhlIGFjdHVhbCBhdHRyLiBTbyB5b3UgaGF2ZSB0aGUgY29udHJvbFxuICAgICAgICAgICAgICogaG93IG9mdGVuIHlvdSB3aWxsIGJlIG5vdGlmaWVkLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIE1pZ2h0IGJlIGNoYW5nZWQgaW4gdGhlIGZ1dHVyZSB2ZXJzaW9uIG9mIGFzeW5jOlxuICAgICAgICAgICAgICogQ3VycmVudGx5IHRoaXMgaXMgb25seSBleGVjdXRlZCBmb3IgY2FubnkgbW9kdWxlcyB3aGljaCBhcmUgbG9hZGVkIGZyb20gdGhlIERPTSBkaXJlY3RseS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gZmNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcHVzaExvYWRDQiA6IGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgICAgIHB1c2hMb2FkQ0JzLnB1c2goZmMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRG8gYSBzaW1wbGUgYWpheCBjYWxsLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBwYXJhbXMge3tcbiAgICAgICAgICAgICAqICAgbm9DYWNoZTpib29sZWFuLFxuICAgICAgICAgICAgICogICBtZXRob2Q6c3RyaW5nfFBPU1QoZGVmYXVsdCksXG4gICAgICAgICAgICAgKiAgIGRhdGE6b2JqZWN0LHN0cmluZyxcbiAgICAgICAgICAgICAqICAgYXN5bmM6Ym9vbGVhbnx0cnVlKGRlZmF1bHQpLFxuICAgICAgICAgICAgICogICBwYXRoOnN0cmluZyxcbiAgICAgICAgICAgICAqICAgb25SZXF1ZXN0OmZ1bmN0aW9uICh3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB4bWxIVFRQUmVxdWVzdCBvYmplY3QgcXVpdGUgY2xvc2UgYmVmb3JlIHRoZSBzZW5kIG1ldGhvZCBpcyBjYWxsZWQpLFxuICAgICAgICAgICAgICogICBvbkZhaWx1cmU6ZnVuY3Rpb24sXG4gICAgICAgICAgICAgKiAgIG9uU3VjY2VzczpmdW5jdGlvbixcbiAgICAgICAgICAgICAqICAgY29udGVudFR5cGU6c3RyaW5nfENvbnRlbnQtVHlwZShkZWZhdWx0KSxcbiAgICAgICAgICAgICAqICAgbWltZVR5cGU6c3RyaW5nfHRleHQgcGxhaW4oZGVmYXVsdClcbiAgICAgICAgICAgICAqIH19XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRvQWpheDogZG9BamF4LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSBhdHRyIHt7XG4gICAgICAgICAgICAgKiAgdXJsOnN0cmluZyxcbiAgICAgICAgICAgICAqICBtZWRpYVVSTDpzdHJpbmdcbiAgICAgICAgICAgICAqIH19XG4gICAgICAgICAgICAgKiBAcGFyYW0gY2JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbG9hZEhUTUwgOiBsb2FkSFRNTCxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGVwcmVjYXRlZDogdXNlIGxvYWRIVE1MIGluc3RlYWRcbiAgICAgICAgICAgICAqIEBwYXJhbSBwYXRoXG4gICAgICAgICAgICAgKiBAcGFyYW0gY2JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbG9hZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignYXN5bmM6bG9hZCBmdW5jdGlvbiBsb2FkIGlzIGRlcHJlY2F0ZWQuIFVzZSBsb2FkSFRNTCBpbnN0ZWFkJyk7XG4gICAgICAgICAgICAgICAgbG9hZC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogY2FubnkncyBhZGQgbWV0aG9kXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSBhdHRyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFkZDogZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHsgICAgLy8gcGFydCBvZiBhcGlcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGltcGxlbWVudCBsb2dpYyBmb3IgbG9hZGluZyBpdCBkaXJlY3RseSBmcm9tIGh0bWxcbiAgICAgICAgICAgICAgICBpZiAoYXR0ci5oYXNPd25Qcm9wZXJ0eSgndXJsJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWFkeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXNUb0xvYWQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyOiBhdHRyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRIVE1MKG5vZGUsIGF0dHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlYWR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9iaiwgY2JDb3VudCA9IGZpbGVzVG9Mb2FkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZmlsZXNUb0xvYWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBmaWxlc1RvTG9hZC5zcGxpY2UoMCwgMSlbMF07XG4gICAgICAgICAgICAgICAgICAgIGxvYWRIVE1MKG9iai5ub2RlLCBvYmouYXR0ciwgZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZWVwUHVzaENCID0gW10sIHRtcENiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2JDb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHB1c2hMb2FkQ0JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBDYiA9IHB1c2hMb2FkQ0JzLnNwbGljZSgwLCAxKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG1wQ2IoYXR0cikgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2VlcFB1c2hDQi5wdXNoKHRtcENiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoTG9hZENCcyA9IGtlZXBQdXNoQ0I7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KCkpO1xuICAgIC8vIGV4cG9ydCBhcyBtb2R1bGUgb3IgYmluZCB0byBnbG9iYWxcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmhhc093blByb3BlcnR5KCdleHBvcnRzJykpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBhc3luYztcbiAgICB9IGVsc2Uge1xuICAgICAgICBjYW5ueS5hZGQoJ2FzeW5jJywgYXN5bmMpO1xuICAgIH1cblxufSgpKTsiLCIvKmdsb2JhbCBjYW5ueSAqL1xuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSovXG5cbi8qKlxuICogRS5nLjogY2FubnktbW9kPVwiZmxvd0NvbnRyb2xcIiBjYW5ueS12YXI9XCJ7J3ZpZXcnIDogJ3ZpZXdOYW1lJ31cIlxuICpcbiAqIHlvdSBjYW4gYWN0aXZhdGUgYSBpbml0aWFsIHZpZXcgd2l0aCBhIGFuY2hvciBpbiB0aGUgVVJMIGUuZy46IHlvdXJkb21haW4uaHRtbCN2aWV3VG9TaG93XG4gKiBPciBwYXNzIGEgY29tbWEgc2VwYXJhdGVkIG1vZHVsZSBsaXN0IGZvciBhY3RpdmF0ZSBtb3JlIG1vZHVsZSAjdmlld1RvU2hvdyxvdGhlclZpZXcuXG4gKlxuICogVE9ETyBtYWRlIGl0IHBvc3NpYmxlIHRvIHN1bW1hcml6ZSB2aWV3cyB3aXRoIG9uZSBpZGVudGlmaWVyLlxuICogSW5zdGVhZCBvZiBjYWxsOiBjYW5ueS5mbG93Q29udHJvbC5zaG93KCd2aWV3MScsICd2aWV3MicsICd2aWV3MycpIGNhbGwgY2FubnkuZmxvd0NvbnRyb2wuc2hvdygndmlldycpLlxuICpcbiAqIFRPRE8gYWRkIGEgaGlkZSBtZXRob2QgdGhhdCBqdXN0IGhpZGUgdGhlIHNwZWNpZmljIGVsZW1lbnQuXG4gKlxuICogVE9ETyBoYW5kbGUgdGhlIGZhZGUgaW4gYW5kIG91dCB2aWEgQ1NTIGNsYXNzZXMgLSBhbmQgdXNlIHRyYW5zaXRpb25zIGZvciBpdFxuICovXG4oZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLyoqXG4gICAgICogd3JhcHMgdHJhbnNpdGlvbmVuZCBldmVudCB2ZW5kb3IgaW1wbGVtZW50YXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvblRyYW5zaXRpb25FbmRPbmNlKG5vZGUsIGNiKSB7XG4gICAgICAgIHZhciBldmVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuc3R5bGUud2Via2l0VHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLnN0eWxlLnRyYW5zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zaXRpb25lbmQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0oKSksXG4gICAgICAgICAgICBsaXN0ZW5lciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBlLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGUudHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIGNiKGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZsb3dDb250cm9sSW5zdGFuY2UgPSBmdW5jdGlvbiAoZmNJbnN0YW5jZU5hbWUpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZU5hbWUgPSBmY0luc3RhbmNlTmFtZSxcbiAgICAgICAgICAgICAgICAvLyBmbGFnIHRvIHNhdmUgaWYgdGhlIGluaXRpYWwgcXVldWUgaXMgYWxyZWFkeSBpbml0aWFsaXplZCBvciBub3RcbiAgICAgICAgICAgICAgICBzaG93SW5pdGlhbFZpZXdDb21wbGV0ZSA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIG9uU2hvd0luaXRpYWxWaWV3Q29tcGxldGUgPSBbXSxcbiAgICAgICAgICAgICAgICBtb2RWaWV3cyA9IHt9LCAvLyBzYXZlcyBtb2R1bGUgdmlld3NcbiAgICAgICAgICAgICAgICBnZXRWaWV3QW5jaG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2ggfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ4ID0gbmV3IFJlZ0V4cCgnW15hLXpBLVotXyxdJywgJ2cnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2hTdWI7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2hTdWIgPSBoYXNoLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNoU3ViLnNlYXJjaChyeCkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2hTdWIgPSBoYXNoU3ViLnN1YnN0cmluZygwLCBoYXNoU3ViLnNlYXJjaChyeCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc2hTdWIuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0QWxsTW9kdWxlQ2hpbGRyZW5zID0gZnVuY3Rpb24gKGNOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gdGVzdCBzZWxlY3RvciBpZiB3ZSBoYXZlIG1vcmUgdGhhbiBvbmUgbW9kdWxlIGluIGNhbm55LW1vZFxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBjTm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbY2FubnktbW9kKj0nICsgaW5zdGFuY2VOYW1lICsgJ10nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjX2NoaWxkTm9kZXMgPSB7fTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjTm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXS5zbGljZS5jYWxsKGNOb2RlLmNoaWxkcmVuKS5mb3JFYWNoKGZpbmRDaGlsZHJlbik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwoY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJWYWx1ZSwgdmlldztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVhZCBhdHRyaWJ1dGVzIHNob3VsZCBiZSBhIHBhcnQgb2YgY2FubnkgZnVuY3Rpb25hbGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0clZhbHVlID0gbW9kLmdldEF0dHJpYnV0ZSgnY2FubnktdmFyJykuc3BsaXQoXCJcXCdcIikuam9pbignXFxcIicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC86Ly50ZXN0KGF0dHJWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb3VsZCBiZSBhIEpTT05cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3ID0gSlNPTi5wYXJzZShhdHRyVmFsdWUpLnZpZXc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcgPSBhdHRyVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmY19jaGlsZE5vZGVzW3ZpZXddID0gbW9kO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZjX2NoaWxkTm9kZXM7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBFYWNoIGZsb3dDb250cm9sIG5vZGUgd2lsbCBlbmQgdXAgaW4gYSBmbG93Q29udHJvbE1vZHVsZS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGF0dHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7e2hhc0NoaWxkcmVuV2l0aE5hbWU6IGhhc0NoaWxkcmVuV2l0aE5hbWUsIGdldFZpZXdOYW1lOiBnZXRWaWV3TmFtZSwgc2hvdzogc2hvdywgaGlkZTogaGlkZSwgZmFkZU91dDogZmFkZU91dCwgZ2V0Tm9kZTogZ2V0Tm9kZSwgZmFkZUluOiBmYWRlSW59fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZsb3dDb250cm9sTW9kdWxlID0gZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZsb3dDb250cm9sQ2hpbGROb2RlcyA9IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmMgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFZpZXdzID0gZmMuZ2V0UGFyZW50Tm9kZShhdHRyLnZpZXcpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzYXZlcyBhbGwgY2hpbGRyZW4gaW4gYSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgZmxvd0NvbnRyb2xDaGlsZE5vZGVzID0gZ2V0QWxsTW9kdWxlQ2hpbGRyZW5zKG5vZGUpO1xuLy8gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdmbG93Q29udHJvbENoaWxkTm9kZXM6JywgZmxvd0NvbnRyb2xDaGlsZE5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NoaWxkcmVuV2l0aE5hbWUgOiBmdW5jdGlvbiAodmlld05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxvd0NvbnRyb2xDaGlsZE5vZGVzLmhhc093blByb3BlcnR5KHZpZXdOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRWaWV3TmFtZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0ci52aWV3O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgY2FsbCBwYXJlbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgZmFkZSBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3cgOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50Vmlld3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Vmlld3MuZm9yRWFjaChmdW5jdGlvbiAoZmNfbW9kdWxlKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3BhcmVudFZpZXdzJywgZmNfbW9kdWxlLmdldFZpZXdOYW1lKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmNfbW9kdWxlLmRpc3BsYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXN5bmMgJiYgYXR0ci5oYXNPd25Qcm9wZXJ0eSgnYXN5bmMnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5ueS5hc3luYy5sb2FkSFRNTChub2RlLCB7dXJsIDogYXR0ci5hc3luY30sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyLndoaXNrZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2Fubnkud2hpc2tlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbm55LndoaXNrZXIuYWRkKG5vZGUsIGF0dHIud2hpc2tlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImZsb3dDb250cm9sOnRyeSBleGVjdXRlIHdoaXNrZXIgYnV0IG5vIHdoaXNrZXIgbW9kdWxlIGlzIHJlZ2lzdGVyZWQgb24gY2FubnkuXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYiAmJiBjYigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWRlT3V0IDogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmMuZmFkZU91dChub2RlLCBjYiB8fCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Tm9kZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWRlSW4gOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50Vmlld3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Vmlld3MuZm9yRWFjaChmdW5jdGlvbiAoZmNfbW9kdWxlKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3BhcmVudFZpZXdzJywgZmNfbW9kdWxlLmdldFZpZXdOYW1lKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmNfbW9kdWxlLmRpc3BsYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXN5bmMgJiYgYXR0ci5oYXNPd25Qcm9wZXJ0eSgnYXN5bmMnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5ueS5hc3luYy5sb2FkSFRNTChub2RlLCB7dXJsIDogYXR0ci5hc3luY30sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyLndoaXNrZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2Fubnkud2hpc2tlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbm55LndoaXNrZXIuYWRkKG5vZGUsIGF0dHIud2hpc2tlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImZsb3dDb250cm9sOnRyeSBleGVjdXRlIHdoaXNrZXIgYnV0IG5vIHdoaXNrZXIgbW9kdWxlIGlzIHJlZ2lzdGVyZWQgb24gY2FubnkuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZjLmZhZGVJbihub2RlLCAgY2IgfHwgZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZjLmZhZGVJbihub2RlLCAgY2IgfHwgZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2hvd0luaXRpYWxWaWV3ID0gZ2V0Vmlld0FuY2hvcigpLFxuICAgICAgICAgICAgICAgIGZjID0ge1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgYWxsIHBhcmVudCBtb2R1bGVzIGZyb20gdGhlIGdpdmVuIHZpZXdOYW1lXG4gICAgICAgICAgICAgICAgICAgIGdldFBhcmVudE5vZGUgOiBmdW5jdGlvbiAodmlld05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxdWV1ZSA9IE9iamVjdC5rZXlzKG1vZFZpZXdzKSwgbCwgaSwgcGFyZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbCA9IHF1ZXVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZpZXdOYW1lICE9PSBxdWV1ZVtpXSAmJiBtb2RWaWV3c1txdWV1ZVtpXV1bMF0uaGFzQ2hpbGRyZW5XaXRoTmFtZSh2aWV3TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50cy5wdXNoKG1vZFZpZXdzW3F1ZXVlW2ldXVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudHMubGVuZ3RoID09PSAwID8gbnVsbCA6IHBhcmVudHM7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhc3NlcyBhIHZpZXcgbGlzdCBhbmQgY29tcGxldGUgdGhlIGxpc3Qgd2l0aCBhbGwgcGFyZW50IG5vZGUgbmFtZXNcbiAgICAgICAgICAgICAgICAgICAgYWRkUGFyZW50cyA6IGZ1bmN0aW9uICh2aWV3cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4dFZpZXdzID0gdmlld3MsIGksIGwsIHBOb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hFeHRWaWV3cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRWaWV3cy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0Vmlld3MucHVzaChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUGFyZW50VmlldyA9IGZ1bmN0aW9uICh2aWV3TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGNhbGwgZW5kcyBhbHdheXMgd2l0aCBudWxsIC0gdmlld05hbWUgaXMgdG9wIHBhcmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcFZpZXdOYW1lID0gZmMuZ2V0UGFyZW50Tm9kZSh2aWV3TmFtZSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygndmlld05hbWU6ICcgKyB2aWV3TmFtZSwgJ3BWaWV3TmFtZSAnICsgcFZpZXdOYW1lICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwVmlld05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBWaWV3TmFtZS5mb3JFYWNoKGZ1bmN0aW9uIChmY19tb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHdoaWxlIGhhcyBwYXJlbnQgYWRkIGl0IHRvIHRoZSBleHRWaWV3c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hFeHRWaWV3cyhmY19tb2R1bGUuZ2V0Vmlld05hbWUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUGFyZW50VmlldyhmY19tb2R1bGUuZ2V0Vmlld05hbWUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBsID0gdmlld3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBOb2RlID0gZmMuZ2V0UGFyZW50Tm9kZSh2aWV3c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBOb2RlLmZvckVhY2goZnVuY3Rpb24gKGZjX21vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaEV4dFZpZXdzKGZjX21vZHVsZS5nZXRWaWV3TmFtZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIGZhciB3ZSBoYXZlIHBhcmVudHMgZG8gaXQgcmVjdXJzaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIG5vdCBuZWVkZWQgZWFjaCBwYXJlbnQgd2lsbCBkbyBpdCBieSBvd24gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUGFyZW50VmlldyhmY19tb2R1bGUuZ2V0Vmlld05hbWUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHRWaWV3cztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZmFkZU91dCA6IGZ1bmN0aW9uIChub2RlLCBjYikge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihub2RlLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgnYy1mbG93Q29udHJvbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgnZmFkZS1vdXQnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnYy1mbG93Q29udHJvbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNsYXNzTGlzdC5yZW1vdmUoJ2ZhZGUtb3V0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBmYWRlSW4gOiBmdW5jdGlvbiAobm9kZSwgY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGZhZGUgaW4gZG9lcyBub3Qgd29yayBwcm9wZXJseVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNsYXNzTGlzdC5hZGQoJ2MtZmxvd0NvbnRyb2wnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgnZmFkZS1pbicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnYy1mbG93Q29udHJvbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnZmFkZS1pbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIHJlZmxvdyB0byBmaXggdGhlIGJsYWNrIGJveGVzIGlzc3VlIEZUVFdPLTEyNDlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBjaGVjayBpZiB0aGlzIGNhbiBiZSBhdm9pZGVkIG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJveCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50LWNlbnRlckJveC1jb250ZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJveCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3guc3R5bGUub3BhY2l0eSA9IDAuOTk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3guc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAzMDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gaW5uZXJOb2RlXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt7cmVtb3ZlOiByZW1vdmV9fVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3MgOiBmdW5jdGlvbiAobm9kZSwgaW5uZXJOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLCBjZW50ZXJOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIHR4dE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUuc3R5bGUub3BhY2l0eSA9ICcwLjYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnIzY2Nic7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUuc3R5bGUudG9wID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUuc3R5bGUubGVmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLnN0eWxlLndpZHRoID0gbm9kZS5vZmZzZXRXaWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLnN0eWxlLmhlaWdodCA9IG5vZGUub2Zmc2V0SGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUuc3R5bGUuYm9yZGVyUmFkaXVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbCkuYm9yZGVyUmFkaXVzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXJOb2RlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlck5vZGUuc3R5bGUudG9wID0gKG5vZGUub2Zmc2V0SGVpZ2h0IC8gMikgLSAzMCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXJOb2RlLnN0eWxlLndpZHRoID0gbm9kZS5vZmZzZXRXaWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXJOb2RlLnN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXJOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyTm9kZS5hcHBlbmRDaGlsZChpbm5lck5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChuZXdOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoY2VudGVyTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZSA6IGZ1bmN0aW9uIChkZWxheSwgY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKG5ld05vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChjZW50ZXJOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiICYmIGNiKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGRlbGF5IHx8IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFkZU91dCA6IGZ1bmN0aW9uIChkZWxheSwgY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYy5mYWRlT3V0KG5ld05vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKG5ld05vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQoY2VudGVyTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBkZWxheSB8fCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHt7bW9kOiB7fSwgY3JlYXRlTmV3SW5zdGFuY2U6IGNyZWF0ZU5ld0luc3RhbmNlLCByZWFkeTogcmVhZHksIGFkZDogYWRkLCBzaG93OiBzaG93LCBmYWRlSW46IGZhZGVJbiwgc2hvd0ltbWVkaWF0ZWx5OiBzaG93SW1tZWRpYXRlbHksIG92ZXJsYXk6IG92ZXJsYXl9fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGFwaSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbW9kIDogbW9kVmlld3MsIC8vIHBhcnQgb2YgYXBpXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiB0aGlzIG1ldGhvZCBjb3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBuZXcgaW5zdGFuY2VzIG9mIGZsb3dDb250cm9sIChvbmx5IG5lZWRlZCBpZiB5b3VcbiAgICAgICAgICAgICAgICAgICAgICogbG9hZCB0aGlzIHNjcmlwdCBkaXJlY3RseSB3aXRob3V0IHJlcXVpcmUpXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBuYW1lICh1bmlxdWUgbW9kdWxlIG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAqKi9cbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlTmV3SW5zdGFuY2UgOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsb3dDb250cm9sKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZWFkeSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2ROYW1lcyA9IE9iamVjdC5rZXlzKG1vZFZpZXdzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsSW5pdGlhbFZpZXdDb21wbGV0ZVF1ZXVlID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gbW9kTmFtZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvd0luaXRpYWxWaWV3ICYmIGwgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgc2hvd0luaXRpYWxWaWV3IGNvbnRhaW5zIGEgcmVnaXN0ZXJlZCBtb2R1bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBleGlzdGluZyBuYW1lIGluIHNob3dJbml0aWFsVmlld1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvd0luaXRpYWxWaWV3LmluZGV4T2YobW9kTmFtZXNbaV0pICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0luaXRpYWxWaWV3LnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uU2hvd0luaXRpYWxWaWV3Q29tcGxldGUuZm9yRWFjaChmdW5jdGlvbihmYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93SW5pdGlhbFZpZXdDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZjKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxJbml0aWFsVmlld0NvbXBsZXRlUXVldWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5zaG93SW1tZWRpYXRlbHkuYXBwbHkobnVsbCwgc2hvd0luaXRpYWxWaWV3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbEluaXRpYWxWaWV3Q29tcGxldGVRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uU2hvd0luaXRpYWxWaWV3Q29tcGxldGUuZm9yRWFjaChmdW5jdGlvbihmYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93SW5pdGlhbFZpZXdDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZjKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBDYWxscyB0aGUgZ2l2ZW4gZnVuY3Rpb24gYWZ0ZXIgbG9hZGluZyBhbGwgaW5pdGlhbCB2aWV3cy5cbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIGZjXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBvblNob3dJbml0aWFsVmlld0NvbXBsZXRlIDogZnVuY3Rpb24oZmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSBwYXNzZWQgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWxzbyBhZnRlciBpbml0aWFsaXNhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaG93SW5pdGlhbFZpZXdDb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uU2hvd0luaXRpYWxWaWV3Q29tcGxldGUucHVzaChmYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZjKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gYXR0ciB7e3ZpZXc6KGlkZW50aWZpZXIpLH19XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBhZGQgOiBmdW5jdGlvbiAobm9kZSwgYXR0cikgeyAgICAvLyBwYXJ0IG9mIGFwaVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtb2RWaWV3c1thdHRyLnZpZXddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kVmlld3NbYXR0ci52aWV3XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kVmlld3NbYXR0ci52aWV3XS5wdXNoKGZsb3dDb250cm9sTW9kdWxlKG5vZGUsIGF0dHIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEBkZXByZWNhdGVkIHdpbGwgaGFuZGxlIHNob3dJbW1lZGlhdGVseSBpbiBuZWFyIGZ1dHVyZVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgc2hvdyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5mYWRlSW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBuYW1lIChhcmd1bWVudHMgbGlzdCBvZiB2aWV3cyB0byBzaG93KVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgZmFkZUluIDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaG93TW9kcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZSA9IE9iamVjdC5rZXlzKG1vZFZpZXdzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZUNvdW50ID0gMCwvLyA9IHF1ZXVlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWRlSW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dNb2RzLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZFZpZXdzLmhhc093blByb3BlcnR5KG1vZHVsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RWaWV3c1ttb2R1bGVdLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouZmFkZUluKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGQURFIElOIERPTkUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gY291bnQgY2FsbGJhY2tzIGFuZCBoYW5kbGUgaXQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGxhc3QgcGFyYW0gaXMgZnVuY3Rpb24gdGhhbiBoYW5kbGUgaXQgYXMgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzaG93TW9kc1tzaG93TW9kcy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd01vZHNbc2hvd01vZHMubGVuZ3RoIC0gMV0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93TW9kcyA9IGZjLmFkZFBhcmVudHMoc2hvd01vZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUuZm9yRWFjaChmdW5jdGlvbiAodmlldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlQ291bnQgKz0gbW9kVmlld3Nbdmlld10ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRlIG92ZXIgYWxsIHJlZ2lzdGVyZWQgbW9kdWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUuZm9yRWFjaChmdW5jdGlvbiAodmlldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGUgb3ZlciBhbGwgaW5zdGFuY2VzIG9mIHRoZSBzYW1lIHZpZXdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RWaWV3c1t2aWV3XS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGlkZSBhbGwgKGV4Y2VwdCBpbmNvbWluZyBhbmQgcGFyZW50cykgVE9ETyBidXQgb25seSB0aGUgcGFyZW50cyBvZiB0aGUgbW9kdWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG93TW9kcy5pbmRleE9mKHZpZXcpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmZhZGVPdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlQ291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocXVldWVDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhZGVJbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVDb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXVlQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhZGVJbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEBkZXByZWNhdGVkIHVzZSBzaG93IGluc3RlYWRcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHNob3dJbW1lZGlhdGVseSA6IGZ1bmN0aW9uICgpIHsgICAgLy8gbW9kdWxlIHNwZWNpZmljXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2hvd01vZHMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUgPSBPYmplY3Qua2V5cyhtb2RWaWV3cyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRDYiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYiwgbGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgbGFzdCBwYXJhbSBpcyBmdW5jdGlvbiB0aGFuIGhhbmRsZSBpdCBhcyBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNob3dNb2RzW3Nob3dNb2RzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYiA9IHNob3dNb2RzW3Nob3dNb2RzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudFVwIDogZnVuY3Rpb24gKG51bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCArPSBudW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkdWNlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYiAmJiBsZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dNb2RzLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZFZpZXdzLmhhc093blByb3BlcnR5KG1vZHVsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudENiLmNvdW50VXAobW9kVmlld3NbbW9kdWxlXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZFZpZXdzW21vZHVsZV0uZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5zaG93KGNvdW50Q2IucmVkdWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dNb2RzID0gZmMuYWRkUGFyZW50cyhzaG93TW9kcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoaWRlIGFsbCAoZXhjZXB0IGluY29taW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUuZm9yRWFjaChmdW5jdGlvbiAodmlldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZFZpZXdzW3ZpZXddLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvd01vZHMuaW5kZXhPZihvYmopID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93KCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkgOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIG93biBtb2R1bGU/XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kVmlld3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbW9kVmlld3NbbmFtZV0uZ2V0Tm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgOiBmdW5jdGlvbiAobmFtZSwgdGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXh0W25hbWVdKG5vZGUsIHRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGFwaTtcbiAgICAgICAgfSxcbiAgICAgICAgZmxvd0NvbnRyb2wgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlcyA9IHt9O1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICBkZWYgPSBuYW1lIHx8ICdmbG93Q29udHJvbCc7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlcy5oYXNPd25Qcm9wZXJ0eShkZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlID0gaW5zdGFuY2VzW2RlZl07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VzW2RlZl0gPSBmbG93Q29udHJvbEluc3RhbmNlKGRlZik7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlID0gaW5zdGFuY2VzW2RlZl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0oKSk7XG4gICAgLy8gZXhwb3J0IGFzIG1vZHVsZSBvciBiaW5kIHRvIGdsb2JhbFxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuaGFzT3duUHJvcGVydHkoJ2V4cG9ydHMnKSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZsb3dDb250cm9sOyB9IGVsc2Uge2Nhbm55LmFkZCgnZmxvd0NvbnRyb2wnLCBmbG93Q29udHJvbCgnZmxvd0NvbnRyb2wnKSk7IH1cblxufSgpKTsiLCIvKmdsb2JhbCBjYW5ueSAqL1xuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSovXG5cbi8qKlxuICogcmVwZWF0XG4gKlxuICogRS5nLlxuICogIDxkaXYgY2FubnktbW9kPVwicmVwZWF0XCIgY2FubnktdmFyPVwieydmb3InOidpdGVtJywgJ2luJzoncGF0aC50by5saXN0J31cIj5cbiAqICAgICA8cD5EQVRBOiB7e2l0ZW19fSk8L3A+XG4gKiAgPC9kaXY+XG4gKiAgb3I6XG4gKiAgPGRpdiBjYW5ueS1tb2Q9XCJyZXBlYXRcIiBjYW5ueS12YXI9XCJ7J2Zvcic6J29iamVjdEl0ZW0nLCAnaW4nOidwYXRoLnRvLm9iamVjdCd9XCI+XG4gKiAgICAgPHA+REFUQSBGT086IHt7b2JqZWN0SXRlbS5mb299fSk8L3A+XG4gKiAgICAgPHA+REFUQSBCQVI6IHt7b2JqZWN0SXRlbS5iYXJ9fSk8L3A+XG4gKiAgPC9kaXY+XG4gKlxuICogZm9yOlxuICogaXMgdGhlIG5hbWUgb2YgdGhlIGl0ZXJhdGluZyBpdGVtIHRvIGhhdmUgYWNjZXNzIGZyb20gdGhlIERPTS5cbiAqXG4gKiBpbjpcbiAqIGlzIHRoZSBzb3VyY2Ugd2hlcmUgcmVwZWF0IGNhbiBmaW5kIHRoZSBhcnJheS5cbiAqIEl0IGFjY2VwdHMgZnVuY3Rpb25zLCBhcnJheSwgYW5kIG9iamVjdHMgcG9pbnRlclxuICogLSBvYmplY3Q6IGtlZXAgaW4gbWluZCB0aGF0IG9iamVjdCBoYXMgbm8gc3BlY2lmaWMgc29ydGluZ1xuICogLSBhcnJheTpcbiAqIC0gZnVuY3Rpb246IHJlcGVhdCB3aWxsIGNhbGwgaXQgd2l0aCB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcjpcbiAqICAqIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSBvYmplY3Qgb3IgbGlzdFxuICogICogLi4uXG4gKlxuICogIFRPRE86IGFkZCBleGFtcGxlIHRvIGdldCBkYXRhIGRpcmVjdCBmcm9tXG4gKiAgICogYSBsaXN0IG9mIGZ1bmN0aW9uXG4gKiAgICogYSBvYmplY3Qgd2hpY2ggY29udGFpbiBmdW5jdGlvbnNcbiAqXG4gKi9cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG9wZW5DaGFyID0gJ3snLFxuICAgICAgICBlbmRDaGFyICA9ICd9JyxcbiAgICAgICAgRVNDQVBFX1JFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZyxcbiAgICAgICAgcmVwZWF0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBCSU5ESU5HX1JFID0gZ2V0UmVnZXgoKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiAgUGFyc2UgYSBwaWVjZSBvZiB0ZXh0LCByZXR1cm4gYW4gYXJyYXkgb2YgdG9rZW5zXG4gICAgICAgICAgICAgKiAgVE9ETyByZWZhY3RvciBtZXRob2RcbiAgICAgICAgICAgICAqICBAcGFyYW0gdGV4dFxuICAgICAgICAgICAgICogIEByZXR1cm4gW3trZXk6U3RyaW5nLCBodG1sOmJvb2xlYW59XVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZSh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFCSU5ESU5HX1JFLnRlc3QodGV4dCkpIHtyZXR1cm4gbnVsbDsgfVxuICAgICAgICAgICAgICAgIHZhciBtLCBpLCB0b2tlbiwgbWF0Y2gsIHRva2VucyA9IFtdLCBvcmlnID0ge3RleHQ6IHRleHQsIGlkeCA6IDB9LCB0ZXh0T2JqZWN0O1xuICAgICAgICAgICAgICAgIC8qIGpzaGludCBib3NzOiB0cnVlICovXG4gICAgICAgICAgICAgICAgd2hpbGUgKG0gPSB0ZXh0Lm1hdGNoKEJJTkRJTkdfUkUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBtLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHtjb25jYXQgOiB0cnVlfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JpZy5pZHggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0T2JqZWN0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25jYXQgOiBvcmlnLnRleHRbb3JpZy5pZHggLSAxXSAhPT0gJyAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA6IHRleHQuc2xpY2UoMCwgaSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnLmlkeCArPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnLmlkeCArPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRPYmplY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNhdCA6IG9yaWcudGV4dFtvcmlnLmlkeCAtIDFdICE9PSAnICcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIDogdGV4dC5zbGljZSgwLCBpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godGV4dE9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3JpZy5pZHggKz0gaTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4ua2V5ID0gbVsxXS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gbVswXTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4uaHRtbCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaC5jaGFyQXQoMikgPT09IG9wZW5DaGFyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaC5jaGFyQXQobWF0Y2gubGVuZ3RoIC0gMykgPT09IGVuZENoYXI7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoaSArIG1bMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt2YWx1ZSA6IHRleHQsIHRleHQgOiB0cnVlLCBjb25jYXQ6IHRydWV9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0gZGF0YU9ialxuICAgICAgICAgICAgICogQHBhcmFtIGl0ZW1OYW1lXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHRva2VucyBbe2tleTpTdHJpbmcsIG5vZGU6RE9NIG5vZGUsIGh0bWw6IGJvb2xlYW59XVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBjb21waWxlVGV4dE5vZGUobm9kZSwgZGF0YU9iaiwgaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gcGFyc2Uobm9kZS5ub2RlVmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBvYmogPSBkYXRhT2JqLFxuICAgICAgICAgICAgICAgICAgICBlbCwgdG9rZW4sIGksIGwsIHRtcCwgdG9rZW5PYmplY3RQcm9wZXJ0eSwgdmFsO1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW5zIHx8IG9iaiA9PT0gdW5kZWZpbmVkKSB7cmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ29iamVjdCcgJiYgdG9rZW4uaGFzT3duUHJvcGVydHkoJ2tleScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSB0b2tlbi5rZXkuc3BsaXQoJy4nKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRtcC5sZW5ndGggPiAwICYmIHRtcFswXSA9PT0gaXRlbU5hbWUpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0bXBbMF0gIT09IGl0ZW1OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gaW1wbGVtZW50IGVycm9yIGhhbmRsaW5nIGlmIGtleSBkb2Vzbid0IG1hdGNoIHdpdGggaXRlbU5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigncmVwZWF0OmNvbXBpbGVUZXh0Tm9kZSBodXBzIHNvbWV0aGluZyBpcyB3cm9uZyB3aGljaCBuZWVkcyB0byBiZSBmaXhlZCEhISBUb2tlbiB3aXRoIG5hbWUnLCB0b2tlbi5rZXksICdkb2VzblxcJ3QgbWF0Y2ggd2l0aCBzY29wZSBuYW1lOiAnLCBpdGVtTmFtZSAsICcgUmVwZWF0IHdpbGwgY29udGludWUgYnV0IGJlIGNhcmVmdWxseSB0aGlzIFwiYnVnXCIgd2lsbCBiZSByZW1vdmVkIGluIG5leHQgdmVyc2lvbiBvZiByZXBlYXQhISEnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbk9iamVjdFByb3BlcnR5ID0gdG1wLnNsaWNlKDEpLmpvaW4oJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gZ2V0R2xvYmFsQ2FsbCh0b2tlbk9iamVjdFByb3BlcnR5LCBvYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IG9iajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgYSBzdHJpbmc/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gb2JqO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsKG5vZGUucGFyZW50Tm9kZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBbMF0gPT09IGl0ZW1OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvcGVydHkgaXMgbm90IGV4aXN0cyBidXQgaXQgaXMgdGhlIHNhbWUgc2NvcGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSB0aGUgdG9rZW4uLi4gbG9va3MgbGlrZSBpcyBub3QgbWluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ3t7JyArIHRva2VuLmtleSArICd9fScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4ubm9kZSA9IGVsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0b2tlbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IG5vcm1hbCBzdHJpbmcgcHV0IGJhY2sgdG8gdmlld1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICAgICAgICogQHBhcmFtIGRhdGFPYmpcbiAgICAgICAgICAgICAqIEBwYXJhbSBpdGVtTmFtZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBjb21waWxlRWxlbWVudCAobm9kZSwgZGF0YU9iaiwgaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyByZWN1cnNpdmVseSBjb21waWxlIGNoaWxkTm9kZXNcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgW10uc2xpY2UuY2FsbChub2RlLmNoaWxkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21waWxlKGNoaWxkLCBkYXRhT2JqLCBpdGVtTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29tcGlsZSBhIERPTSBub2RlIChyZWN1cnNpdmUpXG4gICAgICAgICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICAgICAgICogQHBhcmFtIGRhdGFPYmpcbiAgICAgICAgICAgICAqIEBwYXJhbSBpdGVtTmFtZVxuICAgICAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBpbGUobm9kZSwgZGF0YU9iaiwgaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZVR5cGUgPSBub2RlLm5vZGVUeXBlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PT0gMSAmJiBub2RlLnRhZ05hbWUgIT09ICdTQ1JJUFQnKSB7IC8vIGEgbm9ybWFsIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgY29tcGlsZUVsZW1lbnQobm9kZSwgZGF0YU9iaiwgaXRlbU5hbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGlsZVRleHROb2RlKG5vZGUsIGRhdGFPYmosIGl0ZW1OYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBoZWxwZXIgZnVuY3Rpb24gdG8gZG8gdGhlIHJlYWQgdmFyaWFibGUgZnJvbSBzdHJpbmcgbWFnaWMuXG4gICAgICAgICAgICAgKiBUaGUgY2Igd2lsbCBjYWxsZWQgd2l0aCB0aGUgcHJvcGVydHkgdmFsdWUgLSBpbiBjYXNlIG9mIHVuZGVmaW5lZCB0aGUgdmFyaWFibGUgZG9lcyBub3QgZXhpc3RzXG4gICAgICAgICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICAgICAgICogQHBhcmFtIGF0dHJpYnV0ZU5hbWVcbiAgICAgICAgICAgICAqIEBwYXJhbSBjYlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRMb29wVmFsdWVGcm9tQXR0cmlidXRlKG5vZGUsIG9iaiwgaXRlbU5hbWUsIGF0dHJpYnV0ZU5hbWUsIGNiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpLnNwbGl0KCcuJyksIHRva2VuT2JqZWN0UHJvcGVydHk7XG4gICAgICAgICAgICAgICAgaWYgKHRtcC5sZW5ndGggPiAwICYmIHRtcFswXSA9PT0gaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5PYmplY3RQcm9wZXJ0eSA9IHRtcC5zbGljZSgxKS5qb2luKCcuJyk7XG4gICAgICAgICAgICAgICAgICAgIGNiKGdldEdsb2JhbENhbGwodG9rZW5PYmplY3RQcm9wZXJ0eSwgb2JqKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBoYW5kbGUgdGhpcyBjb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigncmVwZWF0OmdldExvb3BWYWx1ZUZyb21BdHRyaWJ1dGUgaGFzIHByb2JsZW1zJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHJlZ2lzdGVyIGNsaWNrIGV2ZW50c1xuICAgICAgICAgICAgICogXG4gICAgICAgICAgICAgKiBAZGVwcmVjYXRlZCB1c2UgcnAtYmluZCBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICogQHBhcmFtIGNsb25lXG4gICAgICAgICAgICAgKiBAcGFyYW0gaXRlbVxuICAgICAgICAgICAgICogQHBhcmFtIGl0ZW1OYW1lXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZUV2ZW50cyhjbG9uZSwgb2JqLCBpdGVtTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBvbkNsaWNrID0gJ29uLWNsaWNrJztcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBjaGlsZHJlbiBvZiBjbG9uZVxuICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwoY2xvbmUucXVlcnlTZWxlY3RvckFsbCgnWycgKyBvbkNsaWNrICsgJ10nKSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBnZXRMb29wVmFsdWVGcm9tQXR0cmlidXRlKG5vZGUsIG9iaiwgaXRlbU5hbWUsIG9uQ2xpY2ssIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdyZXBlYXQ6Y2FuIG5vdCByZWdpc3RlciBjbGljayBsaXN0ZW5lciB3aXRob3V0IGEgZnVuY3Rpb24nLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogcmVnaXN0ZXIgcnAtYmluZCBoYW5kbGVyXG4gICAgICAgICAgICAgKiBcbiAgICAgICAgICAgICAqIFdpdGggaGVscCBvZiB0aGlzIHRoZSBpZiBhbmQgaWYtbm90IGFuZCBvbkNsaWNrIGF0dHJpYnV0ZSBpcyBkZXByZWNhdGVkIC0geW91IGNhbiBqdXN0IHBhc3MgYSBmdW5jdGlvbiBcbiAgICAgICAgICAgICAqIHBvaW50ZXIgdG8gcnAtYmluZCBhbmQgZG8gYWxsIHRoZSByZXF1aXJlZCBsb2dpYyBieSB5b3VyIG93bi5cbiAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICogSWYgeW91IHJldHVybiBmYWxzZSB0aGVuIHRoZSBub2RlIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBET01cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gY2xvbmVcbiAgICAgICAgICAgICAqIEBwYXJhbSBvYmpcbiAgICAgICAgICAgICAqIEBwYXJhbSBpdGVtTmFtZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVSUEJpbmRBdHRyaWJ1dGUoY2xvbmUsIG9iaiwgaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ck5hbWUgPSAncnAtYmluZCc7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgY2hpbGRyZW4gb2YgY2xvbmVcbiAgICAgICAgICAgICAgICBbXS5zbGljZS5jYWxsKGNsb25lLnF1ZXJ5U2VsZWN0b3JBbGwoJ1snICsgYXR0ck5hbWUgKyAnXScpKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldExvb3BWYWx1ZUZyb21BdHRyaWJ1dGUobm9kZSwgb2JqLCBpdGVtTmFtZSwgYXR0ck5hbWUsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbChub2RlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG5vZGUgaWYgZnVuY3Rpb24gcmV0dXJucyBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdyZXBlYXQ6Y2FuIG5vdCByZWdpc3RlciBjb250cm9sIGZ1bmN0aW9uIHdpdGhvdXQgYSBmdW5jdGlvbiBwb2ludGVyJywgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlcGxhY2VzIGV4cHJlc3Npb25zIGZvciBhbGwgdGFnIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gY2xvbmVcbiAgICAgICAgICAgICAqIEBwYXJhbSBvYmpcbiAgICAgICAgICAgICAqIEBwYXJhbSBpdGVtTmFtZSAoY3VycmVudGx5IG5vdCBpbiB1c2VkIGJ1dCBuZWVkcyB0byBiZSBjaGVja2VkKVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVBdHRyaWJ1dGVzKGNvbnRhaW5lck5vZGUsIG9iaiwgaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0dXJuVG9rZW5zID0gW107XG4gICAgICAgICAgICAgICAgKGZ1bmN0aW9uIHNlYXJjaEZvckV4cHJlc3Npb25zKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwoY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpLCBhdHRyLCByVG9rZW5zO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvIGl0IHJlY3Vyc2l2ZSBmb3IgYWxsIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoRm9yRXhwcmVzc2lvbnMobm9kZS5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggZWFjaCBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyID0gbm9kZS5hdHRyaWJ1dGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXFx7XFx7Ly50ZXN0KGF0dHIudGV4dENvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJUb2tlbnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHBhcnNlKGF0dHIudGV4dENvbnRlbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmREYXRhID0gW10sIHRtcFRva2VuLCBqLCB0bXBUb2tlblNwbGl0LCB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdG9rZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wVG9rZW4gPSB0b2tlbltqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdG9rZW4gbm90IGl0ZW1OYW1lIHNraXBwIGFsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG1wVG9rZW4ua2V5ICE9PSB1bmRlZmluZWQgJiYgdG1wVG9rZW4ua2V5LnNwbGl0KCcuJylbMF0gPT09IGl0ZW1OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzYXZlIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRva2VuLmF0dHIgPSBhdHRyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9cXC4vLnRlc3QodG1wVG9rZW4ua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRva2VuU3BsaXQgPSB0bXBUb2tlbi5rZXkuc3BsaXQoJy4nKS5zbGljZSgxKS5qb2luKCcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRva2VuU3BsaXQgPSB0bXBUb2tlbi5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBUb2tlbi52YWx1ZSA9IGdldEdsb2JhbENhbGwodG1wVG9rZW5TcGxpdCwgb2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRtcFRva2VuLnZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdG1wVG9rZW4udmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRtcFRva2VuLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG9iajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG1wVG9rZW4uaGFzT3duUHJvcGVydHkoJ2tleScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSBleHByZXNzaW9uIC0gbWlnaHQgYmUgYW5vdGhlciB3aGlza2VyIGluc3RhbmNlIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lZWRzIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJ3t7JyArIHRtcFRva2VuLmtleSArICd9fSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRtcFRva2VuLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGEucHVzaCh7dmFsdWUgOiB2YWx1ZSwgY29uY2F0IDogdG1wVG9rZW4uY29uY2F0fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIudGV4dENvbnRlbnQgPSBlbmREYXRhLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5jb25jYXQgPyBkLnZhbHVlIDogJyAnICsgZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVG9rZW5zID0gcmV0dXJuVG9rZW5zLmNvbmNhdChyVG9rZW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfShjb250YWluZXJOb2RlLmNoaWxkcmVuKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblRva2VucztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBoYW5kbGUgdGhlIGlmIGNvbmRpdGlvbnMgaWYgYW5kIGlmLW5vdFxuICAgICAgICAgICAgICogXG4gICAgICAgICAgICAgKiBAZGVwcmVjYXRlZCB1c2UgcnAtYmluZCBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICogQHBhcmFtIGNsb25lXG4gICAgICAgICAgICAgKiBAcGFyYW0gb2JqXG4gICAgICAgICAgICAgKiBAcGFyYW0gaXRlbU5hbWVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gaGFuZGxlSWZDb25kaXRpb24oY2xvbmUsIG9iaiwgaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlTmFtZV9pZiA9ICdpZicsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWVfaWZfbm90ID0gJ2lmLW5vdCc7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjaGVja0lmKHZhbCwgbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrSWZOb3QodmFsLCBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBjaGlsZHJlbiBvZiBjbG9uZVxuICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwoY2xvbmUucXVlcnlTZWxlY3RvckFsbCgnWycgK2F0dHJpYnV0ZU5hbWVfaWYgKyAnXScpKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldExvb3BWYWx1ZUZyb21BdHRyaWJ1dGUobm9kZSwgb2JqLCBpdGVtTmFtZSwgYXR0cmlidXRlTmFtZV9pZiwgZnVuY3Rpb24gKHZhbCkge2NoZWNrSWYodmFsLCBub2RlKTt9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwoY2xvbmUucXVlcnlTZWxlY3RvckFsbCgnWycgK2F0dHJpYnV0ZU5hbWVfaWZfbm90ICsgJ10nKSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBnZXRMb29wVmFsdWVGcm9tQXR0cmlidXRlKG5vZGUsIG9iaiwgaXRlbU5hbWUsIGF0dHJpYnV0ZU5hbWVfaWZfbm90LCBmdW5jdGlvbiAodmFsKSB7Y2hlY2tJZk5vdCh2YWwsIG5vZGUpO30pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExvb3BlZCB0aHJvdWdoIHRoZSBjb2xsZWN0aW9uIGFuZCBkbyB0aGUgbG9naWMgZm9yIGVhY2ggY2xvbmUgaW5zdGFuY2UuXG4gICAgICAgICAgICAgKiBBY3R1YWxseSBpdCBzdXBwb3J0cyBvbmx5IGNvbGxlY3Rpb24gLSBubyBvYmplY3RzLlxuICAgICAgICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSBpdGVtTmFtZVxuICAgICAgICAgICAgICogQHBhcmFtIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAqIEBwYXJhbSB0ZW1wbGF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiByZWdpc3RlclRlbXBsYXRlKG5vZGUsIGl0ZW1OYW1lLCBjb2xsZWN0aW9uLCB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBtYWluRnJhZztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb24gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoY29sbGVjdGlvbikgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IGlzIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0ZW0gY291bGQgYmUgYW4gb2JqZWN0IG9yIGp1c3QgYSBwcm9wZXJ0eSBsaWtlIGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmcgKGluIGNhc2Ugb2YgaXQgaXMgZGlyZWN0IGEgbGlzdCBvZiBzdHJpbmdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkVHBsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gd29ya3MgYWxzbyB3aXRoIGZyYWdtZW50IGJ1dCB0aGVuIHRoZSBxdW5pdCB0ZXN0IGZhaWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gdGhlcmUgaXMgYSBwcm9ibGVtIHdpdGggdGhlIHBoYW50b21qc1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGNoaWxkVHBsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVJZkNvbmRpdGlvbihmcmFnbWVudCwgaXRlbSwgaXRlbU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBjb25kaXRpb25zIGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSBjbG9uZSAtIGl0J3MgaW1wb3J0YW50IHRoYXQgdGhpcyBpcyBleGVjdXRlZCBmaXJzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQuY2hpbGRyZW4gJiYgZnJhZ21lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVSUEJpbmRBdHRyaWJ1dGUoZnJhZ21lbnQsIGl0ZW0sIGl0ZW1OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBycC1iaW5kIGF0dHJpYnV0ZSBjYW4gYWxzbyByZW1vdmUgZWxlbWVudHMgc28gbmVlZCB0byBjaGVjayBhZ2FpbiBpZiBub2RlIGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQuY2hpbGRyZW4gJiYgZnJhZ21lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVFdmVudHMoZnJhZ21lbnQsIGl0ZW0sIGl0ZW1OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUF0dHJpYnV0ZXMoZnJhZ21lbnQsIGl0ZW0sIGl0ZW1OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgdGV4dHM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluRnJhZy5hcHBlbmRDaGlsZChjb21waWxlKGZyYWdtZW50LmNoaWxkcmVuWzBdLCBpdGVtLCBpdGVtTmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygncmVwZWF0OmVsZW1lbnQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIERPTScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQobWFpbkZyYWcpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgaXMgYW4gb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdyZXBlYXQgZGV0ZWN0IG9iamVjdCBidXQgb2JqZWN0IGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGF0IHJlbmRlcj8gLSBwcm9wZXJ0eSBuYW1lIG9yIHZhbHVlPyAtIEJvdGg/XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdyZXBlYXQ6cmVnaXN0ZXJUZW1wbGF0ZSBkZXRlY3Qgbm9uZSBhY2NlcHRhYmxlIGRhdGEgYXJndW1lbnQnLCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlIGEgbmV3IHJlcGVhdCBpbnN0YW5jZSBhbmQgZG8gdGhlIFwibWFnaWNcIi5cbiAgICAgICAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0gc2NvcGVOYW1lXG4gICAgICAgICAgICAgKiBAcGFyYW0gZGF0YSB7W10sIGZ1bmN0aW9ufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBleGVjUmVwZWF0KG5vZGUsIHNjb3BlTmFtZSwgZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IFtdO1xuICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwobm9kZS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUucHVzaChub2RlLnJlbW92ZUNoaWxkKGNoaWxkKSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YShmdW5jdGlvbiAobmFtZSwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZU5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJldHRlciB3b3VsZCBiZSBhIHVwZGF0ZSBjaGlsZHJlbiBidXQgdGhpcyBpcyBtdWNoIGVmZm9ydCB0byBkZXRlY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwobm9kZS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJUZW1wbGF0ZShub2RlLCBzY29wZU5hbWUsIGRhdGEsIHRlbXBsYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJUZW1wbGF0ZShub2RlLCBzY29wZU5hbWUsIGRhdGEsIHRlbXBsYXRlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiB0aGUgYXR0cmlidXRlIHJlcXVpcmVzOlxuICAgICAgICAgICAgICAgICAqICBmb3I6IG5hbWUgb2YgdGhlIGl0ZXJhdG9yXG4gICAgICAgICAgICAgICAgICogIGluOiBwb2ludGVyIHRvOiBmdW5jdGlvbiwgYXJyYXkgb3Igb2JqZWN0XG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBhdHRyIHt7Zm9yOnN0cmluZyxpbjpzdHJpbmd9fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGFkZCA6IGZ1bmN0aW9uIChub2RlLCBhdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpblBvaW50ZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXR0ciA9PT0gJ29iamVjdCcgJiYgYXR0ci5pbiAmJiBhdHRyLmZvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhdHRyLmluID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVwbGFjZSB3aW5kb3cgd2l0aCB0aGlzIGFuZCBhbHNvIG90aGVyIGluc3RhbmNlcyBjb3VsZCB1c2UgdGhlIG1hZ2ljIGFzIGNsb3N1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpblBvaW50ZXIgPSBnZXRHbG9iYWxDYWxsKGF0dHIuaW4sIHdpbmRvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluUG9pbnRlciA9IGF0dHIuaW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjUmVwZWF0KG5vZGUsIGF0dHIuZm9yIHx8ICdpdGVtJywgaW5Qb2ludGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXR0cikgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWNSZXBlYXQobm9kZSwgJ2l0ZW0nLCBhdHRyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXR0ciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY1JlcGVhdChub2RlLCAnaXRlbScsIGF0dHIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhdHRyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5Qb2ludGVyID0gZ2V0R2xvYmFsQ2FsbChhdHRyLCB3aW5kb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY1JlcGVhdChub2RlLCAnaXRlbScsIGluUG9pbnRlcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3JlcGVhdDphZGQgbm9uZSBhY2NlcHRhYmxlIGF0dHJpYnV0ZXMnLCBhdHRyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0oKSk7XG5cbiAgICBmdW5jdGlvbiBlc2NhcGVSZWdleChzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKEVTQ0FQRV9SRSwgJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFJlZ2V4KCkge1xuICAgICAgICB2YXIgb3BlbiA9IGVzY2FwZVJlZ2V4KG9wZW5DaGFyKSxcbiAgICAgICAgICAgIGVuZCAgPSBlc2NhcGVSZWdleChlbmRDaGFyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAob3BlbiArIG9wZW4gKyBvcGVuICsgJz8oLis/KScgKyBlbmQgKyAnPycgKyBlbmQgKyBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBwcm9wZXJ0eSBmcm9tIGEgZ2l2ZW4gc3RyaW5nIGFuZCBvYmplY3QuXG4gICAgICogUmV0dXJucyB0aGUgZm91bmRlZCBwcm9wZXJ0eSBwb2ludGVyIG9yIHVuZGVmaW5lZC5cbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gb2JqXG4gICAgICogQHJldHVybnMgeyp9IG9yIHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEdsb2JhbENhbGwgKHZhbHVlLCBvYmopIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gdmFsdWUuc3BsaXQoJy4nKSxcbiAgICAgICAgICAgIHJlYyA9IGZ1bmN0aW9uIChjdXIpIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqW2N1cl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmpbY3VyXTtcbiAgICAgICAgICAgICAgICAgICAgcmVjKHNwbGl0LnNoaWZ0KCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyID09PSB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIHJlYyhzcGxpdC5zaGlmdCgpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICAvLyBleHBvcnQgYXMgbW9kdWxlIG9yIGJpbmQgdG8gZ2xvYmFsXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5oYXNPd25Qcm9wZXJ0eSgnZXhwb3J0cycpKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVwZWF0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbm55LmFkZCgncmVwZWF0JywgcmVwZWF0KTtcbiAgICB9XG5cbn0oKSk7XG4iLCIvKmdsb2JhbCBjYW5ueSAqL1xuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSovXG4vKipcbiAqXG4gKiBFLmcuIHt7d2hpc2tlcn19OlxuICogIDxkaXYgY2FubnktbW9kPVwid2hpc2tlclwiIGNhbm55LXZhcj1cInsnYmluZCc6J3Njb3BlJywndG8nOnsnbWVzc2FnZSc6J015IHRleHQnfX1cIj5cbiAqICAgICA8cD5EQVRBOiB7e3Njb3BlLm1lc3NhZ2V9fSk8L3A+XG4gKiAgPC9kaXY+XG4gKiAgT3IganVzdCBwYXNzIHRoZSBmdW5jdGlvbiBwb2ludGVyIHRoZSBkZWZhdWx0IHNjb3BlIGlzICdzY29wZScuXG4gKiAgPGRpdiBjYW5ueS1tb2Q9XCJ3aGlza2VyXCIgY2FubnktdmFyPVwibXltb2R1bGUuZnVuY3Rpb25Qb2ludGVyXCI+XG4gKiAgICAgPHA+REFUQToge3tzY29wZS5tZXNzYWdlfX0pPC9wPlxuICogIDwvZGl2PlxuICpcbiAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBvcGVuQ2hhciA9ICd7JyxcbiAgICAgICAgZW5kQ2hhciAgPSAnfScsXG4gICAgICAgIEVTQ0FQRV9SRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2csXG4gICAgICAgIHdoaXNrZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIEJJTkRJTkdfUkUgPSBnZXRSZWdleCgpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiAgUGFyc2UgYSBwaWVjZSBvZiB0ZXh0LCByZXR1cm4gYW4gYXJyYXkgb2YgdG9rZW5zXG4gICAgICAgICAgICAgKiAgVE9ETyByZWZhY3RvciBtZXRob2RcbiAgICAgICAgICAgICAqICBAcGFyYW0gdGV4dFxuICAgICAgICAgICAgICogIEByZXR1cm4gW3trZXk6U3RyaW5nLCBodG1sOmJvb2xlYW59XVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZSh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFCSU5ESU5HX1JFLnRlc3QodGV4dCkpIHtyZXR1cm4gbnVsbDsgfVxuICAgICAgICAgICAgICAgIHZhciBtLCBpLCB0b2tlbiwgbWF0Y2gsIHRva2VucyA9IFtdLCBvcmlnID0ge3RleHQ6IHRleHQsIGlkeCA6IDB9LCB0ZXh0T2JqZWN0O1xuICAgICAgICAgICAgICAgIC8qIGpzaGludCBib3NzOiB0cnVlICovXG4gICAgICAgICAgICAgICAgd2hpbGUgKG0gPSB0ZXh0Lm1hdGNoKEJJTkRJTkdfUkUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBtLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHtjb25jYXQgOiB0cnVlfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JpZy5pZHggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0T2JqZWN0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25jYXQgOiBvcmlnLnRleHRbb3JpZy5pZHggLSAxXSAhPT0gJyAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA6IHRleHQuc2xpY2UoMCwgaSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnLmlkeCArPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnLmlkeCArPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRPYmplY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNhdCA6IG9yaWcudGV4dFtvcmlnLmlkeCAtIDFdICE9PSAnICcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIDogdGV4dC5zbGljZSgwLCBpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godGV4dE9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3JpZy5pZHggKz0gaTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4ua2V5ID0gbVsxXS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gbVswXTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4uaHRtbCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaC5jaGFyQXQoMikgPT09IG9wZW5DaGFyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaC5jaGFyQXQobWF0Y2gubGVuZ3RoIC0gMykgPT09IGVuZENoYXI7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoaSArIG1bMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt2YWx1ZSA6IHRleHQsIHRleHQgOiB0cnVlLCBjb25jYXQ6IHRydWV9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0gZGF0YU9ialxuICAgICAgICAgICAgICogQHBhcmFtIGl0ZW1OYW1lXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHRva2VucyBbe2tleTpTdHJpbmcsIG5vZGU6RE9NIG5vZGUsIGh0bWw6IGJvb2xlYW59XVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBjb21waWxlVGV4dE5vZGUobm9kZSwgZGF0YU9iaiwgaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gcGFyc2Uobm9kZS5ub2RlVmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBvYmogPSBkYXRhT2JqLFxuICAgICAgICAgICAgICAgICAgICBlbCwgdG9rZW4sIGksIGwsIHRtcCwgdG9rZW5PYmplY3RQcm9wZXJ0eSwgdmFsLCB2YWxVbmtub3duO1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW5zIHx8IG9iaiA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7cmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnb2JqZWN0JyAmJiB0b2tlbi5oYXNPd25Qcm9wZXJ0eSgna2V5JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IHRva2VuLmtleS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRtcC5sZW5ndGggPiAwICYmIHRtcFswXSA9PT0gaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbk9iamVjdFByb3BlcnR5ID0gdG1wLnNsaWNlKDEpLmpvaW4oJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsVW5rbm93biA9IGdldEdsb2JhbENhbGwodG9rZW5PYmplY3RQcm9wZXJ0eSwgb2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxVbmtub3duID0gb2JqO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBhIHN0cmluZz9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxVbmtub3duID0gb2JqO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbFVua25vd24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWxVbmtub3duKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWxVbmtub3duO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBbMF0gPT09IGl0ZW1OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvcGVydHkgaXMgbm90IGV4aXN0cyBidXQgaXQgaXMgdGhlIHNhbWUgc2NvcGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSB0aGUgdG9rZW4uLi4gbG9va3MgbGlrZSBpcyBub3QgbWluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ3t7JyArIHRva2VuLmtleSArICd9fScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4ubm9kZSA9IGVsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0b2tlbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IG5vcm1hbCBzdHJpbmcgcHV0IGJhY2sgdG8gdmlld1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICAgICAgICogQHBhcmFtIGRhdGFPYmpcbiAgICAgICAgICAgICAqIEBwYXJhbSBpdGVtTmFtZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBjb21waWxlRWxlbWVudCAobm9kZSwgZGF0YU9iaiwgaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gW10sXG4gICAgICAgICAgICAgICAgICAgIHRva2VuO1xuICAgICAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGNvbXBpbGUgY2hpbGROb2Rlc1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICBbXS5zbGljZS5jYWxsKG5vZGUuY2hpbGROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gY29tcGlsZShjaGlsZCwgZGF0YU9iaiwgaXRlbU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5zLmxlbmd0aCA+IDAgPyB0b2tlbnMgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBoZWxwZXIgZnVuY3Rpb24gdG8gZG8gdGhlIHJlYWQgdmFyaWFibGUgZnJvbSBzdHJpbmcgbWFnaWMuXG4gICAgICAgICAgICAgKiBUaGUgY2Igd2lsbCBjYWxsZWQgd2l0aCB0aGUgcHJvcGVydHkgdmFsdWUgLSBpbiBjYXNlIG9mIHVuZGVmaW5lZCB0aGUgdmFyaWFibGUgZG9lcyBub3QgZXhpc3RzXG4gICAgICAgICAgICAgKiBcbiAgICAgICAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0gb2JqXG4gICAgICAgICAgICAgKiBAcGFyYW0gaXRlbU5hbWVcbiAgICAgICAgICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVOYW1lXG4gICAgICAgICAgICAgKiBcbiAgICAgICAgICAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufSB8IGZhbHNlIGlmIGl0IGlzIG5vdCBhIGZ1bmN0aW9uIG9yIG5vdCBhdmFpbGFibGUgXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFdrQmluZFZhbHVlKG5vZGUsIG9iaiwgaXRlbU5hbWUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkuc3BsaXQoJy4nKSwgdG9rZW5PYmplY3RQcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICBpZiAodG1wLmxlbmd0aCA+IDAgJiYgdG1wWzBdID09PSBpdGVtTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbk9iamVjdFByb3BlcnR5ID0gdG1wLnNsaWNlKDEpLmpvaW4oJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEdsb2JhbENhbGwodG9rZW5PYmplY3RQcm9wZXJ0eSwgb2JqKSB8fCBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHJlZ2lzdGVyIHJwLWJpbmQgaGFuZGxlclxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFdpdGggaGVscCBvZiB0aGlzIHRoZSBpZiBhbmQgaWYtbm90IGFuZCBvbkNsaWNrIGF0dHJpYnV0ZSBpcyBkZXByZWNhdGVkIC0geW91IGNhbiBqdXN0IHBhc3MgYSBmdW5jdGlvbiBwb2ludGVyIHRvIHJwLWJpbmQgYW5kXG4gICAgICAgICAgICAgKiBkbyBhbGwgdGhlIHJlcXVpcmVkIGxvZ2ljIGJ5IHlvdXIgb3duLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIElmIHlvdSByZXR1cm4gZmFsc2UgdGhlbiB0aGUgbm9kZSB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgRE9NXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSBvYmpcbiAgICAgICAgICAgICAqIEBwYXJhbSBzY29wZU5hbWVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gaGFuZGxlV0tCaW5kQXR0cmlidXRlKG5vZGUsIG9iaiwgc2NvcGVOYW1lKSB7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBwYXJzZUNoaWxkQXR0cmlidXRlKGNoaWxkLCBkYXRhLCBzY29wZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJOYW1lID0gJ3drLWJpbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gY2hpbGQuZ2V0QXR0cmlidXRlKCd3ay1iaW5kJyksXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjID0gZ2V0V2tCaW5kVmFsdWUoY2hpbGQsIGRhdGEsIHNjb3BlTmFtZSwgYXR0ck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2hhZG93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZjID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3cuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZjKGNoaWxkKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBub2RlIGlmIGZ1bmN0aW9uIHJldHVybnMgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoc2hhZG93LCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZGVuIDogaGlkZGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA6IGNoaWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93Tm9kZSA6IHNoYWRvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzV2tCaW5kVG9rZW4gOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYga2V5IGlzIG5lZWRlZCBiZWNhdXNlIGl0IGhhcyB0aGUgd2tCaW5kIGZ1bmN0aW9uIHBvaW50ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA6IGNoaWxkLmdldEF0dHJpYnV0ZSgnd2stYmluZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3doaXNrZXI6Y2FuIG5vdCByZWdpc3RlciBjb250cm9sIGZ1bmN0aW9uIHdpdGhvdXQgYSBmdW5jdGlvbiBwb2ludGVyJywgY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0oZmMpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhbGlkIGluIGNhc2Ugb2YgdGhlcmUgaXMgYSBkaWZmZXJlbnQgc2NvcGUgdmFyaWFibGUgb3JcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGF0dHJOYW1lID0gJ3drLWJpbmQnLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBjaGlsZHJlbiBvZiBjbG9uZVxuICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwobm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbJyArIGF0dHJOYW1lICsgJ10nKSkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcFRva2VuID0gcGFyc2VDaGlsZEF0dHJpYnV0ZShjaGlsZCwgb2JqLCBzY29wZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG1wVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRtcFRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbnNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiAgQ29tcGlsZSBhIERPTSBub2RlIChyZWN1cnNpdmUpXG4gICAgICAgICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICAgICAgICogQHBhcmFtIGRhdGFPYmpcbiAgICAgICAgICAgICAqIEBwYXJhbSBpdGVtTmFtZVxuICAgICAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBpbGUobm9kZSwgZGF0YU9iaiwgaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZVR5cGUgPSBub2RlLm5vZGVUeXBlLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW47XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVUeXBlID09PSAxICYmIG5vZGUudGFnTmFtZSAhPT0gJ1NDUklQVCcpIHsgLy8gYSBub3JtYWwgbm9kZVxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGNvbXBpbGVFbGVtZW50KG5vZGUsIGRhdGFPYmosIGl0ZW1OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBjb21waWxlVGV4dE5vZGUobm9kZSwgZGF0YU9iaiwgaXRlbU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VucyA9IHRva2Vucy5jb25jYXQodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbnMubGVuZ3RoID4gMCA/IHRva2VucyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXBsYWNlcyBleHByZXNzaW9ucyBmb3IgYWxsIHRhZyBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogbG9vcCB0aG91Z2ggYWxsIGNoaWxkcmVuIGFuZCBjaGVjayBpZiBhIGF0dHJpYnV0ZSBoYXMgYSBleHByZXNzaW9ucyBpbnNpZGVcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gY29udGFpbmVyTm9kZVxuICAgICAgICAgICAgICogQHBhcmFtIG9ialxuICAgICAgICAgICAgICogQHBhcmFtIGl0ZW1OYW1lXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHJldHVyblRva2VucyBbe2tleTpTdHJpbmcsIGF0dHI6IG5vZGUgYXR0cmlidXRlIHJlZmVyZW5jZSwgaHRtbDogYm9vbGVhbn1dXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZUF0dHJpYnV0ZXMoY29udGFpbmVyTm9kZSwgb2JqLCBpdGVtTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciByZXR1cm5Ub2tlbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gc2VhcmNoRm9yRXhwcmVzc2lvbnMoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgW10uc2xpY2UuY2FsbChjaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIGF0dHIsIHJUb2tlbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gaXQgcmVjdXJzaXZlIGZvciBhbGwgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hGb3JFeHByZXNzaW9ucyhub2RlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBlYWNoIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIgPSBub2RlLmF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9cXHtcXHsvLnRlc3QoYXR0ci50ZXh0Q29udGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHIubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgclRva2VucyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRva2VuID0gcGFyc2UoYXR0ci50ZXh0Q29udGVudCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGEgPSBbXSwgdG1wVG9rZW4sIGosIHRtcFRva2VuU3BsaXQsIHZhbHVlLCB0bXBWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdG9rZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wVG9rZW4gPSB0b2tlbltqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdG9rZW4gbm90IGl0ZW1OYW1lIHNraXBwIGFsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG1wVG9rZW4ua2V5ICE9PSB1bmRlZmluZWQgJiYgdG1wVG9rZW4ua2V5LnNwbGl0KCcuJylbMF0gPT09IGl0ZW1OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzYXZlIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRva2VuLmF0dHIgPSBhdHRyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9cXC4vLnRlc3QodG1wVG9rZW4ua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRva2VuU3BsaXQgPSB0bXBUb2tlbi5rZXkuc3BsaXQoJy4nKS5zbGljZSgxKS5qb2luKCcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRva2VuU3BsaXQgPSB0bXBUb2tlbi5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBWYWx1ZSA9IGdldEdsb2JhbENhbGwodG1wVG9rZW5TcGxpdCwgb2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRtcFZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRva2VuLnZhbHVlID0gdG1wVmFsdWUobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRva2VuLm5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRva2VuLnZhbHVlID0gdG1wVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdG1wVG9rZW4udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvYmo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG9iaihub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRtcFRva2VuLmhhc093blByb3BlcnR5KCdrZXknKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSB0aGUgZXhwcmVzc2lvbiAtIG1pZ2h0IGJlIGFub3RoZXIgd2hpc2tlciBpbnN0YW5jZSB3aWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWVkcyB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICd7eycgKyB0bXBUb2tlbi5rZXkgKyAnfX0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0bXBUb2tlbi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmREYXRhLnB1c2goe3ZhbHVlIDogdmFsdWUsIGNvbmNhdCA6IHRtcFRva2VuLmNvbmNhdH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyLnRleHRDb250ZW50ID0gZW5kRGF0YS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQuY29uY2F0ID8gZC52YWx1ZSA6ICcgJyArIGQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuam9pbignJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblRva2VucyA9IHJldHVyblRva2Vucy5jb25jYXQoclRva2Vucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0oY29udGFpbmVyTm9kZS5jaGlsZHJlbikpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5Ub2tlbnM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogZG8gdGhlIG1hZ2ljIGZvciBhdHRyaWJ1dGVzIG9yIHRleHQgbm9kZXNcbiAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICogVE9ETzogYnVnIGlmIHByb3BlcnR5IGRvZXNuJ3QgZXhpc3RzIGluIGZpcnN0IGV4ZWN1dGlvbiBpdCB3YW50IHdvcmsgYW55bW9yZSBmb3IgYXR0cmlidXRlcyBhbmQgd2stYmluZFxuICAgICAgICAgICAgICogIFNlZTogd2hpc2tlclNwZWNzLmpzID4gZHluYW1pY2FsbHlDaGFuZ2VEYXRhV2l0aEluaXRpYWxNaXNzaW5nUHJvcGVydGllc1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0gc2NvcGVOYW1lXG4gICAgICAgICAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBmaWxsRGF0YShub2RlLCBzY29wZU5hbWUsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gW107XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGVFdmVudHMobm9kZSwgZGF0YSwgc2NvcGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdChoYW5kbGVBdHRyaWJ1dGVzKG5vZGUsIGRhdGEsIHNjb3BlTmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhhdCB0aGUgY29tcGlsZXIgYWxzbyB1cGRhdGVzIHRoZSBoaWRkZW4gZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KGNvbXBpbGUobm9kZSwgZGF0YSwgc2NvcGVOYW1lKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdChoYW5kbGVXS0JpbmRBdHRyaWJ1dGUobm9kZSwgZGF0YSwgc2NvcGVOYW1lKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVwbGFjZSB0ZXh0czpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCd3aGlza2VyOmhhbmRsZUF0dHJpYnV0ZXMgZGV0ZWN0IG5vbmUgYWNjZXB0YWJsZSBkYXRhIGFyZ3VtZW50JywgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGhlbHBlciBmdW5jdGlvbiBmb3IgdXBkYXRlRGF0YSB0byB1cGRhdGUgdGhlIERPTSBFbGVtZW50c1xuICAgICAgICAgICAgICogQHBhcmFtIHRva2VuXG4gICAgICAgICAgICAgKiBAcGFyYW0gZG9tRWxlbWVudCBET01FbGVtZW50XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZURPTUVsZW1lbnQodG9rZW4sIGRvbUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi5ub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGRvbUVsZW1lbnQsIHRva2VuLm5vZGUpO1xuICAgICAgICAgICAgICAgIHRva2VuLm5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0b2tlbi5ub2RlKTtcbiAgICAgICAgICAgICAgICB0b2tlbi5ub2RlID0gZG9tRWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogaGVscGVyIGZ1bmN0aW9uIGZvciB1cGRhdGVEYXRhIHRvIHVwZGF0ZSB0aGUgdGV4dCBub2Rlc1xuICAgICAgICAgICAgICogQHBhcmFtIHRva2VuXG4gICAgICAgICAgICAgKiBAcGFyYW0gdmFsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRleHQodG9rZW4sIHZhbCkge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0Tm9kZTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4ubm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgYmFjayB0byB0ZXh0Tm9kZVxuICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4ubm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0ZXh0Tm9kZSwgdG9rZW4ubm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuLm5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0b2tlbi5ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4ubm9kZSA9IHRleHROb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4ubm9kZS5ub2RlVmFsdWUgPSB2YWw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyB0ZXN0XG4gICAgICAgICAgICAgICAgICAgIHRva2VuLm5vZGUubm9kZVZhbHVlID0gdmFsLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGhlbHBlciBmdW5jdGlvbiBmb3IgdXBkYXRlRGF0YSB0byB1cGRhdGUgdGhlIGF0dHJpYnV0ZXMgZm9yIGEgbm9kZVxuICAgICAgICAgICAgICogQHBhcmFtIHRva2VuXG4gICAgICAgICAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlQXR0cmlidXRlcyh0b2tlbiwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsdWUodG9rZW4ubm9kZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZVRleHQgPSB0b2tlbi5hdHRyLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVwbGFjZVRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLmF0dHIudGV4dENvbnRlbnQgPSByZXBsYWNlVGV4dC5yZXBsYWNlKHRva2VuLnZhbHVlLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4uYXR0ci50ZXh0Q29udGVudCA9IHJlcGxhY2VUZXh0ICsgdmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRva2VuLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gdGVzdCAobWFrZXMgbm8gc2Vuc2UgZm9yIGFuIGF0dHJpYnV0ZSBidXQgbmVlZHMgdG8gYmUgaGFuZGxlZCBjb3JyZWN0bHkgKHRoaW5rIGFib3V0IHdoYXQgdG8gZG8gaW4gdGhpcyBjYXNlKVxuICAgICAgICAgICAgICAgICAgICB0b2tlbi5ub2RlLm5vZGVWYWx1ZSA9IHZhbC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIENhbGwgdGhpcyB0byB1cGRhdGUgdGhlIGV4aXN0aW5nIGRhdGEnc1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRPRE8gdGVzdCBhbHNvIGJvb2xlYW4gYW5kIGZ1bmN0aW9uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHRva2VuT2JqTGlzdCBbe2tleSA6IFwic2NvcGVOYW1lLnByb3BlcnR5XCIsIG5vZGV9XVxuICAgICAgICAgICAgICogQHBhcmFtIHNjb3BlTmFtZVxuICAgICAgICAgICAgICogQHBhcmFtIG9ialxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVEYXRhKHRva2VuT2JqTGlzdCwgc2NvcGVOYW1lLCBvYmopIHtcbiAgICAgICAgICAgICAgICB0b2tlbk9iakxpc3QuZm9yRWFjaChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICYmIHRva2VuLmhhc093blByb3BlcnR5KCdrZXknKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IHRva2VuLmtleS5zcGxpdCgnLicpLCB0b2tlbk9iamVjdFByb3BlcnR5LCB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG1wLmxlbmd0aCA+IDAgJiYgdG1wWzBdID09PSBzY29wZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbk9iamVjdFByb3BlcnR5ID0gdG1wLnNsaWNlKDEpLmpvaW4oJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gZ2V0R2xvYmFsQ2FsbCh0b2tlbk9iamVjdFByb3BlcnR5LCBvYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IG9iajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLmhhc093blByb3BlcnR5KCdhdHRyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUF0dHJpYnV0ZXModG9rZW4sIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4uaXNXa0JpbmRUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlTWVJZkltRmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVNZUlmSW1GYWxzZSA9IHZhbCh0b2tlbi5ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92ZU1lSWZJbUZhbHNlID09PSBmYWxzZSAmJiB0b2tlbi5oaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLm5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodG9rZW4uc2hhZG93Tm9kZSwgdG9rZW4ubm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZW1vdmVNZUlmSW1GYWxzZSAhPT0gZmFsc2UgJiYgdG9rZW4uaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5zaGFkb3dOb2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHRva2VuLm5vZGUsIHRva2VuLnNoYWRvd05vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhIHJldHVybiByZXN1bHQgY291bGQgYWxzbyBiZSBhIEhUTUxFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgPyB2YWwodG9rZW4ubm9kZSkgOiB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZURPTUVsZW1lbnQodG9rZW4sIHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVGV4dCh0b2tlbiwgcmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHZhbCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUT0RPIGRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgKiBDcmVhdGUgYSBuZXcgd2hpc2tlciBpbnN0YW5jZSBhbmQgZG8gdGhlIFwibWFnaWNcIi5cbiAgICAgICAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0gc2NvcGVOYW1lXG4gICAgICAgICAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBleGVjKG5vZGUsIGRhdGEsIHNjb3BlTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50U2NvcGUgPSBzY29wZU5hbWUgfHwgJ2l0ZW0nLFxuICAgICAgICAgICAgICAgICAgICBrZXlWYWx1ZWhvbGRlciA9IHt9O1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhKGZ1bmN0aW9uIChzY29wZSwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbmRlclNjb3BlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclNjb3BlID0gY3VycmVudFNjb3BlID0gc2NvcGUgfHwgY3VycmVudFNjb3BlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gc2NvcGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHVzZSB0aGUgc2NvcGUgZnJvbSB0aGUgaW5pdGlhbGlzYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTY29wZSA9IGN1cnJlbnRTY29wZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlWYWx1ZWhvbGRlci5oYXNPd25Qcm9wZXJ0eShyZW5kZXJTY29wZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVEYXRhKGtleVZhbHVlaG9sZGVyW3JlbmRlclNjb3BlXSwgcmVuZGVyU2NvcGUsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlWYWx1ZWhvbGRlcltyZW5kZXJTY29wZV0gPSBmaWxsRGF0YShub2RlLCByZW5kZXJTY29wZSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxEYXRhKG5vZGUsIGN1cnJlbnRTY29wZSwgZGF0YSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWRkIDogZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluUG9pbnRlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhdHRyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHIudG8gJiYgYXR0ci5iaW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhdHRyLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHJlcGxhY2Ugd2luZG93IHdpdGggdGhpcyBhbmQgYWxzbyBvdGhlciBpbnN0YW5jZXMgY291bGQgdXNlIHRoZSBtYWdpYyBhcyBjbG9zdXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluUG9pbnRlciA9IGdldEdsb2JhbENhbGwoYXR0ci50bywgd2luZG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpblBvaW50ZXIgPSBhdHRyLnRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5Qb2ludGVyID0gYXR0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWMobm9kZSwgaW5Qb2ludGVyLCBhdHRyLmJpbmQgfHwgJ2l0ZW0nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXR0ciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluUG9pbnRlciA9IGdldEdsb2JhbENhbGwoYXR0ciwgd2luZG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5Qb2ludGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhlYyhub2RlLCBpblBvaW50ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3doaXNrZXI6YWRkIG5vbmUgYWNjZXB0YWJsZSBhdHRyaWJ1dGVzJywgYXR0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjKG5vZGUsIGF0dHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSgpKTtcblxuICAgIGZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoRVNDQVBFX1JFLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UmVnZXgoKSB7XG4gICAgICAgIHZhciBvcGVuID0gZXNjYXBlUmVnZXgob3BlbkNoYXIpLFxuICAgICAgICAgICAgZW5kICA9IGVzY2FwZVJlZ2V4KGVuZENoYXIpO1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgb3BlbiArIG9wZW4gKyAnPyguKz8pJyArIGVuZCArICc/JyArIGVuZCArIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVhZCBhIHByb3BlcnR5IGZyb20gYSBnaXZlbiBzdHJpbmcgYW5kIG9iamVjdC5cbiAgICAgKiBSZXR1cm5zIHRoZSBmb3VuZGVkIHByb3BlcnR5IHBvaW50ZXIgb3IgdW5kZWZpbmVkLlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSBvYmpcbiAgICAgKiBAcmV0dXJucyB7Kn0gb3IgdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0R2xvYmFsQ2FsbCAodmFsdWUsIG9iaikge1xuICAgICAgICB2YXIgc3BsaXQgPSB2YWx1ZS5zcGxpdCgnLicpLFxuICAgICAgICAgICAgcmVjID0gZnVuY3Rpb24gKGN1cikge1xuICAgICAgICAgICAgICAgIGlmIChvYmpbY3VyXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IG9ialtjdXJdO1xuICAgICAgICAgICAgICAgICAgICByZWMoc3BsaXQuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXIgPT09IHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgcmVjKHNwbGl0LnNoaWZ0KCkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIC8vIGV4cG9ydCBhcyBtb2R1bGUgb3IgYmluZCB0byBnbG9iYWxcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmhhc093blByb3BlcnR5KCdleHBvcnRzJykpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSB3aGlza2VyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbm55LmFkZCgnd2hpc2tlcicsIHdoaXNrZXIpO1xuICAgIH1cblxufSgpKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHhzLCBmbikge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB4ID0gZm4oeHNbaV0sIGkpO1xuICAgICAgICBpZiAoaXNBcnJheSh4KSkgcmVzLnB1c2guYXBwbHkocmVzLCB4KTtcbiAgICAgICAgZWxzZSByZXMucHVzaCh4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCJ2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIHNjcnViYmVyID0gcmVxdWlyZSgnLi9saWIvc2NydWInKTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi9saWIva2V5cycpO1xudmFyIGZvckVhY2ggPSByZXF1aXJlKCcuL2xpYi9mb3JlYWNoJyk7XG52YXIgaXNFbnVtZXJhYmxlID0gcmVxdWlyZSgnLi9saWIvaXNfZW51bScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25zLCBvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm90byhjb25zLCBvcHRzKTtcbn07XG5cbihmdW5jdGlvbiAoKSB7IC8vIGJyb3dzZXJzIGJsZWhcbiAgICBmb3IgKHZhciBrZXkgaW4gRXZlbnRFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgICAgICBQcm90by5wcm90b3R5cGVba2V5XSA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGVba2V5XTtcbiAgICB9XG59KSgpO1xuXG5mdW5jdGlvbiBQcm90byAoY29ucywgb3B0cykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBFdmVudEVtaXR0ZXIuY2FsbChzZWxmKTtcbiAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgICBcbiAgICBzZWxmLnJlbW90ZSA9IHt9O1xuICAgIHNlbGYuY2FsbGJhY2tzID0geyBsb2NhbCA6IFtdLCByZW1vdGUgOiBbXSB9O1xuICAgIHNlbGYud3JhcCA9IG9wdHMud3JhcDtcbiAgICBzZWxmLnVud3JhcCA9IG9wdHMudW53cmFwO1xuICAgIFxuICAgIHNlbGYuc2NydWJiZXIgPSBzY3J1YmJlcihzZWxmLmNhbGxiYWNrcy5sb2NhbCk7XG4gICAgXG4gICAgaWYgKHR5cGVvZiBjb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHNlbGYuaW5zdGFuY2UgPSBuZXcgY29ucyhzZWxmLnJlbW90ZSwgc2VsZik7XG4gICAgfVxuICAgIGVsc2Ugc2VsZi5pbnN0YW5jZSA9IGNvbnMgfHwge307XG59XG5cblByb3RvLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlcXVlc3QoJ21ldGhvZHMnLCBbIHRoaXMuaW5zdGFuY2UgXSk7XG59O1xuXG5Qcm90by5wcm90b3R5cGUuY3VsbCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrcy5yZW1vdGVbaWRdO1xuICAgIHRoaXMuZW1pdCgncmVxdWVzdCcsIHtcbiAgICAgICAgbWV0aG9kIDogJ2N1bGwnLFxuICAgICAgICBhcmd1bWVudHMgOiBbIGlkIF1cbiAgICB9KTtcbn07XG5cblByb3RvLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG1ldGhvZCwgYXJncykge1xuICAgIHZhciBzY3J1YiA9IHRoaXMuc2NydWJiZXIuc2NydWIoYXJncyk7XG4gICAgXG4gICAgdGhpcy5lbWl0KCdyZXF1ZXN0Jywge1xuICAgICAgICBtZXRob2QgOiBtZXRob2QsXG4gICAgICAgIGFyZ3VtZW50cyA6IHNjcnViLmFyZ3VtZW50cyxcbiAgICAgICAgY2FsbGJhY2tzIDogc2NydWIuY2FsbGJhY2tzLFxuICAgICAgICBsaW5rcyA6IHNjcnViLmxpbmtzXG4gICAgfSk7XG59O1xuXG5Qcm90by5wcm90b3R5cGUuaGFuZGxlID0gZnVuY3Rpb24gKHJlcSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXJncyA9IHNlbGYuc2NydWJiZXIudW5zY3J1YihyZXEsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoc2VsZi5jYWxsYmFja3MucmVtb3RlW2lkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb25seSBpZiBvbmUgaGFzbid0IGFscmVhZHkgYmVlbiBjcmVhdGVkXG4gICAgICAgICAgICAvLyBmb3IgYSBwYXJ0aWN1bGFyIGlkXG4gICAgICAgICAgICB2YXIgY2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5yZXF1ZXN0KGlkLCBbXS5zbGljZS5hcHBseShhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZWxmLmNhbGxiYWNrcy5yZW1vdGVbaWRdID0gc2VsZi53cmFwID8gc2VsZi53cmFwKGNiLCBpZCkgOiBjYjtcbiAgICAgICAgICAgIHJldHVybiBjYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZi51bndyYXBcbiAgICAgICAgICAgID8gc2VsZi51bndyYXAoc2VsZi5jYWxsYmFja3MucmVtb3RlW2lkXSwgaWQpXG4gICAgICAgICAgICA6IHNlbGYuY2FsbGJhY2tzLnJlbW90ZVtpZF1cbiAgICAgICAgO1xuICAgIH0pO1xuICAgIFxuICAgIGlmIChyZXEubWV0aG9kID09PSAnbWV0aG9kcycpIHtcbiAgICAgICAgc2VsZi5oYW5kbGVNZXRob2RzKGFyZ3NbMF0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZXEubWV0aG9kID09PSAnY3VsbCcpIHtcbiAgICAgICAgZm9yRWFjaChhcmdzLCBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzZWxmLmNhbGxiYWNrcy5sb2NhbFtpZF07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgcmVxLm1ldGhvZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGlzRW51bWVyYWJsZShzZWxmLmluc3RhbmNlLCByZXEubWV0aG9kKSkge1xuICAgICAgICAgICAgc2VsZi5hcHBseShzZWxmLmluc3RhbmNlW3JlcS5tZXRob2RdLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuZW1pdCgnZmFpbCcsIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAncmVxdWVzdCBmb3Igbm9uLWVudW1lcmFibGUgbWV0aG9kOiAnICsgcmVxLm1ldGhvZFxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHJlcS5tZXRob2QgPT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIGZuID0gc2VsZi5jYWxsYmFja3MubG9jYWxbcmVxLm1ldGhvZF07XG4gICAgICAgIGlmICghZm4pIHtcbiAgICAgICAgICAgIHNlbGYuZW1pdCgnZmFpbCcsIG5ldyBFcnJvcignbm8gc3VjaCBtZXRob2QnKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBzZWxmLmFwcGx5KGZuLCBhcmdzKTtcbiAgICB9XG59O1xuXG5Qcm90by5wcm90b3R5cGUuaGFuZGxlTWV0aG9kcyA9IGZ1bmN0aW9uIChtZXRob2RzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgbWV0aG9kcyAhPSAnb2JqZWN0Jykge1xuICAgICAgICBtZXRob2RzID0ge307XG4gICAgfVxuICAgIFxuICAgIC8vIGNvcHkgc2luY2UgYXNzaWdubWVudCBkaXNjYXJkcyB0aGUgcHJldmlvdXMgcmVmc1xuICAgIGZvckVhY2gob2JqZWN0S2V5cyhzZWxmLnJlbW90ZSksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgZGVsZXRlIHNlbGYucmVtb3RlW2tleV07XG4gICAgfSk7XG4gICAgXG4gICAgZm9yRWFjaChvYmplY3RLZXlzKG1ldGhvZHMpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHNlbGYucmVtb3RlW2tleV0gPSBtZXRob2RzW2tleV07XG4gICAgfSk7XG4gICAgXG4gICAgc2VsZi5lbWl0KCdyZW1vdGUnLCBzZWxmLnJlbW90ZSk7XG4gICAgc2VsZi5lbWl0KCdyZWFkeScpO1xufTtcblxuUHJvdG8ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKGYsIGFyZ3MpIHtcbiAgICB0cnkgeyBmLmFwcGx5KHVuZGVmaW5lZCwgYXJncykgfVxuICAgIGNhdGNoIChlcnIpIHsgdGhpcy5lbWl0KCdlcnJvcicsIGVycikgfVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9yRWFjaCAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZm9yRWFjaCkgcmV0dXJuIHhzLmZvckVhY2goZilcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGYuY2FsbCh4cywgeHNbaV0sIGkpO1xuICAgIH1cbn1cbiIsInZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwga2V5KSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIGtleSk7XG4gICAgfVxuICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoa2V5ID09PSBrZXlzW2ldKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gICAgcmV0dXJuIGtleXM7XG59O1xuIiwidmFyIHRyYXZlcnNlID0gcmVxdWlyZSgndHJhdmVyc2UnKTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoJy4vZm9yZWFjaCcpO1xuXG5mdW5jdGlvbiBpbmRleE9mICh4cywgeCkge1xuICAgIGlmICh4cy5pbmRleE9mKSByZXR1cm4geHMuaW5kZXhPZih4KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICAgIHJldHVybiAtMTtcbn1cblxuLy8gc2NydWIgY2FsbGJhY2tzIG91dCBvZiByZXF1ZXN0cyBpbiBvcmRlciB0byBjYWxsIHRoZW0gYWdhaW4gbGF0ZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNhbGxiYWNrcykge1xuICAgIHJldHVybiBuZXcgU2NydWJiZXIoY2FsbGJhY2tzKTtcbn07XG5cbmZ1bmN0aW9uIFNjcnViYmVyIChjYWxsYmFja3MpIHtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbn1cblxuLy8gVGFrZSB0aGUgZnVuY3Rpb25zIG91dCBhbmQgbm90ZSB0aGVtIGZvciBmdXR1cmUgdXNlXG5TY3J1YmJlci5wcm90b3R5cGUuc2NydWIgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwYXRocyA9IHt9O1xuICAgIHZhciBsaW5rcyA9IFtdO1xuICAgIFxuICAgIHZhciBhcmdzID0gdHJhdmVyc2Uob2JqKS5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgaSA9IGluZGV4T2Yoc2VsZi5jYWxsYmFja3MsIG5vZGUpO1xuICAgICAgICAgICAgaWYgKGkgPj0gMCAmJiAhKGkgaW4gcGF0aHMpKSB7XG4gICAgICAgICAgICAgICAgLy8gS2VlcCBwcmV2aW91cyBmdW5jdGlvbiBJRHMgb25seSBmb3IgdGhlIGZpcnN0IGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgLy8gZm91bmQuIFRoaXMgaXMgc29tZXdoYXQgc3Vib3B0aW1hbCBidXQgdGhlIGFsdGVybmF0aXZlc1xuICAgICAgICAgICAgICAgIC8vIGFyZSB3b3JzZS5cbiAgICAgICAgICAgICAgICBwYXRoc1tpXSA9IHRoaXMucGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IHNlbGYuY2FsbGJhY2tzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGxiYWNrcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIHBhdGhzW2lkXSA9IHRoaXMucGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy51cGRhdGUoJ1tGdW5jdGlvbl0nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNpcmN1bGFyKSB7XG4gICAgICAgICAgICBsaW5rcy5wdXNoKHsgZnJvbSA6IHRoaXMuY2lyY3VsYXIucGF0aCwgdG8gOiB0aGlzLnBhdGggfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgnW0NpcmN1bGFyXScpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXJndW1lbnRzIDogYXJncyxcbiAgICAgICAgY2FsbGJhY2tzIDogcGF0aHMsXG4gICAgICAgIGxpbmtzIDogbGlua3NcbiAgICB9O1xufTtcbiBcbi8vIFJlcGxhY2UgY2FsbGJhY2tzLiBUaGUgc3VwcGxpZWQgZnVuY3Rpb24gc2hvdWxkIHRha2UgYSBjYWxsYmFjayBpZCBhbmRcbi8vIHJldHVybiBhIGNhbGxiYWNrIG9mIGl0cyBvd24uXG5TY3J1YmJlci5wcm90b3R5cGUudW5zY3J1YiA9IGZ1bmN0aW9uIChtc2csIGYpIHtcbiAgICB2YXIgYXJncyA9IG1zZy5hcmd1bWVudHMgfHwgW107XG4gICAgZm9yRWFjaChvYmplY3RLZXlzKG1zZy5jYWxsYmFja3MgfHwge30pLCBmdW5jdGlvbiAoc2lkKSB7XG4gICAgICAgIHZhciBpZCA9IHBhcnNlSW50KHNpZCwgMTApO1xuICAgICAgICB2YXIgcGF0aCA9IG1zZy5jYWxsYmFja3NbaWRdO1xuICAgICAgICB0cmF2ZXJzZS5zZXQoYXJncywgcGF0aCwgZihpZCkpO1xuICAgIH0pO1xuICAgIFxuICAgIGZvckVhY2gobXNnLmxpbmtzIHx8IFtdLCBmdW5jdGlvbiAobGluaykge1xuICAgICAgICB2YXIgdmFsdWUgPSB0cmF2ZXJzZS5nZXQoYXJncywgbGluay5mcm9tKTtcbiAgICAgICAgdHJhdmVyc2Uuc2V0KGFyZ3MsIGxpbmsudG8sIHZhbHVlKTtcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gYXJncztcbn07XG4iLCJ2YXIgZG5vZGUgPSByZXF1aXJlKCcuL2xpYi9kbm9kZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25zLCBvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBkbm9kZShjb25zLCBvcHRzKTtcbn07XG4iLCJ2YXIgcHJvdG9jb2wgPSByZXF1aXJlKCdkbm9kZS1wcm90b2NvbCcpO1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xudmFyIGpzb24gPSB0eXBlb2YgSlNPTiA9PT0gJ29iamVjdCcgPyBKU09OIDogcmVxdWlyZSgnanNvbmlmeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRub2RlO1xuZG5vZGUucHJvdG90eXBlID0ge307XG4oZnVuY3Rpb24gKCkgeyAvLyBicm93c2VycyBldGNcbiAgICBmb3IgKHZhciBrZXkgaW4gU3RyZWFtLnByb3RvdHlwZSkge1xuICAgICAgICBkbm9kZS5wcm90b3R5cGVba2V5XSA9IFN0cmVhbS5wcm90b3R5cGVba2V5XTtcbiAgICB9XG59KSgpO1xuXG5mdW5jdGlvbiBkbm9kZSAoY29ucywgb3B0cykge1xuICAgIFN0cmVhbS5jYWxsKHRoaXMpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBcbiAgICBzZWxmLm9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIFxuICAgIHNlbGYuY29ucyA9IHR5cGVvZiBjb25zID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY29uc1xuICAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnMgfHwge30gfVxuICAgIDtcbiAgICBcbiAgICBzZWxmLnJlYWRhYmxlID0gdHJ1ZTtcbiAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNlbGYuX2VuZGVkKSByZXR1cm47XG4gICAgICAgIHNlbGYucHJvdG8gPSBzZWxmLl9jcmVhdGVQcm90bygpO1xuICAgICAgICBzZWxmLnByb3RvLnN0YXJ0KCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXNlbGYuX2hhbmRsZVF1ZXVlKSByZXR1cm47XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5faGFuZGxlUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNlbGYuaGFuZGxlKHNlbGYuX2hhbmRsZVF1ZXVlW2ldKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5kbm9kZS5wcm90b3R5cGUuX2NyZWF0ZVByb3RvID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcHJvdG8gPSBwcm90b2NvbChmdW5jdGlvbiAocmVtb3RlKSB7XG4gICAgICAgIGlmIChzZWxmLl9lbmRlZCkgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgdmFyIHJlZiA9IHNlbGYuY29ucy5jYWxsKHRoaXMsIHJlbW90ZSwgc2VsZik7XG4gICAgICAgIGlmICh0eXBlb2YgcmVmICE9PSAnb2JqZWN0JykgcmVmID0gdGhpcztcbiAgICAgICAgXG4gICAgICAgIHNlbGYuZW1pdCgnbG9jYWwnLCByZWYsIHNlbGYpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJlZjtcbiAgICB9LCBzZWxmLm9wdHMucHJvdG8pO1xuICAgIFxuICAgIHByb3RvLm9uKCdyZW1vdGUnLCBmdW5jdGlvbiAocmVtb3RlKSB7XG4gICAgICAgIHNlbGYuZW1pdCgncmVtb3RlJywgcmVtb3RlLCBzZWxmKTtcbiAgICAgICAgc2VsZi5lbWl0KCdyZWFkeScpOyAvLyBiYWNrd2FyZHMgY29tcGF0YWJpbGl0eSwgZGVwcmVjYXRlZFxuICAgIH0pO1xuICAgIFxuICAgIHByb3RvLm9uKCdyZXF1ZXN0JywgZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICBpZiAoIXNlbGYucmVhZGFibGUpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIGlmIChzZWxmLm9wdHMuZW1pdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHNlbGYuZW1pdCgnZGF0YScsIHJlcSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBzZWxmLmVtaXQoJ2RhdGEnLCBqc29uLnN0cmluZ2lmeShyZXEpICsgJ1xcbicpO1xuICAgIH0pO1xuICAgIFxuICAgIHByb3RvLm9uKCdmYWlsJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAvLyBlcnJvcnMgdGhhdCB0aGUgcmVtb3RlIGVuZCB3YXMgcmVzcG9uc2libGUgZm9yXG4gICAgICAgIHNlbGYuZW1pdCgnZmFpbCcsIGVycik7XG4gICAgfSk7XG4gICAgXG4gICAgcHJvdG8ub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAvLyBlcnJvcnMgdGhhdCB0aGUgbG9jYWwgY29kZSB3YXMgcmVzcG9uc2libGUgZm9yXG4gICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBwcm90bztcbn07XG5cbmRub2RlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICBpZiAodGhpcy5fZW5kZWQpIHJldHVybjtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHJvdztcbiAgICBcbiAgICBpZiAoYnVmICYmIHR5cGVvZiBidWYgPT09ICdvYmplY3QnXG4gICAgJiYgYnVmLmNvbnN0cnVjdG9yICYmIGJ1Zi5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQnVmZmVyJ1xuICAgICYmIGJ1Zi5sZW5ndGhcbiAgICAmJiB0eXBlb2YgYnVmLnNsaWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIHRyZWF0IGxpa2UgYSBidWZmZXJcbiAgICAgICAgaWYgKCFzZWxmLl9idWZzKSBzZWxmLl9idWZzID0gW107XG4gICAgICAgIFxuICAgICAgICAvLyB0cmVhdCBsaWtlIGEgYnVmZmVyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGJ1ZltpXSA9PT0gMHgwYSkge1xuICAgICAgICAgICAgICAgIHNlbGYuX2J1ZnMucHVzaChidWYuc2xpY2UoaiwgaSkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBsaW5lID0gJyc7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBzZWxmLl9idWZzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgKz0gU3RyaW5nKHNlbGYuX2J1ZnNba10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0cnkgeyByb3cgPSBqc29uLnBhcnNlKGxpbmUpIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7IHJldHVybiBzZWxmLmVuZCgpIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBqID0gaSArIDE7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc2VsZi5oYW5kbGUocm93KTtcbiAgICAgICAgICAgICAgICBzZWxmLl9idWZzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChqIDwgYnVmLmxlbmd0aCkgc2VsZi5fYnVmcy5wdXNoKGJ1Zi5zbGljZShqLCBidWYubGVuZ3RoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJ1ZiAmJiB0eXBlb2YgYnVmID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyAuaXNCdWZmZXIoKSB3aXRob3V0IHRoZSBCdWZmZXJcbiAgICAgICAgLy8gVXNlIHNlbGYgdG8gcGlwZSBKU09OU3RyZWFtLnBhcnNlKCkgc3RyZWFtcy5cbiAgICAgICAgc2VsZi5oYW5kbGUoYnVmKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgYnVmICE9PSAnc3RyaW5nJykgYnVmID0gU3RyaW5nKGJ1Zik7XG4gICAgICAgIGlmICghc2VsZi5fbGluZSkgc2VsZi5fbGluZSA9ICcnO1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChidWYuY2hhckNvZGVBdChpKSA9PT0gMHgwYSkge1xuICAgICAgICAgICAgICAgIHRyeSB7IHJvdyA9IGpzb24ucGFyc2Uoc2VsZi5fbGluZSkgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHsgcmV0dXJuIHNlbGYuZW5kKCkgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHNlbGYuX2xpbmUgPSAnJztcbiAgICAgICAgICAgICAgICBzZWxmLmhhbmRsZShyb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBzZWxmLl9saW5lICs9IGJ1Zi5jaGFyQXQoaSlcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmRub2RlLnByb3RvdHlwZS5oYW5kbGUgPSBmdW5jdGlvbiAocm93KSB7XG4gICAgaWYgKCF0aGlzLnByb3RvKSB7XG4gICAgICAgIGlmICghdGhpcy5faGFuZGxlUXVldWUpIHRoaXMuX2hhbmRsZVF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuX2hhbmRsZVF1ZXVlLnB1c2gocm93KTtcbiAgICB9XG4gICAgZWxzZSB0aGlzLnByb3RvLmhhbmRsZShyb3cpO1xufTtcblxuZG5vZGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fZW5kZWQpIHJldHVybjtcbiAgICB0aGlzLl9lbmRlZCA9IHRydWU7XG4gICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ2VuZCcpO1xufTtcblxuZG5vZGUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbmQoKTtcbn07XG4iLCIvKmdsb2JhbCBIVE1MRWxlbWVudCAqL1xuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSAqL1xuXG52YXIgZG9tT3B0cyA9IHt9O1xuXG5kb21PcHRzLnBhcmFtcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHBhcmFtcyA9IHt9LCBpLCBudiwgcGFydHM7XG4gICAgaWYgKGxvY2F0aW9uLnNlYXJjaCkge1xuICAgICAgICBwYXJ0cyA9IGxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSkuc3BsaXQoJyYnKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBudiA9IHBhcnRzW2ldLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICBpZiAobnZbMF0pIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNbbnZbMF1dID0gbnZbMV0gfHwgdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zO1xufSgpKTtcblxuZG9tT3B0cy5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHRhZywgaWQsIGNsYXNzZXMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgbmV3Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICBpZiAoaWQpIHtuZXdOb2RlLnNldEF0dHJpYnV0ZSgnaWQnLCBpZCk7IH1cbiAgICBpZiAoY2xhc3Nlcykge25ld05vZGUuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNsYXNzZXMpOyB9XG4gICAgcmV0dXJuIG5ld05vZGU7XG59O1xubW9kdWxlLmV4cG9ydHMgPSAgZG9tT3B0cztcblxuLy8gZG9tIG9wZXJhdGlvbnM6XG5IVE1MRWxlbWVudC5wcm90b3R5cGUuZG9tQWRkQ2xhc3MgPSBmdW5jdGlvbiAoYWRkQ2xhc3Nlcykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBhdHRyQ2xhc3MgPSB0aGlzLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSxcbiAgICAgICAgYWRkQ2xhc3Nlc0xpc3QgPSBhZGRDbGFzc2VzLnNwbGl0KCcgJyksIG5ld0NsYXNzZXMgPSBbXSwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYWRkQ2xhc3Nlc0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbUhhc0NsYXNzKGFkZENsYXNzZXNMaXN0W2ldKSkge1xuICAgICAgICAgICAgbmV3Q2xhc3Nlcy5wdXNoKGFkZENsYXNzZXNMaXN0W2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBhdHRyQ2xhc3MgIT09IG51bGwgPyBhdHRyQ2xhc3MgKyAnICcgKyBuZXdDbGFzc2VzLmpvaW4oJyAnKSA6IG5ld0NsYXNzZXMuam9pbignICcpKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG4vLyBUT0RPIHJlbW92ZSBhbGwgY2xhc3NlcyB3aXRoIHNhbWUgbmFtZVxuSFRNTEVsZW1lbnQucHJvdG90eXBlLmRvbVJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKHJlbW92ZWFibGVDbGFzc2VzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHJlbW92ZUNsYXNzZXMgPSAocmVtb3ZlYWJsZUNsYXNzZXMgJiYgcmVtb3ZlYWJsZUNsYXNzZXMuc3BsaXQoJyAnKSkgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykuc3BsaXQoJyAnKSxcbiAgICAgICAgYXR0ckNsYXNzID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2NsYXNzJyksXG4gICAgICAgIGN1cnJlbnRDbGFzc2VzLFxuICAgICAgICBpLFxuICAgICAgICBpZHg7XG4gICAgaWYgKGF0dHJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICBjdXJyZW50Q2xhc3NlcyA9IGF0dHJDbGFzcy5zcGxpdCgnICcpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVtb3ZlQ2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWR4ID0gY3VycmVudENsYXNzZXMuaW5kZXhPZihyZW1vdmVDbGFzc2VzW2ldKTtcbiAgICAgICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDbGFzc2VzID0gY3VycmVudENsYXNzZXMuc2xpY2UoMCwgaWR4KS5jb25jYXQoY3VycmVudENsYXNzZXMuc2xpY2UoaWR4ICsgMSwgY3VycmVudENsYXNzZXMubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cnJlbnRDbGFzc2VzLmpvaW4oJyAnKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLy8gZG9tIG9wZXJhdGlvbnM6XG5IVE1MRWxlbWVudC5wcm90b3R5cGUuZG9tSGFzQ2xhc3MgPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGNsYXNzZXMgPSB0aGlzLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSwgY3VycmVudENsYXNzZXMsIGk7XG4gICAgaWYgKGNsYXNzZXMgIT09IG51bGwpIHtcbiAgICAgICAgY3VycmVudENsYXNzZXMgPSBjbGFzc2VzLnNwbGl0KCcgJyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjdXJyZW50Q2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRDbGFzc2VzW2ldID09PSBjbGFzc05hbWUpIHtyZXR1cm4gdHJ1ZTsgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbkhUTUxFbGVtZW50LnByb3RvdHlwZS5kb21SZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMpO1xufTtcbi8qKlxuICogcmVtb3ZlIGFsbCBjaGlsZCBlbGVtZW50cyBmcm9tIG5vZGVcbiAqL1xuSFRNTEVsZW1lbnQucHJvdG90eXBlLmRvbUVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLmRvbVJlbW92ZSh0aGlzKTtcbiAgICB9KTtcbn07XG5cbkhUTUxFbGVtZW50LnByb3RvdHlwZS5kb21BcHBlbmRUbyA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIG5vZGUgPSBlbGVtO1xuICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG5vZGUpO1xuICAgIH1cbiAgICBub2RlLmFwcGVuZENoaWxkKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuSFRNTEVsZW1lbnQucHJvdG90eXBlLmRvbUFwcGVuZENoaWxkID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgbm9kZSA9IGVsZW07XG4gICAgaWYgKHR5cGVvZiBub2RlID09PSAnc3RyaW5nJykge1xuICAgICAgICBub2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobm9kZSk7XG4gICAgfVxuICAgIHRoaXMuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5IVE1MRWxlbWVudC5wcm90b3R5cGUuZG9tQ2hpbGRUYWdzID0gZnVuY3Rpb24gKHRhZykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB0YWdzID0gW107XG4gICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHRhZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICB0YWdzLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGFncztcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwiLypcbiAqIGV4aXRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jb3dib3kvbm9kZS1leGl0XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzIFwiQ293Ym95XCIgQmVuIEFsbWFuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4aXQoZXhpdENvZGUsIHN0cmVhbXMpIHtcbiAgaWYgKCFzdHJlYW1zKSB7IHN0cmVhbXMgPSBbcHJvY2Vzcy5zdGRvdXQsIHByb2Nlc3Muc3RkZXJyXTsgfVxuICB2YXIgZHJhaW5Db3VudCA9IDA7XG4gIC8vIEFjdHVhbGx5IGV4aXQgaWYgYWxsIHN0cmVhbXMgYXJlIGRyYWluZWQuXG4gIGZ1bmN0aW9uIHRyeVRvRXhpdCgpIHtcbiAgICBpZiAoZHJhaW5Db3VudCA9PT0gc3RyZWFtcy5sZW5ndGgpIHtcbiAgICAgIHByb2Nlc3MuZXhpdChleGl0Q29kZSk7XG4gICAgfVxuICB9XG4gIHN0cmVhbXMuZm9yRWFjaChmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAvLyBDb3VudCBkcmFpbmVkIHN0cmVhbXMgbm93LCBidXQgbW9uaXRvciBub24tZHJhaW5lZCBzdHJlYW1zLlxuICAgIGlmIChzdHJlYW0uYnVmZmVyU2l6ZSA9PT0gMCkge1xuICAgICAgZHJhaW5Db3VudCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0ud3JpdGUoJycsICd1dGYtOCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBkcmFpbkNvdW50Kys7XG4gICAgICAgIHRyeVRvRXhpdCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFByZXZlbnQgZnVydGhlciB3cml0aW5nLlxuICAgIHN0cmVhbS53cml0ZSA9IGZ1bmN0aW9uKCkge307XG4gIH0pO1xuICAvLyBJZiBhbGwgc3RyZWFtcyB3ZXJlIGFscmVhZHkgZHJhaW5lZCwgZXhpdCBub3cuXG4gIHRyeVRvRXhpdCgpO1xuICAvLyBJbiBXaW5kb3dzLCB3aGVuIHJ1biBhcyBhIE5vZGUuanMgY2hpbGQgcHJvY2VzcywgYSBzY3JpcHQgdXRpbGl6aW5nXG4gIC8vIHRoaXMgbGlicmFyeSBtaWdodCBqdXN0IGV4aXQgd2l0aCBhIDAgZXhpdCBjb2RlLCByZWdhcmRsZXNzLiBUaGlzIGNvZGUsXG4gIC8vIGRlc3BpdGUgdGhlIGZhY3QgdGhhdCBpdCBsb29rcyBhIGJpdCBjcmF6eSwgYXBwZWFycyB0byBmaXggdGhhdC5cbiAgcHJvY2Vzcy5vbignZXhpdCcsIGZ1bmN0aW9uKCkge1xuICAgIHByb2Nlc3MuZXhpdChleGl0Q29kZSk7XG4gIH0pO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVhbHBhdGhcbnJlYWxwYXRoLnJlYWxwYXRoID0gcmVhbHBhdGhcbnJlYWxwYXRoLnN5bmMgPSByZWFscGF0aFN5bmNcbnJlYWxwYXRoLnJlYWxwYXRoU3luYyA9IHJlYWxwYXRoU3luY1xucmVhbHBhdGgubW9ua2V5cGF0Y2ggPSBtb25rZXlwYXRjaFxucmVhbHBhdGgudW5tb25rZXlwYXRjaCA9IHVubW9ua2V5cGF0Y2hcblxudmFyIGZzID0gcmVxdWlyZSgnZnMnKVxudmFyIG9yaWdSZWFscGF0aCA9IGZzLnJlYWxwYXRoXG52YXIgb3JpZ1JlYWxwYXRoU3luYyA9IGZzLnJlYWxwYXRoU3luY1xuXG52YXIgdmVyc2lvbiA9IHByb2Nlc3MudmVyc2lvblxudmFyIG9rID0gL152WzAtNV1cXC4vLnRlc3QodmVyc2lvbilcbnZhciBvbGQgPSByZXF1aXJlKCcuL29sZC5qcycpXG5cbmZ1bmN0aW9uIG5ld0Vycm9yIChlcikge1xuICByZXR1cm4gZXIgJiYgZXIuc3lzY2FsbCA9PT0gJ3JlYWxwYXRoJyAmJiAoXG4gICAgZXIuY29kZSA9PT0gJ0VMT09QJyB8fFxuICAgIGVyLmNvZGUgPT09ICdFTk9NRU0nIHx8XG4gICAgZXIuY29kZSA9PT0gJ0VOQU1FVE9PTE9ORydcbiAgKVxufVxuXG5mdW5jdGlvbiByZWFscGF0aCAocCwgY2FjaGUsIGNiKSB7XG4gIGlmIChvaykge1xuICAgIHJldHVybiBvcmlnUmVhbHBhdGgocCwgY2FjaGUsIGNiKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjYWNoZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2FjaGVcbiAgICBjYWNoZSA9IG51bGxcbiAgfVxuICBvcmlnUmVhbHBhdGgocCwgY2FjaGUsIGZ1bmN0aW9uIChlciwgcmVzdWx0KSB7XG4gICAgaWYgKG5ld0Vycm9yKGVyKSkge1xuICAgICAgb2xkLnJlYWxwYXRoKHAsIGNhY2hlLCBjYilcbiAgICB9IGVsc2Uge1xuICAgICAgY2IoZXIsIHJlc3VsdClcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJlYWxwYXRoU3luYyAocCwgY2FjaGUpIHtcbiAgaWYgKG9rKSB7XG4gICAgcmV0dXJuIG9yaWdSZWFscGF0aFN5bmMocCwgY2FjaGUpXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBvcmlnUmVhbHBhdGhTeW5jKHAsIGNhY2hlKVxuICB9IGNhdGNoIChlcikge1xuICAgIGlmIChuZXdFcnJvcihlcikpIHtcbiAgICAgIHJldHVybiBvbGQucmVhbHBhdGhTeW5jKHAsIGNhY2hlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlclxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtb25rZXlwYXRjaCAoKSB7XG4gIGZzLnJlYWxwYXRoID0gcmVhbHBhdGhcbiAgZnMucmVhbHBhdGhTeW5jID0gcmVhbHBhdGhTeW5jXG59XG5cbmZ1bmN0aW9uIHVubW9ua2V5cGF0Y2ggKCkge1xuICBmcy5yZWFscGF0aCA9IG9yaWdSZWFscGF0aFxuICBmcy5yZWFscGF0aFN5bmMgPSBvcmlnUmVhbHBhdGhTeW5jXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHBhdGhNb2R1bGUgPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgaXNXaW5kb3dzID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJztcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cbi8vIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgcmVhbHBhdGgsIHBvcnRlZCBmcm9tIG5vZGUgcHJlLXY2XG5cbnZhciBERUJVRyA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgJiYgL2ZzLy50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcpO1xuXG5mdW5jdGlvbiByZXRocm93KCkge1xuICAvLyBPbmx5IGVuYWJsZSBpbiBkZWJ1ZyBtb2RlLiBBIGJhY2t0cmFjZSB1c2VzIH4xMDAwIGJ5dGVzIG9mIGhlYXAgc3BhY2UgYW5kXG4gIC8vIGlzIGZhaXJseSBzbG93IHRvIGdlbmVyYXRlLlxuICB2YXIgY2FsbGJhY2s7XG4gIGlmIChERUJVRykge1xuICAgIHZhciBiYWNrdHJhY2UgPSBuZXcgRXJyb3I7XG4gICAgY2FsbGJhY2sgPSBkZWJ1Z0NhbGxiYWNrO1xuICB9IGVsc2VcbiAgICBjYWxsYmFjayA9IG1pc3NpbmdDYWxsYmFjaztcblxuICByZXR1cm4gY2FsbGJhY2s7XG5cbiAgZnVuY3Rpb24gZGVidWdDYWxsYmFjayhlcnIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBiYWNrdHJhY2UubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgICAgZXJyID0gYmFja3RyYWNlO1xuICAgICAgbWlzc2luZ0NhbGxiYWNrKGVycik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWlzc2luZ0NhbGxiYWNrKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pXG4gICAgICAgIHRocm93IGVycjsgIC8vIEZvcmdvdCBhIGNhbGxiYWNrIGJ1dCBkb24ndCBrbm93IHdoZXJlPyBVc2UgTk9ERV9ERUJVRz1mc1xuICAgICAgZWxzZSBpZiAoIXByb2Nlc3Mubm9EZXByZWNhdGlvbikge1xuICAgICAgICB2YXIgbXNnID0gJ2ZzOiBtaXNzaW5nIGNhbGxiYWNrICcgKyAoZXJyLnN0YWNrIHx8IGVyci5tZXNzYWdlKTtcbiAgICAgICAgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbilcbiAgICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlQ2FsbGJhY2soY2IpIHtcbiAgcmV0dXJuIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJyA/IGNiIDogcmV0aHJvdygpO1xufVxuXG52YXIgbm9ybWFsaXplID0gcGF0aE1vZHVsZS5ub3JtYWxpemU7XG5cbi8vIFJlZ2V4cCB0aGF0IGZpbmRzIHRoZSBuZXh0IHBhcnRpb24gb2YgYSAocGFydGlhbCkgcGF0aFxuLy8gcmVzdWx0IGlzIFtiYXNlX3dpdGhfc2xhc2gsIGJhc2VdLCBlLmcuIFsnc29tZWRpci8nLCAnc29tZWRpciddXG5pZiAoaXNXaW5kb3dzKSB7XG4gIHZhciBuZXh0UGFydFJlID0gLyguKj8pKD86W1xcL1xcXFxdK3wkKS9nO1xufSBlbHNlIHtcbiAgdmFyIG5leHRQYXJ0UmUgPSAvKC4qPykoPzpbXFwvXSt8JCkvZztcbn1cblxuLy8gUmVnZXggdG8gZmluZCB0aGUgZGV2aWNlIHJvb3QsIGluY2x1ZGluZyB0cmFpbGluZyBzbGFzaC4gRS5nLiAnYzpcXFxcJy5cbmlmIChpc1dpbmRvd3MpIHtcbiAgdmFyIHNwbGl0Um9vdFJlID0gL14oPzpbYS16QS1aXTp8W1xcXFxcXC9dezJ9W15cXFxcXFwvXStbXFxcXFxcL11bXlxcXFxcXC9dKyk/W1xcXFxcXC9dKi87XG59IGVsc2Uge1xuICB2YXIgc3BsaXRSb290UmUgPSAvXltcXC9dKi87XG59XG5cbmV4cG9ydHMucmVhbHBhdGhTeW5jID0gZnVuY3Rpb24gcmVhbHBhdGhTeW5jKHAsIGNhY2hlKSB7XG4gIC8vIG1ha2UgcCBpcyBhYnNvbHV0ZVxuICBwID0gcGF0aE1vZHVsZS5yZXNvbHZlKHApO1xuXG4gIGlmIChjYWNoZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2FjaGUsIHApKSB7XG4gICAgcmV0dXJuIGNhY2hlW3BdO1xuICB9XG5cbiAgdmFyIG9yaWdpbmFsID0gcCxcbiAgICAgIHNlZW5MaW5rcyA9IHt9LFxuICAgICAga25vd25IYXJkID0ge307XG5cbiAgLy8gY3VycmVudCBjaGFyYWN0ZXIgcG9zaXRpb24gaW4gcFxuICB2YXIgcG9zO1xuICAvLyB0aGUgcGFydGlhbCBwYXRoIHNvIGZhciwgaW5jbHVkaW5nIGEgdHJhaWxpbmcgc2xhc2ggaWYgYW55XG4gIHZhciBjdXJyZW50O1xuICAvLyB0aGUgcGFydGlhbCBwYXRoIHdpdGhvdXQgYSB0cmFpbGluZyBzbGFzaCAoZXhjZXB0IHdoZW4gcG9pbnRpbmcgYXQgYSByb290KVxuICB2YXIgYmFzZTtcbiAgLy8gdGhlIHBhcnRpYWwgcGF0aCBzY2FubmVkIGluIHRoZSBwcmV2aW91cyByb3VuZCwgd2l0aCBzbGFzaFxuICB2YXIgcHJldmlvdXM7XG5cbiAgc3RhcnQoKTtcblxuICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAvLyBTa2lwIG92ZXIgcm9vdHNcbiAgICB2YXIgbSA9IHNwbGl0Um9vdFJlLmV4ZWMocCk7XG4gICAgcG9zID0gbVswXS5sZW5ndGg7XG4gICAgY3VycmVudCA9IG1bMF07XG4gICAgYmFzZSA9IG1bMF07XG4gICAgcHJldmlvdXMgPSAnJztcblxuICAgIC8vIE9uIHdpbmRvd3MsIGNoZWNrIHRoYXQgdGhlIHJvb3QgZXhpc3RzLiBPbiB1bml4IHRoZXJlIGlzIG5vIG5lZWQuXG4gICAgaWYgKGlzV2luZG93cyAmJiAha25vd25IYXJkW2Jhc2VdKSB7XG4gICAgICBmcy5sc3RhdFN5bmMoYmFzZSk7XG4gICAgICBrbm93bkhhcmRbYmFzZV0gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIHdhbGsgZG93biB0aGUgcGF0aCwgc3dhcHBpbmcgb3V0IGxpbmtlZCBwYXRocGFydHMgZm9yIHRoZWlyIHJlYWxcbiAgLy8gdmFsdWVzXG4gIC8vIE5COiBwLmxlbmd0aCBjaGFuZ2VzLlxuICB3aGlsZSAocG9zIDwgcC5sZW5ndGgpIHtcbiAgICAvLyBmaW5kIHRoZSBuZXh0IHBhcnRcbiAgICBuZXh0UGFydFJlLmxhc3RJbmRleCA9IHBvcztcbiAgICB2YXIgcmVzdWx0ID0gbmV4dFBhcnRSZS5leGVjKHApO1xuICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICBjdXJyZW50ICs9IHJlc3VsdFswXTtcbiAgICBiYXNlID0gcHJldmlvdXMgKyByZXN1bHRbMV07XG4gICAgcG9zID0gbmV4dFBhcnRSZS5sYXN0SW5kZXg7XG5cbiAgICAvLyBjb250aW51ZSBpZiBub3QgYSBzeW1saW5rXG4gICAgaWYgKGtub3duSGFyZFtiYXNlXSB8fCAoY2FjaGUgJiYgY2FjaGVbYmFzZV0gPT09IGJhc2UpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgcmVzb2x2ZWRMaW5rO1xuICAgIGlmIChjYWNoZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2FjaGUsIGJhc2UpKSB7XG4gICAgICAvLyBzb21lIGtub3duIHN5bWJvbGljIGxpbmsuICBubyBuZWVkIHRvIHN0YXQgYWdhaW4uXG4gICAgICByZXNvbHZlZExpbmsgPSBjYWNoZVtiYXNlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXQgPSBmcy5sc3RhdFN5bmMoYmFzZSk7XG4gICAgICBpZiAoIXN0YXQuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICBrbm93bkhhcmRbYmFzZV0gPSB0cnVlO1xuICAgICAgICBpZiAoY2FjaGUpIGNhY2hlW2Jhc2VdID0gYmFzZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlYWQgdGhlIGxpbmsgaWYgaXQgd2Fzbid0IHJlYWQgYmVmb3JlXG4gICAgICAvLyBkZXYvaW5vIGFsd2F5cyByZXR1cm4gMCBvbiB3aW5kb3dzLCBzbyBza2lwIHRoZSBjaGVjay5cbiAgICAgIHZhciBsaW5rVGFyZ2V0ID0gbnVsbDtcbiAgICAgIGlmICghaXNXaW5kb3dzKSB7XG4gICAgICAgIHZhciBpZCA9IHN0YXQuZGV2LnRvU3RyaW5nKDMyKSArICc6JyArIHN0YXQuaW5vLnRvU3RyaW5nKDMyKTtcbiAgICAgICAgaWYgKHNlZW5MaW5rcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICBsaW5rVGFyZ2V0ID0gc2VlbkxpbmtzW2lkXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxpbmtUYXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgZnMuc3RhdFN5bmMoYmFzZSk7XG4gICAgICAgIGxpbmtUYXJnZXQgPSBmcy5yZWFkbGlua1N5bmMoYmFzZSk7XG4gICAgICB9XG4gICAgICByZXNvbHZlZExpbmsgPSBwYXRoTW9kdWxlLnJlc29sdmUocHJldmlvdXMsIGxpbmtUYXJnZXQpO1xuICAgICAgLy8gdHJhY2sgdGhpcywgaWYgZ2l2ZW4gYSBjYWNoZS5cbiAgICAgIGlmIChjYWNoZSkgY2FjaGVbYmFzZV0gPSByZXNvbHZlZExpbms7XG4gICAgICBpZiAoIWlzV2luZG93cykgc2VlbkxpbmtzW2lkXSA9IGxpbmtUYXJnZXQ7XG4gICAgfVxuXG4gICAgLy8gcmVzb2x2ZSB0aGUgbGluaywgdGhlbiBzdGFydCBvdmVyXG4gICAgcCA9IHBhdGhNb2R1bGUucmVzb2x2ZShyZXNvbHZlZExpbmssIHAuc2xpY2UocG9zKSk7XG4gICAgc3RhcnQoKTtcbiAgfVxuXG4gIGlmIChjYWNoZSkgY2FjaGVbb3JpZ2luYWxdID0gcDtcblxuICByZXR1cm4gcDtcbn07XG5cblxuZXhwb3J0cy5yZWFscGF0aCA9IGZ1bmN0aW9uIHJlYWxwYXRoKHAsIGNhY2hlLCBjYikge1xuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBtYXliZUNhbGxiYWNrKGNhY2hlKTtcbiAgICBjYWNoZSA9IG51bGw7XG4gIH1cblxuICAvLyBtYWtlIHAgaXMgYWJzb2x1dGVcbiAgcCA9IHBhdGhNb2R1bGUucmVzb2x2ZShwKTtcblxuICBpZiAoY2FjaGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNhY2hlLCBwKSkge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGNiLmJpbmQobnVsbCwgbnVsbCwgY2FjaGVbcF0pKTtcbiAgfVxuXG4gIHZhciBvcmlnaW5hbCA9IHAsXG4gICAgICBzZWVuTGlua3MgPSB7fSxcbiAgICAgIGtub3duSGFyZCA9IHt9O1xuXG4gIC8vIGN1cnJlbnQgY2hhcmFjdGVyIHBvc2l0aW9uIGluIHBcbiAgdmFyIHBvcztcbiAgLy8gdGhlIHBhcnRpYWwgcGF0aCBzbyBmYXIsIGluY2x1ZGluZyBhIHRyYWlsaW5nIHNsYXNoIGlmIGFueVxuICB2YXIgY3VycmVudDtcbiAgLy8gdGhlIHBhcnRpYWwgcGF0aCB3aXRob3V0IGEgdHJhaWxpbmcgc2xhc2ggKGV4Y2VwdCB3aGVuIHBvaW50aW5nIGF0IGEgcm9vdClcbiAgdmFyIGJhc2U7XG4gIC8vIHRoZSBwYXJ0aWFsIHBhdGggc2Nhbm5lZCBpbiB0aGUgcHJldmlvdXMgcm91bmQsIHdpdGggc2xhc2hcbiAgdmFyIHByZXZpb3VzO1xuXG4gIHN0YXJ0KCk7XG5cbiAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgLy8gU2tpcCBvdmVyIHJvb3RzXG4gICAgdmFyIG0gPSBzcGxpdFJvb3RSZS5leGVjKHApO1xuICAgIHBvcyA9IG1bMF0ubGVuZ3RoO1xuICAgIGN1cnJlbnQgPSBtWzBdO1xuICAgIGJhc2UgPSBtWzBdO1xuICAgIHByZXZpb3VzID0gJyc7XG5cbiAgICAvLyBPbiB3aW5kb3dzLCBjaGVjayB0aGF0IHRoZSByb290IGV4aXN0cy4gT24gdW5peCB0aGVyZSBpcyBubyBuZWVkLlxuICAgIGlmIChpc1dpbmRvd3MgJiYgIWtub3duSGFyZFtiYXNlXSkge1xuICAgICAgZnMubHN0YXQoYmFzZSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuICAgICAgICBrbm93bkhhcmRbYmFzZV0gPSB0cnVlO1xuICAgICAgICBMT09QKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhMT09QKTtcbiAgICB9XG4gIH1cblxuICAvLyB3YWxrIGRvd24gdGhlIHBhdGgsIHN3YXBwaW5nIG91dCBsaW5rZWQgcGF0aHBhcnRzIGZvciB0aGVpciByZWFsXG4gIC8vIHZhbHVlc1xuICBmdW5jdGlvbiBMT09QKCkge1xuICAgIC8vIHN0b3AgaWYgc2Nhbm5lZCBwYXN0IGVuZCBvZiBwYXRoXG4gICAgaWYgKHBvcyA+PSBwLmxlbmd0aCkge1xuICAgICAgaWYgKGNhY2hlKSBjYWNoZVtvcmlnaW5hbF0gPSBwO1xuICAgICAgcmV0dXJuIGNiKG51bGwsIHApO1xuICAgIH1cblxuICAgIC8vIGZpbmQgdGhlIG5leHQgcGFydFxuICAgIG5leHRQYXJ0UmUubGFzdEluZGV4ID0gcG9zO1xuICAgIHZhciByZXN1bHQgPSBuZXh0UGFydFJlLmV4ZWMocCk7XG4gICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgIGN1cnJlbnQgKz0gcmVzdWx0WzBdO1xuICAgIGJhc2UgPSBwcmV2aW91cyArIHJlc3VsdFsxXTtcbiAgICBwb3MgPSBuZXh0UGFydFJlLmxhc3RJbmRleDtcblxuICAgIC8vIGNvbnRpbnVlIGlmIG5vdCBhIHN5bWxpbmtcbiAgICBpZiAoa25vd25IYXJkW2Jhc2VdIHx8IChjYWNoZSAmJiBjYWNoZVtiYXNlXSA9PT0gYmFzZSkpIHtcbiAgICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKExPT1ApO1xuICAgIH1cblxuICAgIGlmIChjYWNoZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2FjaGUsIGJhc2UpKSB7XG4gICAgICAvLyBrbm93biBzeW1ib2xpYyBsaW5rLiAgbm8gbmVlZCB0byBzdGF0IGFnYWluLlxuICAgICAgcmV0dXJuIGdvdFJlc29sdmVkTGluayhjYWNoZVtiYXNlXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZzLmxzdGF0KGJhc2UsIGdvdFN0YXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ290U3RhdChlcnIsIHN0YXQpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgIC8vIGlmIG5vdCBhIHN5bWxpbmssIHNraXAgdG8gdGhlIG5leHQgcGF0aCBwYXJ0XG4gICAgaWYgKCFzdGF0LmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgIGtub3duSGFyZFtiYXNlXSA9IHRydWU7XG4gICAgICBpZiAoY2FjaGUpIGNhY2hlW2Jhc2VdID0gYmFzZTtcbiAgICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKExPT1ApO1xuICAgIH1cblxuICAgIC8vIHN0YXQgJiByZWFkIHRoZSBsaW5rIGlmIG5vdCByZWFkIGJlZm9yZVxuICAgIC8vIGNhbGwgZ290VGFyZ2V0IGFzIHNvb24gYXMgdGhlIGxpbmsgdGFyZ2V0IGlzIGtub3duXG4gICAgLy8gZGV2L2lubyBhbHdheXMgcmV0dXJuIDAgb24gd2luZG93cywgc28gc2tpcCB0aGUgY2hlY2suXG4gICAgaWYgKCFpc1dpbmRvd3MpIHtcbiAgICAgIHZhciBpZCA9IHN0YXQuZGV2LnRvU3RyaW5nKDMyKSArICc6JyArIHN0YXQuaW5vLnRvU3RyaW5nKDMyKTtcbiAgICAgIGlmIChzZWVuTGlua3MuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgIHJldHVybiBnb3RUYXJnZXQobnVsbCwgc2VlbkxpbmtzW2lkXSwgYmFzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZzLnN0YXQoYmFzZSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgICAgZnMucmVhZGxpbmsoYmFzZSwgZnVuY3Rpb24oZXJyLCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKCFpc1dpbmRvd3MpIHNlZW5MaW5rc1tpZF0gPSB0YXJnZXQ7XG4gICAgICAgIGdvdFRhcmdldChlcnIsIHRhcmdldCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvdFRhcmdldChlcnIsIHRhcmdldCwgYmFzZSkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgdmFyIHJlc29sdmVkTGluayA9IHBhdGhNb2R1bGUucmVzb2x2ZShwcmV2aW91cywgdGFyZ2V0KTtcbiAgICBpZiAoY2FjaGUpIGNhY2hlW2Jhc2VdID0gcmVzb2x2ZWRMaW5rO1xuICAgIGdvdFJlc29sdmVkTGluayhyZXNvbHZlZExpbmspO1xuICB9XG5cbiAgZnVuY3Rpb24gZ290UmVzb2x2ZWRMaW5rKHJlc29sdmVkTGluaykge1xuICAgIC8vIHJlc29sdmUgdGhlIGxpbmssIHRoZW4gc3RhcnQgb3ZlclxuICAgIHAgPSBwYXRoTW9kdWxlLnJlc29sdmUocmVzb2x2ZWRMaW5rLCBwLnNsaWNlKHBvcykpO1xuICAgIHN0YXJ0KCk7XG4gIH1cbn07XG4iLCIvKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwidmFyIHdyYXBweSA9IHJlcXVpcmUoJ3dyYXBweScpXG52YXIgcmVxcyA9IE9iamVjdC5jcmVhdGUobnVsbClcbnZhciBvbmNlID0gcmVxdWlyZSgnb25jZScpXG5cbm1vZHVsZS5leHBvcnRzID0gd3JhcHB5KGluZmxpZ2h0KVxuXG5mdW5jdGlvbiBpbmZsaWdodCAoa2V5LCBjYikge1xuICBpZiAocmVxc1trZXldKSB7XG4gICAgcmVxc1trZXldLnB1c2goY2IpXG4gICAgcmV0dXJuIG51bGxcbiAgfSBlbHNlIHtcbiAgICByZXFzW2tleV0gPSBbY2JdXG4gICAgcmV0dXJuIG1ha2VyZXMoa2V5KVxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VyZXMgKGtleSkge1xuICByZXR1cm4gb25jZShmdW5jdGlvbiBSRVMgKCkge1xuICAgIHZhciBjYnMgPSByZXFzW2tleV1cbiAgICB2YXIgbGVuID0gY2JzLmxlbmd0aFxuICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzKVxuXG4gICAgLy8gWFhYIEl0J3Mgc29tZXdoYXQgYW1iaWd1b3VzIHdoZXRoZXIgYSBuZXcgY2FsbGJhY2sgYWRkZWQgaW4gdGhpc1xuICAgIC8vIHBhc3Mgc2hvdWxkIGJlIHF1ZXVlZCBmb3IgbGF0ZXIgZXhlY3V0aW9uIGlmIHNvbWV0aGluZyBpbiB0aGVcbiAgICAvLyBsaXN0IG9mIGNhbGxiYWNrcyB0aHJvd3MsIG9yIGlmIGl0IHNob3VsZCBqdXN0IGJlIGRpc2NhcmRlZC5cbiAgICAvLyBIb3dldmVyLCBpdCdzIHN1Y2ggYW4gZWRnZSBjYXNlIHRoYXQgaXQgaGFyZGx5IG1hdHRlcnMsIGFuZCBlaXRoZXJcbiAgICAvLyBjaG9pY2UgaXMgbGlrZWx5IGFzIHN1cnByaXNpbmcgYXMgdGhlIG90aGVyLlxuICAgIC8vIEFzIGl0IGhhcHBlbnMsIHdlIGRvIGdvIGFoZWFkIGFuZCBzY2hlZHVsZSBpdCBmb3IgbGF0ZXIgZXhlY3V0aW9uLlxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNic1tpXS5hcHBseShudWxsLCBhcmdzKVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoY2JzLmxlbmd0aCA+IGxlbikge1xuICAgICAgICAvLyBhZGRlZCBtb3JlIGluIHRoZSBpbnRlcmltLlxuICAgICAgICAvLyBkZS16YWxnbywganVzdCBpbiBjYXNlLCBidXQgZG9uJ3QgY2FsbCBhZ2Fpbi5cbiAgICAgICAgY2JzLnNwbGljZSgwLCBsZW4pXG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIFJFUy5hcHBseShudWxsLCBhcmdzKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHJlcXNba2V5XVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gc2xpY2UgKGFyZ3MpIHtcbiAgdmFyIGxlbmd0aCA9IGFyZ3MubGVuZ3RoXG4gIHZhciBhcnJheSA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgYXJyYXlbaV0gPSBhcmdzW2ldXG4gIHJldHVybiBhcnJheVxufVxuIiwiLyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDA4LTIwMTggUGl2b3RhbCBMYWJzXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG5cIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbndpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbmRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG50aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG5pbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbkVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbk5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkVcbkxJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cbk9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuZnVuY3Rpb24gZ2V0SmFzbWluZVJlcXVpcmVPYmooKSB7XG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5qYXNtaW5lUmVxdWlyZSA9IHdpbmRvdy5qYXNtaW5lUmVxdWlyZSB8fCB7fTtcbiAgICByZXR1cm4gd2luZG93Lmphc21pbmVSZXF1aXJlO1xuICB9XG59XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuY29uc29sZSA9IGZ1bmN0aW9uKGpSZXF1aXJlLCBqJCkge1xuICBqJC5Db25zb2xlUmVwb3J0ZXIgPSBqUmVxdWlyZS5Db25zb2xlUmVwb3J0ZXIoKTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuQ29uc29sZVJlcG9ydGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIG5vb3BUaW1lciA9IHtcbiAgICBzdGFydDogZnVuY3Rpb24oKXt9LFxuICAgIGVsYXBzZWQ6IGZ1bmN0aW9uKCl7IHJldHVybiAwOyB9XG4gIH07XG5cbiAgZnVuY3Rpb24gQ29uc29sZVJlcG9ydGVyKG9wdGlvbnMpIHtcbiAgICB2YXIgcHJpbnQgPSBvcHRpb25zLnByaW50LFxuICAgICAgc2hvd0NvbG9ycyA9IG9wdGlvbnMuc2hvd0NvbG9ycyB8fCBmYWxzZSxcbiAgICAgIG9uQ29tcGxldGUgPSBvcHRpb25zLm9uQ29tcGxldGUgfHwgZnVuY3Rpb24oKSB7fSxcbiAgICAgIHRpbWVyID0gb3B0aW9ucy50aW1lciB8fCBub29wVGltZXIsXG4gICAgICBzcGVjQ291bnQsXG4gICAgICBmYWlsdXJlQ291bnQsXG4gICAgICBmYWlsZWRTcGVjcyA9IFtdLFxuICAgICAgcGVuZGluZ0NvdW50LFxuICAgICAgYW5zaSA9IHtcbiAgICAgICAgZ3JlZW46ICdcXHgxQlszMm0nLFxuICAgICAgICByZWQ6ICdcXHgxQlszMW0nLFxuICAgICAgICB5ZWxsb3c6ICdcXHgxQlszM20nLFxuICAgICAgICBub25lOiAnXFx4MUJbMG0nXG4gICAgICB9LFxuICAgICAgZmFpbGVkU3VpdGVzID0gW107XG5cbiAgICBwcmludCgnQ29uc29sZVJlcG9ydGVyIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLicpO1xuXG4gICAgdGhpcy5qYXNtaW5lU3RhcnRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgc3BlY0NvdW50ID0gMDtcbiAgICAgIGZhaWx1cmVDb3VudCA9IDA7XG4gICAgICBwZW5kaW5nQ291bnQgPSAwO1xuICAgICAgcHJpbnQoJ1N0YXJ0ZWQnKTtcbiAgICAgIHByaW50TmV3bGluZSgpO1xuICAgICAgdGltZXIuc3RhcnQoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5qYXNtaW5lRG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcHJpbnROZXdsaW5lKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZhaWxlZFNwZWNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNwZWNGYWlsdXJlRGV0YWlscyhmYWlsZWRTcGVjc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIGlmKHNwZWNDb3VudCA+IDApIHtcbiAgICAgICAgcHJpbnROZXdsaW5lKCk7XG5cbiAgICAgICAgdmFyIHNwZWNDb3VudHMgPSBzcGVjQ291bnQgKyAnICcgKyBwbHVyYWwoJ3NwZWMnLCBzcGVjQ291bnQpICsgJywgJyArXG4gICAgICAgICAgZmFpbHVyZUNvdW50ICsgJyAnICsgcGx1cmFsKCdmYWlsdXJlJywgZmFpbHVyZUNvdW50KTtcblxuICAgICAgICBpZiAocGVuZGluZ0NvdW50KSB7XG4gICAgICAgICAgc3BlY0NvdW50cyArPSAnLCAnICsgcGVuZGluZ0NvdW50ICsgJyBwZW5kaW5nICcgKyBwbHVyYWwoJ3NwZWMnLCBwZW5kaW5nQ291bnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJpbnQoc3BlY0NvdW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmludCgnTm8gc3BlY3MgZm91bmQnKTtcbiAgICAgIH1cblxuICAgICAgcHJpbnROZXdsaW5lKCk7XG4gICAgICB2YXIgc2Vjb25kcyA9IHRpbWVyLmVsYXBzZWQoKSAvIDEwMDA7XG4gICAgICBwcmludCgnRmluaXNoZWQgaW4gJyArIHNlY29uZHMgKyAnICcgKyBwbHVyYWwoJ3NlY29uZCcsIHNlY29uZHMpKTtcbiAgICAgIHByaW50TmV3bGluZSgpO1xuXG4gICAgICBmb3IoaSA9IDA7IGkgPCBmYWlsZWRTdWl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VpdGVGYWlsdXJlRGV0YWlscyhmYWlsZWRTdWl0ZXNbaV0pO1xuICAgICAgfVxuXG4gICAgICBvbkNvbXBsZXRlKGZhaWx1cmVDb3VudCA9PT0gMCk7XG4gICAgfTtcblxuICAgIHRoaXMuc3BlY0RvbmUgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIHNwZWNDb3VudCsrO1xuXG4gICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PSAncGVuZGluZycpIHtcbiAgICAgICAgcGVuZGluZ0NvdW50Kys7XG4gICAgICAgIHByaW50KGNvbG9yZWQoJ3llbGxvdycsICcqJykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09ICdwYXNzZWQnKSB7XG4gICAgICAgIHByaW50KGNvbG9yZWQoJ2dyZWVuJywgJy4nKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgZmFpbHVyZUNvdW50Kys7XG4gICAgICAgIGZhaWxlZFNwZWNzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgcHJpbnQoY29sb3JlZCgncmVkJywgJ0YnKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuc3VpdGVEb25lID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICBpZiAocmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucyAmJiByZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZmFpbHVyZUNvdW50Kys7XG4gICAgICAgIGZhaWxlZFN1aXRlcy5wdXNoKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gICAgZnVuY3Rpb24gcHJpbnROZXdsaW5lKCkge1xuICAgICAgcHJpbnQoJ1xcbicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbG9yZWQoY29sb3IsIHN0cikge1xuICAgICAgcmV0dXJuIHNob3dDb2xvcnMgPyAoYW5zaVtjb2xvcl0gKyBzdHIgKyBhbnNpLm5vbmUpIDogc3RyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBsdXJhbChzdHIsIGNvdW50KSB7XG4gICAgICByZXR1cm4gY291bnQgPT0gMSA/IHN0ciA6IHN0ciArICdzJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXBlYXQodGhpbmcsIHRpbWVzKSB7XG4gICAgICB2YXIgYXJyID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbWVzOyBpKyspIHtcbiAgICAgICAgYXJyLnB1c2godGhpbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbmRlbnQoc3RyLCBzcGFjZXMpIHtcbiAgICAgIHZhciBsaW5lcyA9IChzdHIgfHwgJycpLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBuZXdBcnIgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3QXJyLnB1c2gocmVwZWF0KCcgJywgc3BhY2VzKS5qb2luKCcnKSArIGxpbmVzW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdBcnIuam9pbignXFxuJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3BlY0ZhaWx1cmVEZXRhaWxzKHJlc3VsdCkge1xuICAgICAgcHJpbnROZXdsaW5lKCk7XG4gICAgICBwcmludChyZXN1bHQuZnVsbE5hbWUpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZhaWxlZEV4cGVjdGF0aW9uID0gcmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9uc1tpXTtcbiAgICAgICAgcHJpbnROZXdsaW5lKCk7XG4gICAgICAgIHByaW50KGluZGVudChmYWlsZWRFeHBlY3RhdGlvbi5tZXNzYWdlLCAyKSk7XG4gICAgICAgIHByaW50KGluZGVudChmYWlsZWRFeHBlY3RhdGlvbi5zdGFjaywgMikpO1xuICAgICAgfVxuXG4gICAgICBwcmludE5ld2xpbmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdWl0ZUZhaWx1cmVEZXRhaWxzKHJlc3VsdCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByaW50TmV3bGluZSgpO1xuICAgICAgICBwcmludChjb2xvcmVkKCdyZWQnLCAnQW4gZXJyb3Igd2FzIHRocm93biBpbiBhbiBhZnRlckFsbCcpKTtcbiAgICAgICAgcHJpbnROZXdsaW5lKCk7XG4gICAgICAgIHByaW50KGNvbG9yZWQoJ3JlZCcsICdBZnRlckFsbCAnICsgcmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9uc1tpXS5tZXNzYWdlKSk7XG5cbiAgICAgIH1cbiAgICAgIHByaW50TmV3bGluZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBDb25zb2xlUmVwb3J0ZXI7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9qYXNtaW5lLWNvcmUvamFzbWluZS5qc1wiKTtcbm1vZHVsZS5leHBvcnRzLmJvb3QgPSByZXF1aXJlKCcuL2phc21pbmUtY29yZS9ub2RlX2Jvb3QuanMnKTtcblxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyksXG4gICAgZnMgPSByZXF1aXJlKCdmcycpO1xuXG52YXIgcm9vdFBhdGggPSBwYXRoLmpvaW4oX19kaXJuYW1lLCBcImphc21pbmUtY29yZVwiKSxcbiAgICBib290RmlsZXMgPSBbJ2Jvb3QuanMnXSxcbiAgICBub2RlQm9vdEZpbGVzID0gWydub2RlX2Jvb3QuanMnXSxcbiAgICBjc3NGaWxlcyA9IFtdLFxuICAgIGpzRmlsZXMgPSBbXSxcbiAgICBqc0ZpbGVzVG9Ta2lwID0gWydqYXNtaW5lLmpzJ10uY29uY2F0KGJvb3RGaWxlcywgbm9kZUJvb3RGaWxlcyk7XG5cbmZzLnJlYWRkaXJTeW5jKHJvb3RQYXRoKS5mb3JFYWNoKGZ1bmN0aW9uKGZpbGUpIHtcbiAgaWYoZnMuc3RhdFN5bmMocGF0aC5qb2luKHJvb3RQYXRoLCBmaWxlKSkuaXNGaWxlKCkpIHtcbiAgICBzd2l0Y2gocGF0aC5leHRuYW1lKGZpbGUpKSB7XG4gICAgICBjYXNlICcuY3NzJzpcbiAgICAgICAgY3NzRmlsZXMucHVzaChmaWxlKTtcbiAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnLmpzJzpcbiAgICAgICAgaWYgKGpzRmlsZXNUb1NraXAuaW5kZXhPZihmaWxlKSA8IDApIHtcbiAgICAgICAganNGaWxlcy5wdXNoKGZpbGUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMuZmlsZXMgPSB7XG4gIHBhdGg6IHJvb3RQYXRoLFxuICBib290RGlyOiByb290UGF0aCxcbiAgYm9vdEZpbGVzOiBib290RmlsZXMsXG4gIG5vZGVCb290RmlsZXM6IG5vZGVCb290RmlsZXMsXG4gIGNzc0ZpbGVzOiBjc3NGaWxlcyxcbiAganNGaWxlczogWydqYXNtaW5lLmpzJ10uY29uY2F0KGpzRmlsZXMpLFxuICBpbWFnZXNEaXI6IHBhdGguam9pbihfX2Rpcm5hbWUsICcuLi9pbWFnZXMnKVxufTtcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMDgtMjAxOCBQaXZvdGFsIExhYnNcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG5hIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcblwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xud2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG5wZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbnRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG5NRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG5XSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG52YXIgZ2V0SmFzbWluZVJlcXVpcmVPYmogPSAoZnVuY3Rpb24gKGphc21pbmVHbG9iYWwpIHtcbiAgdmFyIGphc21pbmVSZXF1aXJlO1xuXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyAmJiB0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGphc21pbmVHbG9iYWwgPSBnbG9iYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGphc21pbmVHbG9iYWwgPSB7fTtcbiAgICB9XG4gICAgamFzbWluZVJlcXVpcmUgPSBleHBvcnRzO1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LnRvU3RyaW5nID09PSAnZnVuY3Rpb24nICYmIHdpbmRvdy50b1N0cmluZygpID09PSAnW29iamVjdCBHanNHbG9iYWxdJykge1xuICAgICAgamFzbWluZUdsb2JhbCA9IHdpbmRvdztcbiAgICB9XG4gICAgamFzbWluZVJlcXVpcmUgPSBqYXNtaW5lR2xvYmFsLmphc21pbmVSZXF1aXJlID0ge307XG4gIH1cblxuICBmdW5jdGlvbiBnZXRKYXNtaW5lUmVxdWlyZSgpIHtcbiAgICByZXR1cm4gamFzbWluZVJlcXVpcmU7XG4gIH1cblxuICBnZXRKYXNtaW5lUmVxdWlyZSgpLmNvcmUgPSBmdW5jdGlvbihqUmVxdWlyZSkge1xuICAgIHZhciBqJCA9IHt9O1xuXG4gICAgalJlcXVpcmUuYmFzZShqJCwgamFzbWluZUdsb2JhbCk7XG4gICAgaiQudXRpbCA9IGpSZXF1aXJlLnV0aWwoaiQpO1xuICAgIGokLmVycm9ycyA9IGpSZXF1aXJlLmVycm9ycygpO1xuICAgIGokLmZvcm1hdEVycm9yTXNnID0galJlcXVpcmUuZm9ybWF0RXJyb3JNc2coKTtcbiAgICBqJC5BbnkgPSBqUmVxdWlyZS5BbnkoaiQpO1xuICAgIGokLkFueXRoaW5nID0galJlcXVpcmUuQW55dGhpbmcoaiQpO1xuICAgIGokLkNhbGxUcmFja2VyID0galJlcXVpcmUuQ2FsbFRyYWNrZXIoaiQpO1xuICAgIGokLk1vY2tEYXRlID0galJlcXVpcmUuTW9ja0RhdGUoKTtcbiAgICBqJC5nZXRDbGVhclN0YWNrID0galJlcXVpcmUuY2xlYXJTdGFjayhqJCk7XG4gICAgaiQuQ2xvY2sgPSBqUmVxdWlyZS5DbG9jaygpO1xuICAgIGokLkRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlciA9IGpSZXF1aXJlLkRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlcihqJCk7XG4gICAgaiQuRW52ID0galJlcXVpcmUuRW52KGokKTtcbiAgICBqJC5FeGNlcHRpb25Gb3JtYXR0ZXIgPSBqUmVxdWlyZS5FeGNlcHRpb25Gb3JtYXR0ZXIoKTtcbiAgICBqJC5FeHBlY3RhdGlvbiA9IGpSZXF1aXJlLkV4cGVjdGF0aW9uKCk7XG4gICAgaiQuYnVpbGRFeHBlY3RhdGlvblJlc3VsdCA9IGpSZXF1aXJlLmJ1aWxkRXhwZWN0YXRpb25SZXN1bHQoKTtcbiAgICBqJC5Kc0FwaVJlcG9ydGVyID0galJlcXVpcmUuSnNBcGlSZXBvcnRlcigpO1xuICAgIGokLm1hdGNoZXJzVXRpbCA9IGpSZXF1aXJlLm1hdGNoZXJzVXRpbChqJCk7XG4gICAgaiQuT2JqZWN0Q29udGFpbmluZyA9IGpSZXF1aXJlLk9iamVjdENvbnRhaW5pbmcoaiQpO1xuICAgIGokLkFycmF5Q29udGFpbmluZyA9IGpSZXF1aXJlLkFycmF5Q29udGFpbmluZyhqJCk7XG4gICAgaiQuQXJyYXlXaXRoRXhhY3RDb250ZW50cyA9IGpSZXF1aXJlLkFycmF5V2l0aEV4YWN0Q29udGVudHMoaiQpO1xuICAgIGokLnBwID0galJlcXVpcmUucHAoaiQpO1xuICAgIGokLlF1ZXVlUnVubmVyID0galJlcXVpcmUuUXVldWVSdW5uZXIoaiQpO1xuICAgIGokLlJlcG9ydERpc3BhdGNoZXIgPSBqUmVxdWlyZS5SZXBvcnREaXNwYXRjaGVyKGokKTtcbiAgICBqJC5TcGVjID0galJlcXVpcmUuU3BlYyhqJCk7XG4gICAgaiQuU3B5ID0galJlcXVpcmUuU3B5KGokKTtcbiAgICBqJC5TcHlSZWdpc3RyeSA9IGpSZXF1aXJlLlNweVJlZ2lzdHJ5KGokKTtcbiAgICBqJC5TcHlTdHJhdGVneSA9IGpSZXF1aXJlLlNweVN0cmF0ZWd5KGokKTtcbiAgICBqJC5TdHJpbmdNYXRjaGluZyA9IGpSZXF1aXJlLlN0cmluZ01hdGNoaW5nKGokKTtcbiAgICBqJC5Vc2VyQ29udGV4dCA9IGpSZXF1aXJlLlVzZXJDb250ZXh0KGokKTtcbiAgICBqJC5TdWl0ZSA9IGpSZXF1aXJlLlN1aXRlKGokKTtcbiAgICBqJC5UaW1lciA9IGpSZXF1aXJlLlRpbWVyKCk7XG4gICAgaiQuVHJlZVByb2Nlc3NvciA9IGpSZXF1aXJlLlRyZWVQcm9jZXNzb3IoKTtcbiAgICBqJC52ZXJzaW9uID0galJlcXVpcmUudmVyc2lvbigpO1xuICAgIGokLk9yZGVyID0galJlcXVpcmUuT3JkZXIoKTtcbiAgICBqJC5EaWZmQnVpbGRlciA9IGpSZXF1aXJlLkRpZmZCdWlsZGVyKGokKTtcbiAgICBqJC5OdWxsRGlmZkJ1aWxkZXIgPSBqUmVxdWlyZS5OdWxsRGlmZkJ1aWxkZXIoaiQpO1xuICAgIGokLk9iamVjdFBhdGggPSBqUmVxdWlyZS5PYmplY3RQYXRoKGokKTtcbiAgICBqJC5HbG9iYWxFcnJvcnMgPSBqUmVxdWlyZS5HbG9iYWxFcnJvcnMoaiQpO1xuXG4gICAgaiQubWF0Y2hlcnMgPSBqUmVxdWlyZS5yZXF1aXJlTWF0Y2hlcnMoalJlcXVpcmUsIGokKTtcblxuICAgIHJldHVybiBqJDtcbiAgfTtcblxuICByZXR1cm4gZ2V0SmFzbWluZVJlcXVpcmU7XG59KSh0aGlzKTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5yZXF1aXJlTWF0Y2hlcnMgPSBmdW5jdGlvbihqUmVxdWlyZSwgaiQpIHtcbiAgdmFyIGF2YWlsYWJsZU1hdGNoZXJzID0gW1xuICAgICAgJ25vdGhpbmcnLFxuICAgICAgJ3RvQmUnLFxuICAgICAgJ3RvQmVDbG9zZVRvJyxcbiAgICAgICd0b0JlRGVmaW5lZCcsXG4gICAgICAndG9CZUZhbHN5JyxcbiAgICAgICd0b0JlR3JlYXRlclRoYW4nLFxuICAgICAgJ3RvQmVHcmVhdGVyVGhhbk9yRXF1YWwnLFxuICAgICAgJ3RvQmVMZXNzVGhhbicsXG4gICAgICAndG9CZUxlc3NUaGFuT3JFcXVhbCcsXG4gICAgICAndG9CZU5hTicsXG4gICAgICAndG9CZU5lZ2F0aXZlSW5maW5pdHknLFxuICAgICAgJ3RvQmVOdWxsJyxcbiAgICAgICd0b0JlUG9zaXRpdmVJbmZpbml0eScsXG4gICAgICAndG9CZVRydXRoeScsXG4gICAgICAndG9CZVVuZGVmaW5lZCcsXG4gICAgICAndG9Db250YWluJyxcbiAgICAgICd0b0VxdWFsJyxcbiAgICAgICd0b0hhdmVCZWVuQ2FsbGVkJyxcbiAgICAgICd0b0hhdmVCZWVuQ2FsbGVkQmVmb3JlJyxcbiAgICAgICd0b0hhdmVCZWVuQ2FsbGVkVGltZXMnLFxuICAgICAgJ3RvSGF2ZUJlZW5DYWxsZWRXaXRoJyxcbiAgICAgICd0b01hdGNoJyxcbiAgICAgICd0b1Rocm93JyxcbiAgICAgICd0b1Rocm93RXJyb3InXG4gICAgXSxcbiAgICBtYXRjaGVycyA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXZhaWxhYmxlTWF0Y2hlcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmFtZSA9IGF2YWlsYWJsZU1hdGNoZXJzW2ldO1xuICAgIG1hdGNoZXJzW25hbWVdID0galJlcXVpcmVbbmFtZV0oaiQpO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXJzO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5iYXNlID0gZnVuY3Rpb24oaiQsIGphc21pbmVHbG9iYWwpIHtcbiAgaiQudW5pbXBsZW1lbnRlZE1ldGhvZF8gPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuaW1wbGVtZW50ZWQgbWV0aG9kJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1heGltdW0gb2JqZWN0IGRlcHRoIHRoZSBwcmV0dHkgcHJpbnRlciB3aWxsIHByaW50IHRvLlxuICAgKiBTZXQgdGhpcyB0byBhIGxvd2VyIHZhbHVlIHRvIHNwZWVkIHVwIHByZXR0eSBwcmludGluZyBpZiB5b3UgaGF2ZSBsYXJnZSBvYmplY3RzLlxuICAgKiBAbmFtZSBqYXNtaW5lLk1BWF9QUkVUVFlfUFJJTlRfREVQVEhcbiAgICovXG4gIGokLk1BWF9QUkVUVFlfUFJJTlRfREVQVEggPSA4O1xuICAvKipcbiAgICogTWF4aW11bSBudW1iZXIgb2YgYXJyYXkgZWxlbWVudHMgdG8gZGlzcGxheSB3aGVuIHByZXR0eSBwcmludGluZyBvYmplY3RzLlxuICAgKiBUaGlzIHdpbGwgYWxzbyBsaW1pdCB0aGUgbnVtYmVyIG9mIGtleXMgYW5kIHZhbHVlcyBkaXNwbGF5ZWQgZm9yIGFuIG9iamVjdC5cbiAgICogRWxlbWVudHMgcGFzdCB0aGlzIG51bWJlciB3aWxsIGJlIGVsbGlwaXNlZC5cbiAgICogQG5hbWUgamFzbWluZS5NQVhfUFJFVFRZX1BSSU5UX0FSUkFZX0xFTkdUSFxuICAgKi9cbiAgaiQuTUFYX1BSRVRUWV9QUklOVF9BUlJBWV9MRU5HVEggPSA1MDtcbiAgLyoqXG4gICAqIE1heGltdW0gbnVtYmVyIG9mIGNoYXJhc3RlcnMgdG8gZGlzcGxheSB3aGVuIHByZXR0eSBwcmludGluZyBvYmplY3RzLlxuICAgKiBDaGFyYWN0ZXJzIHBhc3QgdGhpcyBudW1iZXIgd2lsbCBiZSBlbGxpcGlzZWQuXG4gICAqIEBuYW1lIGphc21pbmUuTUFYX1BSRVRUWV9QUklOVF9DSEFSU1xuICAgKi9cbiAgaiQuTUFYX1BSRVRUWV9QUklOVF9DSEFSUyA9IDEwMDA7XG4gIC8qKlxuICAgKiBEZWZhdWx0IG51bWJlciBvZiBtaWxsaXNlY29uZHMgSmFzbWluZSB3aWxsIHdhaXQgZm9yIGFuIGFzeW5jaHJvbm91cyBzcGVjIHRvIGNvbXBsZXRlLlxuICAgKiBAbmFtZSBqYXNtaW5lLkRFRkFVTFRfVElNRU9VVF9JTlRFUlZBTFxuICAgKi9cbiAgaiQuREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMID0gNTAwMDtcblxuICBqJC5nZXRHbG9iYWwgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gamFzbWluZUdsb2JhbDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50bHkgYm9vdGVkIEphc21pbmUgRW52aXJvbm1lbnQuXG4gICAqXG4gICAqIEBuYW1lIGphc21pbmUuZ2V0RW52XG4gICAqIEBmdW5jdGlvblxuICAgKiBAcmV0dXJuIHtFbnZ9XG4gICAqL1xuICBqJC5nZXRFbnYgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGVudiA9IGokLmN1cnJlbnRFbnZfID0gaiQuY3VycmVudEVudl8gfHwgbmV3IGokLkVudihvcHRpb25zKTtcbiAgICAvL2phc21pbmUuIHNpbmdsZXRvbnMgaW4gaGVyZSAoc2V0VGltZW91dCBibGFoIGJsYWgpLlxuICAgIHJldHVybiBlbnY7XG4gIH07XG5cbiAgaiQuaXNBcnJheV8gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBqJC5pc0FfKCdBcnJheScsIHZhbHVlKTtcbiAgfTtcblxuICBqJC5pc09iamVjdF8gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiAhaiQudXRpbC5pc1VuZGVmaW5lZCh2YWx1ZSkgJiYgdmFsdWUgIT09IG51bGwgJiYgaiQuaXNBXygnT2JqZWN0JywgdmFsdWUpO1xuICB9O1xuXG4gIGokLmlzU3RyaW5nXyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGokLmlzQV8oJ1N0cmluZycsIHZhbHVlKTtcbiAgfTtcblxuICBqJC5pc051bWJlcl8gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBqJC5pc0FfKCdOdW1iZXInLCB2YWx1ZSk7XG4gIH07XG5cbiAgaiQuaXNGdW5jdGlvbl8gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBqJC5pc0FfKCdGdW5jdGlvbicsIHZhbHVlKTtcbiAgfTtcblxuICBqJC5pc0FzeW5jRnVuY3Rpb25fID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gaiQuaXNBXygnQXN5bmNGdW5jdGlvbicsIHZhbHVlKTtcbiAgfTtcblxuICBqJC5pc1R5cGVkQXJyYXlfID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gaiQuaXNBXygnRmxvYXQzMkFycmF5JywgdmFsdWUpIHx8XG4gICAgICBqJC5pc0FfKCdGbG9hdDY0QXJyYXknLCB2YWx1ZSkgfHxcbiAgICAgIGokLmlzQV8oJ0ludDE2QXJyYXknLCB2YWx1ZSkgfHxcbiAgICAgIGokLmlzQV8oJ0ludDMyQXJyYXknLCB2YWx1ZSkgfHxcbiAgICAgIGokLmlzQV8oJ0ludDhBcnJheScsIHZhbHVlKSB8fFxuICAgICAgaiQuaXNBXygnVWludDE2QXJyYXknLCB2YWx1ZSkgfHxcbiAgICAgIGokLmlzQV8oJ1VpbnQzMkFycmF5JywgdmFsdWUpIHx8XG4gICAgICBqJC5pc0FfKCdVaW50OEFycmF5JywgdmFsdWUpIHx8XG4gICAgICBqJC5pc0FfKCdVaW50OENsYW1wZWRBcnJheScsIHZhbHVlKTtcbiAgfTtcblxuICBqJC5pc0FfID0gZnVuY3Rpb24odHlwZU5hbWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGokLmdldFR5cGVfKHZhbHVlKSA9PT0gJ1tvYmplY3QgJyArIHR5cGVOYW1lICsgJ10nO1xuICB9O1xuXG4gIGokLmdldFR5cGVfID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh2YWx1ZSk7XG4gIH07XG5cbiAgaiQuaXNEb21Ob2RlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iai5ub2RlVHlwZSA+IDA7XG4gIH07XG5cbiAgaiQuaXNNYXAgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIGphc21pbmVHbG9iYWwuTWFwICE9PSAndW5kZWZpbmVkJyAmJiBvYmouY29uc3RydWN0b3IgPT09IGphc21pbmVHbG9iYWwuTWFwO1xuICB9O1xuXG4gIGokLmlzU2V0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBqYXNtaW5lR2xvYmFsLlNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBqYXNtaW5lR2xvYmFsLlNldDtcbiAgfTtcblxuICBqJC5pc1Byb21pc2UgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIGphc21pbmVHbG9iYWwuUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBqYXNtaW5lR2xvYmFsLlByb21pc2U7XG4gIH07XG5cbiAgaiQuZm5OYW1lRm9yID0gZnVuY3Rpb24oZnVuYykge1xuICAgIGlmIChmdW5jLm5hbWUpIHtcbiAgICAgIHJldHVybiBmdW5jLm5hbWU7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoZXMgPSBmdW5jLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb25cXHMqKFxcdyopXFxzKlxcKC8pIHx8XG4gICAgICBmdW5jLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqXFxbb2JqZWN0XFxzKihcXHcqKUNvbnN0cnVjdG9yXFxdLyk7XG5cbiAgICByZXR1cm4gbWF0Y2hlcyA/IG1hdGNoZXNbMV0gOiAnPGFub255bW91cz4nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBtYXRjaGVyLCB1c2FibGUgaW4gYW55IHtAbGluayBtYXRjaGVyc3xtYXRjaGVyfSB0aGF0IHVzZXMgSmFzbWluZSdzIGVxdWFsaXR5IChlLmcuIHtAbGluayBtYXRjaGVycyN0b0VxdWFsfHRvRXF1YWx9LCB7QGxpbmsgbWF0Y2hlcnMjdG9Db250YWlufHRvQ29udGFpbn0sIG9yIHtAbGluayBtYXRjaGVycyN0b0hhdmVCZWVuQ2FsbGVkV2l0aHx0b0hhdmVCZWVuQ2FsbGVkV2l0aH0pLFxuICAgKiB0aGF0IHdpbGwgc3VjY2VlZCBpZiB0aGUgYWN0dWFsIHZhbHVlIGJlaW5nIGNvbXBhcmVkIGlzIGFuIGluc3RhbmNlIG9mIHRoZSBzcGVjaWZpZWQgY2xhc3MvY29uc3RydWN0b3IuXG4gICAqIEBuYW1lIGphc21pbmUuYW55XG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0NvbnN0cnVjdG9yfSBjbGF6eiAtIFRoZSBjb25zdHJ1Y3RvciB0byBjaGVjayBhZ2FpbnN0LlxuICAgKi9cbiAgaiQuYW55ID0gZnVuY3Rpb24oY2xhenopIHtcbiAgICByZXR1cm4gbmV3IGokLkFueShjbGF6eik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIG1hdGNoZXIsIHVzYWJsZSBpbiBhbnkge0BsaW5rIG1hdGNoZXJzfG1hdGNoZXJ9IHRoYXQgdXNlcyBKYXNtaW5lJ3MgZXF1YWxpdHkgKGUuZy4ge0BsaW5rIG1hdGNoZXJzI3RvRXF1YWx8dG9FcXVhbH0sIHtAbGluayBtYXRjaGVycyN0b0NvbnRhaW58dG9Db250YWlufSwgb3Ige0BsaW5rIG1hdGNoZXJzI3RvSGF2ZUJlZW5DYWxsZWRXaXRofHRvSGF2ZUJlZW5DYWxsZWRXaXRofSksXG4gICAqIHRoYXQgd2lsbCBzdWNjZWVkIGlmIHRoZSBhY3R1YWwgdmFsdWUgYmVpbmcgY29tcGFyZWQgaXMgbm90IGBudWxsYCBhbmQgbm90IGB1bmRlZmluZWRgLlxuICAgKiBAbmFtZSBqYXNtaW5lLmFueXRoaW5nXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgaiQuYW55dGhpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IGokLkFueXRoaW5nKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIG1hdGNoZXIsIHVzYWJsZSBpbiBhbnkge0BsaW5rIG1hdGNoZXJzfG1hdGNoZXJ9IHRoYXQgdXNlcyBKYXNtaW5lJ3MgZXF1YWxpdHkgKGUuZy4ge0BsaW5rIG1hdGNoZXJzI3RvRXF1YWx8dG9FcXVhbH0sIHtAbGluayBtYXRjaGVycyN0b0NvbnRhaW58dG9Db250YWlufSwgb3Ige0BsaW5rIG1hdGNoZXJzI3RvSGF2ZUJlZW5DYWxsZWRXaXRofHRvSGF2ZUJlZW5DYWxsZWRXaXRofSksXG4gICAqIHRoYXQgd2lsbCBzdWNjZWVkIGlmIHRoZSBhY3R1YWwgdmFsdWUgYmVpbmcgY29tcGFyZWQgY29udGFpbnMgYXQgbGVhc3QgdGhlIGtleXMgYW5kIHZhbHVlcy5cbiAgICogQG5hbWUgamFzbWluZS5vYmplY3RDb250YWluaW5nXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gc2FtcGxlIC0gVGhlIHN1YnNldCBvZiBwcm9wZXJ0aWVzIHRoYXQgX211c3RfIGJlIGluIHRoZSBhY3R1YWwuXG4gICAqL1xuICBqJC5vYmplY3RDb250YWluaW5nID0gZnVuY3Rpb24oc2FtcGxlKSB7XG4gICAgcmV0dXJuIG5ldyBqJC5PYmplY3RDb250YWluaW5nKHNhbXBsZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIG1hdGNoZXIsIHVzYWJsZSBpbiBhbnkge0BsaW5rIG1hdGNoZXJzfG1hdGNoZXJ9IHRoYXQgdXNlcyBKYXNtaW5lJ3MgZXF1YWxpdHkgKGUuZy4ge0BsaW5rIG1hdGNoZXJzI3RvRXF1YWx8dG9FcXVhbH0sIHtAbGluayBtYXRjaGVycyN0b0NvbnRhaW58dG9Db250YWlufSwgb3Ige0BsaW5rIG1hdGNoZXJzI3RvSGF2ZUJlZW5DYWxsZWRXaXRofHRvSGF2ZUJlZW5DYWxsZWRXaXRofSksXG4gICAqIHRoYXQgd2lsbCBzdWNjZWVkIGlmIHRoZSBhY3R1YWwgdmFsdWUgaXMgYSBgU3RyaW5nYCB0aGF0IG1hdGNoZXMgdGhlIGBSZWdFeHBgIG9yIGBTdHJpbmdgLlxuICAgKiBAbmFtZSBqYXNtaW5lLnN0cmluZ01hdGNoaW5nXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IGV4cGVjdGVkXG4gICAqL1xuICBqJC5zdHJpbmdNYXRjaGluZyA9IGZ1bmN0aW9uKGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIG5ldyBqJC5TdHJpbmdNYXRjaGluZyhleHBlY3RlZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIG1hdGNoZXIsIHVzYWJsZSBpbiBhbnkge0BsaW5rIG1hdGNoZXJzfG1hdGNoZXJ9IHRoYXQgdXNlcyBKYXNtaW5lJ3MgZXF1YWxpdHkgKGUuZy4ge0BsaW5rIG1hdGNoZXJzI3RvRXF1YWx8dG9FcXVhbH0sIHtAbGluayBtYXRjaGVycyN0b0NvbnRhaW58dG9Db250YWlufSwgb3Ige0BsaW5rIG1hdGNoZXJzI3RvSGF2ZUJlZW5DYWxsZWRXaXRofHRvSGF2ZUJlZW5DYWxsZWRXaXRofSksXG4gICAqIHRoYXQgd2lsbCBzdWNjZWVkIGlmIHRoZSBhY3R1YWwgdmFsdWUgaXMgYW4gYEFycmF5YCB0aGF0IGNvbnRhaW5zIGF0IGxlYXN0IHRoZSBlbGVtZW50cyBpbiB0aGUgc2FtcGxlLlxuICAgKiBAbmFtZSBqYXNtaW5lLmFycmF5Q29udGFpbmluZ1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheX0gc2FtcGxlXG4gICAqL1xuICBqJC5hcnJheUNvbnRhaW5pbmcgPSBmdW5jdGlvbihzYW1wbGUpIHtcbiAgICByZXR1cm4gbmV3IGokLkFycmF5Q29udGFpbmluZyhzYW1wbGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBtYXRjaGVyLCB1c2FibGUgaW4gYW55IHtAbGluayBtYXRjaGVyc3xtYXRjaGVyfSB0aGF0IHVzZXMgSmFzbWluZSdzIGVxdWFsaXR5IChlLmcuIHtAbGluayBtYXRjaGVycyN0b0VxdWFsfHRvRXF1YWx9LCB7QGxpbmsgbWF0Y2hlcnMjdG9Db250YWlufHRvQ29udGFpbn0sIG9yIHtAbGluayBtYXRjaGVycyN0b0hhdmVCZWVuQ2FsbGVkV2l0aHx0b0hhdmVCZWVuQ2FsbGVkV2l0aH0pLFxuICAgKiB0aGF0IHdpbGwgc3VjY2VlZCBpZiB0aGUgYWN0dWFsIHZhbHVlIGlzIGFuIGBBcnJheWAgdGhhdCBjb250YWlucyBhbGwgb2YgdGhlIGVsZW1lbnRzIGluIHRoZSBzYW1wbGUgaW4gYW55IG9yZGVyLlxuICAgKiBAbmFtZSBqYXNtaW5lLmFycmF5V2l0aEV4YWN0Q29udGVudHNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNhbXBsZVxuICAgKi9cbiAgaiQuYXJyYXlXaXRoRXhhY3RDb250ZW50cyA9IGZ1bmN0aW9uKHNhbXBsZSkge1xuICAgIHJldHVybiBuZXcgaiQuQXJyYXlXaXRoRXhhY3RDb250ZW50cyhzYW1wbGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBiYXJlIHtAbGluayBTcHl9IG9iamVjdC4gVGhpcyB3b24ndCBiZSBpbnN0YWxsZWQgYW55d2hlcmUgYW5kIHdpbGwgbm90IGhhdmUgYW55IGltcGxlbWVudGF0aW9uIGJlaGluZCBpdC5cbiAgICogQG5hbWUgamFzbWluZS5jcmVhdGVTcHlcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZV0gLSBOYW1lIHRvIGdpdmUgdGhlIHNweS4gVGhpcyB3aWxsIGJlIGRpc3BsYXllZCBpbiBmYWlsdXJlIG1lc3NhZ2VzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3JpZ2luYWxGbl0gLSBGdW5jdGlvbiB0byBhY3QgYXMgdGhlIHJlYWwgaW1wbGVtZW50YXRpb24uXG4gICAqIEByZXR1cm4ge1NweX1cbiAgICovXG4gIGokLmNyZWF0ZVNweSA9IGZ1bmN0aW9uKG5hbWUsIG9yaWdpbmFsRm4pIHtcbiAgICByZXR1cm4gaiQuU3B5KG5hbWUsIG9yaWdpbmFsRm4pO1xuICB9O1xuXG4gIGokLmlzU3B5ID0gZnVuY3Rpb24ocHV0YXRpdmVTcHkpIHtcbiAgICBpZiAoIXB1dGF0aXZlU3B5KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBwdXRhdGl2ZVNweS5hbmQgaW5zdGFuY2VvZiBqJC5TcHlTdHJhdGVneSAmJlxuICAgICAgcHV0YXRpdmVTcHkuY2FsbHMgaW5zdGFuY2VvZiBqJC5DYWxsVHJhY2tlcjtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIG9iamVjdCB3aXRoIG11bHRpcGxlIHtAbGluayBTcHl9cyBhcyBpdHMgbWVtYmVycy5cbiAgICogQG5hbWUgamFzbWluZS5jcmVhdGVTcHlPYmpcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbYmFzZU5hbWVdIC0gQmFzZSBuYW1lIGZvciB0aGUgc3BpZXMgaW4gdGhlIG9iamVjdC5cbiAgICogQHBhcmFtIHtTdHJpbmdbXXxPYmplY3R9IG1ldGhvZE5hbWVzIC0gQXJyYXkgb2YgbWV0aG9kIG5hbWVzIHRvIGNyZWF0ZSBzcGllcyBmb3IsIG9yIE9iamVjdCB3aG9zZSBrZXlzIHdpbGwgYmUgbWV0aG9kIG5hbWVzIGFuZCB2YWx1ZXMgdGhlIHtAbGluayBTcHkjYW5kI3JldHVyblZhbHVlfHJldHVyblZhbHVlfS5cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgaiQuY3JlYXRlU3B5T2JqID0gZnVuY3Rpb24oYmFzZU5hbWUsIG1ldGhvZE5hbWVzKSB7XG4gICAgdmFyIGJhc2VOYW1lSXNDb2xsZWN0aW9uID0gaiQuaXNPYmplY3RfKGJhc2VOYW1lKSB8fCBqJC5pc0FycmF5XyhiYXNlTmFtZSk7XG5cbiAgICBpZiAoYmFzZU5hbWVJc0NvbGxlY3Rpb24gJiYgaiQudXRpbC5pc1VuZGVmaW5lZChtZXRob2ROYW1lcykpIHtcbiAgICAgIG1ldGhvZE5hbWVzID0gYmFzZU5hbWU7XG4gICAgICBiYXNlTmFtZSA9ICd1bmtub3duJztcbiAgICB9XG5cbiAgICB2YXIgb2JqID0ge307XG4gICAgdmFyIHNwaWVzV2VyZVNldCA9IGZhbHNlO1xuXG4gICAgaWYgKGokLmlzQXJyYXlfKG1ldGhvZE5hbWVzKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRob2ROYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBvYmpbbWV0aG9kTmFtZXNbaV1dID0gaiQuY3JlYXRlU3B5KGJhc2VOYW1lICsgJy4nICsgbWV0aG9kTmFtZXNbaV0pO1xuICAgICAgICBzcGllc1dlcmVTZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaiQuaXNPYmplY3RfKG1ldGhvZE5hbWVzKSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIG1ldGhvZE5hbWVzKSB7XG4gICAgICAgIGlmIChtZXRob2ROYW1lcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgb2JqW2tleV0gPSBqJC5jcmVhdGVTcHkoYmFzZU5hbWUgKyAnLicgKyBrZXkpO1xuICAgICAgICAgIG9ialtrZXldLmFuZC5yZXR1cm5WYWx1ZShtZXRob2ROYW1lc1trZXldKTtcbiAgICAgICAgICBzcGllc1dlcmVTZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzcGllc1dlcmVTZXQpIHtcbiAgICAgIHRocm93ICdjcmVhdGVTcHlPYmogcmVxdWlyZXMgYSBub24tZW1wdHkgYXJyYXkgb3Igb2JqZWN0IG9mIG1ldGhvZCBuYW1lcyB0byBjcmVhdGUgc3BpZXMgZm9yJztcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS51dGlsID0gZnVuY3Rpb24oaiQpIHtcblxuICB2YXIgdXRpbCA9IHt9O1xuXG4gIHV0aWwuaW5oZXJpdCA9IGZ1bmN0aW9uKGNoaWxkQ2xhc3MsIHBhcmVudENsYXNzKSB7XG4gICAgdmFyIFN1YmNsYXNzID0gZnVuY3Rpb24oKSB7XG4gICAgfTtcbiAgICBTdWJjbGFzcy5wcm90b3R5cGUgPSBwYXJlbnRDbGFzcy5wcm90b3R5cGU7XG4gICAgY2hpbGRDbGFzcy5wcm90b3R5cGUgPSBuZXcgU3ViY2xhc3MoKTtcbiAgfTtcblxuICB1dGlsLmh0bWxFc2NhcGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0cikge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xuICB9O1xuXG4gIHV0aWwuYXJnc1RvQXJyYXkgPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgdmFyIGFycmF5T2ZBcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcnJheU9mQXJncy5wdXNoKGFyZ3NbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlPZkFyZ3M7XG4gIH07XG5cbiAgdXRpbC5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfTtcblxuICB1dGlsLmFycmF5Q29udGFpbnMgPSBmdW5jdGlvbihhcnJheSwgc2VhcmNoKSB7XG4gICAgdmFyIGkgPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKGFycmF5W2ldID09PSBzZWFyY2gpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICB1dGlsLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICAgIH1cblxuICAgIHZhciBjbG9uZWQgPSB7fTtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICBjbG9uZWRbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfTtcblxuICB1dGlsLmNsb25lQXJncyA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICB2YXIgY2xvbmVkQXJncyA9IFtdO1xuICAgIHZhciBhcmdzQXNBcnJheSA9IGokLnV0aWwuYXJnc1RvQXJyYXkoYXJncyk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3NBc0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShhcmdzQXNBcnJheVtpXSksXG4gICAgICAgIHByaW1pdGl2ZXMgPSAvXlxcW29iamVjdCAoQm9vbGVhbnxTdHJpbmd8UmVnRXhwfE51bWJlcikvO1xuXG4gICAgICAvLyBBbGwgZmFsc2V5IHZhbHVlcyBhcmUgZWl0aGVyIHByaW1pdGl2ZXMsIGBudWxsYCwgb3IgYHVuZGVmaW5lZC5cbiAgICAgIGlmICghYXJnc0FzQXJyYXlbaV0gfHwgc3RyLm1hdGNoKHByaW1pdGl2ZXMpKSB7XG4gICAgICAgIGNsb25lZEFyZ3MucHVzaChhcmdzQXNBcnJheVtpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9uZWRBcmdzLnB1c2goaiQudXRpbC5jbG9uZShhcmdzQXNBcnJheVtpXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xvbmVkQXJncztcbiAgfTtcblxuICB1dGlsLmdldFByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgIHZhciBkZXNjcmlwdG9yLFxuICAgICAgcHJvdG8gPSBvYmo7XG5cbiAgICBkbyB7XG4gICAgICBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgbWV0aG9kTmFtZSk7XG4gICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gICAgfSB3aGlsZSAoIWRlc2NyaXB0b3IgJiYgcHJvdG8pO1xuXG4gICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gIH07XG5cbiAgdXRpbC5vYmplY3REaWZmZXJlbmNlID0gZnVuY3Rpb24ob2JqLCB0b1JlbW92ZSkge1xuICAgIHZhciBkaWZmID0ge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAodXRpbC5oYXMob2JqLCBrZXkpICYmICF1dGlsLmhhcyh0b1JlbW92ZSwga2V5KSkge1xuICAgICAgICBkaWZmW2tleV0gPSBvYmpba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGlmZjtcbiAgfTtcblxuICB1dGlsLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gIH07XG5cbiAgcmV0dXJuIHV0aWw7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlNwZWMgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBTcGVjKGF0dHJzKSB7XG4gICAgdGhpcy5leHBlY3RhdGlvbkZhY3RvcnkgPSBhdHRycy5leHBlY3RhdGlvbkZhY3Rvcnk7XG4gICAgdGhpcy5yZXN1bHRDYWxsYmFjayA9IGF0dHJzLnJlc3VsdENhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy5pZCA9IGF0dHJzLmlkO1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBhdHRycy5kZXNjcmlwdGlvbiB8fCAnJztcbiAgICB0aGlzLnF1ZXVlYWJsZUZuID0gYXR0cnMucXVldWVhYmxlRm47XG4gICAgdGhpcy5iZWZvcmVBbmRBZnRlckZucyA9IGF0dHJzLmJlZm9yZUFuZEFmdGVyRm5zIHx8IGZ1bmN0aW9uKCkgeyByZXR1cm4ge2JlZm9yZXM6IFtdLCBhZnRlcnM6IFtdfTsgfTtcbiAgICB0aGlzLnVzZXJDb250ZXh0ID0gYXR0cnMudXNlckNvbnRleHQgfHwgZnVuY3Rpb24oKSB7IHJldHVybiB7fTsgfTtcbiAgICB0aGlzLm9uU3RhcnQgPSBhdHRycy5vblN0YXJ0IHx8IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy5nZXRTcGVjTmFtZSA9IGF0dHJzLmdldFNwZWNOYW1lIHx8IGZ1bmN0aW9uKCkgeyByZXR1cm4gJyc7IH07XG4gICAgdGhpcy5leHBlY3RhdGlvblJlc3VsdEZhY3RvcnkgPSBhdHRycy5leHBlY3RhdGlvblJlc3VsdEZhY3RvcnkgfHwgZnVuY3Rpb24oKSB7IH07XG4gICAgdGhpcy5xdWV1ZVJ1bm5lckZhY3RvcnkgPSBhdHRycy5xdWV1ZVJ1bm5lckZhY3RvcnkgfHwgZnVuY3Rpb24oKSB7fTtcbiAgICB0aGlzLmNhdGNoaW5nRXhjZXB0aW9ucyA9IGF0dHJzLmNhdGNoaW5nRXhjZXB0aW9ucyB8fCBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH07XG4gICAgdGhpcy50aHJvd09uRXhwZWN0YXRpb25GYWlsdXJlID0gISFhdHRycy50aHJvd09uRXhwZWN0YXRpb25GYWlsdXJlO1xuXG4gICAgaWYgKCF0aGlzLnF1ZXVlYWJsZUZuLmZuKSB7XG4gICAgICB0aGlzLnBlbmQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiBTcGVjUmVzdWx0XG4gICAgICogQHByb3BlcnR5IHtJbnR9IGlkIC0gVGhlIHVuaXF1ZSBpZCBvZiB0aGlzIHNwZWMuXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IGRlc2NyaXB0aW9uIC0gVGhlIGRlc2NyaXB0aW9uIHBhc3NlZCB0byB0aGUge0BsaW5rIGl0fSB0aGF0IGNyZWF0ZWQgdGhpcyBzcGVjLlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBmdWxsTmFtZSAtIFRoZSBmdWxsIGRlc2NyaXB0aW9uIGluY2x1ZGluZyBhbGwgYW5jZXN0b3JzIG9mIHRoaXMgc3BlYy5cbiAgICAgKiBAcHJvcGVydHkge0V4cGVjdGF0aW9uW119IGZhaWxlZEV4cGVjdGF0aW9ucyAtIFRoZSBsaXN0IG9mIGV4cGVjdGF0aW9ucyB0aGF0IGZhaWxlZCBkdXJpbmcgZXhlY3V0aW9uIG9mIHRoaXMgc3BlYy5cbiAgICAgKiBAcHJvcGVydHkge0V4cGVjdGF0aW9uW119IHBhc3NlZEV4cGVjdGF0aW9ucyAtIFRoZSBsaXN0IG9mIGV4cGVjdGF0aW9ucyB0aGF0IHBhc3NlZCBkdXJpbmcgZXhlY3V0aW9uIG9mIHRoaXMgc3BlYy5cbiAgICAgKiBAcHJvcGVydHkge0V4cGVjdGF0aW9uW119IGRlcHJlY2F0aW9uV2FybmluZ3MgLSBUaGUgbGlzdCBvZiBkZXByZWNhdGlvbiB3YXJuaW5ncyB0aGF0IG9jY3VycmVkIGR1cmluZyBleGVjdXRpb24gdGhpcyBzcGVjLlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwZW5kaW5nUmVhc29uIC0gSWYgdGhlIHNwZWMgaXMge0BsaW5rIHBlbmRpbmd9LCB0aGlzIHdpbGwgYmUgdGhlIHJlYXNvbi5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gc3RhdHVzIC0gT25jZSB0aGUgc3BlYyBoYXMgY29tcGxldGVkLCB0aGlzIHN0cmluZyByZXByZXNlbnRzIHRoZSBwYXNzL2ZhaWwgc3RhdHVzIG9mIHRoaXMgc3BlYy5cbiAgICAgKi9cbiAgICB0aGlzLnJlc3VsdCA9IHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICBmdWxsTmFtZTogdGhpcy5nZXRGdWxsTmFtZSgpLFxuICAgICAgZmFpbGVkRXhwZWN0YXRpb25zOiBbXSxcbiAgICAgIHBhc3NlZEV4cGVjdGF0aW9uczogW10sXG4gICAgICBkZXByZWNhdGlvbldhcm5pbmdzOiBbXSxcbiAgICAgIHBlbmRpbmdSZWFzb246ICcnXG4gICAgfTtcbiAgfVxuXG4gIFNwZWMucHJvdG90eXBlLmFkZEV4cGVjdGF0aW9uUmVzdWx0ID0gZnVuY3Rpb24ocGFzc2VkLCBkYXRhLCBpc0Vycm9yKSB7XG4gICAgdmFyIGV4cGVjdGF0aW9uUmVzdWx0ID0gdGhpcy5leHBlY3RhdGlvblJlc3VsdEZhY3RvcnkoZGF0YSk7XG4gICAgaWYgKHBhc3NlZCkge1xuICAgICAgdGhpcy5yZXN1bHQucGFzc2VkRXhwZWN0YXRpb25zLnB1c2goZXhwZWN0YXRpb25SZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMucHVzaChleHBlY3RhdGlvblJlc3VsdCk7XG5cbiAgICAgIGlmICh0aGlzLnRocm93T25FeHBlY3RhdGlvbkZhaWx1cmUgJiYgIWlzRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IGokLmVycm9ycy5FeHBlY3RhdGlvbkZhaWxlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBTcGVjLnByb3RvdHlwZS5leHBlY3QgPSBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICByZXR1cm4gdGhpcy5leHBlY3RhdGlvbkZhY3RvcnkoYWN0dWFsLCB0aGlzKTtcbiAgfTtcblxuICBTcGVjLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24ob25Db21wbGV0ZSwgZW5hYmxlZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMub25TdGFydCh0aGlzKTtcblxuICAgIHZhciBmbnMgPSB0aGlzLmJlZm9yZUFuZEFmdGVyRm5zKCk7XG4gICAgdmFyIHJlZ3VsYXJGbnMgPSBmbnMuYmVmb3Jlcy5jb25jYXQodGhpcy5xdWV1ZWFibGVGbik7XG5cbiAgICB2YXIgcnVubmVyQ29uZmlnID0ge1xuICAgICAgaXNMZWFmOiB0cnVlLFxuICAgICAgcXVldWVhYmxlRm5zOiByZWd1bGFyRm5zLFxuICAgICAgY2xlYW51cEZuczogZm5zLmFmdGVycyxcbiAgICAgIG9uRXhjZXB0aW9uOiBmdW5jdGlvbigpIHsgc2VsZi5vbkV4Y2VwdGlvbi5hcHBseShzZWxmLCBhcmd1bWVudHMpOyB9LFxuICAgICAgb25Db21wbGV0ZTogY29tcGxldGUsXG4gICAgICB1c2VyQ29udGV4dDogdGhpcy51c2VyQ29udGV4dCgpXG4gICAgfTtcblxuICAgIGlmICghdGhpcy5pc0V4ZWN1dGFibGUoKSB8fCB0aGlzLm1hcmtlZFBlbmRpbmcgfHwgZW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJ1bm5lckNvbmZpZy5xdWV1ZWFibGVGbnMgPSBbXTtcbiAgICAgIHJ1bm5lckNvbmZpZy5jbGVhbnVwRm5zID0gW107XG4gICAgICBydW5uZXJDb25maWcub25Db21wbGV0ZSA9IGZ1bmN0aW9uKCkgeyBjb21wbGV0ZShlbmFibGVkKTsgfTtcbiAgICB9XG5cbiAgICB0aGlzLnF1ZXVlUnVubmVyRmFjdG9yeShydW5uZXJDb25maWcpO1xuXG4gICAgZnVuY3Rpb24gY29tcGxldGUoZW5hYmxlZEFnYWluKSB7XG4gICAgICBzZWxmLnJlc3VsdC5zdGF0dXMgPSBzZWxmLnN0YXR1cyhlbmFibGVkQWdhaW4pO1xuICAgICAgc2VsZi5yZXN1bHRDYWxsYmFjayhzZWxmLnJlc3VsdCk7XG5cbiAgICAgIGlmIChvbkNvbXBsZXRlKSB7XG4gICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU3BlYy5wcm90b3R5cGUub25FeGNlcHRpb24gPSBmdW5jdGlvbiBvbkV4Y2VwdGlvbihlKSB7XG4gICAgaWYgKFNwZWMuaXNQZW5kaW5nU3BlY0V4Y2VwdGlvbihlKSkge1xuICAgICAgdGhpcy5wZW5kKGV4dHJhY3RDdXN0b21QZW5kaW5nTWVzc2FnZShlKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGUgaW5zdGFuY2VvZiBqJC5lcnJvcnMuRXhwZWN0YXRpb25GYWlsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmFkZEV4cGVjdGF0aW9uUmVzdWx0KGZhbHNlLCB7XG4gICAgICBtYXRjaGVyTmFtZTogJycsXG4gICAgICBwYXNzZWQ6IGZhbHNlLFxuICAgICAgZXhwZWN0ZWQ6ICcnLFxuICAgICAgYWN0dWFsOiAnJyxcbiAgICAgIGVycm9yOiBlXG4gICAgfSwgdHJ1ZSk7XG4gIH07XG5cbiAgU3BlYy5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGlzYWJsZWQgPSB0cnVlO1xuICB9O1xuXG4gIFNwZWMucHJvdG90eXBlLnBlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgdGhpcy5tYXJrZWRQZW5kaW5nID0gdHJ1ZTtcbiAgICBpZiAobWVzc2FnZSkge1xuICAgICAgdGhpcy5yZXN1bHQucGVuZGluZ1JlYXNvbiA9IG1lc3NhZ2U7XG4gICAgfVxuICB9O1xuXG4gIFNwZWMucHJvdG90eXBlLmdldFJlc3VsdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVzdWx0LnN0YXR1cyA9IHRoaXMuc3RhdHVzKCk7XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0O1xuICB9O1xuXG4gIFNwZWMucHJvdG90eXBlLnN0YXR1cyA9IGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCBlbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuICdkaXNhYmxlZCc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWFya2VkUGVuZGluZykge1xuICAgICAgcmV0dXJuICdwZW5kaW5nJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiAnZmFpbGVkJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICdwYXNzZWQnO1xuICAgIH1cbiAgfTtcblxuICBTcGVjLnByb3RvdHlwZS5pc0V4ZWN1dGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gIXRoaXMuZGlzYWJsZWQ7XG4gIH07XG5cbiAgU3BlYy5wcm90b3R5cGUuZ2V0RnVsbE5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTcGVjTmFtZSh0aGlzKTtcbiAgfTtcblxuICBTcGVjLnByb3RvdHlwZS5hZGREZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbihtc2cpIHtcbiAgICB0aGlzLnJlc3VsdC5kZXByZWNhdGlvbldhcm5pbmdzLnB1c2godGhpcy5leHBlY3RhdGlvblJlc3VsdEZhY3RvcnkoeyBtZXNzYWdlOiBtc2cgfSkpO1xuICB9O1xuXG4gIHZhciBleHRyYWN0Q3VzdG9tUGVuZGluZ01lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGZ1bGxNZXNzYWdlID0gZS50b1N0cmluZygpLFxuICAgICAgICBib2lsZXJwbGF0ZVN0YXJ0ID0gZnVsbE1lc3NhZ2UuaW5kZXhPZihTcGVjLnBlbmRpbmdTcGVjRXhjZXB0aW9uTWVzc2FnZSksXG4gICAgICAgIGJvaWxlcnBsYXRlRW5kID0gYm9pbGVycGxhdGVTdGFydCArIFNwZWMucGVuZGluZ1NwZWNFeGNlcHRpb25NZXNzYWdlLmxlbmd0aDtcblxuICAgIHJldHVybiBmdWxsTWVzc2FnZS5zdWJzdHIoYm9pbGVycGxhdGVFbmQpO1xuICB9O1xuXG4gIFNwZWMucGVuZGluZ1NwZWNFeGNlcHRpb25NZXNzYWdlID0gJz0+IG1hcmtlZCBQZW5kaW5nJztcblxuICBTcGVjLmlzUGVuZGluZ1NwZWNFeGNlcHRpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuICEhKGUgJiYgZS50b1N0cmluZyAmJiBlLnRvU3RyaW5nKCkuaW5kZXhPZihTcGVjLnBlbmRpbmdTcGVjRXhjZXB0aW9uTWVzc2FnZSkgIT09IC0xKTtcbiAgfTtcblxuICByZXR1cm4gU3BlYztcbn07XG5cbmlmICh0eXBlb2Ygd2luZG93ID09IHZvaWQgMCAmJiB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0Jykge1xuICBleHBvcnRzLlNwZWMgPSBqYXNtaW5lUmVxdWlyZS5TcGVjO1xufVxuXG4vKmpzaGludCBiaXR3aXNlOiBmYWxzZSovXG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuT3JkZXIgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gT3JkZXIob3B0aW9ucykge1xuICAgIHRoaXMucmFuZG9tID0gJ3JhbmRvbScgaW4gb3B0aW9ucyA/IG9wdGlvbnMucmFuZG9tIDogdHJ1ZTtcbiAgICB2YXIgc2VlZCA9IHRoaXMuc2VlZCA9IG9wdGlvbnMuc2VlZCB8fCBnZW5lcmF0ZVNlZWQoKTtcbiAgICB0aGlzLnNvcnQgPSB0aGlzLnJhbmRvbSA/IHJhbmRvbU9yZGVyIDogbmF0dXJhbE9yZGVyO1xuXG4gICAgZnVuY3Rpb24gbmF0dXJhbE9yZGVyKGl0ZW1zKSB7XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmFuZG9tT3JkZXIoaXRlbXMpIHtcbiAgICAgIHZhciBjb3B5ID0gaXRlbXMuc2xpY2UoKTtcbiAgICAgIGNvcHkuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBqZW5raW5zSGFzaChzZWVkICsgYS5pZCkgLSBqZW5raW5zSGFzaChzZWVkICsgYi5pZCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlU2VlZCgpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoTWF0aC5yYW5kb20oKSkuc2xpY2UoLTUpO1xuICAgIH1cblxuICAgIC8vIEJvYiBKZW5raW5zIE9uZS1hdC1hLVRpbWUgSGFzaCBhbGdvcml0aG0gaXMgYSBub24tY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uXG4gICAgLy8gdXNlZCB0byBnZXQgYSBkaWZmZXJlbnQgb3V0cHV0IHdoZW4gdGhlIGtleSBjaGFuZ2VzIHNsaWdobHkuXG4gICAgLy8gV2UgdXNlIHlvdXIgcmV0dXJuIHRvIHNvcnQgdGhlIGNoaWxkcmVuIHJhbmRvbWx5IGluIGEgY29uc2lzdGVudCB3YXkgd2hlblxuICAgIC8vIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBhIHNlZWRcblxuICAgIGZ1bmN0aW9uIGplbmtpbnNIYXNoKGtleSkge1xuICAgICAgdmFyIGhhc2gsIGk7XG4gICAgICBmb3IoaGFzaCA9IGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGhhc2ggKz0ga2V5LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGhhc2ggKz0gKGhhc2ggPDwgMTApO1xuICAgICAgICBoYXNoIF49IChoYXNoID4+IDYpO1xuICAgICAgfVxuICAgICAgaGFzaCArPSAoaGFzaCA8PCAzKTtcbiAgICAgIGhhc2ggXj0gKGhhc2ggPj4gMTEpO1xuICAgICAgaGFzaCArPSAoaGFzaCA8PCAxNSk7XG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBPcmRlcjtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuRW52ID0gZnVuY3Rpb24oaiQpIHtcbiAgLyoqXG4gICAqIF9Ob3RlOl8gRG8gbm90IGNvbnN0cnVjdCB0aGlzIGRpcmVjdGx5LCBKYXNtaW5lIHdpbGwgbWFrZSBvbmUgZHVyaW5nIGJvb3RpbmcuXG4gICAqIEBuYW1lIEVudlxuICAgKiBAY2xhc3NkZXNjIFRoZSBKYXNtaW5lIGVudmlyb25tZW50XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gRW52KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZ2xvYmFsID0gb3B0aW9ucy5nbG9iYWwgfHwgaiQuZ2V0R2xvYmFsKCk7XG5cbiAgICB2YXIgaGFzRXhlY3V0ZWQgPSBmYWxzZTtcblxuICAgIHZhciB0b3RhbFNwZWNzRGVmaW5lZCA9IDA7XG5cbiAgICB2YXIgY2F0Y2hFeGNlcHRpb25zID0gdHJ1ZTtcblxuICAgIHZhciByZWFsU2V0VGltZW91dCA9IGokLmdldEdsb2JhbCgpLnNldFRpbWVvdXQ7XG4gICAgdmFyIHJlYWxDbGVhclRpbWVvdXQgPSBqJC5nZXRHbG9iYWwoKS5jbGVhclRpbWVvdXQ7XG4gICAgdmFyIGNsZWFyU3RhY2sgPSBqJC5nZXRDbGVhclN0YWNrKGokLmdldEdsb2JhbCgpKTtcbiAgICB0aGlzLmNsb2NrID0gbmV3IGokLkNsb2NrKGdsb2JhbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IGokLkRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlcigpOyB9LCBuZXcgaiQuTW9ja0RhdGUoZ2xvYmFsKSk7XG5cbiAgICB2YXIgcnVubmFibGVSZXNvdXJjZXMgPSB7fTtcblxuICAgIHZhciBjdXJyZW50U3BlYyA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRseUV4ZWN1dGluZ1N1aXRlcyA9IFtdO1xuICAgIHZhciBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZSA9IG51bGw7XG4gICAgdmFyIHRocm93T25FeHBlY3RhdGlvbkZhaWx1cmUgPSBmYWxzZTtcbiAgICB2YXIgcmFuZG9tID0gZmFsc2U7XG4gICAgdmFyIHNlZWQgPSBudWxsO1xuXG4gICAgdmFyIGN1cnJlbnRTdWl0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRseUV4ZWN1dGluZ1N1aXRlc1tjdXJyZW50bHlFeGVjdXRpbmdTdWl0ZXMubGVuZ3RoIC0gMV07XG4gICAgfTtcblxuICAgIHZhciBjdXJyZW50UnVubmFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjdXJyZW50U3BlYyB8fCBjdXJyZW50U3VpdGUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyByZXByZXNlbnRzIHRoZSBhdmFpbGFibGUgcmVwb3J0ZXIgY2FsbGJhY2sgZm9yIGFuIG9iamVjdCBwYXNzZWQgdG8ge0BsaW5rIEVudiNhZGRSZXBvcnRlcn0uXG4gICAgICogQGludGVyZmFjZSBSZXBvcnRlclxuICAgICAqL1xuICAgIHZhciByZXBvcnRlciA9IG5ldyBqJC5SZXBvcnREaXNwYXRjaGVyKFtcbiAgICAgIC8qKlxuICAgICAgICogYGphc21pbmVTdGFydGVkYCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIG9mIHRoZSBzcGVjcyBoYXZlIGJlZW4gbG9hZGVkLCBidXQganVzdCBiZWZvcmUgZXhlY3V0aW9uIHN0YXJ0cy5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQG5hbWUgUmVwb3J0ZXIjamFzbWluZVN0YXJ0ZWRcbiAgICAgICAqIEBwYXJhbSB7SmFzbWluZVN0YXJ0ZWRJbmZvfSBzdWl0ZUluZm8gSW5mb3JtYXRpb24gYWJvdXQgdGhlIGZ1bGwgSmFzbWluZSBzdWl0ZSB0aGF0IGlzIGJlaW5nIHJ1blxuICAgICAgICovXG4gICAgICAnamFzbWluZVN0YXJ0ZWQnLFxuICAgICAgLyoqXG4gICAgICAgKiBXaGVuIHRoZSBlbnRpcmUgc3VpdGUgaGFzIGZpbmlzaGVkIGV4ZWN1dGlvbiBgamFzbWluZURvbmVgIGlzIGNhbGxlZFxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAbmFtZSBSZXBvcnRlciNqYXNtaW5lRG9uZVxuICAgICAgICogQHBhcmFtIHtKYXNtaW5lRG9uZUluZm99IHN1aXRlSW5mbyBJbmZvcm1hdGlvbiBhYm91dCB0aGUgZnVsbCBKYXNtaW5lIHN1aXRlIHRoYXQganVzdCBmaW5pc2hlZCBydW5uaW5nLlxuICAgICAgICovXG4gICAgICAnamFzbWluZURvbmUnLFxuICAgICAgLyoqXG4gICAgICAgKiBgc3VpdGVTdGFydGVkYCBpcyBpbnZva2VkIHdoZW4gYSBgZGVzY3JpYmVgIHN0YXJ0cyB0byBydW5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQG5hbWUgUmVwb3J0ZXIjc3VpdGVTdGFydGVkXG4gICAgICAgKiBAcGFyYW0ge1N1aXRlUmVzdWx0fSByZXN1bHQgSW5mb3JtYXRpb24gYWJvdXQgdGhlIGluZGl2aWR1YWwge0BsaW5rIGRlc2NyaWJlfSBiZWluZyBydW5cbiAgICAgICAqL1xuICAgICAgJ3N1aXRlU3RhcnRlZCcsXG4gICAgICAvKipcbiAgICAgICAqIGBzdWl0ZURvbmVgIGlzIGludm9rZWQgd2hlbiBhbGwgb2YgdGhlIGNoaWxkIHNwZWNzIGFuZCBzdWl0ZXMgZm9yIGEgZ2l2ZW4gc3VpdGUgaGF2ZSBiZWVuIHJ1blxuICAgICAgICpcbiAgICAgICAqIFdoaWxlIGphc21pbmUgZG9lc24ndCByZXF1aXJlIGFueSBzcGVjaWZpYyBmdW5jdGlvbnMsIG5vdCBkZWZpbmluZyBhIGBzdWl0ZURvbmVgIHdpbGwgbWFrZSBpdCBpbXBvc3NpYmxlIGZvciBhIHJlcG9ydGVyIHRvIGtub3cgd2hlbiBhIHN1aXRlIGhhcyBmYWlsdXJlcyBpbiBhbiBgYWZ0ZXJBbGxgLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAbmFtZSBSZXBvcnRlciNzdWl0ZURvbmVcbiAgICAgICAqIEBwYXJhbSB7U3VpdGVSZXN1bHR9IHJlc3VsdFxuICAgICAgICovXG4gICAgICAnc3VpdGVEb25lJyxcbiAgICAgIC8qKlxuICAgICAgICogYHNwZWNTdGFydGVkYCBpcyBpbnZva2VkIHdoZW4gYW4gYGl0YCBzdGFydHMgdG8gcnVuIChpbmNsdWRpbmcgYXNzb2NpYXRlZCBgYmVmb3JlRWFjaGAgZnVuY3Rpb25zKVxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAbmFtZSBSZXBvcnRlciNzcGVjU3RhcnRlZFxuICAgICAgICogQHBhcmFtIHtTcGVjUmVzdWx0fSByZXN1bHQgSW5mb3JtYXRpb24gYWJvdXQgdGhlIGluZGl2aWR1YWwge0BsaW5rIGl0fSBiZWluZyBydW5cbiAgICAgICAqL1xuICAgICAgJ3NwZWNTdGFydGVkJyxcbiAgICAgIC8qKlxuICAgICAgICogYHNwZWNEb25lYCBpcyBpbnZva2VkIHdoZW4gYW4gYGl0YCBhbmQgaXRzIGFzc29jaWF0ZWQgYGJlZm9yZUVhY2hgIGFuZCBgYWZ0ZXJFYWNoYCBmdW5jdGlvbnMgaGF2ZSBiZWVuIHJ1bi5cbiAgICAgICAqXG4gICAgICAgKiBXaGlsZSBqYXNtaW5lIGRvZXNuJ3QgcmVxdWlyZSBhbnkgc3BlY2lmaWMgZnVuY3Rpb25zLCBub3QgZGVmaW5pbmcgYSBgc3BlY0RvbmVgIHdpbGwgbWFrZSBpdCBpbXBvc3NpYmxlIGZvciBhIHJlcG9ydGVyIHRvIGtub3cgd2hlbiBhIHNwZWMgaGFzIGZhaWxlZC5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQG5hbWUgUmVwb3J0ZXIjc3BlY0RvbmVcbiAgICAgICAqIEBwYXJhbSB7U3BlY1Jlc3VsdH0gcmVzdWx0XG4gICAgICAgKi9cbiAgICAgICdzcGVjRG9uZSdcbiAgICBdKTtcblxuICAgIHZhciBnbG9iYWxFcnJvcnMgPSBuZXcgaiQuR2xvYmFsRXJyb3JzKCk7XG5cbiAgICB0aGlzLnNwZWNGaWx0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICB0aGlzLmFkZEN1c3RvbUVxdWFsaXR5VGVzdGVyID0gZnVuY3Rpb24odGVzdGVyKSB7XG4gICAgICBpZighY3VycmVudFJ1bm5hYmxlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDdXN0b20gRXF1YWxpdGllcyBtdXN0IGJlIGFkZGVkIGluIGEgYmVmb3JlIGZ1bmN0aW9uIG9yIGEgc3BlYycpO1xuICAgICAgfVxuICAgICAgcnVubmFibGVSZXNvdXJjZXNbY3VycmVudFJ1bm5hYmxlKCkuaWRdLmN1c3RvbUVxdWFsaXR5VGVzdGVycy5wdXNoKHRlc3Rlcik7XG4gICAgfTtcblxuICAgIHRoaXMuYWRkTWF0Y2hlcnMgPSBmdW5jdGlvbihtYXRjaGVyc1RvQWRkKSB7XG4gICAgICBpZighY3VycmVudFJ1bm5hYmxlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXRjaGVycyBtdXN0IGJlIGFkZGVkIGluIGEgYmVmb3JlIGZ1bmN0aW9uIG9yIGEgc3BlYycpO1xuICAgICAgfVxuICAgICAgdmFyIGN1c3RvbU1hdGNoZXJzID0gcnVubmFibGVSZXNvdXJjZXNbY3VycmVudFJ1bm5hYmxlKCkuaWRdLmN1c3RvbU1hdGNoZXJzO1xuICAgICAgZm9yICh2YXIgbWF0Y2hlck5hbWUgaW4gbWF0Y2hlcnNUb0FkZCkge1xuICAgICAgICBjdXN0b21NYXRjaGVyc1ttYXRjaGVyTmFtZV0gPSBtYXRjaGVyc1RvQWRkW21hdGNoZXJOYW1lXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaiQuRXhwZWN0YXRpb24uYWRkQ29yZU1hdGNoZXJzKGokLm1hdGNoZXJzKTtcblxuICAgIHZhciBuZXh0U3BlY0lkID0gMDtcbiAgICB2YXIgZ2V0TmV4dFNwZWNJZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICdzcGVjJyArIG5leHRTcGVjSWQrKztcbiAgICB9O1xuXG4gICAgdmFyIG5leHRTdWl0ZUlkID0gMDtcbiAgICB2YXIgZ2V0TmV4dFN1aXRlSWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnc3VpdGUnICsgbmV4dFN1aXRlSWQrKztcbiAgICB9O1xuXG4gICAgdmFyIGV4cGVjdGF0aW9uRmFjdG9yeSA9IGZ1bmN0aW9uKGFjdHVhbCwgc3BlYykge1xuICAgICAgcmV0dXJuIGokLkV4cGVjdGF0aW9uLkZhY3Rvcnkoe1xuICAgICAgICB1dGlsOiBqJC5tYXRjaGVyc1V0aWwsXG4gICAgICAgIGN1c3RvbUVxdWFsaXR5VGVzdGVyczogcnVubmFibGVSZXNvdXJjZXNbc3BlYy5pZF0uY3VzdG9tRXF1YWxpdHlUZXN0ZXJzLFxuICAgICAgICBjdXN0b21NYXRjaGVyczogcnVubmFibGVSZXNvdXJjZXNbc3BlYy5pZF0uY3VzdG9tTWF0Y2hlcnMsXG4gICAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgICBhZGRFeHBlY3RhdGlvblJlc3VsdDogYWRkRXhwZWN0YXRpb25SZXN1bHRcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBhZGRFeHBlY3RhdGlvblJlc3VsdChwYXNzZWQsIHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gc3BlYy5hZGRFeHBlY3RhdGlvblJlc3VsdChwYXNzZWQsIHJlc3VsdCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBkZWZhdWx0UmVzb3VyY2VzRm9yUnVubmFibGUgPSBmdW5jdGlvbihpZCwgcGFyZW50UnVubmFibGVJZCkge1xuICAgICAgdmFyIHJlc291cmNlcyA9IHtzcGllczogW10sIGN1c3RvbUVxdWFsaXR5VGVzdGVyczogW10sIGN1c3RvbU1hdGNoZXJzOiB7fX07XG5cbiAgICAgIGlmKHJ1bm5hYmxlUmVzb3VyY2VzW3BhcmVudFJ1bm5hYmxlSWRdKXtcbiAgICAgICAgcmVzb3VyY2VzLmN1c3RvbUVxdWFsaXR5VGVzdGVycyA9IGokLnV0aWwuY2xvbmUocnVubmFibGVSZXNvdXJjZXNbcGFyZW50UnVubmFibGVJZF0uY3VzdG9tRXF1YWxpdHlUZXN0ZXJzKTtcbiAgICAgICAgcmVzb3VyY2VzLmN1c3RvbU1hdGNoZXJzID0gaiQudXRpbC5jbG9uZShydW5uYWJsZVJlc291cmNlc1twYXJlbnRSdW5uYWJsZUlkXS5jdXN0b21NYXRjaGVycyk7XG4gICAgICB9XG5cbiAgICAgIHJ1bm5hYmxlUmVzb3VyY2VzW2lkXSA9IHJlc291cmNlcztcbiAgICB9O1xuXG4gICAgdmFyIGNsZWFyUmVzb3VyY2VzRm9yUnVubmFibGUgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICBzcHlSZWdpc3RyeS5jbGVhclNwaWVzKCk7XG4gICAgICAgIGRlbGV0ZSBydW5uYWJsZVJlc291cmNlc1tpZF07XG4gICAgfTtcblxuICAgIHZhciBiZWZvcmVBbmRBZnRlckZucyA9IGZ1bmN0aW9uKHN1aXRlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBiZWZvcmVzID0gW10sXG4gICAgICAgICAgYWZ0ZXJzID0gW107XG5cbiAgICAgICAgd2hpbGUoc3VpdGUpIHtcbiAgICAgICAgICBiZWZvcmVzID0gYmVmb3Jlcy5jb25jYXQoc3VpdGUuYmVmb3JlRm5zKTtcbiAgICAgICAgICBhZnRlcnMgPSBhZnRlcnMuY29uY2F0KHN1aXRlLmFmdGVyRm5zKTtcblxuICAgICAgICAgIHN1aXRlID0gc3VpdGUucGFyZW50U3VpdGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJlZm9yZXM6IGJlZm9yZXMucmV2ZXJzZSgpLFxuICAgICAgICAgIGFmdGVyczogYWZ0ZXJzXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgZ2V0U3BlY05hbWUgPSBmdW5jdGlvbihzcGVjLCBzdWl0ZSkge1xuICAgICAgdmFyIGZ1bGxOYW1lID0gW3NwZWMuZGVzY3JpcHRpb25dLFxuICAgICAgICAgIHN1aXRlRnVsbE5hbWUgPSBzdWl0ZS5nZXRGdWxsTmFtZSgpO1xuXG4gICAgICBpZiAoc3VpdGVGdWxsTmFtZSAhPT0gJycpIHtcbiAgICAgICAgZnVsbE5hbWUudW5zaGlmdChzdWl0ZUZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdWxsTmFtZS5qb2luKCcgJyk7XG4gICAgfTtcblxuICAgIC8vIFRPRE86IHdlIG1heSBqdXN0IGJlIGFibGUgdG8gcGFzcyBpbiB0aGUgZm4gaW5zdGVhZCBvZiB3cmFwcGluZyBoZXJlXG4gICAgdmFyIGJ1aWxkRXhwZWN0YXRpb25SZXN1bHQgPSBqJC5idWlsZEV4cGVjdGF0aW9uUmVzdWx0LFxuICAgICAgICBleGNlcHRpb25Gb3JtYXR0ZXIgPSBuZXcgaiQuRXhjZXB0aW9uRm9ybWF0dGVyKCksXG4gICAgICAgIGV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeSA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgICAgICAgYXR0cnMubWVzc2FnZUZvcm1hdHRlciA9IGV4Y2VwdGlvbkZvcm1hdHRlci5tZXNzYWdlO1xuICAgICAgICAgIGF0dHJzLnN0YWNrRm9ybWF0dGVyID0gZXhjZXB0aW9uRm9ybWF0dGVyLnN0YWNrO1xuXG4gICAgICAgICAgcmV0dXJuIGJ1aWxkRXhwZWN0YXRpb25SZXN1bHQoYXR0cnMpO1xuICAgICAgICB9O1xuXG4gICAgLy8gVE9ETzogZml4IHRoaXMgbmFtaW5nLCBhbmQgaGVyZSdzIHdoZXJlIHRoZSB2YWx1ZSBjb21lcyBpblxuICAgIHRoaXMuY2F0Y2hFeGNlcHRpb25zID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGNhdGNoRXhjZXB0aW9ucyA9ICEhdmFsdWU7XG4gICAgICBpZiAoIWNhdGNoRXhjZXB0aW9ucykge1xuICAgICAgICB0aGlzLmRlcHJlY2F0ZWQoJ1RoZSBjYXRjaEV4Y2VwdGlvbnMgb3B0aW9uIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBzdG9wT25TcGVjRmFpbHVyZSBpbiBKYXNtaW5lIDMuMCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhdGNoRXhjZXB0aW9ucztcbiAgICB9O1xuXG4gICAgdGhpcy5jYXRjaGluZ0V4Y2VwdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjYXRjaEV4Y2VwdGlvbnM7XG4gICAgfTtcblxuICAgIHZhciBtYXhpbXVtU3BlY0NhbGxiYWNrRGVwdGggPSAyMDtcbiAgICB2YXIgY3VycmVudFNwZWNDYWxsYmFja0RlcHRoID0gMDtcblxuICAgIHZhciBjYXRjaEV4Y2VwdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHJldHVybiBqJC5TcGVjLmlzUGVuZGluZ1NwZWNFeGNlcHRpb24oZSkgfHwgY2F0Y2hFeGNlcHRpb25zO1xuICAgIH07XG5cbiAgICB0aGlzLnRocm93T25FeHBlY3RhdGlvbkZhaWx1cmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdGhyb3dPbkV4cGVjdGF0aW9uRmFpbHVyZSA9ICEhdmFsdWU7XG4gICAgfTtcblxuICAgIHRoaXMudGhyb3dpbmdFeHBlY3RhdGlvbkZhaWx1cmVzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhyb3dPbkV4cGVjdGF0aW9uRmFpbHVyZTtcbiAgICB9O1xuXG4gICAgdGhpcy5yYW5kb21pemVUZXN0cyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByYW5kb20gPSAhIXZhbHVlO1xuICAgIH07XG5cbiAgICB0aGlzLnJhbmRvbVRlc3RzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmFuZG9tO1xuICAgIH07XG5cbiAgICB0aGlzLnNlZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHNlZWQgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWVkO1xuICAgIH07XG5cbiAgICB0aGlzLmRlcHJlY2F0ZWQgPSBmdW5jdGlvbihtc2cpIHtcbiAgICAgIHZhciBydW5uYWJsZSA9IGN1cnJlbnRSdW5uYWJsZSgpIHx8IHRvcFN1aXRlO1xuICAgICAgcnVubmFibGUuYWRkRGVwcmVjYXRpb25XYXJuaW5nKG1zZyk7XG4gICAgICBpZih0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUud2FybiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignREVQUkVDQVRJT046ICcgKyBtc2cpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcXVldWVSdW5uZXJGYWN0b3J5ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucy5jYXRjaEV4Y2VwdGlvbiA9IGNhdGNoRXhjZXB0aW9uO1xuICAgICAgb3B0aW9ucy5jbGVhclN0YWNrID0gb3B0aW9ucy5jbGVhclN0YWNrIHx8IGNsZWFyU3RhY2s7XG4gICAgICBvcHRpb25zLnRpbWVvdXQgPSB7c2V0VGltZW91dDogcmVhbFNldFRpbWVvdXQsIGNsZWFyVGltZW91dDogcmVhbENsZWFyVGltZW91dH07XG4gICAgICBvcHRpb25zLmZhaWwgPSBzZWxmLmZhaWw7XG4gICAgICBvcHRpb25zLmdsb2JhbEVycm9ycyA9IGdsb2JhbEVycm9ycztcbiAgICAgIG9wdGlvbnMuY29tcGxldGVPbkZpcnN0RXJyb3IgPSB0aHJvd09uRXhwZWN0YXRpb25GYWlsdXJlICYmIG9wdGlvbnMuaXNMZWFmO1xuICAgICAgb3B0aW9ucy5kZXByZWNhdGVkID0gc2VsZi5kZXByZWNhdGVkO1xuXG4gICAgICBuZXcgaiQuUXVldWVSdW5uZXIob3B0aW9ucykuZXhlY3V0ZSgpO1xuICAgIH07XG5cbiAgICB2YXIgdG9wU3VpdGUgPSBuZXcgaiQuU3VpdGUoe1xuICAgICAgZW52OiB0aGlzLFxuICAgICAgaWQ6IGdldE5leHRTdWl0ZUlkKCksXG4gICAgICBkZXNjcmlwdGlvbjogJ0phc21pbmVfX1RvcExldmVsX19TdWl0ZScsXG4gICAgICBleHBlY3RhdGlvbkZhY3Rvcnk6IGV4cGVjdGF0aW9uRmFjdG9yeSxcbiAgICAgIGV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeTogZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5XG4gICAgfSk7XG4gICAgZGVmYXVsdFJlc291cmNlc0ZvclJ1bm5hYmxlKHRvcFN1aXRlLmlkKTtcbiAgICBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZSA9IHRvcFN1aXRlO1xuXG4gICAgdGhpcy50b3BTdWl0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRvcFN1aXRlO1xuICAgIH07XG5cbiAgICB0aGlzLmV4ZWN1dGUgPSBmdW5jdGlvbihydW5uYWJsZXNUb1J1bikge1xuICAgICAgaWYgKGhhc0V4ZWN1dGVkKSB7XG4gICAgICAgIHRoaXMuZGVwcmVjYXRlZCgnRXhlY3V0aW5nIHRoZSBzYW1lIEphc21pbmUgbXVsdGlwbGUgdGltZXMgd2lsbCBubyBsb25nZXIgd29yayBpbiBKYXNtaW5lIDMuMCcpO1xuICAgICAgfVxuXG4gICAgICBoYXNFeGVjdXRlZCA9IHRydWU7XG5cbiAgICAgIGlmKCFydW5uYWJsZXNUb1J1bikge1xuICAgICAgICBpZiAoZm9jdXNlZFJ1bm5hYmxlcy5sZW5ndGgpIHtcbiAgICAgICAgICBydW5uYWJsZXNUb1J1biA9IGZvY3VzZWRSdW5uYWJsZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcnVubmFibGVzVG9SdW4gPSBbdG9wU3VpdGUuaWRdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBvcmRlciA9IG5ldyBqJC5PcmRlcih7XG4gICAgICAgIHJhbmRvbTogcmFuZG9tLFxuICAgICAgICBzZWVkOiBzZWVkXG4gICAgICB9KTtcblxuICAgICAgdmFyIHByb2Nlc3NvciA9IG5ldyBqJC5UcmVlUHJvY2Vzc29yKHtcbiAgICAgICAgdHJlZTogdG9wU3VpdGUsXG4gICAgICAgIHJ1bm5hYmxlSWRzOiBydW5uYWJsZXNUb1J1bixcbiAgICAgICAgcXVldWVSdW5uZXJGYWN0b3J5OiBxdWV1ZVJ1bm5lckZhY3RvcnksXG4gICAgICAgIG5vZGVTdGFydDogZnVuY3Rpb24oc3VpdGUpIHtcbiAgICAgICAgICBjdXJyZW50bHlFeGVjdXRpbmdTdWl0ZXMucHVzaChzdWl0ZSk7XG4gICAgICAgICAgZGVmYXVsdFJlc291cmNlc0ZvclJ1bm5hYmxlKHN1aXRlLmlkLCBzdWl0ZS5wYXJlbnRTdWl0ZS5pZCk7XG4gICAgICAgICAgcmVwb3J0ZXIuc3VpdGVTdGFydGVkKHN1aXRlLnJlc3VsdCk7XG4gICAgICAgIH0sXG4gICAgICAgIG5vZGVDb21wbGV0ZTogZnVuY3Rpb24oc3VpdGUsIHJlc3VsdCkge1xuICAgICAgICAgIGlmIChzdWl0ZSAhPT0gY3VycmVudFN1aXRlKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJpZWQgdG8gY29tcGxldGUgdGhlIHdyb25nIHN1aXRlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFzdWl0ZS5tYXJrZWRQZW5kaW5nKSB7XG4gICAgICAgICAgICBjbGVhclJlc291cmNlc0ZvclJ1bm5hYmxlKHN1aXRlLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudGx5RXhlY3V0aW5nU3VpdGVzLnBvcCgpO1xuICAgICAgICAgIHJlcG9ydGVyLnN1aXRlRG9uZShyZXN1bHQpO1xuICAgICAgICB9LFxuICAgICAgICBvcmRlckNoaWxkcmVuOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIG9yZGVyLnNvcnQobm9kZS5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZighcHJvY2Vzc29yLnByb2Nlc3NUcmVlKCkudmFsaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9yZGVyOiB3b3VsZCBjYXVzZSBhIGJlZm9yZUFsbCBvciBhZnRlckFsbCB0byBiZSBydW4gbXVsdGlwbGUgdGltZXMnKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBJbmZvcm1hdGlvbiBwYXNzZWQgdG8gdGhlIHtAbGluayBSZXBvcnRlciNqYXNtaW5lU3RhcnRlZH0gZXZlbnQuXG4gICAgICAgKiBAdHlwZWRlZiBKYXNtaW5lU3RhcnRlZEluZm9cbiAgICAgICAqIEBwcm9wZXJ0eSB7SW50fSB0b3RhbFNwZWNzRGVmaW5lZCAtIFRoZSB0b3RhbCBudW1iZXIgb2Ygc3BlY3MgZGVmaW5lZCBpbiB0aGlzIHN1aXRlLlxuICAgICAgICogQHByb3BlcnR5IHtPcmRlcn0gb3JkZXIgLSBJbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JkZXJpbmcgKHJhbmRvbSBvciBub3QpIG9mIHRoaXMgZXhlY3V0aW9uIG9mIHRoZSBzdWl0ZS5cbiAgICAgICAqL1xuICAgICAgcmVwb3J0ZXIuamFzbWluZVN0YXJ0ZWQoe1xuICAgICAgICB0b3RhbFNwZWNzRGVmaW5lZDogdG90YWxTcGVjc0RlZmluZWQsXG4gICAgICAgIG9yZGVyOiBvcmRlclxuICAgICAgfSk7XG5cbiAgICAgIGN1cnJlbnRseUV4ZWN1dGluZ1N1aXRlcy5wdXNoKHRvcFN1aXRlKTtcblxuICAgICAgZ2xvYmFsRXJyb3JzLmluc3RhbGwoKTtcbiAgICAgIHByb2Nlc3Nvci5leGVjdXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclJlc291cmNlc0ZvclJ1bm5hYmxlKHRvcFN1aXRlLmlkKTtcbiAgICAgICAgY3VycmVudGx5RXhlY3V0aW5nU3VpdGVzLnBvcCgpO1xuICAgICAgICBnbG9iYWxFcnJvcnMudW5pbnN0YWxsKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZm9ybWF0aW9uIHBhc3NlZCB0byB0aGUge0BsaW5rIFJlcG9ydGVyI2phc21pbmVEb25lfSBldmVudC5cbiAgICAgICAgICogQHR5cGVkZWYgSmFzbWluZURvbmVJbmZvXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3JkZXJ9IG9yZGVyIC0gSW5mb3JtYXRpb24gYWJvdXQgdGhlIG9yZGVyaW5nIChyYW5kb20gb3Igbm90KSBvZiB0aGlzIGV4ZWN1dGlvbiBvZiB0aGUgc3VpdGUuXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7RXhwZWN0YXRpb25bXX0gZmFpbGVkRXhwZWN0YXRpb25zIC0gTGlzdCBvZiBleHBlY3RhdGlvbnMgdGhhdCBmYWlsZWQgaW4gYW4ge0BsaW5rIGFmdGVyQWxsfSBhdCB0aGUgZ2xvYmFsIGxldmVsLlxuICAgICAgICAgKiBAcHJvcGVydHkge0V4cGVjdGF0aW9uW119IGRlcHJlY2F0aW9uV2FybmluZ3MgLSBMaXN0IG9mIGRlcHJlY2F0aW9uIHdhcm5pbmdzIHRoYXQgb2NjdXJyZWQgYXQgdGhlIGdsb2JhbCBsZXZlbC5cbiAgICAgICAgICovXG4gICAgICAgIHJlcG9ydGVyLmphc21pbmVEb25lKHtcbiAgICAgICAgICBvcmRlcjogb3JkZXIsXG4gICAgICAgICAgZmFpbGVkRXhwZWN0YXRpb25zOiB0b3BTdWl0ZS5yZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zLFxuICAgICAgICAgIGRlcHJlY2F0aW9uV2FybmluZ3M6IHRvcFN1aXRlLnJlc3VsdC5kZXByZWNhdGlvbldhcm5pbmdzXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGN1c3RvbSByZXBvcnRlciB0byB0aGUgSmFzbWluZSBlbnZpcm9ubWVudC5cbiAgICAgKiBAbmFtZSBFbnYjYWRkUmVwb3J0ZXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1JlcG9ydGVyfSByZXBvcnRlclRvQWRkIFRoZSByZXBvcnRlciB0byBiZSBhZGRlZC5cbiAgICAgKiBAc2VlIGN1c3RvbV9yZXBvcnRlclxuICAgICAqL1xuICAgIHRoaXMuYWRkUmVwb3J0ZXIgPSBmdW5jdGlvbihyZXBvcnRlclRvQWRkKSB7XG4gICAgICByZXBvcnRlci5hZGRSZXBvcnRlcihyZXBvcnRlclRvQWRkKTtcbiAgICB9O1xuXG4gICAgdGhpcy5wcm92aWRlRmFsbGJhY2tSZXBvcnRlciA9IGZ1bmN0aW9uKHJlcG9ydGVyVG9BZGQpIHtcbiAgICAgIHJlcG9ydGVyLnByb3ZpZGVGYWxsYmFja1JlcG9ydGVyKHJlcG9ydGVyVG9BZGQpO1xuICAgIH07XG5cbiAgICB0aGlzLmNsZWFyUmVwb3J0ZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXBvcnRlci5jbGVhclJlcG9ydGVycygpO1xuICAgIH07XG5cbiAgICB2YXIgc3B5UmVnaXN0cnkgPSBuZXcgaiQuU3B5UmVnaXN0cnkoe2N1cnJlbnRTcGllczogZnVuY3Rpb24oKSB7XG4gICAgICBpZighY3VycmVudFJ1bm5hYmxlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTcGllcyBtdXN0IGJlIGNyZWF0ZWQgaW4gYSBiZWZvcmUgZnVuY3Rpb24gb3IgYSBzcGVjJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcnVubmFibGVSZXNvdXJjZXNbY3VycmVudFJ1bm5hYmxlKCkuaWRdLnNwaWVzO1xuICAgIH19KTtcblxuICAgIHRoaXMuYWxsb3dSZXNweSA9IGZ1bmN0aW9uKGFsbG93KXtcbiAgICAgIHNweVJlZ2lzdHJ5LmFsbG93UmVzcHkoYWxsb3cpO1xuICAgIH07XG5cbiAgICB0aGlzLnNweU9uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3B5UmVnaXN0cnkuc3B5T24uYXBwbHkoc3B5UmVnaXN0cnksIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIHRoaXMuc3B5T25Qcm9wZXJ0eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNweVJlZ2lzdHJ5LnNweU9uUHJvcGVydHkuYXBwbHkoc3B5UmVnaXN0cnksIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIHZhciBlbnN1cmVJc0Z1bmN0aW9uID0gZnVuY3Rpb24oZm4sIGNhbGxlcikge1xuICAgICAgaWYgKCFqJC5pc0Z1bmN0aW9uXyhmbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNhbGxlciArICcgZXhwZWN0cyBhIGZ1bmN0aW9uIGFyZ3VtZW50OyByZWNlaXZlZCAnICsgaiQuZ2V0VHlwZV8oZm4pKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGVuc3VyZUlzRnVuY3Rpb25PckFzeW5jID0gZnVuY3Rpb24oZm4sIGNhbGxlcikge1xuICAgICAgaWYgKCFqJC5pc0Z1bmN0aW9uXyhmbikgJiYgIWokLmlzQXN5bmNGdW5jdGlvbl8oZm4pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihjYWxsZXIgKyAnIGV4cGVjdHMgYSBmdW5jdGlvbiBhcmd1bWVudDsgcmVjZWl2ZWQgJyArIGokLmdldFR5cGVfKGZuKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGVuc3VyZUlzTm90TmVzdGVkKG1ldGhvZCkge1xuICAgICAgdmFyIHJ1bm5hYmxlID0gY3VycmVudFJ1bm5hYmxlKCk7XG4gICAgICBpZiAocnVubmFibGUgIT09IG51bGwgJiYgcnVubmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1xcJycgKyBtZXRob2QgKyAnXFwnIHNob3VsZCBvbmx5IGJlIHVzZWQgaW4gXFwnZGVzY3JpYmVcXCcgZnVuY3Rpb24nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3VpdGVGYWN0b3J5ID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICAgIHZhciBzdWl0ZSA9IG5ldyBqJC5TdWl0ZSh7XG4gICAgICAgIGVudjogc2VsZixcbiAgICAgICAgaWQ6IGdldE5leHRTdWl0ZUlkKCksXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgICAgcGFyZW50U3VpdGU6IGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLFxuICAgICAgICBleHBlY3RhdGlvbkZhY3Rvcnk6IGV4cGVjdGF0aW9uRmFjdG9yeSxcbiAgICAgICAgZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5OiBleHBlY3RhdGlvblJlc3VsdEZhY3RvcnksXG4gICAgICAgIHRocm93T25FeHBlY3RhdGlvbkZhaWx1cmU6IHRocm93T25FeHBlY3RhdGlvbkZhaWx1cmVcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gc3VpdGU7XG4gICAgfTtcblxuICAgIHRoaXMuZGVzY3JpYmUgPSBmdW5jdGlvbihkZXNjcmlwdGlvbiwgc3BlY0RlZmluaXRpb25zKSB7XG4gICAgICBlbnN1cmVJc05vdE5lc3RlZCgnZGVzY3JpYmUnKTtcbiAgICAgIGVuc3VyZUlzRnVuY3Rpb24oc3BlY0RlZmluaXRpb25zLCAnZGVzY3JpYmUnKTtcbiAgICAgIHZhciBzdWl0ZSA9IHN1aXRlRmFjdG9yeShkZXNjcmlwdGlvbik7XG4gICAgICBpZiAoc3BlY0RlZmluaXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZXNjcmliZSBkb2VzIG5vdCBleHBlY3QgYW55IGFyZ3VtZW50cycpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLm1hcmtlZFBlbmRpbmcpIHtcbiAgICAgICAgc3VpdGUucGVuZCgpO1xuICAgICAgfVxuICAgICAgYWRkU3BlY3NUb1N1aXRlKHN1aXRlLCBzcGVjRGVmaW5pdGlvbnMpO1xuICAgICAgcmV0dXJuIHN1aXRlO1xuICAgIH07XG5cbiAgICB0aGlzLnhkZXNjcmliZSA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uLCBzcGVjRGVmaW5pdGlvbnMpIHtcbiAgICAgIGVuc3VyZUlzTm90TmVzdGVkKCd4ZGVzY3JpYmUnKTtcbiAgICAgIGVuc3VyZUlzRnVuY3Rpb24oc3BlY0RlZmluaXRpb25zLCAneGRlc2NyaWJlJyk7XG4gICAgICB2YXIgc3VpdGUgPSBzdWl0ZUZhY3RvcnkoZGVzY3JpcHRpb24pO1xuICAgICAgc3VpdGUucGVuZCgpO1xuICAgICAgYWRkU3BlY3NUb1N1aXRlKHN1aXRlLCBzcGVjRGVmaW5pdGlvbnMpO1xuICAgICAgcmV0dXJuIHN1aXRlO1xuICAgIH07XG5cbiAgICB2YXIgZm9jdXNlZFJ1bm5hYmxlcyA9IFtdO1xuXG4gICAgdGhpcy5mZGVzY3JpYmUgPSBmdW5jdGlvbihkZXNjcmlwdGlvbiwgc3BlY0RlZmluaXRpb25zKSB7XG4gICAgICB0aGlzLmRlcHJlY2F0ZWQoJ2ZpdCBhbmQgZmRlc2NyaWJlIHdpbGwgY2F1c2UgeW91ciBzdWl0ZSB0byByZXBvcnQgYW4gXFwnaW5jb21wbGV0ZVxcJyBzdGF0dXMgaW4gSmFzbWluZSAzLjAnKTtcbiAgICAgIGVuc3VyZUlzTm90TmVzdGVkKCdmZGVzY3JpYmUnKTtcbiAgICAgIGVuc3VyZUlzRnVuY3Rpb24oc3BlY0RlZmluaXRpb25zLCAnZmRlc2NyaWJlJyk7XG4gICAgICB2YXIgc3VpdGUgPSBzdWl0ZUZhY3RvcnkoZGVzY3JpcHRpb24pO1xuICAgICAgc3VpdGUuaXNGb2N1c2VkID0gdHJ1ZTtcblxuICAgICAgZm9jdXNlZFJ1bm5hYmxlcy5wdXNoKHN1aXRlLmlkKTtcbiAgICAgIHVuZm9jdXNBbmNlc3RvcigpO1xuICAgICAgYWRkU3BlY3NUb1N1aXRlKHN1aXRlLCBzcGVjRGVmaW5pdGlvbnMpO1xuXG4gICAgICByZXR1cm4gc3VpdGU7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGFkZFNwZWNzVG9TdWl0ZShzdWl0ZSwgc3BlY0RlZmluaXRpb25zKSB7XG4gICAgICB2YXIgcGFyZW50U3VpdGUgPSBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZTtcbiAgICAgIHBhcmVudFN1aXRlLmFkZENoaWxkKHN1aXRlKTtcbiAgICAgIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlID0gc3VpdGU7XG5cbiAgICAgIHZhciBkZWNsYXJhdGlvbkVycm9yID0gbnVsbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNwZWNEZWZpbml0aW9ucy5jYWxsKHN1aXRlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVjbGFyYXRpb25FcnJvciA9IGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWNsYXJhdGlvbkVycm9yKSB7XG4gICAgICAgIHNlbGYuaXQoJ2VuY291bnRlcmVkIGEgZGVjbGFyYXRpb24gZXhjZXB0aW9uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhyb3cgZGVjbGFyYXRpb25FcnJvcjtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlID0gcGFyZW50U3VpdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluZEZvY3VzZWRBbmNlc3RvcihzdWl0ZSkge1xuICAgICAgd2hpbGUgKHN1aXRlKSB7XG4gICAgICAgIGlmIChzdWl0ZS5pc0ZvY3VzZWQpIHtcbiAgICAgICAgICByZXR1cm4gc3VpdGUuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3VpdGUgPSBzdWl0ZS5wYXJlbnRTdWl0ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5mb2N1c0FuY2VzdG9yKCkge1xuICAgICAgdmFyIGZvY3VzZWRBbmNlc3RvciA9IGZpbmRGb2N1c2VkQW5jZXN0b3IoY3VycmVudERlY2xhcmF0aW9uU3VpdGUpO1xuICAgICAgaWYgKGZvY3VzZWRBbmNlc3Rvcikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvY3VzZWRSdW5uYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZm9jdXNlZFJ1bm5hYmxlc1tpXSA9PT0gZm9jdXNlZEFuY2VzdG9yKSB7XG4gICAgICAgICAgICBmb2N1c2VkUnVubmFibGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzcGVjRmFjdG9yeSA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uLCBmbiwgc3VpdGUsIHRpbWVvdXQpIHtcbiAgICAgIHRvdGFsU3BlY3NEZWZpbmVkKys7XG4gICAgICB2YXIgc3BlYyA9IG5ldyBqJC5TcGVjKHtcbiAgICAgICAgaWQ6IGdldE5leHRTcGVjSWQoKSxcbiAgICAgICAgYmVmb3JlQW5kQWZ0ZXJGbnM6IGJlZm9yZUFuZEFmdGVyRm5zKHN1aXRlKSxcbiAgICAgICAgZXhwZWN0YXRpb25GYWN0b3J5OiBleHBlY3RhdGlvbkZhY3RvcnksXG4gICAgICAgIHJlc3VsdENhbGxiYWNrOiBzcGVjUmVzdWx0Q2FsbGJhY2ssXG4gICAgICAgIGdldFNwZWNOYW1lOiBmdW5jdGlvbihzcGVjKSB7XG4gICAgICAgICAgcmV0dXJuIGdldFNwZWNOYW1lKHNwZWMsIHN1aXRlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TdGFydDogc3BlY1N0YXJ0ZWQsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgICAgZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5OiBleHBlY3RhdGlvblJlc3VsdEZhY3RvcnksXG4gICAgICAgIHF1ZXVlUnVubmVyRmFjdG9yeTogcXVldWVSdW5uZXJGYWN0b3J5LFxuICAgICAgICB1c2VyQ29udGV4dDogZnVuY3Rpb24oKSB7IHJldHVybiBzdWl0ZS5jbG9uZWRTaGFyZWRVc2VyQ29udGV4dCgpOyB9LFxuICAgICAgICBxdWV1ZWFibGVGbjoge1xuICAgICAgICAgIGZuOiBmbixcbiAgICAgICAgICB0aW1lb3V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRpbWVvdXQgfHwgaiQuREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMOyB9XG4gICAgICAgIH0sXG4gICAgICAgIHRocm93T25FeHBlY3RhdGlvbkZhaWx1cmU6IHRocm93T25FeHBlY3RhdGlvbkZhaWx1cmVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXNlbGYuc3BlY0ZpbHRlcihzcGVjKSkge1xuICAgICAgICBzcGVjLmRpc2FibGUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNwZWM7XG5cbiAgICAgIGZ1bmN0aW9uIHNwZWNSZXN1bHRDYWxsYmFjayhyZXN1bHQpIHtcbiAgICAgICAgY2xlYXJSZXNvdXJjZXNGb3JSdW5uYWJsZShzcGVjLmlkKTtcbiAgICAgICAgY3VycmVudFNwZWMgPSBudWxsO1xuICAgICAgICByZXBvcnRlci5zcGVjRG9uZShyZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzcGVjU3RhcnRlZChzcGVjKSB7XG4gICAgICAgIGN1cnJlbnRTcGVjID0gc3BlYztcbiAgICAgICAgZGVmYXVsdFJlc291cmNlc0ZvclJ1bm5hYmxlKHNwZWMuaWQsIHN1aXRlLmlkKTtcbiAgICAgICAgcmVwb3J0ZXIuc3BlY1N0YXJ0ZWQoc3BlYy5yZXN1bHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLml0ID0gZnVuY3Rpb24oZGVzY3JpcHRpb24sIGZuLCB0aW1lb3V0KSB7XG4gICAgICBlbnN1cmVJc05vdE5lc3RlZCgnaXQnKTtcbiAgICAgIC8vIGl0KCkgc29tZXRpbWVzIGRvZXNuJ3QgaGF2ZSBhIGZuIGFyZ3VtZW50LCBzbyBvbmx5IGNoZWNrIHRoZSB0eXBlIGlmXG4gICAgICAvLyBpdCdzIGdpdmVuLlxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBmbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZW5zdXJlSXNGdW5jdGlvbk9yQXN5bmMoZm4sICdpdCcpO1xuICAgICAgfVxuICAgICAgdmFyIHNwZWMgPSBzcGVjRmFjdG9yeShkZXNjcmlwdGlvbiwgZm4sIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLCB0aW1lb3V0KTtcbiAgICAgIGlmIChjdXJyZW50RGVjbGFyYXRpb25TdWl0ZS5tYXJrZWRQZW5kaW5nKSB7XG4gICAgICAgIHNwZWMucGVuZCgpO1xuICAgICAgfVxuICAgICAgY3VycmVudERlY2xhcmF0aW9uU3VpdGUuYWRkQ2hpbGQoc3BlYyk7XG4gICAgICByZXR1cm4gc3BlYztcbiAgICB9O1xuXG4gICAgdGhpcy54aXQgPSBmdW5jdGlvbihkZXNjcmlwdGlvbiwgZm4sIHRpbWVvdXQpIHtcbiAgICAgIGVuc3VyZUlzTm90TmVzdGVkKCd4aXQnKTtcbiAgICAgIC8vIHhpdCgpLCBsaWtlIGl0KCksIGRvZXNuJ3QgYWx3YXlzIGhhdmUgYSBmbiBhcmd1bWVudCwgc28gb25seSBjaGVjayB0aGVcbiAgICAgIC8vIHR5cGUgd2hlbiBuZWVkZWQuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGZuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbnN1cmVJc0Z1bmN0aW9uT3JBc3luYyhmbiwgJ3hpdCcpO1xuICAgICAgfVxuICAgICAgdmFyIHNwZWMgPSB0aGlzLml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBzcGVjLnBlbmQoJ1RlbXBvcmFyaWx5IGRpc2FibGVkIHdpdGggeGl0Jyk7XG4gICAgICByZXR1cm4gc3BlYztcbiAgICB9O1xuXG4gICAgdGhpcy5maXQgPSBmdW5jdGlvbihkZXNjcmlwdGlvbiwgZm4sIHRpbWVvdXQpe1xuICAgICAgdGhpcy5kZXByZWNhdGVkKCdmaXQgYW5kIGZkZXNjcmliZSB3aWxsIGNhdXNlIHlvdXIgc3VpdGUgdG8gcmVwb3J0IGFuIFxcJ2luY29tcGxldGVcXCcgc3RhdHVzIGluIEphc21pbmUgMy4wJyk7XG4gICAgICBlbnN1cmVJc05vdE5lc3RlZCgnZml0Jyk7XG4gICAgICBlbnN1cmVJc0Z1bmN0aW9uT3JBc3luYyhmbiwgJ2ZpdCcpO1xuICAgICAgdmFyIHNwZWMgPSBzcGVjRmFjdG9yeShkZXNjcmlwdGlvbiwgZm4sIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLCB0aW1lb3V0KTtcbiAgICAgIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLmFkZENoaWxkKHNwZWMpO1xuICAgICAgZm9jdXNlZFJ1bm5hYmxlcy5wdXNoKHNwZWMuaWQpO1xuICAgICAgdW5mb2N1c0FuY2VzdG9yKCk7XG4gICAgICByZXR1cm4gc3BlYztcbiAgICB9O1xuXG4gICAgdGhpcy5leHBlY3QgPSBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICAgIGlmICghY3VycmVudFJ1bm5hYmxlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcXCdleHBlY3RcXCcgd2FzIHVzZWQgd2hlbiB0aGVyZSB3YXMgbm8gY3VycmVudCBzcGVjLCB0aGlzIGNvdWxkIGJlIGJlY2F1c2UgYW4gYXN5bmNocm9ub3VzIHRlc3QgdGltZWQgb3V0Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJyZW50UnVubmFibGUoKS5leHBlY3QoYWN0dWFsKTtcbiAgICB9O1xuXG4gICAgdGhpcy5iZWZvcmVFYWNoID0gZnVuY3Rpb24oYmVmb3JlRWFjaEZ1bmN0aW9uLCB0aW1lb3V0KSB7XG4gICAgICBlbnN1cmVJc05vdE5lc3RlZCgnYmVmb3JlRWFjaCcpO1xuICAgICAgZW5zdXJlSXNGdW5jdGlvbk9yQXN5bmMoYmVmb3JlRWFjaEZ1bmN0aW9uLCAnYmVmb3JlRWFjaCcpO1xuICAgICAgY3VycmVudERlY2xhcmF0aW9uU3VpdGUuYmVmb3JlRWFjaCh7XG4gICAgICAgIGZuOiBiZWZvcmVFYWNoRnVuY3Rpb24sXG4gICAgICAgIHRpbWVvdXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGltZW91dCB8fCBqJC5ERUZBVUxUX1RJTUVPVVRfSU5URVJWQUw7IH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLmJlZm9yZUFsbCA9IGZ1bmN0aW9uKGJlZm9yZUFsbEZ1bmN0aW9uLCB0aW1lb3V0KSB7XG4gICAgICBlbnN1cmVJc05vdE5lc3RlZCgnYmVmb3JlQWxsJyk7XG4gICAgICBlbnN1cmVJc0Z1bmN0aW9uT3JBc3luYyhiZWZvcmVBbGxGdW5jdGlvbiwgJ2JlZm9yZUFsbCcpO1xuICAgICAgY3VycmVudERlY2xhcmF0aW9uU3VpdGUuYmVmb3JlQWxsKHtcbiAgICAgICAgZm46IGJlZm9yZUFsbEZ1bmN0aW9uLFxuICAgICAgICB0aW1lb3V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRpbWVvdXQgfHwgaiQuREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMOyB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5hZnRlckVhY2ggPSBmdW5jdGlvbihhZnRlckVhY2hGdW5jdGlvbiwgdGltZW91dCkge1xuICAgICAgZW5zdXJlSXNOb3ROZXN0ZWQoJ2FmdGVyRWFjaCcpO1xuICAgICAgZW5zdXJlSXNGdW5jdGlvbk9yQXN5bmMoYWZ0ZXJFYWNoRnVuY3Rpb24sICdhZnRlckVhY2gnKTtcbiAgICAgIGFmdGVyRWFjaEZ1bmN0aW9uLmlzQ2xlYW51cCA9IHRydWU7XG4gICAgICBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZS5hZnRlckVhY2goe1xuICAgICAgICBmbjogYWZ0ZXJFYWNoRnVuY3Rpb24sXG4gICAgICAgIHRpbWVvdXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGltZW91dCB8fCBqJC5ERUZBVUxUX1RJTUVPVVRfSU5URVJWQUw7IH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLmFmdGVyQWxsID0gZnVuY3Rpb24oYWZ0ZXJBbGxGdW5jdGlvbiwgdGltZW91dCkge1xuICAgICAgZW5zdXJlSXNOb3ROZXN0ZWQoJ2FmdGVyQWxsJyk7XG4gICAgICBlbnN1cmVJc0Z1bmN0aW9uT3JBc3luYyhhZnRlckFsbEZ1bmN0aW9uLCAnYWZ0ZXJBbGwnKTtcbiAgICAgIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLmFmdGVyQWxsKHtcbiAgICAgICAgZm46IGFmdGVyQWxsRnVuY3Rpb24sXG4gICAgICAgIHRpbWVvdXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGltZW91dCB8fCBqJC5ERUZBVUxUX1RJTUVPVVRfSU5URVJWQUw7IH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLnBlbmRpbmcgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICB2YXIgZnVsbE1lc3NhZ2UgPSBqJC5TcGVjLnBlbmRpbmdTcGVjRXhjZXB0aW9uTWVzc2FnZTtcbiAgICAgIGlmKG1lc3NhZ2UpIHtcbiAgICAgICAgZnVsbE1lc3NhZ2UgKz0gbWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIHRocm93IGZ1bGxNZXNzYWdlO1xuICAgIH07XG5cbiAgICB0aGlzLmZhaWwgPSBmdW5jdGlvbihlcnJvcikge1xuICAgICAgaWYgKCFjdXJyZW50UnVubmFibGUoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1xcJ2ZhaWxcXCcgd2FzIHVzZWQgd2hlbiB0aGVyZSB3YXMgbm8gY3VycmVudCBzcGVjLCB0aGlzIGNvdWxkIGJlIGJlY2F1c2UgYW4gYXN5bmNocm9ub3VzIHRlc3QgdGltZWQgb3V0Jyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtZXNzYWdlID0gJ0ZhaWxlZCc7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgbWVzc2FnZSArPSAnOiAnO1xuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgIG1lc3NhZ2UgKz0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgfSBlbHNlIGlmIChqYXNtaW5lLmlzU3RyaW5nXyhlcnJvcikpIHtcbiAgICAgICAgICBtZXNzYWdlICs9IGVycm9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHByZXR0eSBwcmludCBhbGwga2luZCBvZiBvYmplY3RzLiBUaGlzIGluY2x1ZGVzIGFycmF5cy5cbiAgICAgICAgICBtZXNzYWdlICs9IGphc21pbmUucHAoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRSdW5uYWJsZSgpLmFkZEV4cGVjdGF0aW9uUmVzdWx0KGZhbHNlLCB7XG4gICAgICAgIG1hdGNoZXJOYW1lOiAnJyxcbiAgICAgICAgcGFzc2VkOiBmYWxzZSxcbiAgICAgICAgZXhwZWN0ZWQ6ICcnLFxuICAgICAgICBhY3R1YWw6ICcnLFxuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICBlcnJvcjogZXJyb3IgJiYgZXJyb3IubWVzc2FnZSA/IGVycm9yIDogbnVsbFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChzZWxmLnRocm93aW5nRXhwZWN0YXRpb25GYWlsdXJlcygpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIEVudjtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuSnNBcGlSZXBvcnRlciA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciBub29wVGltZXIgPSB7XG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCl7fSxcbiAgICBlbGFwc2VkOiBmdW5jdGlvbigpeyByZXR1cm4gMDsgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBqc0FwaVJlcG9ydGVyXG4gICAqIEBjbGFzc2Rlc2Mge0BsaW5rIFJlcG9ydGVyfSBhZGRlZCBieSBkZWZhdWx0IGluIGBib290LmpzYCB0byByZWNvcmQgcmVzdWx0cyBmb3IgcmV0cmlldmFsIGluIGphdmFzY3JpcHQgY29kZS4gQW4gaW5zdGFuY2UgaXMgbWFkZSBhdmFpbGFibGUgYXMgYGpzQXBpUmVwb3J0ZXJgIG9uIHRoZSBnbG9iYWwgb2JqZWN0LlxuICAgKiBAY2xhc3NcbiAgICogQGhpZGVjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gSnNBcGlSZXBvcnRlcihvcHRpb25zKSB7XG4gICAgdmFyIHRpbWVyID0gb3B0aW9ucy50aW1lciB8fCBub29wVGltZXIsXG4gICAgICAgIHN0YXR1cyA9ICdsb2FkZWQnO1xuXG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMucnVuRGV0YWlscyA9IHt9O1xuXG4gICAgdGhpcy5qYXNtaW5lU3RhcnRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgIHN0YXR1cyA9ICdzdGFydGVkJztcbiAgICAgIHRpbWVyLnN0YXJ0KCk7XG4gICAgfTtcblxuICAgIHZhciBleGVjdXRpb25UaW1lO1xuXG4gICAgdGhpcy5qYXNtaW5lRG9uZSA9IGZ1bmN0aW9uKHJ1bkRldGFpbHMpIHtcbiAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgdGhpcy5ydW5EZXRhaWxzID0gcnVuRGV0YWlscztcbiAgICAgIGV4ZWN1dGlvblRpbWUgPSB0aW1lci5lbGFwc2VkKCk7XG4gICAgICBzdGF0dXMgPSAnZG9uZSc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBzdGF0dXMgZm9yIHRoZSBKYXNtaW5lIGVudmlyb25tZW50LlxuICAgICAqIEBuYW1lIGpzQXBpUmVwb3J0ZXIjc3RhdHVzXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAtIE9uZSBvZiBgbG9hZGVkYCwgYHN0YXJ0ZWRgLCBvciBgZG9uZWBcbiAgICAgKi9cbiAgICB0aGlzLnN0YXR1cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9O1xuXG4gICAgdmFyIHN1aXRlcyA9IFtdLFxuICAgICAgc3VpdGVzX2hhc2ggPSB7fTtcblxuICAgIHRoaXMuc3VpdGVTdGFydGVkID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICBzdWl0ZXNfaGFzaFtyZXN1bHQuaWRdID0gcmVzdWx0O1xuICAgIH07XG5cbiAgICB0aGlzLnN1aXRlRG9uZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgc3RvcmVTdWl0ZShyZXN1bHQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJlc3VsdHMgZm9yIGEgc2V0IG9mIHN1aXRlcy5cbiAgICAgKlxuICAgICAqIFJldHJpZXZhYmxlIGluIHNsaWNlcyBmb3IgZWFzaWVyIHNlcmlhbGl6YXRpb24uXG4gICAgICogQG5hbWUganNBcGlSZXBvcnRlciNzdWl0ZVJlc3VsdHNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBUaGUgcG9zaXRpb24gaW4gdGhlIHN1aXRlcyBsaXN0IHRvIHN0YXJ0IGZyb20uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCAtIE1heGltdW0gbnVtYmVyIG9mIHN1aXRlIHJlc3VsdHMgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm4ge1N1aXRlUmVzdWx0W119XG4gICAgICovXG4gICAgdGhpcy5zdWl0ZVJlc3VsdHMgPSBmdW5jdGlvbihpbmRleCwgbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gc3VpdGVzLnNsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHN0b3JlU3VpdGUocmVzdWx0KSB7XG4gICAgICBzdWl0ZXMucHVzaChyZXN1bHQpO1xuICAgICAgc3VpdGVzX2hhc2hbcmVzdWx0LmlkXSA9IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIG9mIHRoZSBzdWl0ZXMgaW4gYSBzaW5nbGUgb2JqZWN0LCB3aXRoIHRoZWlyIGBpZGAgYXMgdGhlIGtleS5cbiAgICAgKiBAbmFtZSBqc0FwaVJlcG9ydGVyI3N1aXRlc1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge09iamVjdH0gLSBNYXAgb2Ygc3VpdGUgaWQgdG8ge0BsaW5rIFN1aXRlUmVzdWx0fVxuICAgICAqL1xuICAgIHRoaXMuc3VpdGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3VpdGVzX2hhc2g7XG4gICAgfTtcblxuICAgIHZhciBzcGVjcyA9IFtdO1xuXG4gICAgdGhpcy5zcGVjRG9uZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgc3BlY3MucHVzaChyZXN1bHQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJlc3VsdHMgZm9yIGEgc2V0IG9mIHNwZWNzLlxuICAgICAqXG4gICAgICogUmV0cmlldmFibGUgaW4gc2xpY2VzIGZvciBlYXNpZXIgc2VyaWFsaXphdGlvbi5cbiAgICAgKiBAbmFtZSBqc0FwaVJlcG9ydGVyI3NwZWNSZXN1bHRzXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIHBvc2l0aW9uIGluIHRoZSBzcGVjcyBsaXN0IHRvIHN0YXJ0IGZyb20uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCAtIE1heGltdW0gbnVtYmVyIG9mIHNwZWNzIHJlc3VsdHMgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm4ge1NwZWNSZXN1bHRbXX1cbiAgICAgKi9cbiAgICB0aGlzLnNwZWNSZXN1bHRzID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCkge1xuICAgICAgcmV0dXJuIHNwZWNzLnNsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgc3BlYyByZXN1bHRzLlxuICAgICAqIEBuYW1lIGpzQXBpUmVwb3J0ZXIjc3BlY3NcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtTcGVjUmVzdWx0W119XG4gICAgICovXG4gICAgdGhpcy5zcGVjcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNwZWNzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGZ1bGwgSmFzbWluZSBzdWl0ZSB0byBydW4uXG4gICAgICogQG5hbWUganNBcGlSZXBvcnRlciNleGVjdXRpb25UaW1lXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZXhlY3V0aW9uVGltZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4ZWN1dGlvblRpbWU7XG4gICAgfTtcblxuICB9XG5cbiAgcmV0dXJuIEpzQXBpUmVwb3J0ZXI7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkFueSA9IGZ1bmN0aW9uKGokKSB7XG5cbiAgZnVuY3Rpb24gQW55KGV4cGVjdGVkT2JqZWN0KSB7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZE9iamVjdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdqYXNtaW5lLmFueSgpIGV4cGVjdHMgdG8gYmUgcGFzc2VkIGEgY29uc3RydWN0b3IgZnVuY3Rpb24uICcgK1xuICAgICAgICAnUGxlYXNlIHBhc3Mgb25lIG9yIHVzZSBqYXNtaW5lLmFueXRoaW5nKCkgdG8gbWF0Y2ggYW55IG9iamVjdC4nXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdGVkT2JqZWN0ID0gZXhwZWN0ZWRPYmplY3Q7XG4gIH1cblxuICBBbnkucHJvdG90eXBlLmFzeW1tZXRyaWNNYXRjaCA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgaWYgKHRoaXMuZXhwZWN0ZWRPYmplY3QgPT0gU3RyaW5nKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG90aGVyID09ICdzdHJpbmcnIHx8IG90aGVyIGluc3RhbmNlb2YgU3RyaW5nO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmV4cGVjdGVkT2JqZWN0ID09IE51bWJlcikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvdGhlciA9PSAnbnVtYmVyJyB8fCBvdGhlciBpbnN0YW5jZW9mIE51bWJlcjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5leHBlY3RlZE9iamVjdCA9PSBGdW5jdGlvbikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvdGhlciA9PSAnZnVuY3Rpb24nIHx8IG90aGVyIGluc3RhbmNlb2YgRnVuY3Rpb247XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZXhwZWN0ZWRPYmplY3QgPT0gT2JqZWN0KSB7XG4gICAgICBpZiAob3RoZXIgPT09IG51bGwpIHtcbiAgICAgICAgaiQuZ2V0RW52KCkuZGVwcmVjYXRlZCgnamFzbWluZS5BbnkoT2JqZWN0KSB3aWxsIG5vIGxvbmdlciBtYXRjaCBudWxsIGluIEphc21pbmUgMy4wJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIG90aGVyID09ICdvYmplY3QnO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmV4cGVjdGVkT2JqZWN0ID09IEJvb2xlYW4pIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb3RoZXIgPT0gJ2Jvb2xlYW4nO1xuICAgIH1cblxuICAgIC8qIGpzaGludCAtVzEyMiAqL1xuICAgIGlmICh0eXBlb2YgU3ltYm9sICE9ICd1bmRlZmluZWQnICYmIHRoaXMuZXhwZWN0ZWRPYmplY3QgPT0gU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG90aGVyID09ICdzeW1ib2wnO1xuICAgIH1cbiAgICAvKiBqc2hpbnQgK1cxMjIgKi9cblxuICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIHRoaXMuZXhwZWN0ZWRPYmplY3Q7XG4gIH07XG5cbiAgQW55LnByb3RvdHlwZS5qYXNtaW5lVG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJzxqYXNtaW5lLmFueSgnICsgaiQuZm5OYW1lRm9yKHRoaXMuZXhwZWN0ZWRPYmplY3QpICsgJyk+JztcbiAgfTtcblxuICByZXR1cm4gQW55O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5Bbnl0aGluZyA9IGZ1bmN0aW9uKGokKSB7XG5cbiAgZnVuY3Rpb24gQW55dGhpbmcoKSB7fVxuXG4gIEFueXRoaW5nLnByb3RvdHlwZS5hc3ltbWV0cmljTWF0Y2ggPSBmdW5jdGlvbihvdGhlcikge1xuICAgIHJldHVybiAhaiQudXRpbC5pc1VuZGVmaW5lZChvdGhlcikgJiYgb3RoZXIgIT09IG51bGw7XG4gIH07XG5cbiAgQW55dGhpbmcucHJvdG90eXBlLmphc21pbmVUb1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnPGphc21pbmUuYW55dGhpbmc+JztcbiAgfTtcblxuICByZXR1cm4gQW55dGhpbmc7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkFycmF5Q29udGFpbmluZyA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIEFycmF5Q29udGFpbmluZyhzYW1wbGUpIHtcbiAgICB0aGlzLnNhbXBsZSA9IHNhbXBsZTtcbiAgfVxuXG4gIEFycmF5Q29udGFpbmluZy5wcm90b3R5cGUuYXN5bW1ldHJpY01hdGNoID0gZnVuY3Rpb24ob3RoZXIsIGN1c3RvbVRlc3RlcnMpIHtcbiAgICBpZiAoIWokLmlzQXJyYXlfKHRoaXMuc2FtcGxlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBwcm92aWRlIGFuIGFycmF5IHRvIGFycmF5Q29udGFpbmluZywgbm90ICcgKyBqJC5wcCh0aGlzLnNhbXBsZSkgKyAnLicpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zYW1wbGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gdGhpcy5zYW1wbGVbaV07XG4gICAgICBpZiAoIWokLm1hdGNoZXJzVXRpbC5jb250YWlucyhvdGhlciwgaXRlbSwgY3VzdG9tVGVzdGVycykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIEFycmF5Q29udGFpbmluZy5wcm90b3R5cGUuamFzbWluZVRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnPGphc21pbmUuYXJyYXlDb250YWluaW5nKCcgKyBqYXNtaW5lLnBwKHRoaXMuc2FtcGxlKSArJyk+JztcbiAgfTtcblxuICByZXR1cm4gQXJyYXlDb250YWluaW5nO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5BcnJheVdpdGhFeGFjdENvbnRlbnRzID0gZnVuY3Rpb24oaiQpIHtcblxuICBmdW5jdGlvbiBBcnJheVdpdGhFeGFjdENvbnRlbnRzKHNhbXBsZSkge1xuICAgIHRoaXMuc2FtcGxlID0gc2FtcGxlO1xuICB9XG5cbiAgQXJyYXlXaXRoRXhhY3RDb250ZW50cy5wcm90b3R5cGUuYXN5bW1ldHJpY01hdGNoID0gZnVuY3Rpb24ob3RoZXIsIGN1c3RvbVRlc3RlcnMpIHtcbiAgICBpZiAoIWokLmlzQXJyYXlfKHRoaXMuc2FtcGxlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBwcm92aWRlIGFuIGFycmF5IHRvIGFycmF5V2l0aEV4YWN0Q29udGVudHMsIG5vdCAnICsgaiQucHAodGhpcy5zYW1wbGUpICsgJy4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zYW1wbGUubGVuZ3RoICE9PSBvdGhlci5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2FtcGxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHRoaXMuc2FtcGxlW2ldO1xuICAgICAgaWYgKCFqJC5tYXRjaGVyc1V0aWwuY29udGFpbnMob3RoZXIsIGl0ZW0sIGN1c3RvbVRlc3RlcnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBBcnJheVdpdGhFeGFjdENvbnRlbnRzLnByb3RvdHlwZS5qYXNtaW5lVG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJzxqYXNtaW5lLmFycmF5V2l0aEV4YWN0Q29udGVudHMgJyArIGokLnBwKHRoaXMuc2FtcGxlKSArICc+JztcbiAgfTtcblxuICByZXR1cm4gQXJyYXlXaXRoRXhhY3RDb250ZW50cztcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuT2JqZWN0Q29udGFpbmluZyA9IGZ1bmN0aW9uKGokKSB7XG5cbiAgZnVuY3Rpb24gT2JqZWN0Q29udGFpbmluZyhzYW1wbGUpIHtcbiAgICB0aGlzLnNhbXBsZSA9IHNhbXBsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFByb3RvdHlwZShvYmopIHtcbiAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgfVxuXG4gICAgaWYgKG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT0gb2JqKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc1Byb3BlcnR5KG9iaiwgcHJvcGVydHkpIHtcbiAgICBpZiAoIW9iaikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wZXJ0eSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBoYXNQcm9wZXJ0eShnZXRQcm90b3R5cGUob2JqKSwgcHJvcGVydHkpO1xuICB9XG5cbiAgT2JqZWN0Q29udGFpbmluZy5wcm90b3R5cGUuYXN5bW1ldHJpY01hdGNoID0gZnVuY3Rpb24ob3RoZXIsIGN1c3RvbVRlc3RlcnMpIHtcbiAgICBpZiAodHlwZW9mKHRoaXMuc2FtcGxlKSAhPT0gJ29iamVjdCcpIHsgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBwcm92aWRlIGFuIG9iamVjdCB0byBvYmplY3RDb250YWluaW5nLCBub3QgXFwnJyt0aGlzLnNhbXBsZSsnXFwnLicpOyB9XG5cbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzLnNhbXBsZSkge1xuICAgICAgaWYgKCFoYXNQcm9wZXJ0eShvdGhlciwgcHJvcGVydHkpIHx8XG4gICAgICAgICAgIWokLm1hdGNoZXJzVXRpbC5lcXVhbHModGhpcy5zYW1wbGVbcHJvcGVydHldLCBvdGhlcltwcm9wZXJ0eV0sIGN1c3RvbVRlc3RlcnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBPYmplY3RDb250YWluaW5nLnByb3RvdHlwZS5qYXNtaW5lVG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJzxqYXNtaW5lLm9iamVjdENvbnRhaW5pbmcoJyArIGokLnBwKHRoaXMuc2FtcGxlKSArICcpPic7XG4gIH07XG5cbiAgcmV0dXJuIE9iamVjdENvbnRhaW5pbmc7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlN0cmluZ01hdGNoaW5nID0gZnVuY3Rpb24oaiQpIHtcblxuICBmdW5jdGlvbiBTdHJpbmdNYXRjaGluZyhleHBlY3RlZCkge1xuICAgIGlmICghaiQuaXNTdHJpbmdfKGV4cGVjdGVkKSAmJiAhaiQuaXNBXygnUmVnRXhwJywgZXhwZWN0ZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGlzIG5vdCBhIFN0cmluZyBvciBhIFJlZ0V4cCcpO1xuICAgIH1cblxuICAgIHRoaXMucmVnZXhwID0gbmV3IFJlZ0V4cChleHBlY3RlZCk7XG4gIH1cblxuICBTdHJpbmdNYXRjaGluZy5wcm90b3R5cGUuYXN5bW1ldHJpY01hdGNoID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdleHAudGVzdChvdGhlcik7XG4gIH07XG5cbiAgU3RyaW5nTWF0Y2hpbmcucHJvdG90eXBlLmphc21pbmVUb1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnPGphc21pbmUuc3RyaW5nTWF0Y2hpbmcoJyArIHRoaXMucmVnZXhwICsgJyk+JztcbiAgfTtcblxuICByZXR1cm4gU3RyaW5nTWF0Y2hpbmc7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkNhbGxUcmFja2VyID0gZnVuY3Rpb24oaiQpIHtcblxuICAvKipcbiAgICogQG5hbWVzcGFjZSBTcHkjY2FsbHNcbiAgICovXG4gIGZ1bmN0aW9uIENhbGxUcmFja2VyKCkge1xuICAgIHZhciBjYWxscyA9IFtdO1xuICAgIHZhciBvcHRzID0ge307XG5cbiAgICB0aGlzLnRyYWNrID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgaWYob3B0cy5jbG9uZUFyZ3MpIHtcbiAgICAgICAgY29udGV4dC5hcmdzID0gaiQudXRpbC5jbG9uZUFyZ3MoY29udGV4dC5hcmdzKTtcbiAgICAgIH1cbiAgICAgIGNhbGxzLnB1c2goY29udGV4dCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhpcyBzcHkgaGFzIGJlZW4gaW52b2tlZC5cbiAgICAgKiBAbmFtZSBTcHkjY2FsbHMjYW55XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmFueSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICEhY2FsbHMubGVuZ3RoO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBpbnZvY2F0aW9ucyBvZiB0aGlzIHNweS5cbiAgICAgKiBAbmFtZSBTcHkjY2FsbHMjY291bnRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtJbnRlZ2VyfVxuICAgICAqL1xuICAgIHRoaXMuY291bnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjYWxscy5sZW5ndGg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYXJndW1lbnRzIHRoYXQgd2VyZSBwYXNzZWQgdG8gYSBzcGVjaWZpYyBpbnZvY2F0aW9uIG9mIHRoaXMgc3B5LlxuICAgICAqIEBuYW1lIFNweSNjYWxscyNhcmdzRm9yXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBpbmRleCBUaGUgMC1iYXNlZCBpbnZvY2F0aW9uIGluZGV4LlxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYXJnc0ZvciA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICB2YXIgY2FsbCA9IGNhbGxzW2luZGV4XTtcbiAgICAgIHJldHVybiBjYWxsID8gY2FsbC5hcmdzIDogW107XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcmF3IGNhbGxzIGFycmF5IGZvciB0aGlzIHNweS5cbiAgICAgKiBAbmFtZSBTcHkjY2FsbHMjYWxsXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7U3B5LmNhbGxEYXRhW119XG4gICAgICovXG4gICAgdGhpcy5hbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjYWxscztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBvZiB0aGUgYXJndW1lbnRzIGZvciBlYWNoIGludm9jYXRpb24gb2YgdGhpcyBzcHkgaW4gdGhlIG9yZGVyIHRoZXkgd2VyZSByZWNlaXZlZC5cbiAgICAgKiBAbmFtZSBTcHkjY2FsbHMjYWxsQXJnc1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYWxsQXJncyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNhbGxBcmdzID0gW107XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2FsbHMubGVuZ3RoOyBpKyspe1xuICAgICAgICBjYWxsQXJncy5wdXNoKGNhbGxzW2ldLmFyZ3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FsbEFyZ3M7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZmlyc3QgaW52b2NhdGlvbiBvZiB0aGlzIHNweS5cbiAgICAgKiBAbmFtZSBTcHkjY2FsbHMjZmlyc3RcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY1NweS5jYWxsRGF0YX1cbiAgICAgKi9cbiAgICB0aGlzLmZpcnN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY2FsbHNbMF07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbW9zdCByZWNlbnQgaW52b2NhdGlvbiBvZiB0aGlzIHNweS5cbiAgICAgKiBAbmFtZSBTcHkjY2FsbHMjbW9zdFJlY2VudFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge09iamVjU3B5LmNhbGxEYXRhfVxuICAgICAqL1xuICAgIHRoaXMubW9zdFJlY2VudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNhbGxzW2NhbGxzLmxlbmd0aCAtIDFdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGlzIHNweSBhcyBpZiBpdCBoYXMgbmV2ZXIgYmVlbiBjYWxsZWQuXG4gICAgICogQG5hbWUgU3B5I2NhbGxzI3Jlc2V0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY2FsbHMgPSBbXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoaXMgc3B5IHRvIGRvIGEgc2hhbGxvdyBjbG9uZSBvZiBhcmd1bWVudHMgcGFzc2VkIHRvIGVhY2ggaW52b2NhdGlvbi5cbiAgICAgKiBAbmFtZSBTcHkjY2FsbHMjc2F2ZUFyZ3VtZW50c0J5VmFsdWVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICB0aGlzLnNhdmVBcmd1bWVudHNCeVZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICBvcHRzLmNsb25lQXJncyA9IHRydWU7XG4gICAgfTtcblxuICB9XG5cbiAgcmV0dXJuIENhbGxUcmFja2VyO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5jbGVhclN0YWNrID0gZnVuY3Rpb24oaiQpIHtcbiAgdmFyIG1heElubGluZUNhbGxDb3VudCA9IDEwO1xuXG4gIGZ1bmN0aW9uIG1lc3NhZ2VDaGFubmVsSW1wbChnbG9iYWwsIHNldFRpbWVvdXQpIHtcbiAgICB2YXIgY2hhbm5lbCA9IG5ldyBnbG9iYWwuTWVzc2FnZUNoYW5uZWwoKSxcbiAgICAgICAgaGVhZCA9IHt9LFxuICAgICAgICB0YWlsID0gaGVhZDtcblxuICAgIHZhciB0YXNrUnVubmluZyA9IGZhbHNlO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdmFyIHRhc2sgPSBoZWFkLnRhc2s7XG4gICAgICBkZWxldGUgaGVhZC50YXNrO1xuXG4gICAgICBpZiAodGFza1J1bm5pbmcpIHtcbiAgICAgICAgZ2xvYmFsLnNldFRpbWVvdXQodGFzaywgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRhc2tSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICB0YXNrKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGFza1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY3VycmVudENhbGxDb3VudCA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNsZWFyU3RhY2soZm4pIHtcbiAgICAgIGN1cnJlbnRDYWxsQ291bnQrKztcblxuICAgICAgaWYgKGN1cnJlbnRDYWxsQ291bnQgPCBtYXhJbmxpbmVDYWxsQ291bnQpIHtcbiAgICAgICAgdGFpbCA9IHRhaWwubmV4dCA9IHsgdGFzazogZm4gfTtcbiAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRDYWxsQ291bnQgPSAwO1xuICAgICAgICBzZXRUaW1lb3V0KGZuKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2xlYXJTdGFjayhnbG9iYWwpIHtcbiAgICB2YXIgY3VycmVudENhbGxDb3VudCA9IDA7XG4gICAgdmFyIHJlYWxTZXRUaW1lb3V0ID0gZ2xvYmFsLnNldFRpbWVvdXQ7XG4gICAgdmFyIHNldFRpbWVvdXRJbXBsID0gZnVuY3Rpb24gY2xlYXJTdGFjayhmbikge1xuICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkocmVhbFNldFRpbWVvdXQsIFtnbG9iYWwsIFtmbiwgMF1dKTtcbiAgICB9O1xuXG4gICAgaWYgKGokLmlzRnVuY3Rpb25fKGdsb2JhbC5zZXRJbW1lZGlhdGUpKSB7XG4gICAgICB2YXIgcmVhbFNldEltbWVkaWF0ZSA9IGdsb2JhbC5zZXRJbW1lZGlhdGU7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgY3VycmVudENhbGxDb3VudCsrO1xuXG4gICAgICAgIGlmIChjdXJyZW50Q2FsbENvdW50IDwgbWF4SW5saW5lQ2FsbENvdW50KSB7XG4gICAgICAgICAgcmVhbFNldEltbWVkaWF0ZShmbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudENhbGxDb3VudCA9IDA7XG5cbiAgICAgICAgICBzZXRUaW1lb3V0SW1wbChmbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICghaiQudXRpbC5pc1VuZGVmaW5lZChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpKSB7XG4gICAgICByZXR1cm4gbWVzc2FnZUNoYW5uZWxJbXBsKGdsb2JhbCwgc2V0VGltZW91dEltcGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2V0VGltZW91dEltcGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdldENsZWFyU3RhY2s7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkNsb2NrID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIE5PREVfSlMgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy52ZXJzaW9ucyAmJiB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlID09PSAnc3RyaW5nJztcblxuICAvKipcbiAgICogX05vdGU6XyBEbyBub3QgY29uc3RydWN0IHRoaXMgZGlyZWN0bHksIEphc21pbmUgd2lsbCBtYWtlIG9uZSBkdXJpbmcgYm9vdGluZy4gWW91IGNhbiBnZXQgdGhlIGN1cnJlbnQgY2xvY2sgd2l0aCB7QGxpbmsgamFzbWluZS5jbG9ja30uXG4gICAqIEBjbGFzcyBDbG9ja1xuICAgKiBAY2xhc3NkZXNjIEphc21pbmUncyBtb2NrIGNsb2NrIGlzIHVzZWQgd2hlbiB0ZXN0aW5nIHRpbWUgZGVwZW5kZW50IGNvZGUuXG4gICAqL1xuICBmdW5jdGlvbiBDbG9jayhnbG9iYWwsIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlckZhY3RvcnksIG1vY2tEYXRlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgcmVhbFRpbWluZ0Z1bmN0aW9ucyA9IHtcbiAgICAgICAgc2V0VGltZW91dDogZ2xvYmFsLnNldFRpbWVvdXQsXG4gICAgICAgIGNsZWFyVGltZW91dDogZ2xvYmFsLmNsZWFyVGltZW91dCxcbiAgICAgICAgc2V0SW50ZXJ2YWw6IGdsb2JhbC5zZXRJbnRlcnZhbCxcbiAgICAgICAgY2xlYXJJbnRlcnZhbDogZ2xvYmFsLmNsZWFySW50ZXJ2YWxcbiAgICAgIH0sXG4gICAgICBmYWtlVGltaW5nRnVuY3Rpb25zID0ge1xuICAgICAgICBzZXRUaW1lb3V0OiBzZXRUaW1lb3V0LFxuICAgICAgICBjbGVhclRpbWVvdXQ6IGNsZWFyVGltZW91dCxcbiAgICAgICAgc2V0SW50ZXJ2YWw6IHNldEludGVydmFsLFxuICAgICAgICBjbGVhckludGVydmFsOiBjbGVhckludGVydmFsXG4gICAgICB9LFxuICAgICAgaW5zdGFsbGVkID0gZmFsc2UsXG4gICAgICBkZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIsXG4gICAgICB0aW1lcjtcblxuICAgIHNlbGYuRmFrZVRpbWVvdXQgPSBGYWtlVGltZW91dDtcblxuICAgIC8qKlxuICAgICAqIEluc3RhbGwgdGhlIG1vY2sgY2xvY2sgb3ZlciB0aGUgYnVpbHQtaW4gbWV0aG9kcy5cbiAgICAgKiBAbmFtZSBDbG9jayNpbnN0YWxsXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7Q2xvY2t9XG4gICAgICovXG4gICAgc2VsZi5pbnN0YWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZighb3JpZ2luYWxUaW1pbmdGdW5jdGlvbnNJbnRhY3QoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0phc21pbmUgQ2xvY2sgd2FzIHVuYWJsZSB0byBpbnN0YWxsIG92ZXIgY3VzdG9tIGdsb2JhbCB0aW1lciBmdW5jdGlvbnMuIElzIHRoZSBjbG9jayBhbHJlYWR5IGluc3RhbGxlZD8nKTtcbiAgICAgIH1cbiAgICAgIHJlcGxhY2UoZ2xvYmFsLCBmYWtlVGltaW5nRnVuY3Rpb25zKTtcbiAgICAgIHRpbWVyID0gZmFrZVRpbWluZ0Z1bmN0aW9ucztcbiAgICAgIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlciA9IGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlckZhY3RvcnkoKTtcbiAgICAgIGluc3RhbGxlZCA9IHRydWU7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVbmluc3RhbGwgdGhlIG1vY2sgY2xvY2ssIHJldHVybmluZyB0aGUgYnVpbHQtaW4gbWV0aG9kcyB0byB0aGVpciBwbGFjZXMuXG4gICAgICogQG5hbWUgQ2xvY2sjdW5pbnN0YWxsXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgc2VsZi51bmluc3RhbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlciA9IG51bGw7XG4gICAgICBtb2NrRGF0ZS51bmluc3RhbGwoKTtcbiAgICAgIHJlcGxhY2UoZ2xvYmFsLCByZWFsVGltaW5nRnVuY3Rpb25zKTtcblxuICAgICAgdGltZXIgPSByZWFsVGltaW5nRnVuY3Rpb25zO1xuICAgICAgaW5zdGFsbGVkID0gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgYSBmdW5jdGlvbiB3aXRoIGEgbW9ja2VkIENsb2NrXG4gICAgICpcbiAgICAgKiBUaGUgY2xvY2sgd2lsbCBiZSB7QGxpbmsgQ2xvY2sjaW5zdGFsbHxpbnN0YWxsfWVkIGJlZm9yZSB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIGFuZCB7QGxpbmsgQ2xvY2sjdW5pbnN0YWxsfHVuaW5zdGFsbH1lZCBpbiBhIGBmaW5hbGx5YCBhZnRlciB0aGUgZnVuY3Rpb24gY29tcGxldGVzLlxuICAgICAqIEBuYW1lIENsb2NrI3dpdGhNb2NrXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtjbG9zdXJlfSBGdW5jdGlvbiBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgICAqL1xuICAgIHNlbGYud2l0aE1vY2sgPSBmdW5jdGlvbihjbG9zdXJlKSB7XG4gICAgICB0aGlzLmluc3RhbGwoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNsb3N1cmUoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMudW5pbnN0YWxsKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluc3RydWN0IHRoZSBpbnN0YWxsZWQgQ2xvY2sgdG8gYWxzbyBtb2NrIHRoZSBkYXRlIHJldHVybmVkIGJ5IGBuZXcgRGF0ZSgpYFxuICAgICAqIEBuYW1lIENsb2NrI21vY2tEYXRlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtEYXRlfSBbaW5pdGlhbERhdGU9bm93XSBUaGUgYERhdGVgIHRvIHByb3ZpZGUuXG4gICAgICovXG4gICAgc2VsZi5tb2NrRGF0ZSA9IGZ1bmN0aW9uKGluaXRpYWxEYXRlKSB7XG4gICAgICBtb2NrRGF0ZS5pbnN0YWxsKGluaXRpYWxEYXRlKTtcbiAgICB9O1xuXG4gICAgc2VsZi5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oZm4sIGRlbGF5LCBwYXJhbXMpIHtcbiAgICAgIGlmIChsZWdhY3lJRSgpKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSUUgPCA5IGNhbm5vdCBzdXBwb3J0IGV4dHJhIHBhcmFtcyB0byBzZXRUaW1lb3V0IHdpdGhvdXQgYSBwb2x5ZmlsbCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aW1lci5zZXRUaW1lb3V0KGZuLCBkZWxheSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KHRpbWVyLnNldFRpbWVvdXQsIFtnbG9iYWwsIGFyZ3VtZW50c10pO1xuICAgIH07XG5cbiAgICBzZWxmLnNldEludGVydmFsID0gZnVuY3Rpb24oZm4sIGRlbGF5LCBwYXJhbXMpIHtcbiAgICAgIGlmIChsZWdhY3lJRSgpKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSUUgPCA5IGNhbm5vdCBzdXBwb3J0IGV4dHJhIHBhcmFtcyB0byBzZXRJbnRlcnZhbCB3aXRob3V0IGEgcG9seWZpbGwnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGltZXIuc2V0SW50ZXJ2YWwoZm4sIGRlbGF5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkodGltZXIuc2V0SW50ZXJ2YWwsIFtnbG9iYWwsIGFyZ3VtZW50c10pO1xuICAgIH07XG5cbiAgICBzZWxmLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYXBwbHkodGltZXIuY2xlYXJUaW1lb3V0LCBbZ2xvYmFsLCBpZF0pO1xuICAgIH07XG5cbiAgICBzZWxmLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbihpZCkge1xuICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmFwcGx5KHRpbWVyLmNsZWFySW50ZXJ2YWwsIFtnbG9iYWwsIGlkXSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRpY2sgdGhlIENsb2NrIGZvcndhcmQsIHJ1bm5pbmcgYW55IGVucXVldWVkIHRpbWVvdXRzIGFsb25nIHRoZSB3YXlcbiAgICAgKiBAbmFtZSBDbG9jayN0aWNrXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtpbnR9IG1pbGxpcyBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aWNrLlxuICAgICAqL1xuICAgIHNlbGYudGljayA9IGZ1bmN0aW9uKG1pbGxpcykge1xuICAgICAgaWYgKGluc3RhbGxlZCkge1xuICAgICAgICBkZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIudGljayhtaWxsaXMsIGZ1bmN0aW9uKG1pbGxpcykgeyBtb2NrRGF0ZS50aWNrKG1pbGxpcyk7IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNb2NrIGNsb2NrIGlzIG5vdCBpbnN0YWxsZWQsIHVzZSBqYXNtaW5lLmNsb2NrKCkuaW5zdGFsbCgpJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xuXG4gICAgZnVuY3Rpb24gb3JpZ2luYWxUaW1pbmdGdW5jdGlvbnNJbnRhY3QoKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsLnNldFRpbWVvdXQgPT09IHJlYWxUaW1pbmdGdW5jdGlvbnMuc2V0VGltZW91dCAmJlxuICAgICAgICBnbG9iYWwuY2xlYXJUaW1lb3V0ID09PSByZWFsVGltaW5nRnVuY3Rpb25zLmNsZWFyVGltZW91dCAmJlxuICAgICAgICBnbG9iYWwuc2V0SW50ZXJ2YWwgPT09IHJlYWxUaW1pbmdGdW5jdGlvbnMuc2V0SW50ZXJ2YWwgJiZcbiAgICAgICAgZ2xvYmFsLmNsZWFySW50ZXJ2YWwgPT09IHJlYWxUaW1pbmdGdW5jdGlvbnMuY2xlYXJJbnRlcnZhbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsZWdhY3lJRSgpIHtcbiAgICAgIC8vaWYgdGhlc2UgbWV0aG9kcyBhcmUgcG9seWZpbGxlZCwgYXBwbHkgd2lsbCBiZSBwcmVzZW50XG4gICAgICByZXR1cm4gIShyZWFsVGltaW5nRnVuY3Rpb25zLnNldFRpbWVvdXQgfHwgcmVhbFRpbWluZ0Z1bmN0aW9ucy5zZXRJbnRlcnZhbCkuYXBwbHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZShkZXN0LCBzb3VyY2UpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIGRlc3RbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0VGltZW91dChmbiwgZGVsYXkpIHtcbiAgICAgIGlmICghTk9ERV9KUykge1xuICAgICAgICByZXR1cm4gZGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyLnNjaGVkdWxlRnVuY3Rpb24oZm4sIGRlbGF5LCBhcmdTbGljZShhcmd1bWVudHMsIDIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpbWVvdXQgPSBuZXcgRmFrZVRpbWVvdXQoKTtcblxuICAgICAgZGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyLnNjaGVkdWxlRnVuY3Rpb24oZm4sIGRlbGF5LCBhcmdTbGljZShhcmd1bWVudHMsIDIpLCBmYWxzZSwgdGltZW91dCk7XG5cbiAgICAgIHJldHVybiB0aW1lb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFyVGltZW91dChpZCkge1xuICAgICAgcmV0dXJuIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlci5yZW1vdmVGdW5jdGlvbldpdGhJZChpZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0SW50ZXJ2YWwoZm4sIGludGVydmFsKSB7XG4gICAgICBpZiAoIU5PREVfSlMpIHtcbiAgICAgICAgcmV0dXJuIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlci5zY2hlZHVsZUZ1bmN0aW9uKGZuLCBpbnRlcnZhbCwgYXJnU2xpY2UoYXJndW1lbnRzLCAyKSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0aW1lb3V0ID0gbmV3IEZha2VUaW1lb3V0KCk7XG5cbiAgICAgIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlci5zY2hlZHVsZUZ1bmN0aW9uKGZuLCBpbnRlcnZhbCwgYXJnU2xpY2UoYXJndW1lbnRzLCAyKSwgdHJ1ZSwgdGltZW91dCk7XG5cbiAgICAgIHJldHVybiB0aW1lb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW50ZXJ2YWwoaWQpIHtcbiAgICAgIHJldHVybiBkZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIucmVtb3ZlRnVuY3Rpb25XaXRoSWQoaWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFyZ1NsaWNlKGFyZ3NPYmosIG4pIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzT2JqLCBuKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTW9ja3MgTm9kZS5qcyBUaW1lb3V0IGNsYXNzXG4gICAqL1xuICBmdW5jdGlvbiBGYWtlVGltZW91dCgpIHt9XG5cbiAgRmFrZVRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBGYWtlVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIENsb2NrO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5EZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBEZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzY2hlZHVsZWRMb29rdXAgPSBbXTtcbiAgICB2YXIgc2NoZWR1bGVkRnVuY3Rpb25zID0ge307XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gMDtcbiAgICB2YXIgZGVsYXllZEZuQ291bnQgPSAwO1xuICAgIHZhciBkZWxldGVkS2V5cyA9IFtdO1xuXG4gICAgc2VsZi50aWNrID0gZnVuY3Rpb24obWlsbGlzLCB0aWNrRGF0ZSkge1xuICAgICAgbWlsbGlzID0gbWlsbGlzIHx8IDA7XG4gICAgICB2YXIgZW5kVGltZSA9IGN1cnJlbnRUaW1lICsgbWlsbGlzO1xuXG4gICAgICBydW5TY2hlZHVsZWRGdW5jdGlvbnMoZW5kVGltZSwgdGlja0RhdGUpO1xuICAgICAgY3VycmVudFRpbWUgPSBlbmRUaW1lO1xuICAgIH07XG5cbiAgICBzZWxmLnNjaGVkdWxlRnVuY3Rpb24gPSBmdW5jdGlvbihmdW5jVG9DYWxsLCBtaWxsaXMsIHBhcmFtcywgcmVjdXJyaW5nLCB0aW1lb3V0S2V5LCBydW5BdE1pbGxpcykge1xuICAgICAgdmFyIGY7XG4gICAgICBpZiAodHlwZW9mKGZ1bmNUb0NhbGwpID09PSAnc3RyaW5nJykge1xuICAgICAgICAvKiBqc2hpbnQgZXZpbDogdHJ1ZSAqL1xuICAgICAgICBmID0gZnVuY3Rpb24oKSB7IHJldHVybiBldmFsKGZ1bmNUb0NhbGwpOyB9O1xuICAgICAgICAvKiBqc2hpbnQgZXZpbDogZmFsc2UgKi9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGYgPSBmdW5jVG9DYWxsO1xuICAgICAgfVxuXG4gICAgICBtaWxsaXMgPSBtaWxsaXMgfHwgMDtcbiAgICAgIHRpbWVvdXRLZXkgPSB0aW1lb3V0S2V5IHx8ICsrZGVsYXllZEZuQ291bnQ7XG4gICAgICBydW5BdE1pbGxpcyA9IHJ1bkF0TWlsbGlzIHx8IChjdXJyZW50VGltZSArIG1pbGxpcyk7XG5cbiAgICAgIHZhciBmdW5jVG9TY2hlZHVsZSA9IHtcbiAgICAgICAgcnVuQXRNaWxsaXM6IHJ1bkF0TWlsbGlzLFxuICAgICAgICBmdW5jVG9DYWxsOiBmLFxuICAgICAgICByZWN1cnJpbmc6IHJlY3VycmluZyxcbiAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgIHRpbWVvdXRLZXk6IHRpbWVvdXRLZXksXG4gICAgICAgIG1pbGxpczogbWlsbGlzXG4gICAgICB9O1xuXG4gICAgICBpZiAocnVuQXRNaWxsaXMgaW4gc2NoZWR1bGVkRnVuY3Rpb25zKSB7XG4gICAgICAgIHNjaGVkdWxlZEZ1bmN0aW9uc1tydW5BdE1pbGxpc10ucHVzaChmdW5jVG9TY2hlZHVsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2hlZHVsZWRGdW5jdGlvbnNbcnVuQXRNaWxsaXNdID0gW2Z1bmNUb1NjaGVkdWxlXTtcbiAgICAgICAgc2NoZWR1bGVkTG9va3VwLnB1c2gocnVuQXRNaWxsaXMpO1xuICAgICAgICBzY2hlZHVsZWRMb29rdXAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aW1lb3V0S2V5O1xuICAgIH07XG5cbiAgICBzZWxmLnJlbW92ZUZ1bmN0aW9uV2l0aElkID0gZnVuY3Rpb24odGltZW91dEtleSkge1xuICAgICAgZGVsZXRlZEtleXMucHVzaCh0aW1lb3V0S2V5KTtcblxuICAgICAgZm9yICh2YXIgcnVuQXRNaWxsaXMgaW4gc2NoZWR1bGVkRnVuY3Rpb25zKSB7XG4gICAgICAgIHZhciBmdW5jcyA9IHNjaGVkdWxlZEZ1bmN0aW9uc1tydW5BdE1pbGxpc107XG4gICAgICAgIHZhciBpID0gaW5kZXhPZkZpcnN0VG9QYXNzKGZ1bmNzLCBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICAgIHJldHVybiBmdW5jLnRpbWVvdXRLZXkgPT09IHRpbWVvdXRLZXk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICBpZiAoZnVuY3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBkZWxldGUgc2NoZWR1bGVkRnVuY3Rpb25zW3J1bkF0TWlsbGlzXTtcbiAgICAgICAgICAgIGRlbGV0ZUZyb21Mb29rdXAocnVuQXRNaWxsaXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmdW5jcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaW50ZXJ2YWxzIGdldCByZXNjaGVkdWxlZCB3aGVuIGV4ZWN1dGVkLCBzbyB0aGVyZSdzIG5ldmVyIG1vcmVcbiAgICAgICAgICAvLyB0aGFuIGEgc2luZ2xlIHNjaGVkdWxlZCBmdW5jdGlvbiB3aXRoIGEgZ2l2ZW4gdGltZW91dEtleVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xuXG4gICAgZnVuY3Rpb24gaW5kZXhPZkZpcnN0VG9QYXNzKGFycmF5LCB0ZXN0Rm4pIHtcbiAgICAgIHZhciBpbmRleCA9IC0xO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICh0ZXN0Rm4oYXJyYXlbaV0pKSB7XG4gICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWxldGVGcm9tTG9va3VwKGtleSkge1xuICAgICAgdmFyIHZhbHVlID0gTnVtYmVyKGtleSk7XG4gICAgICB2YXIgaSA9IGluZGV4T2ZGaXJzdFRvUGFzcyhzY2hlZHVsZWRMb29rdXAsIGZ1bmN0aW9uIChtaWxsaXMpIHtcbiAgICAgICAgcmV0dXJuIG1pbGxpcyA9PT0gdmFsdWU7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICBzY2hlZHVsZWRMb29rdXAuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2NoZWR1bGUoc2NoZWR1bGVkRm4pIHtcbiAgICAgIHNlbGYuc2NoZWR1bGVGdW5jdGlvbihzY2hlZHVsZWRGbi5mdW5jVG9DYWxsLFxuICAgICAgICBzY2hlZHVsZWRGbi5taWxsaXMsXG4gICAgICAgIHNjaGVkdWxlZEZuLnBhcmFtcyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgc2NoZWR1bGVkRm4udGltZW91dEtleSxcbiAgICAgICAgc2NoZWR1bGVkRm4ucnVuQXRNaWxsaXMgKyBzY2hlZHVsZWRGbi5taWxsaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvckVhY2hGdW5jdGlvbihmdW5jc1RvUnVuLCBjYWxsYmFjaykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jc1RvUnVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNhbGxiYWNrKGZ1bmNzVG9SdW5baV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1blNjaGVkdWxlZEZ1bmN0aW9ucyhlbmRUaW1lLCB0aWNrRGF0ZSkge1xuICAgICAgdGlja0RhdGUgPSB0aWNrRGF0ZSB8fCBmdW5jdGlvbigpIHt9O1xuICAgICAgaWYgKHNjaGVkdWxlZExvb2t1cC5sZW5ndGggPT09IDAgfHwgc2NoZWR1bGVkTG9va3VwWzBdID4gZW5kVGltZSkge1xuICAgICAgICB0aWNrRGF0ZShlbmRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRvIHtcbiAgICAgICAgZGVsZXRlZEtleXMgPSBbXTtcbiAgICAgICAgdmFyIG5ld0N1cnJlbnRUaW1lID0gc2NoZWR1bGVkTG9va3VwLnNoaWZ0KCk7XG4gICAgICAgIHRpY2tEYXRlKG5ld0N1cnJlbnRUaW1lIC0gY3VycmVudFRpbWUpO1xuXG4gICAgICAgIGN1cnJlbnRUaW1lID0gbmV3Q3VycmVudFRpbWU7XG5cbiAgICAgICAgdmFyIGZ1bmNzVG9SdW4gPSBzY2hlZHVsZWRGdW5jdGlvbnNbY3VycmVudFRpbWVdO1xuXG4gICAgICAgIGRlbGV0ZSBzY2hlZHVsZWRGdW5jdGlvbnNbY3VycmVudFRpbWVdO1xuXG4gICAgICAgIGZvckVhY2hGdW5jdGlvbihmdW5jc1RvUnVuLCBmdW5jdGlvbihmdW5jVG9SdW4pIHtcbiAgICAgICAgICBpZiAoZnVuY1RvUnVuLnJlY3VycmluZykge1xuICAgICAgICAgICAgcmVzY2hlZHVsZShmdW5jVG9SdW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yRWFjaEZ1bmN0aW9uKGZ1bmNzVG9SdW4sIGZ1bmN0aW9uKGZ1bmNUb1J1bikge1xuICAgICAgICAgIGlmIChqJC51dGlsLmFycmF5Q29udGFpbnMoZGVsZXRlZEtleXMsIGZ1bmNUb1J1bi50aW1lb3V0S2V5KSkge1xuICAgICAgICAgICAgLy8gc2tpcCBhIHRpbWVvdXRLZXkgZGVsZXRlZCB3aGlsc3Qgd2Ugd2VyZSBydW5uaW5nXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmNUb1J1bi5mdW5jVG9DYWxsLmFwcGx5KG51bGwsIGZ1bmNUb1J1bi5wYXJhbXMgfHwgW10pO1xuICAgICAgICB9KTtcbiAgICAgIH0gd2hpbGUgKHNjaGVkdWxlZExvb2t1cC5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgIC8vIGNoZWNraW5nIGZpcnN0IGlmIHdlJ3JlIG91dCBvZiB0aW1lIHByZXZlbnRzIHNldFRpbWVvdXQoMClcbiAgICAgICAgICAgICAgLy8gc2NoZWR1bGVkIGluIGEgZnVuY1RvUnVuIGZyb20gZm9yY2luZyBhbiBleHRyYSBpdGVyYXRpb25cbiAgICAgICAgICAgICAgICAgY3VycmVudFRpbWUgIT09IGVuZFRpbWUgICYmXG4gICAgICAgICAgICAgICAgIHNjaGVkdWxlZExvb2t1cFswXSA8PSBlbmRUaW1lKTtcblxuICAgICAgLy8gcmFuIG91dCBvZiBmdW5jdGlvbnMgdG8gY2FsbCwgYnV0IHN0aWxsIHRpbWUgbGVmdCBvbiB0aGUgY2xvY2tcbiAgICAgIGlmIChjdXJyZW50VGltZSAhPT0gZW5kVGltZSkge1xuICAgICAgICB0aWNrRGF0ZShlbmRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBEZWxheWVkRnVuY3Rpb25TY2hlZHVsZXI7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLmVycm9ycyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBFeHBlY3RhdGlvbkZhaWxlZCgpIHt9XG5cbiAgRXhwZWN0YXRpb25GYWlsZWQucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gIEV4cGVjdGF0aW9uRmFpbGVkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV4cGVjdGF0aW9uRmFpbGVkO1xuXG4gIHJldHVybiB7XG4gICAgRXhwZWN0YXRpb25GYWlsZWQ6IEV4cGVjdGF0aW9uRmFpbGVkXG4gIH07XG59O1xuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5FeGNlcHRpb25Gb3JtYXR0ZXIgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gRXhjZXB0aW9uRm9ybWF0dGVyKCkge1xuICAgIHRoaXMubWVzc2FnZSA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICB2YXIgbWVzc2FnZSA9ICcnO1xuXG4gICAgICBpZiAoZXJyb3IubmFtZSAmJiBlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gZXJyb3IubmFtZSArICc6ICcgKyBlcnJvci5tZXNzYWdlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZSArPSBlcnJvci50b1N0cmluZygpICsgJyB0aHJvd24nO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXJyb3IuZmlsZU5hbWUgfHwgZXJyb3Iuc291cmNlVVJMKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gJyBpbiAnICsgKGVycm9yLmZpbGVOYW1lIHx8IGVycm9yLnNvdXJjZVVSTCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnJvci5saW5lIHx8IGVycm9yLmxpbmVOdW1iZXIpIHtcbiAgICAgICAgbWVzc2FnZSArPSAnIChsaW5lICcgKyAoZXJyb3IubGluZSB8fCBlcnJvci5saW5lTnVtYmVyKSArICcpJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcblxuICAgIHRoaXMuc3RhY2sgPSBmdW5jdGlvbihlcnJvcikge1xuICAgICAgcmV0dXJuIGVycm9yID8gZXJyb3Iuc3RhY2sgOiBudWxsO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gRXhjZXB0aW9uRm9ybWF0dGVyO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5FeHBlY3RhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG4gIC8qKlxuICAgKiBNYXRjaGVycyB0aGF0IGNvbWUgd2l0aCBKYXNtaW5lIG91dCBvZiB0aGUgYm94LlxuICAgKiBAbmFtZXNwYWNlIG1hdGNoZXJzXG4gICAqL1xuICBmdW5jdGlvbiBFeHBlY3RhdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy51dGlsID0gb3B0aW9ucy51dGlsIHx8IHsgYnVpbGRGYWlsdXJlTWVzc2FnZTogZnVuY3Rpb24oKSB7fSB9O1xuICAgIHRoaXMuY3VzdG9tRXF1YWxpdHlUZXN0ZXJzID0gb3B0aW9ucy5jdXN0b21FcXVhbGl0eVRlc3RlcnMgfHwgW107XG4gICAgdGhpcy5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcbiAgICB0aGlzLmFkZEV4cGVjdGF0aW9uUmVzdWx0ID0gb3B0aW9ucy5hZGRFeHBlY3RhdGlvblJlc3VsdCB8fCBmdW5jdGlvbigpe307XG4gICAgdGhpcy5pc05vdCA9IG9wdGlvbnMuaXNOb3Q7XG5cbiAgICB2YXIgY3VzdG9tTWF0Y2hlcnMgPSBvcHRpb25zLmN1c3RvbU1hdGNoZXJzIHx8IHt9O1xuICAgIGZvciAodmFyIG1hdGNoZXJOYW1lIGluIGN1c3RvbU1hdGNoZXJzKSB7XG4gICAgICB0aGlzW21hdGNoZXJOYW1lXSA9IEV4cGVjdGF0aW9uLnByb3RvdHlwZS53cmFwQ29tcGFyZShtYXRjaGVyTmFtZSwgY3VzdG9tTWF0Y2hlcnNbbWF0Y2hlck5hbWVdKTtcbiAgICB9XG4gIH1cblxuICBFeHBlY3RhdGlvbi5wcm90b3R5cGUud3JhcENvbXBhcmUgPSBmdW5jdGlvbihuYW1lLCBtYXRjaGVyRmFjdG9yeSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSxcbiAgICAgICAgZXhwZWN0ZWQgPSBhcmdzLnNsaWNlKDApLFxuICAgICAgICBtZXNzYWdlID0gJyc7XG5cbiAgICAgIGFyZ3MudW5zaGlmdCh0aGlzLmFjdHVhbCk7XG5cbiAgICAgIHZhciBtYXRjaGVyID0gbWF0Y2hlckZhY3RvcnkodGhpcy51dGlsLCB0aGlzLmN1c3RvbUVxdWFsaXR5VGVzdGVycyksXG4gICAgICAgICAgbWF0Y2hlckNvbXBhcmUgPSBtYXRjaGVyLmNvbXBhcmU7XG5cbiAgICAgIGZ1bmN0aW9uIGRlZmF1bHROZWdhdGl2ZUNvbXBhcmUoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBtYXRjaGVyLmNvbXBhcmUuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIHJlc3VsdC5wYXNzID0gIXJlc3VsdC5wYXNzO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc05vdCkge1xuICAgICAgICBtYXRjaGVyQ29tcGFyZSA9IG1hdGNoZXIubmVnYXRpdmVDb21wYXJlIHx8IGRlZmF1bHROZWdhdGl2ZUNvbXBhcmU7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBtYXRjaGVyQ29tcGFyZS5hcHBseShudWxsLCBhcmdzKTtcblxuICAgICAgaWYgKCFyZXN1bHQucGFzcykge1xuICAgICAgICBpZiAoIXJlc3VsdC5tZXNzYWdlKSB7XG4gICAgICAgICAgYXJncy51bnNoaWZ0KHRoaXMuaXNOb3QpO1xuICAgICAgICAgIGFyZ3MudW5zaGlmdChuYW1lKTtcbiAgICAgICAgICBtZXNzYWdlID0gdGhpcy51dGlsLmJ1aWxkRmFpbHVyZU1lc3NhZ2UuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkocmVzdWx0Lm1lc3NhZ2UpID09PSAnW29iamVjdCBGdW5jdGlvbl0nKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gcmVzdWx0Lm1lc3NhZ2UoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSA9IHJlc3VsdC5tZXNzYWdlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZXhwZWN0ZWQubGVuZ3RoID09IDEpIHtcbiAgICAgICAgZXhwZWN0ZWQgPSBleHBlY3RlZFswXTtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogaG93IG1hbnkgb2YgdGhlc2UgcGFyYW1zIGFyZSBuZWVkZWQ/XG4gICAgICB0aGlzLmFkZEV4cGVjdGF0aW9uUmVzdWx0KFxuICAgICAgICByZXN1bHQucGFzcyxcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoZXJOYW1lOiBuYW1lLFxuICAgICAgICAgIHBhc3NlZDogcmVzdWx0LnBhc3MsXG4gICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICBlcnJvcjogcmVzdWx0LmVycm9yLFxuICAgICAgICAgIGFjdHVhbDogdGhpcy5hY3R1YWwsXG4gICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkIC8vIFRPRE86IHRoaXMgbWF5IG5lZWQgdG8gYmUgYXJyYXlpZmllZC9zbGljZWRcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9O1xuICB9O1xuXG4gIEV4cGVjdGF0aW9uLmFkZENvcmVNYXRjaGVycyA9IGZ1bmN0aW9uKG1hdGNoZXJzKSB7XG4gICAgdmFyIHByb3RvdHlwZSA9IEV4cGVjdGF0aW9uLnByb3RvdHlwZTtcbiAgICBmb3IgKHZhciBtYXRjaGVyTmFtZSBpbiBtYXRjaGVycykge1xuICAgICAgdmFyIG1hdGNoZXIgPSBtYXRjaGVyc1ttYXRjaGVyTmFtZV07XG4gICAgICBwcm90b3R5cGVbbWF0Y2hlck5hbWVdID0gcHJvdG90eXBlLndyYXBDb21wYXJlKG1hdGNoZXJOYW1lLCBtYXRjaGVyKTtcbiAgICB9XG4gIH07XG5cbiAgRXhwZWN0YXRpb24uRmFjdG9yeSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBleHBlY3QgPSBuZXcgRXhwZWN0YXRpb24ob3B0aW9ucyk7XG5cbiAgICAvLyBUT0RPOiB0aGlzIHdvdWxkIGJlIG5pY2UgYXMgaXRzIG93biBPYmplY3QgLSBOZWdhdGl2ZUV4cGVjdGF0aW9uXG4gICAgLy8gVE9ETzogY29weSBpbnN0ZWFkIG9mIG11dGF0ZSBvcHRpb25zXG4gICAgb3B0aW9ucy5pc05vdCA9IHRydWU7XG4gICAgZXhwZWN0Lm5vdCA9IG5ldyBFeHBlY3RhdGlvbihvcHRpb25zKTtcblxuICAgIHJldHVybiBleHBlY3Q7XG4gIH07XG5cbiAgcmV0dXJuIEV4cGVjdGF0aW9uO1xufTtcblxuLy9UT0RPOiBleHBlY3RhdGlvbiByZXN1bHQgbWF5IG1ha2UgbW9yZSBzZW5zZSBhcyBhIHByZXNlbnRhdGlvbiBvZiBhbiBleHBlY3RhdGlvbi5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuYnVpbGRFeHBlY3RhdGlvblJlc3VsdCA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBidWlsZEV4cGVjdGF0aW9uUmVzdWx0KG9wdGlvbnMpIHtcbiAgICB2YXIgbWVzc2FnZUZvcm1hdHRlciA9IG9wdGlvbnMubWVzc2FnZUZvcm1hdHRlciB8fCBmdW5jdGlvbigpIHt9LFxuICAgICAgc3RhY2tGb3JtYXR0ZXIgPSBvcHRpb25zLnN0YWNrRm9ybWF0dGVyIHx8IGZ1bmN0aW9uKCkge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiBFeHBlY3RhdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBtYXRjaGVyTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBtYXRjaGVyIHRoYXQgd2FzIGV4ZWN1dGVkIGZvciB0aGlzIGV4cGVjdGF0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBtZXNzYWdlIC0gVGhlIGZhaWx1cmUgbWVzc2FnZSBmb3IgdGhlIGV4cGVjdGF0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzdGFjayAtIFRoZSBzdGFjayB0cmFjZSBmb3IgdGhlIGZhaWx1cmUgaWYgYXZhaWxhYmxlLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gcGFzc2VkIC0gV2hldGhlciB0aGUgZXhwZWN0YXRpb24gcGFzc2VkIG9yIGZhaWxlZC5cbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gZXhwZWN0ZWQgLSBJZiB0aGUgZXhwZWN0YXRpb24gZmFpbGVkLCB3aGF0IHdhcyB0aGUgZXhwZWN0ZWQgdmFsdWUuXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IGFjdHVhbCAtIElmIHRoZSBleHBlY3RhdGlvbiBmYWlsZWQsIHdoYXQgYWN0dWFsIHZhbHVlIHdhcyBwcm9kdWNlZC5cbiAgICAgKi9cbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgbWF0Y2hlck5hbWU6IG9wdGlvbnMubWF0Y2hlck5hbWUsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlKCksXG4gICAgICBzdGFjazogc3RhY2soKSxcbiAgICAgIHBhc3NlZDogb3B0aW9ucy5wYXNzZWRcbiAgICB9O1xuXG4gICAgaWYoIXJlc3VsdC5wYXNzZWQpIHtcbiAgICAgIHJlc3VsdC5leHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gICAgICByZXN1bHQuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGZ1bmN0aW9uIG1lc3NhZ2UoKSB7XG4gICAgICBpZiAob3B0aW9ucy5wYXNzZWQpIHtcbiAgICAgICAgcmV0dXJuICdQYXNzZWQuJztcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5tZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLm1lc3NhZ2U7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VGb3JtYXR0ZXIob3B0aW9ucy5lcnJvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhY2soKSB7XG4gICAgICBpZiAob3B0aW9ucy5wYXNzZWQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXJyb3IgPSBvcHRpb25zLmVycm9yO1xuICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKCkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhY2tGb3JtYXR0ZXIoZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWlsZEV4cGVjdGF0aW9uUmVzdWx0O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5mb3JtYXRFcnJvck1zZyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBnZW5lcmF0ZUVycm9yTXNnKGRvbWFpbiwgdXNhZ2UpIHtcbiAgICB2YXIgdXNhZ2VEZWZpbml0aW9uID0gdXNhZ2UgPyAnXFxuVXNhZ2U6ICcgKyB1c2FnZSA6ICcnO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGVycm9yTXNnKG1zZykge1xuICAgICAgcmV0dXJuIGRvbWFpbiArICcgOiAnICsgbXNnICsgdXNhZ2VEZWZpbml0aW9uO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZ2VuZXJhdGVFcnJvck1zZztcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuR2xvYmFsRXJyb3JzID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gR2xvYmFsRXJyb3JzKGdsb2JhbCkge1xuICAgIHZhciBoYW5kbGVycyA9IFtdO1xuICAgIGdsb2JhbCA9IGdsb2JhbCB8fCBqJC5nZXRHbG9iYWwoKTtcblxuICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24gb25lcnJvcigpIHtcbiAgICAgIHZhciBoYW5kbGVyID0gaGFuZGxlcnNbaGFuZGxlcnMubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkobnVsbCwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMudW5pbnN0YWxsID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG4gICAgdGhpcy5pbnN0YWxsID0gZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgICAgIGlmIChnbG9iYWwucHJvY2VzcyAmJiBnbG9iYWwucHJvY2Vzcy5saXN0ZW5lcnMgJiYgaiQuaXNGdW5jdGlvbl8oZ2xvYmFsLnByb2Nlc3Mub24pKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbEhhbmRsZXJzID0gZ2xvYmFsLnByb2Nlc3MubGlzdGVuZXJzKCd1bmNhdWdodEV4Y2VwdGlvbicpO1xuICAgICAgICBnbG9iYWwucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3VuY2F1Z2h0RXhjZXB0aW9uJyk7XG4gICAgICAgIGdsb2JhbC5wcm9jZXNzLm9uKCd1bmNhdWdodEV4Y2VwdGlvbicsIG9uZXJyb3IpO1xuXG4gICAgICAgIHRoaXMudW5pbnN0YWxsID0gZnVuY3Rpb24gdW5pbnN0YWxsKCkge1xuICAgICAgICAgIGdsb2JhbC5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyKCd1bmNhdWdodEV4Y2VwdGlvbicsIG9uZXJyb3IpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JpZ2luYWxIYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZ2xvYmFsLnByb2Nlc3Mub24oJ3VuY2F1Z2h0RXhjZXB0aW9uJywgb3JpZ2luYWxIYW5kbGVyc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsSGFuZGxlciA9IGdsb2JhbC5vbmVycm9yO1xuICAgICAgICBnbG9iYWwub25lcnJvciA9IG9uZXJyb3I7XG5cbiAgICAgICAgdGhpcy51bmluc3RhbGwgPSBmdW5jdGlvbiB1bmluc3RhbGwoKSB7XG4gICAgICAgICAgZ2xvYmFsLm9uZXJyb3IgPSBvcmlnaW5hbEhhbmRsZXI7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMucHVzaExpc3RlbmVyID0gZnVuY3Rpb24gcHVzaExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICBoYW5kbGVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9O1xuXG4gICAgdGhpcy5wb3BMaXN0ZW5lciA9IGZ1bmN0aW9uIHBvcExpc3RlbmVyKCkge1xuICAgICAgaGFuZGxlcnMucG9wKCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBHbG9iYWxFcnJvcnM7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkRpZmZCdWlsZGVyID0gZnVuY3Rpb24oaiQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIERpZmZCdWlsZGVyKCkge1xuICAgIHZhciBwYXRoID0gbmV3IGokLk9iamVjdFBhdGgoKSxcbiAgICAgICAgbWlzbWF0Y2hlcyA9IFtdO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY29yZDogZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIGZvcm1hdHRlcikge1xuICAgICAgICBmb3JtYXR0ZXIgPSBmb3JtYXR0ZXIgfHwgZGVmYXVsdEZvcm1hdHRlcjtcbiAgICAgICAgbWlzbWF0Y2hlcy5wdXNoKGZvcm1hdHRlcihhY3R1YWwsIGV4cGVjdGVkLCBwYXRoKSk7XG4gICAgICB9LFxuXG4gICAgICBnZXRNZXNzYWdlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtaXNtYXRjaGVzLmpvaW4oJ1xcbicpO1xuICAgICAgfSxcblxuICAgICAgd2l0aFBhdGg6IGZ1bmN0aW9uIChwYXRoQ29tcG9uZW50LCBibG9jaykge1xuICAgICAgICB2YXIgb2xkUGF0aCA9IHBhdGg7XG4gICAgICAgIHBhdGggPSBwYXRoLmFkZChwYXRoQ29tcG9uZW50KTtcbiAgICAgICAgYmxvY2soKTtcbiAgICAgICAgcGF0aCA9IG9sZFBhdGg7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRGb3JtYXR0ZXIgKGFjdHVhbCwgZXhwZWN0ZWQsIHBhdGgpIHtcbiAgICAgIHJldHVybiAnRXhwZWN0ZWQgJyArXG4gICAgICAgIHBhdGggKyAocGF0aC5kZXB0aCgpID8gJyA9ICcgOiAnJykgK1xuICAgICAgICBqJC5wcChhY3R1YWwpICtcbiAgICAgICAgJyB0byBlcXVhbCAnICtcbiAgICAgICAgaiQucHAoZXhwZWN0ZWQpICtcbiAgICAgICAgJy4nO1xuICAgIH1cbiAgfTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkubWF0Y2hlcnNVdGlsID0gZnVuY3Rpb24oaiQpIHtcbiAgLy8gVE9ETzogd2hhdCB0byBkbyBhYm91dCBqYXNtaW5lLnBwIG5vdCBiZWluZyBpbmplY3Q/IG1vdmUgdG8gSlNPTi5zdHJpbmdpZnk/IGd1dCBQcmV0dHlQcmludGVyP1xuXG4gIHJldHVybiB7XG4gICAgZXF1YWxzOiBlcXVhbHMsXG5cbiAgICBjb250YWluczogZnVuY3Rpb24oaGF5c3RhY2ssIG5lZWRsZSwgY3VzdG9tVGVzdGVycykge1xuICAgICAgY3VzdG9tVGVzdGVycyA9IGN1c3RvbVRlc3RlcnMgfHwgW107XG5cbiAgICAgIGlmICgoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShoYXlzdGFjaykgPT09ICdbb2JqZWN0IFNldF0nKSkge1xuICAgICAgICByZXR1cm4gaGF5c3RhY2suaGFzKG5lZWRsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICgoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShoYXlzdGFjaykgPT09ICdbb2JqZWN0IEFycmF5XScpIHx8XG4gICAgICAgICghIWhheXN0YWNrICYmICFoYXlzdGFjay5pbmRleE9mKSlcbiAgICAgIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYXlzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChlcXVhbHMoaGF5c3RhY2tbaV0sIG5lZWRsZSwgY3VzdG9tVGVzdGVycykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhIWhheXN0YWNrICYmIGhheXN0YWNrLmluZGV4T2YobmVlZGxlKSA+PSAwO1xuICAgIH0sXG5cbiAgICBidWlsZEZhaWx1cmVNZXNzYWdlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSxcbiAgICAgICAgbWF0Y2hlck5hbWUgPSBhcmdzWzBdLFxuICAgICAgICBpc05vdCA9IGFyZ3NbMV0sXG4gICAgICAgIGFjdHVhbCA9IGFyZ3NbMl0sXG4gICAgICAgIGV4cGVjdGVkID0gYXJncy5zbGljZSgzKSxcbiAgICAgICAgZW5nbGlzaHlQcmVkaWNhdGUgPSBtYXRjaGVyTmFtZS5yZXBsYWNlKC9bQS1aXS9nLCBmdW5jdGlvbihzKSB7IHJldHVybiAnICcgKyBzLnRvTG93ZXJDYXNlKCk7IH0pO1xuXG4gICAgICB2YXIgbWVzc2FnZSA9ICdFeHBlY3RlZCAnICtcbiAgICAgICAgaiQucHAoYWN0dWFsKSArXG4gICAgICAgIChpc05vdCA/ICcgbm90ICcgOiAnICcpICtcbiAgICAgICAgZW5nbGlzaHlQcmVkaWNhdGU7XG5cbiAgICAgIGlmIChleHBlY3RlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gJywnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZXNzYWdlICs9ICcgJyArIGokLnBwKGV4cGVjdGVkW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVzc2FnZSArICcuJztcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNBc3ltbWV0cmljKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgaiQuaXNBXygnRnVuY3Rpb24nLCBvYmouYXN5bW1ldHJpY01hdGNoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzeW1tZXRyaWNNYXRjaChhLCBiLCBjdXN0b21UZXN0ZXJzLCBkaWZmQnVpbGRlcikge1xuICAgIHZhciBhc3ltbWV0cmljQSA9IGlzQXN5bW1ldHJpYyhhKSxcbiAgICAgICAgYXN5bW1ldHJpY0IgPSBpc0FzeW1tZXRyaWMoYiksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChhc3ltbWV0cmljQSAmJiBhc3ltbWV0cmljQikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoYXN5bW1ldHJpY0EpIHtcbiAgICAgIHJlc3VsdCA9IGEuYXN5bW1ldHJpY01hdGNoKGIsIGN1c3RvbVRlc3RlcnMpO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkKGEsIGIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAoYXN5bW1ldHJpY0IpIHtcbiAgICAgIHJlc3VsdCA9IGIuYXN5bW1ldHJpY01hdGNoKGEsIGN1c3RvbVRlc3RlcnMpO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkKGEsIGIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlcXVhbHMoYSwgYiwgY3VzdG9tVGVzdGVycywgZGlmZkJ1aWxkZXIpIHtcbiAgICBjdXN0b21UZXN0ZXJzID0gY3VzdG9tVGVzdGVycyB8fCBbXTtcbiAgICBkaWZmQnVpbGRlciA9IGRpZmZCdWlsZGVyIHx8IGokLk51bGxEaWZmQnVpbGRlcigpO1xuXG4gICAgcmV0dXJuIGVxKGEsIGIsIFtdLCBbXSwgY3VzdG9tVGVzdGVycywgZGlmZkJ1aWxkZXIpO1xuICB9XG5cbiAgLy8gRXF1YWxpdHkgZnVuY3Rpb24gbG92aW5nbHkgYWRhcHRlZCBmcm9tIGlzRXF1YWwgaW5cbiAgLy8gICBbVW5kZXJzY29yZV0oaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcpXG4gIGZ1bmN0aW9uIGVxKGEsIGIsIGFTdGFjaywgYlN0YWNrLCBjdXN0b21UZXN0ZXJzLCBkaWZmQnVpbGRlcikge1xuICAgIHZhciByZXN1bHQgPSB0cnVlLCBpO1xuXG4gICAgdmFyIGFzeW1tZXRyaWNSZXN1bHQgPSBhc3ltbWV0cmljTWF0Y2goYSwgYiwgY3VzdG9tVGVzdGVycywgZGlmZkJ1aWxkZXIpO1xuICAgIGlmICghaiQudXRpbC5pc1VuZGVmaW5lZChhc3ltbWV0cmljUmVzdWx0KSkge1xuICAgICAgcmV0dXJuIGFzeW1tZXRyaWNSZXN1bHQ7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGN1c3RvbVRlc3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjdXN0b21UZXN0ZXJSZXN1bHQgPSBjdXN0b21UZXN0ZXJzW2ldKGEsIGIpO1xuICAgICAgaWYgKCFqJC51dGlsLmlzVW5kZWZpbmVkKGN1c3RvbVRlc3RlclJlc3VsdCkpIHtcbiAgICAgICAgaWYgKCFjdXN0b21UZXN0ZXJSZXN1bHQpIHtcbiAgICAgICAgICBkaWZmQnVpbGRlci5yZWNvcmQoYSwgYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1c3RvbVRlc3RlclJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIEVycm9yICYmIGIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmVzdWx0ID0gYS5tZXNzYWdlID09IGIubWVzc2FnZTtcbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIGRpZmZCdWlsZGVyLnJlY29yZChhLCBiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSB7XG4gICAgICByZXN1bHQgPSBhICE9PSAwIHx8IDEgLyBhID09IDEgLyBiO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkKGEsIGIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09PSBudWxsIHx8IGIgPT09IG51bGwpIHtcbiAgICAgIHJlc3VsdCA9IGEgPT09IGI7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBkaWZmQnVpbGRlci5yZWNvcmQoYSwgYik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB2YXIgY2xhc3NOYW1lID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGIpKSB7XG4gICAgICBkaWZmQnVpbGRlci5yZWNvcmQoYSwgYik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAvLyBTdHJpbmdzLCBudW1iZXJzLCBkYXRlcywgYW5kIGJvb2xlYW5zIGFyZSBjb21wYXJlZCBieSB2YWx1ZS5cbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgICAgcmVzdWx0ID0gYSA9PSBTdHJpbmcoYik7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkKGEsIGIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgICAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLiBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yXG4gICAgICAgIC8vIG90aGVyIG51bWVyaWMgdmFsdWVzLlxuICAgICAgICByZXN1bHQgPSBhICE9ICthID8gYiAhPSArYiA6IChhID09PSAwID8gMSAvIGEgPT0gMSAvIGIgOiBhID09ICtiKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICBkaWZmQnVpbGRlci5yZWNvcmQoYSwgYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xuICAgICAgICAvLyBvZiBgTmFOYCBhcmUgbm90IGVxdWl2YWxlbnQuXG4gICAgICAgIHJlc3VsdCA9ICthID09ICtiO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIGRpZmZCdWlsZGVyLnJlY29yZChhLCBiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgLy8gUmVnRXhwcyBhcmUgY29tcGFyZWQgYnkgdGhlaXIgc291cmNlIHBhdHRlcm5zIGFuZCBmbGFncy5cbiAgICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XG4gICAgICAgIHJldHVybiBhLnNvdXJjZSA9PSBiLnNvdXJjZSAmJlxuICAgICAgICAgIGEuZ2xvYmFsID09IGIuZ2xvYmFsICYmXG4gICAgICAgICAgYS5tdWx0aWxpbmUgPT0gYi5tdWx0aWxpbmUgJiZcbiAgICAgICAgICBhLmlnbm9yZUNhc2UgPT0gYi5pZ25vcmVDYXNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHtcbiAgICAgIGRpZmZCdWlsZGVyLnJlY29yZChhLCBiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgYUlzRG9tTm9kZSA9IGokLmlzRG9tTm9kZShhKTtcbiAgICB2YXIgYklzRG9tTm9kZSA9IGokLmlzRG9tTm9kZShiKTtcbiAgICBpZiAoYUlzRG9tTm9kZSAmJiBiSXNEb21Ob2RlKSB7XG4gICAgICAvLyBBdCBmaXJzdCB0cnkgdG8gdXNlIERPTTMgbWV0aG9kIGlzRXF1YWxOb2RlXG4gICAgICBpZiAoYS5pc0VxdWFsTm9kZSkge1xuICAgICAgICByZXN1bHQgPSBhLmlzRXF1YWxOb2RlKGIpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIGRpZmZCdWlsZGVyLnJlY29yZChhLCBiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgLy8gSUU4IGRvZXNuJ3Qgc3VwcG9ydCBpc0VxdWFsTm9kZSwgdHJ5IHRvIHVzZSBvdXRlckhUTUwgJiYgaW5uZXJUZXh0XG4gICAgICB2YXIgYUlzRWxlbWVudCA9IGEgaW5zdGFuY2VvZiBFbGVtZW50O1xuICAgICAgdmFyIGJJc0VsZW1lbnQgPSBiIGluc3RhbmNlb2YgRWxlbWVudDtcbiAgICAgIGlmIChhSXNFbGVtZW50ICYmIGJJc0VsZW1lbnQpIHtcbiAgICAgICAgcmVzdWx0ID0gYS5vdXRlckhUTUwgPT0gYi5vdXRlckhUTUw7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkKGEsIGIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoYUlzRWxlbWVudCB8fCBiSXNFbGVtZW50KSB7XG4gICAgICAgIGRpZmZCdWlsZGVyLnJlY29yZChhLCBiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gYS5pbm5lclRleHQgPT0gYi5pbm5lclRleHQgJiYgYS50ZXh0Q29udGVudCA9PSBiLnRleHRDb250ZW50O1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkKGEsIGIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKGFJc0RvbU5vZGUgfHwgYklzRG9tTm9kZSkge1xuICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkKGEsIGIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBhSXNQcm9taXNlID0gaiQuaXNQcm9taXNlKGEpO1xuICAgIHZhciBiSXNQcm9taXNlID0gaiQuaXNQcm9taXNlKGIpO1xuICAgIGlmIChhSXNQcm9taXNlICYmIGJJc1Byb21pc2UpIHtcbiAgICAgIHJldHVybiBhID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgICAvLyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYC5cbiAgICB2YXIgbGVuZ3RoID0gYVN0YWNrLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLlxuICAgICAgaWYgKGFTdGFja1tsZW5ndGhdID09IGEpIHsgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09IGI7IH1cbiAgICB9XG4gICAgLy8gQWRkIHRoZSBmaXJzdCBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wdXNoKGEpO1xuICAgIGJTdGFjay5wdXNoKGIpO1xuICAgIHZhciBzaXplID0gMDtcbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICBpZiAoY2xhc3NOYW1lID09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHZhciBhTGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICB2YXIgYkxlbmd0aCA9IGIubGVuZ3RoO1xuXG4gICAgICBkaWZmQnVpbGRlci53aXRoUGF0aCgnbGVuZ3RoJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChhTGVuZ3RoICE9PSBiTGVuZ3RoKSB7XG4gICAgICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkKGFMZW5ndGgsIGJMZW5ndGgpO1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGFMZW5ndGggfHwgaSA8IGJMZW5ndGg7IGkrKykge1xuICAgICAgICBkaWZmQnVpbGRlci53aXRoUGF0aChpLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXN1bHQgPSBlcShpIDwgYUxlbmd0aCA/IGFbaV0gOiB2b2lkIDAsIGkgPCBiTGVuZ3RoID8gYltpXSA6IHZvaWQgMCwgYVN0YWNrLCBiU3RhY2ssIGN1c3RvbVRlc3RlcnMsIGRpZmZCdWlsZGVyKSAmJiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaiQuaXNNYXAoYSkgJiYgaiQuaXNNYXAoYikpIHtcbiAgICAgIGlmIChhLnNpemUgIT0gYi5zaXplKSB7XG4gICAgICAgIGRpZmZCdWlsZGVyLnJlY29yZChhLCBiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIga2V5c0EgPSBbXTtcbiAgICAgIHZhciBrZXlzQiA9IFtdO1xuICAgICAgYS5mb3JFYWNoKCBmdW5jdGlvbiggdmFsdWVBLCBrZXlBICkge1xuICAgICAgICBrZXlzQS5wdXNoKCBrZXlBICk7XG4gICAgICB9KTtcbiAgICAgIGIuZm9yRWFjaCggZnVuY3Rpb24oIHZhbHVlQiwga2V5QiApIHtcbiAgICAgICAga2V5c0IucHVzaCgga2V5QiApO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEZvciBib3RoIHNldHMgb2Yga2V5cywgY2hlY2sgdGhleSBtYXAgdG8gZXF1YWwgdmFsdWVzIGluIGJvdGggbWFwcy5cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgY29ycmVzcG9uZGluZyBrZXlzIChpbiBpbnNlcnRpb24gb3JkZXIpIGluIG9yZGVyIHRvIGhhbmRsZSBhc3ltbWV0cmljIG9iaiBrZXlzLlxuICAgICAgdmFyIG1hcEtleXMgPSBba2V5c0EsIGtleXNCXTtcbiAgICAgIHZhciBjbXBLZXlzID0gW2tleXNCLCBrZXlzQV07XG4gICAgICB2YXIgbWFwSXRlciwgbWFwS2V5LCBtYXBWYWx1ZUEsIG1hcFZhbHVlQjtcbiAgICAgIHZhciBjbXBJdGVyLCBjbXBLZXk7XG4gICAgICBmb3IgKGkgPSAwOyByZXN1bHQgJiYgaSA8IG1hcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWFwSXRlciA9IG1hcEtleXNbaV07XG4gICAgICAgIGNtcEl0ZXIgPSBjbXBLZXlzW2ldO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyByZXN1bHQgJiYgaiA8IG1hcEl0ZXIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBtYXBLZXkgPSBtYXBJdGVyW2pdO1xuICAgICAgICAgIGNtcEtleSA9IGNtcEl0ZXJbal07XG4gICAgICAgICAgbWFwVmFsdWVBID0gYS5nZXQobWFwS2V5KTtcblxuICAgICAgICAgIC8vIE9ubHkgdXNlIHRoZSBjbXBLZXkgd2hlbiBvbmUgb2YgdGhlIGtleXMgaXMgYXN5bW1ldHJpYyBhbmQgdGhlIGNvcnJlc3BvbmRpbmcga2V5IG1hdGNoZXMsXG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIGV4cGxpY2l0bHkgbG9vayB1cCB0aGUgbWFwS2V5IGluIHRoZSBvdGhlciBNYXAgc2luY2Ugd2Ugd2FudCBrZXlzIHdpdGggdW5pcXVlXG4gICAgICAgICAgLy8gb2JqIGlkZW50aXR5ICh0aGF0IGFyZSBvdGhlcndpc2UgZXF1YWwpIHRvIG5vdCBtYXRjaC5cbiAgICAgICAgICBpZiAoaXNBc3ltbWV0cmljKG1hcEtleSkgfHwgaXNBc3ltbWV0cmljKGNtcEtleSkgJiZcbiAgICAgICAgICAgICAgZXEobWFwS2V5LCBjbXBLZXksIGFTdGFjaywgYlN0YWNrLCBjdXN0b21UZXN0ZXJzLCBqJC5OdWxsRGlmZkJ1aWxkZXIoKSkpIHtcbiAgICAgICAgICAgIG1hcFZhbHVlQiA9IGIuZ2V0KGNtcEtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hcFZhbHVlQiA9IGIuZ2V0KG1hcEtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IGVxKG1hcFZhbHVlQSwgbWFwVmFsdWVCLCBhU3RhY2ssIGJTdGFjaywgY3VzdG9tVGVzdGVycywgaiQuTnVsbERpZmZCdWlsZGVyKCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIGRpZmZCdWlsZGVyLnJlY29yZChhLCBiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaiQuaXNTZXQoYSkgJiYgaiQuaXNTZXQoYikpIHtcbiAgICAgIGlmIChhLnNpemUgIT0gYi5zaXplKSB7XG4gICAgICAgIGRpZmZCdWlsZGVyLnJlY29yZChhLCBiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzQSA9IFtdO1xuICAgICAgYS5mb3JFYWNoKCBmdW5jdGlvbiggdmFsdWVBICkge1xuICAgICAgICB2YWx1ZXNBLnB1c2goIHZhbHVlQSApO1xuICAgICAgfSk7XG4gICAgICB2YXIgdmFsdWVzQiA9IFtdO1xuICAgICAgYi5mb3JFYWNoKCBmdW5jdGlvbiggdmFsdWVCICkge1xuICAgICAgICB2YWx1ZXNCLnB1c2goIHZhbHVlQiApO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEZvciBib3RoIHNldHMsIGNoZWNrIHRoZXkgYXJlIGFsbCBjb250YWluZWQgaW4gdGhlIG90aGVyIHNldFxuICAgICAgdmFyIHNldFBhaXJzID0gW1t2YWx1ZXNBLCB2YWx1ZXNCXSwgW3ZhbHVlc0IsIHZhbHVlc0FdXTtcbiAgICAgIHZhciBzdGFja1BhaXJzID0gW1thU3RhY2ssIGJTdGFja10sIFtiU3RhY2ssIGFTdGFja11dO1xuICAgICAgdmFyIGJhc2VWYWx1ZXMsIGJhc2VWYWx1ZSwgYmFzZVN0YWNrO1xuICAgICAgdmFyIG90aGVyVmFsdWVzLCBvdGhlclZhbHVlLCBvdGhlclN0YWNrO1xuICAgICAgdmFyIGZvdW5kO1xuICAgICAgdmFyIHByZXZTdGFja1NpemU7XG4gICAgICBmb3IgKGkgPSAwOyByZXN1bHQgJiYgaSA8IHNldFBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJhc2VWYWx1ZXMgPSBzZXRQYWlyc1tpXVswXTtcbiAgICAgICAgb3RoZXJWYWx1ZXMgPSBzZXRQYWlyc1tpXVsxXTtcbiAgICAgICAgYmFzZVN0YWNrID0gc3RhY2tQYWlyc1tpXVswXTtcbiAgICAgICAgb3RoZXJTdGFjayA9IHN0YWNrUGFpcnNbaV1bMV07XG4gICAgICAgIC8vIEZvciBlYWNoIHZhbHVlIGluIHRoZSBiYXNlIHNldC4uLlxuICAgICAgICBmb3IgKHZhciBrID0gMDsgcmVzdWx0ICYmIGsgPCBiYXNlVmFsdWVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgYmFzZVZhbHVlID0gYmFzZVZhbHVlc1trXTtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgIC8vIC4uLiB0ZXN0IHRoYXQgaXQgaXMgcHJlc2VudCBpbiB0aGUgb3RoZXIgc2V0XG4gICAgICAgICAgZm9yICh2YXIgbCA9IDA7ICFmb3VuZCAmJiBsIDwgb3RoZXJWYWx1ZXMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgIG90aGVyVmFsdWUgPSBvdGhlclZhbHVlc1tsXTtcbiAgICAgICAgICAgIHByZXZTdGFja1NpemUgPSBiYXNlU3RhY2subGVuZ3RoO1xuICAgICAgICAgICAgLy8gY29tcGFyZSBieSB2YWx1ZSBlcXVhbGl0eVxuICAgICAgICAgICAgZm91bmQgPSBlcShiYXNlVmFsdWUsIG90aGVyVmFsdWUsIGJhc2VTdGFjaywgb3RoZXJTdGFjaywgY3VzdG9tVGVzdGVycywgaiQuTnVsbERpZmZCdWlsZGVyKCkpO1xuICAgICAgICAgICAgaWYgKCFmb3VuZCAmJiBwcmV2U3RhY2tTaXplICE9PSBiYXNlU3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGJhc2VTdGFjay5zcGxpY2UocHJldlN0YWNrU2l6ZSk7XG4gICAgICAgICAgICAgIG90aGVyU3RhY2suc3BsaWNlKHByZXZTdGFja1NpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQgJiYgZm91bmQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgZGlmZkJ1aWxkZXIucmVjb3JkKGEsIGIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzXG4gICAgICAvLyBvciBgQXJyYXlgcyBmcm9tIGRpZmZlcmVudCBmcmFtZXMgYXJlLlxuICAgICAgdmFyIGFDdG9yID0gYS5jb25zdHJ1Y3RvciwgYkN0b3IgPSBiLmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJlxuICAgICAgICAgIGlzRnVuY3Rpb24oYUN0b3IpICYmIGlzRnVuY3Rpb24oYkN0b3IpICYmXG4gICAgICAgICAgYSBpbnN0YW5jZW9mIGFDdG9yICYmIGIgaW5zdGFuY2VvZiBiQ3RvciAmJlxuICAgICAgICAgICEoYUN0b3IgaW5zdGFuY2VvZiBhQ3RvciAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKSkge1xuXG4gICAgICAgIGRpZmZCdWlsZGVyLnJlY29yZChhLCBiLCBjb25zdHJ1Y3RvcnNBcmVEaWZmZXJlbnRGb3JtYXR0ZXIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgdmFyIGFLZXlzID0ga2V5cyhhLCBjbGFzc05hbWUgPT0gJ1tvYmplY3QgQXJyYXldJyksIGtleTtcbiAgICBzaXplID0gYUtleXMubGVuZ3RoO1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgYm90aCBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXMgYmVmb3JlIGNvbXBhcmluZyBkZWVwIGVxdWFsaXR5LlxuICAgIGlmIChrZXlzKGIsIGNsYXNzTmFtZSA9PSAnW29iamVjdCBBcnJheV0nKS5sZW5ndGggIT09IHNpemUpIHtcbiAgICAgIGRpZmZCdWlsZGVyLnJlY29yZChhLCBiLCBvYmplY3RLZXlzQXJlRGlmZmVyZW50Rm9ybWF0dGVyKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICBrZXkgPSBhS2V5c1tpXTtcbiAgICAgIC8vIERlZXAgY29tcGFyZSBlYWNoIG1lbWJlclxuICAgICAgaWYgKCFqJC51dGlsLmhhcyhiLCBrZXkpKSB7XG4gICAgICAgIGRpZmZCdWlsZGVyLnJlY29yZChhLCBiLCBvYmplY3RLZXlzQXJlRGlmZmVyZW50Rm9ybWF0dGVyKTtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBkaWZmQnVpbGRlci53aXRoUGF0aChrZXksIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZighZXEoYVtrZXldLCBiW2tleV0sIGFTdGFjaywgYlN0YWNrLCBjdXN0b21UZXN0ZXJzLCBkaWZmQnVpbGRlcikpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGtleXMob2JqLCBpc0FycmF5KSB7XG4gICAgdmFyIGFsbEtleXMgPSBPYmplY3Qua2V5cyA/IE9iamVjdC5rZXlzKG9iaikgOlxuICAgICAgKGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvKSB7XG4gICAgICAgICAgICAgIGlmIChqJC51dGlsLmhhcyhvLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgIH0pKG9iaik7XG5cbiAgICBpZiAoIWlzQXJyYXkpIHtcbiAgICAgIHJldHVybiBhbGxLZXlzO1xuICAgIH1cblxuICAgIGlmIChhbGxLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYWxsS2V5cztcbiAgICB9XG5cbiAgICB2YXIgZXh0cmFLZXlzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIS9eWzAtOV0rJC8udGVzdChhbGxLZXlzW2ldKSkge1xuICAgICAgICBleHRyYUtleXMucHVzaChhbGxLZXlzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXh0cmFLZXlzO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgZnVuY3Rpb24gb2JqZWN0S2V5c0FyZURpZmZlcmVudEZvcm1hdHRlcihhY3R1YWwsIGV4cGVjdGVkLCBwYXRoKSB7XG4gICAgdmFyIG1pc3NpbmdQcm9wZXJ0aWVzID0gaiQudXRpbC5vYmplY3REaWZmZXJlbmNlKGV4cGVjdGVkLCBhY3R1YWwpLFxuICAgICAgICBleHRyYVByb3BlcnRpZXMgPSBqJC51dGlsLm9iamVjdERpZmZlcmVuY2UoYWN0dWFsLCBleHBlY3RlZCksXG4gICAgICAgIG1pc3NpbmdQcm9wZXJ0aWVzTWVzc2FnZSA9IGZvcm1hdEtleVZhbHVlUGFpcnMobWlzc2luZ1Byb3BlcnRpZXMpLFxuICAgICAgICBleHRyYVByb3BlcnRpZXNNZXNzYWdlID0gZm9ybWF0S2V5VmFsdWVQYWlycyhleHRyYVByb3BlcnRpZXMpLFxuICAgICAgICBtZXNzYWdlcyA9IFtdO1xuXG4gICAgaWYgKCFwYXRoLmRlcHRoKCkpIHtcbiAgICAgIHBhdGggPSAnb2JqZWN0JztcbiAgICB9XG5cbiAgICBpZiAobWlzc2luZ1Byb3BlcnRpZXNNZXNzYWdlLmxlbmd0aCkge1xuICAgICAgbWVzc2FnZXMucHVzaCgnRXhwZWN0ZWQgJyArIHBhdGggKyAnIHRvIGhhdmUgcHJvcGVydGllcycgKyBtaXNzaW5nUHJvcGVydGllc01lc3NhZ2UpO1xuICAgIH1cblxuICAgIGlmIChleHRyYVByb3BlcnRpZXNNZXNzYWdlLmxlbmd0aCkge1xuICAgICAgbWVzc2FnZXMucHVzaCgnRXhwZWN0ZWQgJyArIHBhdGggKyAnIG5vdCB0byBoYXZlIHByb3BlcnRpZXMnICsgZXh0cmFQcm9wZXJ0aWVzTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lc3NhZ2VzLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uc3RydWN0b3JzQXJlRGlmZmVyZW50Rm9ybWF0dGVyKGFjdHVhbCwgZXhwZWN0ZWQsIHBhdGgpIHtcbiAgICBpZiAoIXBhdGguZGVwdGgoKSkge1xuICAgICAgcGF0aCA9ICdvYmplY3QnO1xuICAgIH1cblxuICAgIHJldHVybiAnRXhwZWN0ZWQgJyArXG4gICAgICBwYXRoICsgJyB0byBiZSBhIGtpbmQgb2YgJyArXG4gICAgICBqJC5mbk5hbWVGb3IoZXhwZWN0ZWQuY29uc3RydWN0b3IpICtcbiAgICAgICcsIGJ1dCB3YXMgJyArIGokLnBwKGFjdHVhbCkgKyAnLic7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRLZXlWYWx1ZVBhaXJzKG9iaikge1xuICAgIHZhciBmb3JtYXR0ZWQgPSAnJztcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBmb3JtYXR0ZWQgKz0gJ1xcbiAgICAnICsga2V5ICsgJzogJyArIGokLnBwKG9ialtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdHRlZDtcbiAgfVxufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5ub3RoaW5nID0gZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSBub3RoaW5nIGV4cGxpY2l0bHkuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyNub3RoaW5nXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdCgpLm5vdGhpbmcoKTtcbiAgICovXG4gIGZ1bmN0aW9uIG5vdGhpbmcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG5vdGhpbmc7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLk51bGxEaWZmQnVpbGRlciA9IGZ1bmN0aW9uKGokKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2l0aFBhdGg6IGZ1bmN0aW9uKF8sIGJsb2NrKSB7XG4gICAgICAgIGJsb2NrKCk7XG4gICAgICB9LFxuICAgICAgcmVjb3JkOiBmdW5jdGlvbigpIHt9XG4gICAgfTtcbiAgfTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuT2JqZWN0UGF0aCA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIE9iamVjdFBhdGgoY29tcG9uZW50cykge1xuICAgIHRoaXMuY29tcG9uZW50cyA9IGNvbXBvbmVudHMgfHwgW107XG4gIH1cblxuICBPYmplY3RQYXRoLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gJyQnICsgbWFwKHRoaXMuY29tcG9uZW50cywgZm9ybWF0UHJvcGVydHlBY2Nlc3MpLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9O1xuXG4gIE9iamVjdFBhdGgucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgIHJldHVybiBuZXcgT2JqZWN0UGF0aCh0aGlzLmNvbXBvbmVudHMuY29uY2F0KFtjb21wb25lbnRdKSk7XG4gIH07XG5cbiAgT2JqZWN0UGF0aC5wcm90b3R5cGUuZGVwdGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnRzLmxlbmd0aDtcbiAgfTtcblxuICBmdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eUFjY2Vzcyhwcm9wKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuICdbJyArIHByb3AgKyAnXSc7XG4gICAgfVxuXG4gICAgaWYgKGlzVmFsaWRJZGVudGlmaWVyKHByb3ApKSB7XG4gICAgICByZXR1cm4gJy4nICsgcHJvcDtcbiAgICB9XG5cbiAgICByZXR1cm4gJ1tcXCcnICsgcHJvcCArICdcXCddJztcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdHMucHVzaChmbihhcnJheVtpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVmFsaWRJZGVudGlmaWVyKHN0cmluZykge1xuICAgIHJldHVybiAvXltBLVphLXpcXCRfXVtBLVphLXowLTlcXCRfXSokLy50ZXN0KHN0cmluZyk7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0UGF0aDtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZSA9IGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBiZSBgPT09YCB0byB0aGUgZXhwZWN0ZWQgdmFsdWUuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0JlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHBlY3RlZCAtIFRoZSBleHBlY3RlZCB2YWx1ZSB0byBjb21wYXJlIGFnYWluc3QuXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdCh0aGluZykudG9CZShyZWFsVGhpbmcpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9CZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6IGFjdHVhbCA9PT0gZXhwZWN0ZWRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvQmU7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVDbG9zZVRvID0gZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHZhbHVlIHRvIGJlIHdpdGhpbiBhIHNwZWNpZmllZCBwcmVjaXNpb24gb2YgdGhlIGV4cGVjdGVkIHZhbHVlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9CZUNsb3NlVG9cbiAgICogQHBhcmFtIHtPYmplY3R9IGV4cGVjdGVkIC0gVGhlIGV4cGVjdGVkIHZhbHVlIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwcmVjaXNpb249Ml0gLSBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzIHRvIGNoZWNrLlxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QobnVtYmVyKS50b0JlQ2xvc2VUbyg0Mi4yLCAzKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvQmVDbG9zZVRvKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkLCBwcmVjaXNpb24pIHtcbiAgICAgICAgaWYgKHByZWNpc2lvbiAhPT0gMCkge1xuICAgICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4cGVjdGVkID09PSBudWxsIHx8IGFjdHVhbCA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVzZSB0b0JlQ2xvc2VUbyB3aXRoIG51bGwuIEFyZ3VtZW50cyBldmFsdWF0ZWQgdG86ICcgK1xuICAgICAgICAgICAgJ2V4cGVjdCgnICsgYWN0dWFsICsgJykudG9CZUNsb3NlVG8oJyArIGV4cGVjdGVkICsgJykuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG93ID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbiArIDEpO1xuICAgICAgICB2YXIgZGVsdGEgPSBNYXRoLmFicyhleHBlY3RlZCAtIGFjdHVhbCk7XG4gICAgICAgIHZhciBtYXhEZWx0YSA9IE1hdGgucG93KDEwLCAtcHJlY2lzaW9uKSAvIDI7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXNzOiBNYXRoLnJvdW5kKGRlbHRhICogcG93KSAvIHBvdyA8PSBtYXhEZWx0YVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9CZUNsb3NlVG87XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVEZWZpbmVkID0gZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHZhbHVlIHRvIGJlIGRlZmluZWQuIChOb3QgYHVuZGVmaW5lZGApXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0JlRGVmaW5lZFxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QocmVzdWx0KS50b0JlRGVmaW5lZCgpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9CZURlZmluZWQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6ICh2b2lkIDAgIT09IGFjdHVhbClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvQmVEZWZpbmVkO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlRmFsc3kgPSBmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgdG8gYmUgZmFsc3lcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvQmVGYWxzeVxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QocmVzdWx0KS50b0JlRmFsc3koKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvQmVGYWxzeSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFzczogISEhYWN0dWFsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0JlRmFsc3k7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVHcmVhdGVyVGhhbiA9IGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBiZSBncmVhdGVyIHRoYW4gdGhlIGV4cGVjdGVkIHZhbHVlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9CZUdyZWF0ZXJUaGFuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBleHBlY3RlZCAtIFRoZSB2YWx1ZSB0byBjb21wYXJlIGFnYWluc3QuXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChyZXN1bHQpLnRvQmVHcmVhdGVyVGhhbigzKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvQmVHcmVhdGVyVGhhbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6IGFjdHVhbCA+IGV4cGVjdGVkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0JlR3JlYXRlclRoYW47XG59O1xuXG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGV4cGVjdGVkIHZhbHVlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9CZUdyZWF0ZXJUaGFuT3JFcXVhbFxuICAgKiBAcGFyYW0ge051bWJlcn0gZXhwZWN0ZWQgLSBUaGUgZXhwZWN0ZWQgdmFsdWUgdG8gY29tcGFyZSBhZ2FpbnN0LlxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QocmVzdWx0KS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDI1KTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXNzOiBhY3R1YWwgPj0gZXhwZWN0ZWRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvQmVHcmVhdGVyVGhhbk9yRXF1YWw7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVMZXNzVGhhbiA9IGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBiZSBsZXNzIHRoYW4gdGhlIGV4cGVjdGVkIHZhbHVlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9CZUxlc3NUaGFuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBleHBlY3RlZCAtIFRoZSBleHBlY3RlZCB2YWx1ZSB0byBjb21wYXJlIGFnYWluc3QuXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChyZXN1bHQpLnRvQmVMZXNzVGhhbigwKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvQmVMZXNzVGhhbigpIHtcbiAgICByZXR1cm4ge1xuXG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFzczogYWN0dWFsIDwgZXhwZWN0ZWRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvQmVMZXNzVGhhbjtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZUxlc3NUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGV4cGVjdGVkIHZhbHVlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9CZUxlc3NUaGFuT3JFcXVhbFxuICAgKiBAcGFyYW0ge051bWJlcn0gZXhwZWN0ZWQgLSBUaGUgZXhwZWN0ZWQgdmFsdWUgdG8gY29tcGFyZSBhZ2FpbnN0LlxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QocmVzdWx0KS50b0JlTGVzc1RoYW5PckVxdWFsKDEyMyk7XG4gICAqL1xuICBmdW5jdGlvbiB0b0JlTGVzc1RoYW5PckVxdWFsKCkge1xuICAgIHJldHVybiB7XG5cbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXNzOiBhY3R1YWwgPD0gZXhwZWN0ZWRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvQmVMZXNzVGhhbk9yRXF1YWw7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVOYU4gPSBmdW5jdGlvbihqJCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBiZSBgTmFOYCAoTm90IGEgTnVtYmVyKS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvQmVOYU5cbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KHRoaW5nKS50b0JlTmFOKCk7XG4gICAqL1xuICBmdW5jdGlvbiB0b0JlTmFOKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICBwYXNzOiAoYWN0dWFsICE9PSBhY3R1YWwpXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHJlc3VsdC5wYXNzKSB7XG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSAnRXhwZWN0ZWQgYWN0dWFsIG5vdCB0byBiZSBOYU4uJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ0V4cGVjdGVkICcgKyBqJC5wcChhY3R1YWwpICsgJyB0byBiZSBOYU4uJzsgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0JlTmFOO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlTmVnYXRpdmVJbmZpbml0eSA9IGZ1bmN0aW9uKGokKSB7XG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHZhbHVlIHRvIGJlIGAtSW5maW5pdHlgICgtaW5maW5pdHkpLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9CZU5lZ2F0aXZlSW5maW5pdHlcbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KHRoaW5nKS50b0JlTmVnYXRpdmVJbmZpbml0eSgpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9CZU5lZ2F0aXZlSW5maW5pdHkoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgIHBhc3M6IChhY3R1YWwgPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSlcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocmVzdWx0LnBhc3MpIHtcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9ICdFeHBlY3RlZCBhY3R1YWwgdG8gYmUgLUluZmluaXR5Lic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSBmdW5jdGlvbigpIHsgcmV0dXJuICdFeHBlY3RlZCAnICsgaiQucHAoYWN0dWFsKSArICcgbm90IHRvIGJlIC1JbmZpbml0eS4nOyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvQmVOZWdhdGl2ZUluZmluaXR5O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlTnVsbCA9IGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBiZSBgbnVsbGAuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0JlTnVsbFxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9CZU51bGwoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6IGFjdHVhbCA9PT0gbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9CZU51bGw7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVQb3NpdGl2ZUluZmluaXR5ID0gZnVuY3Rpb24oaiQpIHtcbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgdG8gYmUgYEluZmluaXR5YCAoaW5maW5pdHkpLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9CZVBvc2l0aXZlSW5maW5pdHlcbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KHRoaW5nKS50b0JlUG9zaXRpdmVJbmZpbml0eSgpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9CZVBvc2l0aXZlSW5maW5pdHkoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgIHBhc3M6IChhY3R1YWwgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSlcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocmVzdWx0LnBhc3MpIHtcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9ICdFeHBlY3RlZCBhY3R1YWwgdG8gYmUgSW5maW5pdHkuJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ0V4cGVjdGVkICcgKyBqJC5wcChhY3R1YWwpICsgJyBub3QgdG8gYmUgSW5maW5pdHkuJzsgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0JlUG9zaXRpdmVJbmZpbml0eTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZVRydXRoeSA9IGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCB2YWx1ZSB0byBiZSB0cnV0aHkuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0JlVHJ1dGh5XG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdCh0aGluZykudG9CZVRydXRoeSgpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9CZVRydXRoeSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFzczogISFhY3R1YWxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvQmVUcnV0aHk7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVVbmRlZmluZWQgPSBmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgdG8gYmUgYHVuZGVmaW5lZGAuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0JlVW5kZWZpbmVkXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChyZXN1bHQpLnRvQmVVbmRlZmluZWQoKTpcbiAgICovXG4gIGZ1bmN0aW9uIHRvQmVVbmRlZmluZWQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6IHZvaWQgMCA9PT0gYWN0dWFsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0JlVW5kZWZpbmVkO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0NvbnRhaW4gPSBmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgdG8gY29udGFpbiBhIHNwZWNpZmljIHZhbHVlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9Db250YWluXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHBlY3RlZCAtIFRoZSB2YWx1ZSB0byBsb29rIGZvci5cbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KGFycmF5KS50b0NvbnRhaW4oYW5FbGVtZW50KTtcbiAgICogZXhwZWN0KHN0cmluZykudG9Db250YWluKHN1YnN0cmluZyk7XG4gICAqL1xuICBmdW5jdGlvbiB0b0NvbnRhaW4odXRpbCwgY3VzdG9tRXF1YWxpdHlUZXN0ZXJzKSB7XG4gICAgY3VzdG9tRXF1YWxpdHlUZXN0ZXJzID0gY3VzdG9tRXF1YWxpdHlUZXN0ZXJzIHx8IFtdO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6IHV0aWwuY29udGFpbnMoYWN0dWFsLCBleHBlY3RlZCwgY3VzdG9tRXF1YWxpdHlUZXN0ZXJzKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9Db250YWluO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0VxdWFsID0gZnVuY3Rpb24oaiQpIHtcbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgdG8gYmUgZXF1YWwgdG8gdGhlIGV4cGVjdGVkLCB1c2luZyBkZWVwIGVxdWFsaXR5IGNvbXBhcmlzb24uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0VxdWFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHBlY3RlZCAtIEV4cGVjdGVkIHZhbHVlXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChiaWdPYmplY3QpLnRvRXF1YWwoe1wiZm9vXCI6IFsnYmFyJywgJ2JheiddfSk7XG4gICAqL1xuICBmdW5jdGlvbiB0b0VxdWFsKHV0aWwsIGN1c3RvbUVxdWFsaXR5VGVzdGVycykge1xuICAgIGN1c3RvbUVxdWFsaXR5VGVzdGVycyA9IGN1c3RvbUVxdWFsaXR5VGVzdGVycyB8fCBbXTtcblxuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBwYXNzOiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGlmZkJ1aWxkZXIgPSBqJC5EaWZmQnVpbGRlcigpO1xuXG4gICAgICAgIHJlc3VsdC5wYXNzID0gdXRpbC5lcXVhbHMoYWN0dWFsLCBleHBlY3RlZCwgY3VzdG9tRXF1YWxpdHlUZXN0ZXJzLCBkaWZmQnVpbGRlcik7XG5cbiAgICAgICAgLy8gVE9ETzogb25seSBzZXQgZXJyb3IgbWVzc2FnZSBpZiB0ZXN0IGZhaWxzXG4gICAgICAgIHJlc3VsdC5tZXNzYWdlID0gZGlmZkJ1aWxkZXIuZ2V0TWVzc2FnZSgpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0VxdWFsO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0hhdmVCZWVuQ2FsbGVkID0gZnVuY3Rpb24oaiQpIHtcblxuICB2YXIgZ2V0RXJyb3JNc2cgPSBqJC5mb3JtYXRFcnJvck1zZygnPHRvSGF2ZUJlZW5DYWxsZWQ+JywgJ2V4cGVjdCg8c3B5T2JqPikudG9IYXZlQmVlbkNhbGxlZCgpJyk7XG5cbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgKGEge0BsaW5rIFNweX0pIHRvIGhhdmUgYmVlbiBjYWxsZWQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b0hhdmVCZWVuQ2FsbGVkXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChteVNweSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgKiBleHBlY3QobXlTcHkpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAqL1xuICBmdW5jdGlvbiB0b0hhdmVCZWVuQ2FsbGVkKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgIGlmICghaiQuaXNTcHkoYWN0dWFsKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRFcnJvck1zZygnRXhwZWN0ZWQgYSBzcHksIGJ1dCBnb3QgJyArIGokLnBwKGFjdHVhbCkgKyAnLicpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRFcnJvck1zZygnRG9lcyBub3QgdGFrZSBhcmd1bWVudHMsIHVzZSB0b0hhdmVCZWVuQ2FsbGVkV2l0aCcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wYXNzID0gYWN0dWFsLmNhbGxzLmFueSgpO1xuXG4gICAgICAgIHJlc3VsdC5tZXNzYWdlID0gcmVzdWx0LnBhc3MgP1xuICAgICAgICAgICdFeHBlY3RlZCBzcHkgJyArIGFjdHVhbC5hbmQuaWRlbnRpdHkoKSArICcgbm90IHRvIGhhdmUgYmVlbiBjYWxsZWQuJyA6XG4gICAgICAgICAgJ0V4cGVjdGVkIHNweSAnICsgYWN0dWFsLmFuZC5pZGVudGl0eSgpICsgJyB0byBoYXZlIGJlZW4gY2FsbGVkLic7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvSGF2ZUJlZW5DYWxsZWQ7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvSGF2ZUJlZW5DYWxsZWRCZWZvcmUgPSBmdW5jdGlvbihqJCkge1xuXG4gIHZhciBnZXRFcnJvck1zZyA9IGokLmZvcm1hdEVycm9yTXNnKCc8dG9IYXZlQmVlbkNhbGxlZEJlZm9yZT4nLCAnZXhwZWN0KDxzcHlPYmo+KS50b0hhdmVCZWVuQ2FsbGVkQmVmb3JlKDxzcHlPYmo+KScpO1xuXG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSB0aGUgYWN0dWFsIHZhbHVlIChhIHtAbGluayBTcHl9KSB0byBoYXZlIGJlZW4gY2FsbGVkIGJlZm9yZSBhbm90aGVyIHtAbGluayBTcHl9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9IYXZlQmVlbkNhbGxlZEJlZm9yZVxuICAgKiBAcGFyYW0ge1NweX0gZXhwZWN0ZWQgLSB7QGxpbmsgU3B5fSB0aGF0IHNob3VsZCBoYXZlIGJlZW4gY2FsbGVkIGFmdGVyIHRoZSBgYWN0dWFsYCB7QGxpbmsgU3B5fS5cbiAgICogQGV4YW1wbGVcbiAgICogZXhwZWN0KG15U3B5KS50b0hhdmVCZWVuQ2FsbGVkQmVmb3JlKG90aGVyU3B5KTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvSGF2ZUJlZW5DYWxsZWRCZWZvcmUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGZpcnN0U3B5LCBsYXR0ZXJTcHkpIHtcbiAgICAgICAgaWYgKCFqJC5pc1NweShmaXJzdFNweSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0RXJyb3JNc2coJ0V4cGVjdGVkIGEgc3B5LCBidXQgZ290ICcgKyBqJC5wcChmaXJzdFNweSkgKyAnLicpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWokLmlzU3B5KGxhdHRlclNweSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0RXJyb3JNc2coJ0V4cGVjdGVkIGEgc3B5LCBidXQgZ290ICcgKyBqJC5wcChsYXR0ZXJTcHkpICsgJy4nKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0geyBwYXNzOiBmYWxzZSB9O1xuXG4gICAgICAgIGlmICghZmlyc3RTcHkuY2FsbHMuY291bnQoKSkge1xuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gJ0V4cGVjdGVkIHNweSAnICsgIGZpcnN0U3B5LmFuZC5pZGVudGl0eSgpICsgJyB0byBoYXZlIGJlZW4gY2FsbGVkLic7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxhdHRlclNweS5jYWxscy5jb3VudCgpKSB7XG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSAnRXhwZWN0ZWQgc3B5ICcgKyAgbGF0dGVyU3B5LmFuZC5pZGVudGl0eSgpICsgJyB0byBoYXZlIGJlZW4gY2FsbGVkLic7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXRlc3Qxc3RTcHlDYWxsID0gZmlyc3RTcHkuY2FsbHMubW9zdFJlY2VudCgpLmludm9jYXRpb25PcmRlcjtcbiAgICAgICAgdmFyIGZpcnN0Mm5kU3B5Q2FsbCA9IGxhdHRlclNweS5jYWxscy5maXJzdCgpLmludm9jYXRpb25PcmRlcjtcblxuICAgICAgICByZXN1bHQucGFzcyA9IGxhdGVzdDFzdFNweUNhbGwgPCBmaXJzdDJuZFNweUNhbGw7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5wYXNzKSB7XG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSAnRXhwZWN0ZWQgc3B5ICcgKyBmaXJzdFNweS5hbmQuaWRlbnRpdHkoKSArICcgdG8gbm90IGhhdmUgYmVlbiBjYWxsZWQgYmVmb3JlIHNweSAnICsgbGF0dGVyU3B5LmFuZC5pZGVudGl0eSgpICsgJywgYnV0IGl0IHdhcyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZpcnN0MXN0U3B5Q2FsbCA9IGZpcnN0U3B5LmNhbGxzLmZpcnN0KCkuaW52b2NhdGlvbk9yZGVyO1xuICAgICAgICAgIHZhciBsYXRlc3QybmRTcHlDYWxsID0gbGF0dGVyU3B5LmNhbGxzLm1vc3RSZWNlbnQoKS5pbnZvY2F0aW9uT3JkZXI7XG5cbiAgICAgICAgICBpZihmaXJzdDFzdFNweUNhbGwgPCBmaXJzdDJuZFNweUNhbGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gJ0V4cGVjdGVkIGxhdGVzdCBjYWxsIHRvIHNweSAnICsgZmlyc3RTcHkuYW5kLmlkZW50aXR5KCkgKyAnIHRvIGhhdmUgYmVlbiBjYWxsZWQgYmVmb3JlIGZpcnN0IGNhbGwgdG8gc3B5ICcgKyBsYXR0ZXJTcHkuYW5kLmlkZW50aXR5KCkgKyAnIChubyBpbnRlcmxlYXZlZCBjYWxscyknO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGF0ZXN0Mm5kU3B5Q2FsbCA+IGxhdGVzdDFzdFNweUNhbGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gJ0V4cGVjdGVkIGZpcnN0IGNhbGwgdG8gc3B5ICcgKyBsYXR0ZXJTcHkuYW5kLmlkZW50aXR5KCkgKyAnIHRvIGhhdmUgYmVlbiBjYWxsZWQgYWZ0ZXIgbGF0ZXN0IGNhbGwgdG8gc3B5ICcgKyBmaXJzdFNweS5hbmQuaWRlbnRpdHkoKSArICcgKG5vIGludGVybGVhdmVkIGNhbGxzKSc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gJ0V4cGVjdGVkIHNweSAnICsgZmlyc3RTcHkuYW5kLmlkZW50aXR5KCkgKyAnIHRvIGhhdmUgYmVlbiBjYWxsZWQgYmVmb3JlIHNweSAnICsgbGF0dGVyU3B5LmFuZC5pZGVudGl0eSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0b0hhdmVCZWVuQ2FsbGVkQmVmb3JlO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMgPSBmdW5jdGlvbihqJCkge1xuXG4gIHZhciBnZXRFcnJvck1zZyA9IGokLmZvcm1hdEVycm9yTXNnKCc8dG9IYXZlQmVlbkNhbGxlZFRpbWVzPicsICdleHBlY3QoPHNweU9iaj4pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcyg8TnVtYmVyPiknKTtcblxuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gdGhlIGFjdHVhbCAoYSB7QGxpbmsgU3B5fSkgdG8gaGF2ZSBiZWVuIGNhbGxlZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiB0aW1lcy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvSGF2ZUJlZW5DYWxsZWRUaW1lc1xuICAgKiBAcGFyYW0ge051bWJlcn0gZXhwZWN0ZWQgLSBUaGUgbnVtYmVyIG9mIGludm9jYXRpb25zIHRvIGxvb2sgZm9yLlxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QobXlTcHkpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygzKTtcbiAgICovXG4gIGZ1bmN0aW9uIHRvSGF2ZUJlZW5DYWxsZWRUaW1lcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICAgICAgICBpZiAoIWokLmlzU3B5KGFjdHVhbCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0RXJyb3JNc2coJ0V4cGVjdGVkIGEgc3B5LCBidXQgZ290ICcgKyBqJC5wcChhY3R1YWwpICsgJy4nKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCksXG4gICAgICAgICAgcmVzdWx0ID0geyBwYXNzOiBmYWxzZSB9O1xuXG4gICAgICAgIGlmICghaiQuaXNOdW1iZXJfKGV4cGVjdGVkKSl7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGdldEVycm9yTXNnKCdUaGUgZXhwZWN0ZWQgdGltZXMgZmFpbGVkIGlzIGEgcmVxdWlyZWQgYXJndW1lbnQgYW5kIG11c3QgYmUgYSBudW1iZXIuJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgYWN0dWFsID0gYXJnc1swXTtcbiAgICAgICAgdmFyIGNhbGxzID0gYWN0dWFsLmNhbGxzLmNvdW50KCk7XG4gICAgICAgIHZhciB0aW1lc01lc3NhZ2UgPSBleHBlY3RlZCA9PT0gMSA/ICdvbmNlJyA6IGV4cGVjdGVkICsgJyB0aW1lcyc7XG4gICAgICAgIHJlc3VsdC5wYXNzID0gY2FsbHMgPT09IGV4cGVjdGVkO1xuICAgICAgICByZXN1bHQubWVzc2FnZSA9IHJlc3VsdC5wYXNzID9cbiAgICAgICAgICAnRXhwZWN0ZWQgc3B5ICcgKyBhY3R1YWwuYW5kLmlkZW50aXR5KCkgKyAnIG5vdCB0byBoYXZlIGJlZW4gY2FsbGVkICcgKyB0aW1lc01lc3NhZ2UgKyAnLiBJdCB3YXMgY2FsbGVkICcgKyAgY2FsbHMgKyAnIHRpbWVzLicgOlxuICAgICAgICAgICdFeHBlY3RlZCBzcHkgJyArIGFjdHVhbC5hbmQuaWRlbnRpdHkoKSArICcgdG8gaGF2ZSBiZWVuIGNhbGxlZCAnICsgdGltZXNNZXNzYWdlICsgJy4gSXQgd2FzIGNhbGxlZCAnICsgIGNhbGxzICsgJyB0aW1lcy4nO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9IYXZlQmVlbkNhbGxlZFRpbWVzO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCA9IGZ1bmN0aW9uKGokKSB7XG5cbiAgdmFyIGdldEVycm9yTXNnID0gaiQuZm9ybWF0RXJyb3JNc2coJzx0b0hhdmVCZWVuQ2FsbGVkV2l0aD4nLCAnZXhwZWN0KDxzcHlPYmo+KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCguLi5hcmd1bWVudHMpJyk7XG5cbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgKGEge0BsaW5rIFNweX0pIHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCBwYXJ0aWN1bGFyIGFyZ3VtZW50cyBhdCBsZWFzdCBvbmNlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9IYXZlQmVlbkNhbGxlZFdpdGhcbiAgICogQHBhcmFtIHsuLi5PYmplY3R9IC0gVGhlIGFyZ3VtZW50cyB0byBsb29rIGZvclxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QobXlTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdmb28nLCAnYmFyJywgMik7XG4gICAqL1xuICBmdW5jdGlvbiB0b0hhdmVCZWVuQ2FsbGVkV2l0aCh1dGlsLCBjdXN0b21FcXVhbGl0eVRlc3RlcnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSxcbiAgICAgICAgICBhY3R1YWwgPSBhcmdzWzBdLFxuICAgICAgICAgIGV4cGVjdGVkQXJncyA9IGFyZ3Muc2xpY2UoMSksXG4gICAgICAgICAgcmVzdWx0ID0geyBwYXNzOiBmYWxzZSB9O1xuXG4gICAgICAgIGlmICghaiQuaXNTcHkoYWN0dWFsKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRFcnJvck1zZygnRXhwZWN0ZWQgYSBzcHksIGJ1dCBnb3QgJyArIGokLnBwKGFjdHVhbCkgKyAnLicpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYWN0dWFsLmNhbGxzLmFueSgpKSB7XG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSBmdW5jdGlvbigpIHsgcmV0dXJuICdFeHBlY3RlZCBzcHkgJyArIGFjdHVhbC5hbmQuaWRlbnRpdHkoKSArICcgdG8gaGF2ZSBiZWVuIGNhbGxlZCB3aXRoICcgKyBqJC5wcChleHBlY3RlZEFyZ3MpICsgJyBidXQgaXQgd2FzIG5ldmVyIGNhbGxlZC4nOyB9O1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbC5jb250YWlucyhhY3R1YWwuY2FsbHMuYWxsQXJncygpLCBleHBlY3RlZEFyZ3MsIGN1c3RvbUVxdWFsaXR5VGVzdGVycykpIHtcbiAgICAgICAgICByZXN1bHQucGFzcyA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSBmdW5jdGlvbigpIHsgcmV0dXJuICdFeHBlY3RlZCBzcHkgJyArIGFjdHVhbC5hbmQuaWRlbnRpdHkoKSArICcgbm90IHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCAnICsgaiQucHAoZXhwZWN0ZWRBcmdzKSArICcgYnV0IGl0IHdhcy4nOyB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gZnVuY3Rpb24oKSB7IHJldHVybiAnRXhwZWN0ZWQgc3B5ICcgKyBhY3R1YWwuYW5kLmlkZW50aXR5KCkgKyAnIHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCAnICsgaiQucHAoZXhwZWN0ZWRBcmdzKSArICcgYnV0IGFjdHVhbCBjYWxscyB3ZXJlICcgKyBqJC5wcChhY3R1YWwuY2FsbHMuYWxsQXJncygpKS5yZXBsYWNlKC9eXFxbIHwgXFxdJC9nLCAnJykgKyAnLic7IH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9IYXZlQmVlbkNhbGxlZFdpdGg7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvTWF0Y2ggPSBmdW5jdGlvbihqJCkge1xuXG4gIHZhciBnZXRFcnJvck1zZyA9IGokLmZvcm1hdEVycm9yTXNnKCc8dG9NYXRjaD4nLCAnZXhwZWN0KDxleHBlY3RhdGlvbj4pLnRvTWF0Y2goPHN0cmluZz4gfHwgPHJlZ2V4cD4pJyk7XG5cbiAgLyoqXG4gICAqIHtAbGluayBleHBlY3R9IHRoZSBhY3R1YWwgdmFsdWUgdG8gbWF0Y2ggYSByZWd1bGFyIGV4cHJlc3Npb25cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIG1hdGNoZXJzI3RvTWF0Y2hcbiAgICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSBleHBlY3RlZCAtIFZhbHVlIHRvIGxvb2sgZm9yIGluIHRoZSBzdHJpbmcuXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChcIm15IHN0cmluZ1wiKS50b01hdGNoKC9zdHJpbmckLyk7XG4gICAqIGV4cGVjdChcIm90aGVyIHN0cmluZ1wiKS50b01hdGNoKFwiaGVyXCIpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9NYXRjaCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICAgICAgICBpZiAoIWokLmlzU3RyaW5nXyhleHBlY3RlZCkgJiYgIWokLmlzQV8oJ1JlZ0V4cCcsIGV4cGVjdGVkKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRFcnJvck1zZygnRXhwZWN0ZWQgaXMgbm90IGEgU3RyaW5nIG9yIGEgUmVnRXhwJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoZXhwZWN0ZWQpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFzczogcmVnZXhwLnRlc3QoYWN0dWFsKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdG9NYXRjaDtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9UaHJvdyA9IGZ1bmN0aW9uKGokKSB7XG5cbiAgdmFyIGdldEVycm9yTXNnID0gaiQuZm9ybWF0RXJyb3JNc2coJzx0b1Rocm93PicsICdleHBlY3QoZnVuY3Rpb24oKSB7PGV4cGVjdGF0aW9uPn0pLnRvVGhyb3coKScpO1xuXG4gIC8qKlxuICAgKiB7QGxpbmsgZXhwZWN0fSBhIGZ1bmN0aW9uIHRvIGB0aHJvd2Agc29tZXRoaW5nLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgbWF0Y2hlcnMjdG9UaHJvd1xuICAgKiBAcGFyYW0ge09iamVjdH0gW2V4cGVjdGVkXSAtIFZhbHVlIHRoYXQgc2hvdWxkIGJlIHRocm93bi4gSWYgbm90IHByb3ZpZGVkLCBzaW1wbHkgdGhlIGZhY3QgdGhhdCBzb21ldGhpbmcgd2FzIHRocm93biB3aWxsIGJlIGNoZWNrZWQuXG4gICAqIEBleGFtcGxlXG4gICAqIGV4cGVjdChmdW5jdGlvbigpIHsgcmV0dXJuICd0aGluZ3MnOyB9KS50b1Rocm93KCdmb28nKTtcbiAgICogZXhwZWN0KGZ1bmN0aW9uKCkgeyByZXR1cm4gJ3N0dWZmJzsgfSkudG9UaHJvdygpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9UaHJvdyh1dGlsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgcGFzczogZmFsc2UgfSxcbiAgICAgICAgICB0aHJldyA9IGZhbHNlLFxuICAgICAgICAgIHRocm93bjtcblxuICAgICAgICBpZiAodHlwZW9mIGFjdHVhbCAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGdldEVycm9yTXNnKCdBY3R1YWwgaXMgbm90IGEgRnVuY3Rpb24nKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGFjdHVhbCgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyZXcgPSB0cnVlO1xuICAgICAgICAgIHRocm93biA9IGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRocmV3KSB7XG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSAnRXhwZWN0ZWQgZnVuY3Rpb24gdG8gdGhyb3cgYW4gZXhjZXB0aW9uLic7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICByZXN1bHQucGFzcyA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSBmdW5jdGlvbigpIHsgcmV0dXJuICdFeHBlY3RlZCBmdW5jdGlvbiBub3QgdG8gdGhyb3csIGJ1dCBpdCB0aHJldyAnICsgaiQucHAodGhyb3duKSArICcuJzsgfTtcblxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbC5lcXVhbHModGhyb3duLCBleHBlY3RlZCkpIHtcbiAgICAgICAgICByZXN1bHQucGFzcyA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSBmdW5jdGlvbigpIHsgcmV0dXJuICdFeHBlY3RlZCBmdW5jdGlvbiBub3QgdG8gdGhyb3cgJyArIGokLnBwKGV4cGVjdGVkKSArICcuJzsgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ0V4cGVjdGVkIGZ1bmN0aW9uIHRvIHRocm93ICcgKyBqJC5wcChleHBlY3RlZCkgKyAnLCBidXQgaXQgdGhyZXcgJyArICBqJC5wcCh0aHJvd24pICsgJy4nOyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRvVGhyb3c7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvVGhyb3dFcnJvciA9IGZ1bmN0aW9uKGokKSB7XG5cbiAgdmFyIGdldEVycm9yTXNnID0gIGokLmZvcm1hdEVycm9yTXNnKCc8dG9UaHJvd0Vycm9yPicsICdleHBlY3QoZnVuY3Rpb24oKSB7PGV4cGVjdGF0aW9uPn0pLnRvVGhyb3dFcnJvcig8RXJyb3JDb25zdHJ1Y3Rvcj4sIDxtZXNzYWdlPiknKTtcblxuICAvKipcbiAgICoge0BsaW5rIGV4cGVjdH0gYSBmdW5jdGlvbiB0byBgdGhyb3dgIGFuIGBFcnJvcmAuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBtYXRjaGVycyN0b1Rocm93RXJyb3JcbiAgICogQHBhcmFtIHtFcnJvcn0gW2V4cGVjdGVkXSAtIGBFcnJvcmAgY29uc3RydWN0b3IgdGhlIG9iamVjdCB0aGF0IHdhcyB0aHJvd24gbmVlZHMgdG8gYmUgYW4gaW5zdGFuY2Ugb2YuIElmIG5vdCBwcm92aWRlZCwgYEVycm9yYCB3aWxsIGJlIHVzZWQuXG4gICAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gW21lc3NhZ2VdIC0gVGhlIG1lc3NhZ2UgdGhhdCBzaG91bGQgYmUgc2V0IG9uIHRoZSB0aHJvd24gYEVycm9yYFxuICAgKiBAZXhhbXBsZVxuICAgKiBleHBlY3QoZnVuY3Rpb24oKSB7IHJldHVybiAndGhpbmdzJzsgfSkudG9UaHJvd0Vycm9yKE15Q3VzdG9tRXJyb3IsICdtZXNzYWdlJyk7XG4gICAqIGV4cGVjdChmdW5jdGlvbigpIHsgcmV0dXJuICd0aGluZ3MnOyB9KS50b1Rocm93RXJyb3IoTXlDdXN0b21FcnJvciwgL2Jhci8pO1xuICAgKiBleHBlY3QoZnVuY3Rpb24oKSB7IHJldHVybiAnc3R1ZmYnOyB9KS50b1Rocm93RXJyb3IoTXlDdXN0b21FcnJvcik7XG4gICAqIGV4cGVjdChmdW5jdGlvbigpIHsgcmV0dXJuICdvdGhlcic7IH0pLnRvVGhyb3dFcnJvcigvZm9vLyk7XG4gICAqIGV4cGVjdChmdW5jdGlvbigpIHsgcmV0dXJuICdvdGhlcic7IH0pLnRvVGhyb3dFcnJvcigpO1xuICAgKi9cbiAgZnVuY3Rpb24gdG9UaHJvd0Vycm9yICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgICAgIHZhciB0aHJldyA9IGZhbHNlLFxuICAgICAgICAgIHBhc3MgPSB7cGFzczogdHJ1ZX0sXG4gICAgICAgICAgZmFpbCA9IHtwYXNzOiBmYWxzZX0sXG4gICAgICAgICAgdGhyb3duO1xuXG4gICAgICAgIGlmICh0eXBlb2YgYWN0dWFsICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0RXJyb3JNc2coJ0FjdHVhbCBpcyBub3QgYSBGdW5jdGlvbicpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlcnJvck1hdGNoZXIgPSBnZXRNYXRjaGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhY3R1YWwoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocmV3ID0gdHJ1ZTtcbiAgICAgICAgICB0aHJvd24gPSBlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aHJldykge1xuICAgICAgICAgIGZhaWwubWVzc2FnZSA9ICdFeHBlY3RlZCBmdW5jdGlvbiB0byB0aHJvdyBhbiBFcnJvci4nO1xuICAgICAgICAgIHJldHVybiBmYWlsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IEVycm9yIGNvbnN0cnVjdG9yIG9mIHRocm93blxuICAgICAgICBpZiAoIWlzRXJyb3JPYmplY3QodGhyb3duKSkge1xuICAgICAgICAgIGZhaWwubWVzc2FnZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ0V4cGVjdGVkIGZ1bmN0aW9uIHRvIHRocm93IGFuIEVycm9yLCBidXQgaXQgdGhyZXcgJyArIGokLnBwKHRocm93bikgKyAnLic7IH07XG4gICAgICAgICAgcmV0dXJuIGZhaWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3JNYXRjaGVyLmhhc05vU3BlY2lmaWNzKCkpIHtcbiAgICAgICAgICBwYXNzLm1lc3NhZ2UgPSAnRXhwZWN0ZWQgZnVuY3Rpb24gbm90IHRvIHRocm93IGFuIEVycm9yLCBidXQgaXQgdGhyZXcgJyArIGokLmZuTmFtZUZvcih0aHJvd24pICsgJy4nO1xuICAgICAgICAgIHJldHVybiBwYXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yTWF0Y2hlci5tYXRjaGVzKHRocm93bikpIHtcbiAgICAgICAgICBwYXNzLm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAnRXhwZWN0ZWQgZnVuY3Rpb24gbm90IHRvIHRocm93ICcgKyBlcnJvck1hdGNoZXIuZXJyb3JUeXBlRGVzY3JpcHRpb24gKyBlcnJvck1hdGNoZXIubWVzc2FnZURlc2NyaXB0aW9uKCkgKyAnLic7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gcGFzcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmYWlsLm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAnRXhwZWN0ZWQgZnVuY3Rpb24gdG8gdGhyb3cgJyArIGVycm9yTWF0Y2hlci5lcnJvclR5cGVEZXNjcmlwdGlvbiArIGVycm9yTWF0Y2hlci5tZXNzYWdlRGVzY3JpcHRpb24oKSArXG4gICAgICAgICAgICAgICcsIGJ1dCBpdCB0aHJldyAnICsgZXJyb3JNYXRjaGVyLnRocm93bkRlc2NyaXB0aW9uKHRocm93bikgKyAnLic7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gZmFpbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRNYXRjaGVyKCkge1xuICAgICAgdmFyIGV4cGVjdGVkID0gbnVsbCxcbiAgICAgICAgICBlcnJvclR5cGUgPSBudWxsO1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgIGV4cGVjdGVkID0gYXJndW1lbnRzWzFdO1xuICAgICAgICBpZiAoaXNBbkVycm9yVHlwZShleHBlY3RlZCkpIHtcbiAgICAgICAgICBlcnJvclR5cGUgPSBleHBlY3RlZDtcbiAgICAgICAgICBleHBlY3RlZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgZXJyb3JUeXBlID0gYXJndW1lbnRzWzFdO1xuICAgICAgICBleHBlY3RlZCA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgaWYgKCFpc0FuRXJyb3JUeXBlKGVycm9yVHlwZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0RXJyb3JNc2coJ0V4cGVjdGVkIGVycm9yIHR5cGUgaXMgbm90IGFuIEVycm9yLicpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZXhwZWN0ZWQgJiYgIWlzU3RyaW5nT3JSZWdFeHAoZXhwZWN0ZWQpKSB7XG4gICAgICAgIGlmIChlcnJvclR5cGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0RXJyb3JNc2coJ0V4cGVjdGVkIGVycm9yIG1lc3NhZ2UgaXMgbm90IGEgc3RyaW5nIG9yIFJlZ0V4cC4nKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGdldEVycm9yTXNnKCdFeHBlY3RlZCBpcyBub3QgYW4gRXJyb3IsIHN0cmluZywgb3IgUmVnRXhwLicpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtZXNzYWdlTWF0Y2gobWVzc2FnZSkge1xuICAgICAgICBpZiAodHlwZW9mIGV4cGVjdGVkID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIGV4cGVjdGVkID09IG1lc3NhZ2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3JUeXBlRGVzY3JpcHRpb246IGVycm9yVHlwZSA/IGokLmZuTmFtZUZvcihlcnJvclR5cGUpIDogJ2FuIGV4Y2VwdGlvbicsXG4gICAgICAgIHRocm93bkRlc2NyaXB0aW9uOiBmdW5jdGlvbih0aHJvd24pIHtcbiAgICAgICAgICB2YXIgdGhyb3duTmFtZSA9IGVycm9yVHlwZSA/IGokLmZuTmFtZUZvcih0aHJvd24uY29uc3RydWN0b3IpIDogJ2FuIGV4Y2VwdGlvbicsXG4gICAgICAgICAgICAgIHRocm93bk1lc3NhZ2UgPSAnJztcblxuICAgICAgICAgIGlmIChleHBlY3RlZCkge1xuICAgICAgICAgICAgdGhyb3duTWVzc2FnZSA9ICcgd2l0aCBtZXNzYWdlICcgKyBqJC5wcCh0aHJvd24ubWVzc2FnZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRocm93bk5hbWUgKyB0aHJvd25NZXNzYWdlO1xuICAgICAgICB9LFxuICAgICAgICBtZXNzYWdlRGVzY3JpcHRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChleHBlY3RlZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIHJldHVybiAnIHdpdGggYSBtZXNzYWdlIG1hdGNoaW5nICcgKyBqJC5wcChleHBlY3RlZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnIHdpdGggbWVzc2FnZSAnICsgaiQucHAoZXhwZWN0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaGFzTm9TcGVjaWZpY3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBleHBlY3RlZCA9PT0gbnVsbCAmJiBlcnJvclR5cGUgPT09IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIG1hdGNoZXM6IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIChlcnJvclR5cGUgPT09IG51bGwgfHwgZXJyb3IgaW5zdGFuY2VvZiBlcnJvclR5cGUpICYmXG4gICAgICAgICAgICAoZXhwZWN0ZWQgPT09IG51bGwgfHwgbWVzc2FnZU1hdGNoKGVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1N0cmluZ09yUmVnRXhwKHBvdGVudGlhbCkge1xuICAgICAgcmV0dXJuIHBvdGVudGlhbCBpbnN0YW5jZW9mIFJlZ0V4cCB8fCAodHlwZW9mIHBvdGVudGlhbCA9PSAnc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBbkVycm9yVHlwZSh0eXBlKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgU3Vycm9nYXRlID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgIFN1cnJvZ2F0ZS5wcm90b3R5cGUgPSB0eXBlLnByb3RvdHlwZTtcbiAgICAgIHJldHVybiBpc0Vycm9yT2JqZWN0KG5ldyBTdXJyb2dhdGUoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNFcnJvck9iamVjdCh0aHJvd24pIHtcbiAgICAgIGlmICh0aHJvd24gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aHJvd24gJiYgdGhyb3duLmNvbnN0cnVjdG9yICYmIHRocm93bi5jb25zdHJ1Y3Rvci5jb25zdHJ1Y3RvciAmJlxuICAgICAgICAgICh0aHJvd24gaW5zdGFuY2VvZiAodGhyb3duLmNvbnN0cnVjdG9yLmNvbnN0cnVjdG9yKCdyZXR1cm4gdGhpcycpKCkpLkVycm9yKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG9UaHJvd0Vycm9yO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5Nb2NrRGF0ZSA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBNb2NrRGF0ZShnbG9iYWwpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gMDtcblxuICAgIGlmICghZ2xvYmFsIHx8ICFnbG9iYWwuRGF0ZSkge1xuICAgICAgc2VsZi5pbnN0YWxsID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgIHNlbGYudGljayA9IGZ1bmN0aW9uKCkge307XG4gICAgICBzZWxmLnVuaW5zdGFsbCA9IGZ1bmN0aW9uKCkge307XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICB2YXIgR2xvYmFsRGF0ZSA9IGdsb2JhbC5EYXRlO1xuXG4gICAgc2VsZi5pbnN0YWxsID0gZnVuY3Rpb24obW9ja0RhdGUpIHtcbiAgICAgIGlmIChtb2NrRGF0ZSBpbnN0YW5jZW9mIEdsb2JhbERhdGUpIHtcbiAgICAgICAgY3VycmVudFRpbWUgPSBtb2NrRGF0ZS5nZXRUaW1lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50VGltZSA9IG5ldyBHbG9iYWxEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgfVxuXG4gICAgICBnbG9iYWwuRGF0ZSA9IEZha2VEYXRlO1xuICAgIH07XG5cbiAgICBzZWxmLnRpY2sgPSBmdW5jdGlvbihtaWxsaXMpIHtcbiAgICAgIG1pbGxpcyA9IG1pbGxpcyB8fCAwO1xuICAgICAgY3VycmVudFRpbWUgPSBjdXJyZW50VGltZSArIG1pbGxpcztcbiAgICB9O1xuXG4gICAgc2VsZi51bmluc3RhbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgIGN1cnJlbnRUaW1lID0gMDtcbiAgICAgIGdsb2JhbC5EYXRlID0gR2xvYmFsRGF0ZTtcbiAgICB9O1xuXG4gICAgY3JlYXRlRGF0ZVByb3BlcnRpZXMoKTtcblxuICAgIHJldHVybiBzZWxmO1xuXG4gICAgZnVuY3Rpb24gRmFrZURhdGUoKSB7XG4gICAgICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG5ldyBHbG9iYWxEYXRlKGN1cnJlbnRUaW1lKTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBuZXcgR2xvYmFsRGF0ZShhcmd1bWVudHNbMF0pO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBHbG9iYWxEYXRlKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiBuZXcgR2xvYmFsRGF0ZShhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiBuZXcgR2xvYmFsRGF0ZShhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmV0dXJuIG5ldyBHbG9iYWxEYXRlKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzWzRdKTtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIHJldHVybiBuZXcgR2xvYmFsRGF0ZShhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c1s0XSwgYXJndW1lbnRzWzVdKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbmV3IEdsb2JhbERhdGUoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNbNF0sIGFyZ3VtZW50c1s1XSwgYXJndW1lbnRzWzZdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRlUHJvcGVydGllcygpIHtcbiAgICAgIEZha2VEYXRlLnByb3RvdHlwZSA9IEdsb2JhbERhdGUucHJvdG90eXBlO1xuXG4gICAgICBGYWtlRGF0ZS5ub3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKEdsb2JhbERhdGUubm93KSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRUaW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IERhdGUubm93KCknKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgRmFrZURhdGUudG9Tb3VyY2UgPSBHbG9iYWxEYXRlLnRvU291cmNlO1xuICAgICAgRmFrZURhdGUudG9TdHJpbmcgPSBHbG9iYWxEYXRlLnRvU3RyaW5nO1xuICAgICAgRmFrZURhdGUucGFyc2UgPSBHbG9iYWxEYXRlLnBhcnNlO1xuICAgICAgRmFrZURhdGUuVVRDID0gR2xvYmFsRGF0ZS5VVEM7XG4gICAgfVxuXHR9XG5cbiAgcmV0dXJuIE1vY2tEYXRlO1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5wcCA9IGZ1bmN0aW9uKGokKSB7XG5cbiAgZnVuY3Rpb24gUHJldHR5UHJpbnRlcigpIHtcbiAgICB0aGlzLnBwTmVzdExldmVsXyA9IDA7XG4gICAgdGhpcy5zZWVuID0gW107XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuc3RyaW5nUGFydHMgPSBbXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0N1c3RvbVRvU3RyaW5nKHZhbHVlKSB7XG4gICAgLy8gdmFsdWUudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgaWYgdmFsdWUgaGFzIG5vIGN1c3RvbSB0b1N0cmluZyBidXQgaXMgZnJvbSBhbm90aGVyIGNvbnRleHQgKGUuZy5cbiAgICAvLyBpZnJhbWUsIHdlYiB3b3JrZXIpXG4gICAgcmV0dXJuIGokLmlzRnVuY3Rpb25fKHZhbHVlLnRvU3RyaW5nKSAmJiB2YWx1ZS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyAmJiAodmFsdWUudG9TdHJpbmcoKSAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSk7XG4gIH1cblxuICBQcmV0dHlQcmludGVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXMucHBOZXN0TGV2ZWxfKys7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChqJC51dGlsLmlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJ3VuZGVmaW5lZCcpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJ251bGwnKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDAgJiYgMS92YWx1ZSA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcignLTAnKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IGokLmdldEdsb2JhbCgpKSB7XG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcignPGdsb2JhbD4nKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUuamFzbWluZVRvU3RyaW5nKSB7XG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcih2YWx1ZS5qYXNtaW5lVG9TdHJpbmcoKSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5lbWl0U3RyaW5nKHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaiQuaXNTcHkodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcignc3B5IG9uICcgKyB2YWx1ZS5hbmQuaWRlbnRpdHkoKSk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcih2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcignRnVuY3Rpb24nKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLm5vZGVUeXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJ0hUTUxOb2RlJyk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJ0RhdGUoJyArIHZhbHVlICsgJyknKTtcbiAgICAgIH0gZWxzZSBpZiAoaiQuaXNTZXQodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuZW1pdFNldCh2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGokLmlzTWFwKHZhbHVlKSkge1xuICAgICAgICB0aGlzLmVtaXRNYXAodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChqJC5pc1R5cGVkQXJyYXlfKHZhbHVlKSkge1xuICAgICAgICB0aGlzLmVtaXRUeXBlZEFycmF5KHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUudG9TdHJpbmcgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhaiQuaXNBcnJheV8odmFsdWUpICYmIGhhc0N1c3RvbVRvU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICB0aGlzLmVtaXRTY2FsYXIodmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICB9IGVsc2UgaWYgKGokLnV0aWwuYXJyYXlDb250YWlucyh0aGlzLnNlZW4sIHZhbHVlKSkge1xuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJzxjaXJjdWxhciByZWZlcmVuY2U6ICcgKyAoaiQuaXNBcnJheV8odmFsdWUpID8gJ0FycmF5JyA6ICdPYmplY3QnKSArICc+Jyk7XG4gICAgICB9IGVsc2UgaWYgKGokLmlzQXJyYXlfKHZhbHVlKSB8fCBqJC5pc0FfKCdPYmplY3QnLCB2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5zZWVuLnB1c2godmFsdWUpO1xuICAgICAgICBpZiAoaiQuaXNBcnJheV8odmFsdWUpKSB7XG4gICAgICAgICAgdGhpcy5lbWl0QXJyYXkodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZW1pdE9iamVjdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWVuLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICh0aGlzLnBwTmVzdExldmVsXyA+IDEgfHwgIShlIGluc3RhbmNlb2YgTWF4Q2hhcnNSZWFjaGVkRXJyb3IpKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMucHBOZXN0TGV2ZWxfLS07XG4gICAgfVxuICB9O1xuXG4gIFByZXR0eVByaW50ZXIucHJvdG90eXBlLml0ZXJhdGVPYmplY3QgPSBmdW5jdGlvbihvYmosIGZuKSB7XG4gICAgdmFyIG9iaktleXMgPSBrZXlzKG9iaiwgaiQuaXNBcnJheV8ob2JqKSk7XG4gICAgdmFyIGlzR2V0dGVyID0gZnVuY3Rpb24gaXNHZXR0ZXIocHJvcCkge307XG5cbiAgICBpZiAob2JqLl9fbG9va3VwR2V0dGVyX18pIHtcbiAgICAgIGlzR2V0dGVyID0gZnVuY3Rpb24gaXNHZXR0ZXIocHJvcCkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gb2JqLl9fbG9va3VwR2V0dGVyX18ocHJvcCk7XG4gICAgICAgIHJldHVybiAhaiQudXRpbC5pc1VuZGVmaW5lZChnZXR0ZXIpICYmIGdldHRlciAhPT0gbnVsbDtcbiAgICAgIH07XG5cbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWluKG9iaktleXMubGVuZ3RoLCBqJC5NQVhfUFJFVFRZX1BSSU5UX0FSUkFZX0xFTkdUSCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3BlcnR5ID0gb2JqS2V5c1tpXTtcbiAgICAgIGZuKHByb3BlcnR5LCBpc0dldHRlcihwcm9wZXJ0eSkpO1xuICAgIH1cblxuICAgIHJldHVybiBvYmpLZXlzLmxlbmd0aCA+IGxlbmd0aDtcbiAgfTtcblxuICBQcmV0dHlQcmludGVyLnByb3RvdHlwZS5lbWl0U2NhbGFyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB0aGlzLmFwcGVuZCh2YWx1ZSk7XG4gIH07XG5cbiAgUHJldHR5UHJpbnRlci5wcm90b3R5cGUuZW1pdFN0cmluZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5hcHBlbmQoJ1xcJycgKyB2YWx1ZSArICdcXCcnKTtcbiAgfTtcblxuICBQcmV0dHlQcmludGVyLnByb3RvdHlwZS5lbWl0QXJyYXkgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIGlmICh0aGlzLnBwTmVzdExldmVsXyA+IGokLk1BWF9QUkVUVFlfUFJJTlRfREVQVEgpIHtcbiAgICAgIHRoaXMuYXBwZW5kKCdBcnJheScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oYXJyYXkubGVuZ3RoLCBqJC5NQVhfUFJFVFRZX1BSSU5UX0FSUkFZX0xFTkdUSCk7XG4gICAgdGhpcy5hcHBlbmQoJ1sgJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKCcsICcpO1xuICAgICAgfVxuICAgICAgdGhpcy5mb3JtYXQoYXJyYXlbaV0pO1xuICAgIH1cbiAgICBpZihhcnJheS5sZW5ndGggPiBsZW5ndGgpe1xuICAgICAgdGhpcy5hcHBlbmQoJywgLi4uJyk7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBmaXJzdCA9IGFycmF5Lmxlbmd0aCA9PT0gMDtcbiAgICB2YXIgdHJ1bmNhdGVkID0gdGhpcy5pdGVyYXRlT2JqZWN0KGFycmF5LCBmdW5jdGlvbihwcm9wZXJ0eSwgaXNHZXR0ZXIpIHtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5hcHBlbmQoJywgJyk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuZm9ybWF0UHJvcGVydHkoYXJyYXksIHByb3BlcnR5LCBpc0dldHRlcik7XG4gICAgfSk7XG5cbiAgICBpZiAodHJ1bmNhdGVkKSB7IHRoaXMuYXBwZW5kKCcsIC4uLicpOyB9XG5cbiAgICB0aGlzLmFwcGVuZCgnIF0nKTtcbiAgfTtcblxuICBQcmV0dHlQcmludGVyLnByb3RvdHlwZS5lbWl0U2V0ID0gZnVuY3Rpb24oc2V0KSB7XG4gICAgaWYgKHRoaXMucHBOZXN0TGV2ZWxfID4gaiQuTUFYX1BSRVRUWV9QUklOVF9ERVBUSCkge1xuICAgICAgdGhpcy5hcHBlbmQoJ1NldCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFwcGVuZCgnU2V0KCAnKTtcbiAgICB2YXIgc2l6ZSA9IE1hdGgubWluKHNldC5zaXplLCBqJC5NQVhfUFJFVFRZX1BSSU5UX0FSUkFZX0xFTkdUSCk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHNldC5mb3JFYWNoKCBmdW5jdGlvbiggdmFsdWUsIGtleSApIHtcbiAgICAgIGlmIChpID49IHNpemUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKCcsICcpO1xuICAgICAgfVxuICAgICAgdGhpcy5mb3JtYXQodmFsdWUpO1xuXG4gICAgICBpKys7XG4gICAgfSwgdGhpcyApO1xuICAgIGlmIChzZXQuc2l6ZSA+IHNpemUpe1xuICAgICAgdGhpcy5hcHBlbmQoJywgLi4uJyk7XG4gICAgfVxuICAgIHRoaXMuYXBwZW5kKCcgKScpO1xuICB9O1xuXG4gIFByZXR0eVByaW50ZXIucHJvdG90eXBlLmVtaXRNYXAgPSBmdW5jdGlvbihtYXApIHtcbiAgICBpZiAodGhpcy5wcE5lc3RMZXZlbF8gPiBqJC5NQVhfUFJFVFRZX1BSSU5UX0RFUFRIKSB7XG4gICAgICB0aGlzLmFwcGVuZCgnTWFwJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYXBwZW5kKCdNYXAoICcpO1xuICAgIHZhciBzaXplID0gTWF0aC5taW4obWFwLnNpemUsIGokLk1BWF9QUkVUVFlfUFJJTlRfQVJSQVlfTEVOR1RIKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgbWFwLmZvckVhY2goIGZ1bmN0aW9uKCB2YWx1ZSwga2V5ICkge1xuICAgICAgaWYgKGkgPj0gc2l6ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgdGhpcy5hcHBlbmQoJywgJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmZvcm1hdChba2V5LHZhbHVlXSk7XG5cbiAgICAgIGkrKztcbiAgICB9LCB0aGlzICk7XG4gICAgaWYgKG1hcC5zaXplID4gc2l6ZSl7XG4gICAgICB0aGlzLmFwcGVuZCgnLCAuLi4nKTtcbiAgICB9XG4gICAgdGhpcy5hcHBlbmQoJyApJyk7XG4gIH07XG5cbiAgUHJldHR5UHJpbnRlci5wcm90b3R5cGUuZW1pdE9iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBjdG9yID0gb2JqLmNvbnN0cnVjdG9yLFxuICAgICAgICBjb25zdHJ1Y3Rvck5hbWU7XG5cbiAgICBjb25zdHJ1Y3Rvck5hbWUgPSB0eXBlb2YgY3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmogaW5zdGFuY2VvZiBjdG9yID9cbiAgICAgIGokLmZuTmFtZUZvcihvYmouY29uc3RydWN0b3IpIDpcbiAgICAgICdudWxsJztcblxuICAgIHRoaXMuYXBwZW5kKGNvbnN0cnVjdG9yTmFtZSk7XG5cbiAgICBpZiAodGhpcy5wcE5lc3RMZXZlbF8gPiBqJC5NQVhfUFJFVFRZX1BSSU5UX0RFUFRIKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuYXBwZW5kKCcoeyAnKTtcbiAgICB2YXIgZmlyc3QgPSB0cnVlO1xuXG4gICAgdmFyIHRydW5jYXRlZCA9IHRoaXMuaXRlcmF0ZU9iamVjdChvYmosIGZ1bmN0aW9uKHByb3BlcnR5LCBpc0dldHRlcikge1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmFwcGVuZCgnLCAnKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5mb3JtYXRQcm9wZXJ0eShvYmosIHByb3BlcnR5LCBpc0dldHRlcik7XG4gICAgfSk7XG5cbiAgICBpZiAodHJ1bmNhdGVkKSB7IHRoaXMuYXBwZW5kKCcsIC4uLicpOyB9XG5cbiAgICB0aGlzLmFwcGVuZCgnIH0pJyk7XG4gIH07XG5cbiAgUHJldHR5UHJpbnRlci5wcm90b3R5cGUuZW1pdFR5cGVkQXJyYXkgPSBmdW5jdGlvbihhcnIpIHtcbiAgICB2YXIgY29uc3RydWN0b3JOYW1lID0gaiQuZm5OYW1lRm9yKGFyci5jb25zdHJ1Y3RvciksXG4gICAgICBsaW1pdGVkQXJyYXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnIsIDAsIGokLk1BWF9QUkVUVFlfUFJJTlRfQVJSQVlfTEVOR1RIKSxcbiAgICAgIGl0ZW1zU3RyaW5nID0gQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbChsaW1pdGVkQXJyYXksICcsICcpO1xuXG4gICAgaWYgKGxpbWl0ZWRBcnJheS5sZW5ndGggIT09IGFyci5sZW5ndGgpIHtcbiAgICAgIGl0ZW1zU3RyaW5nICs9ICcsIC4uLic7XG4gICAgfVxuXG4gICAgdGhpcy5hcHBlbmQoY29uc3RydWN0b3JOYW1lICsgJyBbICcgKyBpdGVtc1N0cmluZyArICcgXScpO1xuICB9O1xuXG4gIFByZXR0eVByaW50ZXIucHJvdG90eXBlLmZvcm1hdFByb3BlcnR5ID0gZnVuY3Rpb24ob2JqLCBwcm9wZXJ0eSwgaXNHZXR0ZXIpIHtcbiAgICAgIHRoaXMuYXBwZW5kKHByb3BlcnR5KTtcbiAgICAgIHRoaXMuYXBwZW5kKCc6ICcpO1xuICAgICAgaWYgKGlzR2V0dGVyKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKCc8Z2V0dGVyPicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mb3JtYXQob2JqW3Byb3BlcnR5XSk7XG4gICAgICB9XG4gIH07XG5cbiAgUHJldHR5UHJpbnRlci5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gdHJ1bmNhdGUodmFsdWUsIGokLk1BWF9QUkVUVFlfUFJJTlRfQ0hBUlMgLSB0aGlzLmxlbmd0aCk7XG4gICAgdGhpcy5sZW5ndGggKz0gcmVzdWx0LnZhbHVlLmxlbmd0aDtcbiAgICB0aGlzLnN0cmluZ1BhcnRzLnB1c2gocmVzdWx0LnZhbHVlKTtcblxuICAgIGlmIChyZXN1bHQudHJ1bmNhdGVkKSB7XG4gICAgICB0aHJvdyBuZXcgTWF4Q2hhcnNSZWFjaGVkRXJyb3IoKTtcbiAgICB9XG4gIH07XG5cblxuICBmdW5jdGlvbiB0cnVuY2F0ZShzLCBtYXhsZW4pIHtcbiAgICBpZiAocy5sZW5ndGggPD0gbWF4bGVuKSB7XG4gICAgICByZXR1cm4geyB2YWx1ZTogcywgdHJ1bmNhdGVkOiBmYWxzZSB9O1xuICAgIH1cblxuICAgIHMgPSBzLnN1YnN0cmluZygwLCBtYXhsZW4gLSA0KSArICcgLi4uJztcbiAgICByZXR1cm4geyB2YWx1ZTogcywgdHJ1bmNhdGVkOiB0cnVlIH07XG4gIH1cblxuICBmdW5jdGlvbiBNYXhDaGFyc1JlYWNoZWRFcnJvcigpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSAnRXhjZWVkZWQgJyArIGokLk1BWF9QUkVUVFlfUFJJTlRfQ0hBUlMgK1xuICAgICAgJyBjaGFyYWN0ZXJzIHdoaWxlIHByZXR0eS1wcmludGluZyBhIHZhbHVlJztcbiAgfVxuXG4gIE1heENoYXJzUmVhY2hlZEVycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuXG4gIGZ1bmN0aW9uIGtleXMob2JqLCBpc0FycmF5KSB7XG4gICAgdmFyIGFsbEtleXMgPSBPYmplY3Qua2V5cyA/IE9iamVjdC5rZXlzKG9iaikgOlxuICAgICAgKGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvKSB7XG4gICAgICAgICAgICAgIGlmIChqJC51dGlsLmhhcyhvLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgIH0pKG9iaik7XG5cbiAgICBpZiAoIWlzQXJyYXkpIHtcbiAgICAgIHJldHVybiBhbGxLZXlzO1xuICAgIH1cblxuICAgIGlmIChhbGxLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYWxsS2V5cztcbiAgICB9XG5cbiAgICB2YXIgZXh0cmFLZXlzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIS9eWzAtOV0rJC8udGVzdChhbGxLZXlzW2ldKSkge1xuICAgICAgICBleHRyYUtleXMucHVzaChhbGxLZXlzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXh0cmFLZXlzO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBwcmV0dHlQcmludGVyID0gbmV3IFByZXR0eVByaW50ZXIoKTtcbiAgICBwcmV0dHlQcmludGVyLmZvcm1hdCh2YWx1ZSk7XG4gICAgcmV0dXJuIHByZXR0eVByaW50ZXIuc3RyaW5nUGFydHMuam9pbignJyk7XG4gIH07XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlF1ZXVlUnVubmVyID0gZnVuY3Rpb24oaiQpIHtcblxuICBmdW5jdGlvbiBvbmNlKGZuKSB7XG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gUXVldWVSdW5uZXIoYXR0cnMpIHtcbiAgICB2YXIgcXVldWVhYmxlRm5zID0gYXR0cnMucXVldWVhYmxlRm5zIHx8IFtdO1xuICAgIHRoaXMucXVldWVhYmxlRm5zID0gcXVldWVhYmxlRm5zLmNvbmNhdChhdHRycy5jbGVhbnVwRm5zIHx8IFtdKTtcbiAgICB0aGlzLmZpcnN0Q2xlYW51cEl4ID0gcXVldWVhYmxlRm5zLmxlbmd0aDtcbiAgICB0aGlzLm9uQ29tcGxldGUgPSBhdHRycy5vbkNvbXBsZXRlIHx8IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy5jbGVhclN0YWNrID0gYXR0cnMuY2xlYXJTdGFjayB8fCBmdW5jdGlvbihmbikge2ZuKCk7fTtcbiAgICB0aGlzLm9uRXhjZXB0aW9uID0gYXR0cnMub25FeGNlcHRpb24gfHwgZnVuY3Rpb24oKSB7fTtcbiAgICB0aGlzLmNhdGNoRXhjZXB0aW9uID0gYXR0cnMuY2F0Y2hFeGNlcHRpb24gfHwgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9O1xuICAgIHRoaXMudXNlckNvbnRleHQgPSBhdHRycy51c2VyQ29udGV4dCB8fCBuZXcgaiQuVXNlckNvbnRleHQoKTtcbiAgICB0aGlzLnRpbWVvdXQgPSBhdHRycy50aW1lb3V0IHx8IHtzZXRUaW1lb3V0OiBzZXRUaW1lb3V0LCBjbGVhclRpbWVvdXQ6IGNsZWFyVGltZW91dH07XG4gICAgdGhpcy5mYWlsID0gYXR0cnMuZmFpbCB8fCBmdW5jdGlvbigpIHt9O1xuICAgIHRoaXMuZ2xvYmFsRXJyb3JzID0gYXR0cnMuZ2xvYmFsRXJyb3JzIHx8IHsgcHVzaExpc3RlbmVyOiBmdW5jdGlvbigpIHt9LCBwb3BMaXN0ZW5lcjogZnVuY3Rpb24oKSB7fSB9O1xuICAgIHRoaXMuY29tcGxldGVPbkZpcnN0RXJyb3IgPSAhIWF0dHJzLmNvbXBsZXRlT25GaXJzdEVycm9yO1xuICAgIHRoaXMuZGVwcmVjYXRlZCA9IGF0dHJzLmRlcHJlY2F0ZWQ7XG4gIH1cblxuICBRdWV1ZVJ1bm5lci5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmhhbmRsZUZpbmFsRXJyb3IgPSBmdW5jdGlvbihlcnJvcikge1xuICAgICAgc2VsZi5vbkV4Y2VwdGlvbihlcnJvcik7XG4gICAgfTtcbiAgICB0aGlzLmdsb2JhbEVycm9ycy5wdXNoTGlzdGVuZXIodGhpcy5oYW5kbGVGaW5hbEVycm9yKTtcbiAgICB0aGlzLnJ1bigwKTtcbiAgfTtcblxuICBRdWV1ZVJ1bm5lci5wcm90b3R5cGUuc2tpcFRvQ2xlYW51cCA9IGZ1bmN0aW9uKGxhc3RSYW5JbmRleCkge1xuICAgIGlmIChsYXN0UmFuSW5kZXggPCB0aGlzLmZpcnN0Q2xlYW51cEl4KSB7XG4gICAgICB0aGlzLnJ1bih0aGlzLmZpcnN0Q2xlYW51cEl4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ydW4obGFzdFJhbkluZGV4ICsgMSk7XG4gICAgfVxuICB9O1xuXG4gIFF1ZXVlUnVubmVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbihyZWN1cnNpdmVJbmRleCkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLnF1ZXVlYWJsZUZucy5sZW5ndGgsXG4gICAgICBzZWxmID0gdGhpcyxcbiAgICAgIGl0ZXJhdGl2ZUluZGV4O1xuXG5cbiAgICBmb3IoaXRlcmF0aXZlSW5kZXggPSByZWN1cnNpdmVJbmRleDsgaXRlcmF0aXZlSW5kZXggPCBsZW5ndGg7IGl0ZXJhdGl2ZUluZGV4KyspIHtcbiAgICAgIHZhciByZXN1bHQgPSBhdHRlbXB0KGl0ZXJhdGl2ZUluZGV4KTtcblxuICAgICAgaWYgKCFyZXN1bHQuY29tcGxldGVkU3luY2hyb25vdXNseSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNvbXBsZXRlT25GaXJzdEVycm9yICYmIHJlc3VsdC5lcnJvcmVkKSB7XG4gICAgICAgIHRoaXMuc2tpcFRvQ2xlYW51cChpdGVyYXRpdmVJbmRleCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyU3RhY2soZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmdsb2JhbEVycm9ycy5wb3BMaXN0ZW5lcihzZWxmLmhhbmRsZUZpbmFsRXJyb3IpO1xuICAgICAgc2VsZi5vbkNvbXBsZXRlKCk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhdHRlbXB0KCkge1xuICAgICAgdmFyIGNsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoc2VsZi50aW1lb3V0LmNsZWFyVGltZW91dCwgW2okLmdldEdsb2JhbCgpLCBbdGltZW91dElkXV0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXRUaW1lb3V0ID0gZnVuY3Rpb24oZGVsYXllZEZuLCBkZWxheSkge1xuICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoc2VsZi50aW1lb3V0LnNldFRpbWVvdXQsIFtqJC5nZXRHbG9iYWwoKSwgW2RlbGF5ZWRGbiwgZGVsYXldXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlZFN5bmNocm9ub3VzbHkgPSB0cnVlLFxuICAgICAgICBoYW5kbGVFcnJvciA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgb25FeGNlcHRpb24oZXJyb3IpO1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYW51cCA9IG9uY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgc2VsZi5nbG9iYWxFcnJvcnMucG9wTGlzdGVuZXIoaGFuZGxlRXJyb3IpO1xuICAgICAgICB9KSxcbiAgICAgICAgbmV4dCA9IG9uY2UoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGNsZWFudXAoKTtcblxuICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgc2VsZi5kZXByZWNhdGVkKCdkb25lIGNhbGxiYWNrIHJlY2VpdmVkIGFuIEVycm9yIG9iamVjdC4gSmFzbWluZSAzLjAgd2lsbCB0cmVhdCB0aGlzIGFzIGEgZmFpbHVyZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHJ1bk5leHQoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb21wbGV0ZU9uRmlyc3RFcnJvciAmJiBlcnJvcmVkKSB7XG4gICAgICAgICAgICAgIHNlbGYuc2tpcFRvQ2xlYW51cChpdGVyYXRpdmVJbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxmLnJ1bihpdGVyYXRpdmVJbmRleCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb21wbGV0ZWRTeW5jaHJvbm91c2x5KSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bk5leHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBydW5OZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3JlZCA9IGZhbHNlLFxuICAgICAgICBxdWV1ZWFibGVGbiA9IHNlbGYucXVldWVhYmxlRm5zW2l0ZXJhdGl2ZUluZGV4XSxcbiAgICAgICAgdGltZW91dElkO1xuXG4gICAgICBuZXh0LmZhaWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5mYWlsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIGVycm9yZWQgPSB0cnVlO1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmdsb2JhbEVycm9ycy5wdXNoTGlzdGVuZXIoaGFuZGxlRXJyb3IpO1xuXG4gICAgICBpZiAocXVldWVhYmxlRm4udGltZW91dCkge1xuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVGltZW91dCAtIEFzeW5jIGNhbGxiYWNrIHdhcyBub3QgaW52b2tlZCB3aXRoaW4gdGltZW91dCBzcGVjaWZpZWQgYnkgamFzbWluZS5ERUZBVUxUX1RJTUVPVVRfSU5URVJWQUwuJyk7XG4gICAgICAgICAgb25FeGNlcHRpb24oZXJyb3IpO1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfSwgcXVldWVhYmxlRm4udGltZW91dCgpKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHF1ZXVlYWJsZUZuLmZuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHZhciBtYXliZVRoZW5hYmxlID0gcXVldWVhYmxlRm4uZm4uY2FsbChzZWxmLnVzZXJDb250ZXh0KTtcblxuICAgICAgICAgIGlmIChtYXliZVRoZW5hYmxlICYmIGokLmlzRnVuY3Rpb25fKG1heWJlVGhlbmFibGUudGhlbikpIHtcbiAgICAgICAgICAgIG1heWJlVGhlbmFibGUudGhlbihuZXh0LCBvblByb21pc2VSZWplY3Rpb24pO1xuICAgICAgICAgICAgY29tcGxldGVkU3luY2hyb25vdXNseSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHsgY29tcGxldGVkU3luY2hyb25vdXNseTogZmFsc2UgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcXVldWVhYmxlRm4uZm4uY2FsbChzZWxmLnVzZXJDb250ZXh0LCBuZXh0KTtcbiAgICAgICAgICBjb21wbGV0ZWRTeW5jaHJvbm91c2x5ID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIHsgY29tcGxldGVkU3luY2hyb25vdXNseTogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFeGNlcHRpb24oZSwgcXVldWVhYmxlRm4pO1xuICAgICAgICBlcnJvcmVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgY2xlYW51cCgpO1xuICAgICAgcmV0dXJuIHsgY29tcGxldGVkU3luY2hyb25vdXNseTogdHJ1ZSwgZXJyb3JlZDogZXJyb3JlZCB9O1xuXG4gICAgICBmdW5jdGlvbiBvbkV4Y2VwdGlvbihlKSB7XG4gICAgICAgIHNlbGYub25FeGNlcHRpb24oZSk7XG4gICAgICAgIGVycm9yZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvblByb21pc2VSZWplY3Rpb24oZSkge1xuICAgICAgICBvbkV4Y2VwdGlvbihlKTtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVFeGNlcHRpb24oZSwgcXVldWVhYmxlRm4pIHtcbiAgICAgICAgb25FeGNlcHRpb24oZSk7XG4gICAgICAgIGlmICghc2VsZi5jYXRjaEV4Y2VwdGlvbihlKSkge1xuICAgICAgICAgIC8vVE9ETzogc2V0IGEgdmFyIHdoZW4gd2UgY2F0Y2ggYW4gZXhjZXB0aW9uIGFuZFxuICAgICAgICAgIC8vdXNlIGEgZmluYWxseSBibG9jayB0byBjbG9zZSB0aGUgbG9vcCBpbiBhIG5pY2Ugd2F5Li5cbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBRdWV1ZVJ1bm5lcjtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuUmVwb3J0RGlzcGF0Y2hlciA9IGZ1bmN0aW9uKGokKSB7XG4gIGZ1bmN0aW9uIFJlcG9ydERpc3BhdGNoZXIobWV0aG9kcykge1xuXG4gICAgdmFyIGRpc3BhdGNoZWRNZXRob2RzID0gbWV0aG9kcyB8fCBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hlZE1ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBtZXRob2QgPSBkaXNwYXRjaGVkTWV0aG9kc1tpXTtcbiAgICAgIHRoaXNbbWV0aG9kXSA9IChmdW5jdGlvbihtKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBkaXNwYXRjaChtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShtZXRob2QpKTtcbiAgICB9XG5cbiAgICB2YXIgcmVwb3J0ZXJzID0gW107XG4gICAgdmFyIGZhbGxiYWNrUmVwb3J0ZXIgPSBudWxsO1xuXG4gICAgdGhpcy5hZGRSZXBvcnRlciA9IGZ1bmN0aW9uKHJlcG9ydGVyKSB7XG4gICAgICByZXBvcnRlcnMucHVzaChyZXBvcnRlcik7XG4gICAgfTtcblxuICAgIHRoaXMucHJvdmlkZUZhbGxiYWNrUmVwb3J0ZXIgPSBmdW5jdGlvbihyZXBvcnRlcikge1xuICAgICAgZmFsbGJhY2tSZXBvcnRlciA9IHJlcG9ydGVyO1xuICAgIH07XG5cbiAgICB0aGlzLmNsZWFyUmVwb3J0ZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXBvcnRlcnMgPSBbXTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgICBmdW5jdGlvbiBkaXNwYXRjaChtZXRob2QsIGFyZ3MpIHtcbiAgICAgIGlmIChyZXBvcnRlcnMubGVuZ3RoID09PSAwICYmIGZhbGxiYWNrUmVwb3J0ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICByZXBvcnRlcnMucHVzaChmYWxsYmFja1JlcG9ydGVyKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwb3J0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByZXBvcnRlciA9IHJlcG9ydGVyc1tpXTtcbiAgICAgICAgaWYgKHJlcG9ydGVyW21ldGhvZF0pIHtcbiAgICAgICAgICByZXBvcnRlclttZXRob2RdLmFwcGx5KHJlcG9ydGVyLCBqJC51dGlsLmNsb25lQXJncyhhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gUmVwb3J0RGlzcGF0Y2hlcjtcbn07XG5cblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5pbnRlcmZhY2UgPSBmdW5jdGlvbihqYXNtaW5lLCBlbnYpIHtcbiAgdmFyIGphc21pbmVJbnRlcmZhY2UgPSB7XG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgcGFzc2VkIHRvIHBhcnRzIG9mIHRoZSBKYXNtaW5lIGJhc2UgaW50ZXJmYWNlLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCBKYXNtaW5lIGFzc3VtZXMgdGhpcyBmdW5jdGlvbiBjb21wbGV0ZXMgc3luY2hyb25vdXNseS5cbiAgICAgKiBJZiB5b3UgaGF2ZSBjb2RlIHRoYXQgeW91IG5lZWQgdG8gdGVzdCBhc3luY2hyb25vdXNseSwgeW91IGNhbiBkZWNsYXJlIHRoYXQgeW91IHJlY2VpdmUgYSBgZG9uZWAgY2FsbGJhY2ssIHJldHVybiBhIFByb21pc2UsIG9yIHVzZSB0aGUgYGFzeW5jYCBrZXl3b3JkIGlmIGl0IGlzIHN1cHBvcnRlZCBpbiB5b3VyIGVudmlyb25tZW50LlxuICAgICAqIEBjYWxsYmFjayBpbXBsZW1lbnRhdGlvbkNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2RvbmVdIFVzZWQgdG8gc3BlY2lmeSB0byBKYXNtaW5lIHRoYXQgdGhpcyBjYWxsYmFjayBpcyBhc3luY2hyb25vdXMgYW5kIEphc21pbmUgc2hvdWxkIHdhaXQgdW50aWwgaXQgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSBtb3Zpbmcgb24uXG4gICAgICogQHJldHVybnMge30gT3B0aW9uYWxseSByZXR1cm4gYSBQcm9taXNlIGluc3RlYWQgb2YgdXNpbmcgYGRvbmVgIHRvIGNhdXNlIEphc21pbmUgdG8gd2FpdCBmb3IgY29tcGxldGlvbi5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGdyb3VwIG9mIHNwZWNzIChvZnRlbiBjYWxsZWQgYSBzdWl0ZSkuXG4gICAgICpcbiAgICAgKiBDYWxscyB0byBgZGVzY3JpYmVgIGNhbiBiZSBuZXN0ZWQgd2l0aGluIG90aGVyIGNhbGxzIHRvIGNvbXBvc2UgeW91ciBzdWl0ZSBhcyBhIHRyZWUuXG4gICAgICogQG5hbWUgZGVzY3JpYmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZ2xvYmFsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlc2NyaXB0aW9uIFRleHR1YWwgZGVzY3JpcHRpb24gb2YgdGhlIGdyb3VwXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3BlY0RlZmluaXRpb25zIEZ1bmN0aW9uIGZvciBKYXNtaW5lIHRvIGludm9rZSB0aGF0IHdpbGwgZGVmaW5lIGlubmVyIHN1aXRlcyBhbmQgc3BlY3NcbiAgICAgKi9cbiAgICBkZXNjcmliZTogZnVuY3Rpb24oZGVzY3JpcHRpb24sIHNwZWNEZWZpbml0aW9ucykge1xuICAgICAgcmV0dXJuIGVudi5kZXNjcmliZShkZXNjcmlwdGlvbiwgc3BlY0RlZmluaXRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0ZW1wb3JhcmlseSBkaXNhYmxlZCBbYGRlc2NyaWJlYF17QGxpbmsgZGVzY3JpYmV9XG4gICAgICpcbiAgICAgKiBTcGVjcyB3aXRoaW4gYW4gYHhkZXNjcmliZWAgd2lsbCBiZSBtYXJrZWQgcGVuZGluZyBhbmQgbm90IGV4ZWN1dGVkXG4gICAgICogQG5hbWUgeGRlc2NyaWJlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGdsb2JhbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZXNjcmlwdGlvbiBUZXh0dWFsIGRlc2NyaXB0aW9uIG9mIHRoZSBncm91cFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNwZWNEZWZpbml0aW9ucyBGdW5jdGlvbiBmb3IgSmFzbWluZSB0byBpbnZva2UgdGhhdCB3aWxsIGRlZmluZSBpbm5lciBzdWl0ZXMgYW5kIHNwZWNzXG4gICAgICovXG4gICAgeGRlc2NyaWJlOiBmdW5jdGlvbihkZXNjcmlwdGlvbiwgc3BlY0RlZmluaXRpb25zKSB7XG4gICAgICByZXR1cm4gZW52LnhkZXNjcmliZShkZXNjcmlwdGlvbiwgc3BlY0RlZmluaXRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSBmb2N1c2VkIFtgZGVzY3JpYmVgXXtAbGluayBkZXNjcmliZX1cbiAgICAgKlxuICAgICAqIElmIHN1aXRlcyBvciBzcGVjcyBhcmUgZm9jdXNlZCwgb25seSB0aG9zZSB0aGF0IGFyZSBmb2N1c2VkIHdpbGwgYmUgZXhlY3V0ZWRcbiAgICAgKiBAc2VlIGZpdFxuICAgICAqIEBuYW1lIGZkZXNjcmliZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBnbG9iYWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVzY3JpcHRpb24gVGV4dHVhbCBkZXNjcmlwdGlvbiBvZiB0aGUgZ3JvdXBcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzcGVjRGVmaW5pdGlvbnMgRnVuY3Rpb24gZm9yIEphc21pbmUgdG8gaW52b2tlIHRoYXQgd2lsbCBkZWZpbmUgaW5uZXIgc3VpdGVzIGFuZCBzcGVjc1xuICAgICAqL1xuICAgIGZkZXNjcmliZTogZnVuY3Rpb24oZGVzY3JpcHRpb24sIHNwZWNEZWZpbml0aW9ucykge1xuICAgICAgcmV0dXJuIGVudi5mZGVzY3JpYmUoZGVzY3JpcHRpb24sIHNwZWNEZWZpbml0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlZmluZSBhIHNpbmdsZSBzcGVjLiBBIHNwZWMgc2hvdWxkIGNvbnRhaW4gb25lIG9yIG1vcmUge0BsaW5rIGV4cGVjdHxleHBlY3RhdGlvbnN9IHRoYXQgdGVzdCB0aGUgc3RhdGUgb2YgdGhlIGNvZGUuXG4gICAgICpcbiAgICAgKiBBIHNwZWMgd2hvc2UgZXhwZWN0YXRpb25zIGFsbCBzdWNjZWVkIHdpbGwgYmUgcGFzc2luZyBhbmQgYSBzcGVjIHdpdGggYW55IGZhaWx1cmVzIHdpbGwgZmFpbC5cbiAgICAgKiBAbmFtZSBpdFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBnbG9iYWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVzY3JpcHRpb24gVGV4dHVhbCBkZXNjcmlwdGlvbiBvZiB3aGF0IHRoaXMgc3BlYyBpcyBjaGVja2luZ1xuICAgICAqIEBwYXJhbSB7aW1wbGVtZW50YXRpb25DYWxsYmFja30gW3Rlc3RGdW5jdGlvbl0gRnVuY3Rpb24gdGhhdCBjb250YWlucyB0aGUgY29kZSBvZiB5b3VyIHRlc3QuIElmIG5vdCBwcm92aWRlZCB0aGUgdGVzdCB3aWxsIGJlIGBwZW5kaW5nYC5cbiAgICAgKiBAcGFyYW0ge0ludH0gW3RpbWVvdXQ9e0BsaW5rIGphc21pbmUuREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMfV0gQ3VzdG9tIHRpbWVvdXQgZm9yIGFuIGFzeW5jIHNwZWMuXG4gICAgICovXG4gICAgaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGVudi5pdC5hcHBseShlbnYsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdGVtcG9yYXJpbHkgZGlzYWJsZWQgW2BpdGBde0BsaW5rIGl0fVxuICAgICAqXG4gICAgICogVGhlIHNwZWMgd2lsbCByZXBvcnQgYXMgYHBlbmRpbmdgIGFuZCB3aWxsIG5vdCBiZSBleGVjdXRlZC5cbiAgICAgKiBAbmFtZSB4aXRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZ2xvYmFsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlc2NyaXB0aW9uIFRleHR1YWwgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGlzIHNwZWMgaXMgY2hlY2tpbmcuXG4gICAgICogQHBhcmFtIHtpbXBsZW1lbnRhdGlvbkNhbGxiYWNrfSBbdGVzdEZ1bmN0aW9uXSBGdW5jdGlvbiB0aGF0IGNvbnRhaW5zIHRoZSBjb2RlIG9mIHlvdXIgdGVzdC4gV2lsbCBub3QgYmUgZXhlY3V0ZWQuXG4gICAgICovXG4gICAgeGl0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBlbnYueGl0LmFwcGx5KGVudiwgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSBmb2N1c2VkIFtgaXRgXXtAbGluayBpdH1cbiAgICAgKlxuICAgICAqIElmIHN1aXRlcyBvciBzcGVjcyBhcmUgZm9jdXNlZCwgb25seSB0aG9zZSB0aGF0IGFyZSBmb2N1c2VkIHdpbGwgYmUgZXhlY3V0ZWQuXG4gICAgICogQG5hbWUgZml0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGdsb2JhbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZXNjcmlwdGlvbiBUZXh0dWFsIGRlc2NyaXB0aW9uIG9mIHdoYXQgdGhpcyBzcGVjIGlzIGNoZWNraW5nLlxuICAgICAqIEBwYXJhbSB7aW1wbGVtZW50YXRpb25DYWxsYmFja30gdGVzdEZ1bmN0aW9uIEZ1bmN0aW9uIHRoYXQgY29udGFpbnMgdGhlIGNvZGUgb2YgeW91ciB0ZXN0LlxuICAgICAqIEBwYXJhbSB7SW50fSBbdGltZW91dD17QGxpbmsgamFzbWluZS5ERUZBVUxUX1RJTUVPVVRfSU5URVJWQUx9XSBDdXN0b20gdGltZW91dCBmb3IgYW4gYXN5bmMgc3BlYy5cbiAgICAgKi9cbiAgICBmaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGVudi5maXQuYXBwbHkoZW52LCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSdW4gc29tZSBzaGFyZWQgc2V0dXAgYmVmb3JlIGVhY2ggb2YgdGhlIHNwZWNzIGluIHRoZSB7QGxpbmsgZGVzY3JpYmV9IGluIHdoaWNoIGl0IGlzIGNhbGxlZC5cbiAgICAgKiBAbmFtZSBiZWZvcmVFYWNoXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGdsb2JhbFxuICAgICAqIEBwYXJhbSB7aW1wbGVtZW50YXRpb25DYWxsYmFja30gW2Z1bmN0aW9uXSBGdW5jdGlvbiB0aGF0IGNvbnRhaW5zIHRoZSBjb2RlIHRvIHNldHVwIHlvdXIgc3BlY3MuXG4gICAgICogQHBhcmFtIHtJbnR9IFt0aW1lb3V0PXtAbGluayBqYXNtaW5lLkRFRkFVTFRfVElNRU9VVF9JTlRFUlZBTH1dIEN1c3RvbSB0aW1lb3V0IGZvciBhbiBhc3luYyBiZWZvcmVFYWNoLlxuICAgICAqL1xuICAgIGJlZm9yZUVhY2g6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGVudi5iZWZvcmVFYWNoLmFwcGx5KGVudiwgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUnVuIHNvbWUgc2hhcmVkIHRlYXJkb3duIGFmdGVyIGVhY2ggb2YgdGhlIHNwZWNzIGluIHRoZSB7QGxpbmsgZGVzY3JpYmV9IGluIHdoaWNoIGl0IGlzIGNhbGxlZC5cbiAgICAgKiBAbmFtZSBhZnRlckVhY2hcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZ2xvYmFsXG4gICAgICogQHBhcmFtIHtpbXBsZW1lbnRhdGlvbkNhbGxiYWNrfSBbZnVuY3Rpb25dIEZ1bmN0aW9uIHRoYXQgY29udGFpbnMgdGhlIGNvZGUgdG8gdGVhcmRvd24geW91ciBzcGVjcy5cbiAgICAgKiBAcGFyYW0ge0ludH0gW3RpbWVvdXQ9e0BsaW5rIGphc21pbmUuREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMfV0gQ3VzdG9tIHRpbWVvdXQgZm9yIGFuIGFzeW5jIGFmdGVyRWFjaC5cbiAgICAgKi9cbiAgICBhZnRlckVhY2g6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGVudi5hZnRlckVhY2guYXBwbHkoZW52LCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSdW4gc29tZSBzaGFyZWQgc2V0dXAgb25jZSBiZWZvcmUgYWxsIG9mIHRoZSBzcGVjcyBpbiB0aGUge0BsaW5rIGRlc2NyaWJlfSBhcmUgcnVuLlxuICAgICAqXG4gICAgICogX05vdGU6XyBCZSBjYXJlZnVsLCBzaGFyaW5nIHRoZSBzZXR1cCBmcm9tIGEgYmVmb3JlQWxsIG1ha2VzIGl0IGVhc3kgdG8gYWNjaWRlbnRhbGx5IGxlYWsgc3RhdGUgYmV0d2VlbiB5b3VyIHNwZWNzIHNvIHRoYXQgdGhleSBlcnJvbmVvdXNseSBwYXNzIG9yIGZhaWwuXG4gICAgICogQG5hbWUgYmVmb3JlQWxsXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGdsb2JhbFxuICAgICAqIEBwYXJhbSB7aW1wbGVtZW50YXRpb25DYWxsYmFja30gW2Z1bmN0aW9uXSBGdW5jdGlvbiB0aGF0IGNvbnRhaW5zIHRoZSBjb2RlIHRvIHNldHVwIHlvdXIgc3BlY3MuXG4gICAgICogQHBhcmFtIHtJbnR9IFt0aW1lb3V0PXtAbGluayBqYXNtaW5lLkRFRkFVTFRfVElNRU9VVF9JTlRFUlZBTH1dIEN1c3RvbSB0aW1lb3V0IGZvciBhbiBhc3luYyBiZWZvcmVBbGwuXG4gICAgICovXG4gICAgYmVmb3JlQWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBlbnYuYmVmb3JlQWxsLmFwcGx5KGVudiwgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUnVuIHNvbWUgc2hhcmVkIHRlYXJkb3duIG9uY2UgYWZ0ZXIgYWxsIG9mIHRoZSBzcGVjcyBpbiB0aGUge0BsaW5rIGRlc2NyaWJlfSBhcmUgcnVuLlxuICAgICAqXG4gICAgICogX05vdGU6XyBCZSBjYXJlZnVsLCBzaGFyaW5nIHRoZSB0ZWFyZG93biBmcm9tIGEgYWZ0ZXJBbGwgbWFrZXMgaXQgZWFzeSB0byBhY2NpZGVudGFsbHkgbGVhayBzdGF0ZSBiZXR3ZWVuIHlvdXIgc3BlY3Mgc28gdGhhdCB0aGV5IGVycm9uZW91c2x5IHBhc3Mgb3IgZmFpbC5cbiAgICAgKiBAbmFtZSBhZnRlckFsbFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBnbG9iYWxcbiAgICAgKiBAcGFyYW0ge2ltcGxlbWVudGF0aW9uQ2FsbGJhY2t9IFtmdW5jdGlvbl0gRnVuY3Rpb24gdGhhdCBjb250YWlucyB0aGUgY29kZSB0byB0ZWFyZG93biB5b3VyIHNwZWNzLlxuICAgICAqIEBwYXJhbSB7SW50fSBbdGltZW91dD17QGxpbmsgamFzbWluZS5ERUZBVUxUX1RJTUVPVVRfSU5URVJWQUx9XSBDdXN0b20gdGltZW91dCBmb3IgYW4gYXN5bmMgYWZ0ZXJBbGwuXG4gICAgICovXG4gICAgYWZ0ZXJBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGVudi5hZnRlckFsbC5hcHBseShlbnYsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBleHBlY3RhdGlvbiBmb3IgYSBzcGVjLlxuICAgICAqIEBuYW1lIGV4cGVjdFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBnbG9iYWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWN0dWFsIC0gQWN0dWFsIGNvbXB1dGVkIHZhbHVlIHRvIHRlc3QgZXhwZWN0YXRpb25zIGFnYWluc3QuXG4gICAgICogQHJldHVybiB7bWF0Y2hlcnN9XG4gICAgICovXG4gICAgZXhwZWN0OiBmdW5jdGlvbihhY3R1YWwpIHtcbiAgICAgIHJldHVybiBlbnYuZXhwZWN0KGFjdHVhbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1hcmsgYSBzcGVjIGFzIHBlbmRpbmcsIGV4cGVjdGF0aW9uIHJlc3VsdHMgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqIEBuYW1lIHBlbmRpbmdcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZ2xvYmFsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFttZXNzYWdlXSAtIFJlYXNvbiB0aGUgc3BlYyBpcyBwZW5kaW5nLlxuICAgICAqL1xuICAgIHBlbmRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGVudi5wZW5kaW5nLmFwcGx5KGVudiwgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXhwbGljaXRseSBtYXJrIGEgc3BlYyBhcyBmYWlsZWQuXG4gICAgICogQG5hbWUgZmFpbFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBnbG9iYWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xFcnJvcn0gW2Vycm9yXSAtIFJlYXNvbiBmb3IgdGhlIGZhaWx1cmUuXG4gICAgKi9cbiAgICBmYWlsOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBlbnYuZmFpbC5hcHBseShlbnYsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc3RhbGwgYSBzcHkgb250byBhbiBleGlzdGluZyBvYmplY3QuXG4gICAgICogQG5hbWUgc3B5T25cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZ2xvYmFsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIFRoZSBvYmplY3QgdXBvbiB3aGljaCB0byBpbnN0YWxsIHRoZSB7QGxpbmsgU3B5fS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gcmVwbGFjZSB3aXRoIGEge0BsaW5rIFNweX0uXG4gICAgICogQHJldHVybnMge1NweX1cbiAgICAgKi9cbiAgICBzcHlPbjogZnVuY3Rpb24ob2JqLCBtZXRob2ROYW1lKSB7XG4gICAgICByZXR1cm4gZW52LnNweU9uKG9iaiwgbWV0aG9kTmFtZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc3RhbGwgYSBzcHkgb24gYSBwcm9wZXJ0eSBpbnN0YWxsZWQgd2l0aCBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBvbnRvIGFuIGV4aXN0aW5nIG9iamVjdC5cbiAgICAgKiBAbmFtZSBzcHlPblByb3BlcnR5XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGdsb2JhbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBUaGUgb2JqZWN0IHVwb24gd2hpY2ggdG8gaW5zdGFsbCB0aGUge0BsaW5rIFNweX1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHJlcGxhY2Ugd2l0aCBhIHtAbGluayBTcHl9LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbYWNjZXNzVHlwZT1nZXRdIC0gVGhlIGFjY2VzcyB0eXBlIChnZXR8c2V0KSBvZiB0aGUgcHJvcGVydHkgdG8ge0BsaW5rIFNweX0gb24uXG4gICAgICogQHJldHVybnMge1NweX1cbiAgICAgKi9cbiAgICBzcHlPblByb3BlcnR5OiBmdW5jdGlvbihvYmosIG1ldGhvZE5hbWUsIGFjY2Vzc1R5cGUpIHtcbiAgICAgIHJldHVybiBlbnYuc3B5T25Qcm9wZXJ0eShvYmosIG1ldGhvZE5hbWUsIGFjY2Vzc1R5cGUpO1xuICAgIH0sXG5cbiAgICBqc0FwaVJlcG9ydGVyOiBuZXcgamFzbWluZS5Kc0FwaVJlcG9ydGVyKHtcbiAgICAgIHRpbWVyOiBuZXcgamFzbWluZS5UaW1lcigpXG4gICAgfSksXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlIGphc21pbmVcbiAgICAgKi9cbiAgICBqYXNtaW5lOiBqYXNtaW5lXG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIGN1c3RvbSBlcXVhbGl0eSB0ZXN0ZXIgZm9yIHRoZSBjdXJyZW50IHNjb3BlIG9mIHNwZWNzLlxuICAgKlxuICAgKiBfTm90ZTpfIFRoaXMgaXMgb25seSBjYWxsYWJsZSBmcm9tIHdpdGhpbiBhIHtAbGluayBiZWZvcmVFYWNofSwge0BsaW5rIGl0fSwgb3Ige0BsaW5rIGJlZm9yZUFsbH0uXG4gICAqIEBuYW1lIGphc21pbmUuYWRkQ3VzdG9tRXF1YWxpdHlUZXN0ZXJcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHRlc3RlciAtIEEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgdHdvIGFyZ3VtZW50cyB0byBjb21wYXJlIGFuZCByZXR1cm5zIGEgYHRydWVgIG9yIGBmYWxzZWAgY29tcGFyaXNvbiByZXN1bHQgaWYgaXQga25vd3MgaG93IHRvIGNvbXBhcmUgdGhlbSwgYW5kIGB1bmRlZmluZWRgIG90aGVyd2lzZS5cbiAgICogQHNlZSBjdXN0b21fZXF1YWxpdHlcbiAgICovXG4gIGphc21pbmUuYWRkQ3VzdG9tRXF1YWxpdHlUZXN0ZXIgPSBmdW5jdGlvbih0ZXN0ZXIpIHtcbiAgICBlbnYuYWRkQ3VzdG9tRXF1YWxpdHlUZXN0ZXIodGVzdGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGN1c3RvbSBtYXRjaGVycyBmb3IgdGhlIGN1cnJlbnQgc2NvcGUgb2Ygc3BlY3MuXG4gICAqXG4gICAqIF9Ob3RlOl8gVGhpcyBpcyBvbmx5IGNhbGxhYmxlIGZyb20gd2l0aGluIGEge0BsaW5rIGJlZm9yZUVhY2h9LCB7QGxpbmsgaXR9LCBvciB7QGxpbmsgYmVmb3JlQWxsfS5cbiAgICogQG5hbWUgamFzbWluZS5hZGRNYXRjaGVyc1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG1hdGNoZXJzIC0gS2V5cyBmcm9tIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIG5ldyBtYXRjaGVyIG5hbWVzLlxuICAgKiBAc2VlIGN1c3RvbV9tYXRjaGVyXG4gICAqL1xuICBqYXNtaW5lLmFkZE1hdGNoZXJzID0gZnVuY3Rpb24obWF0Y2hlcnMpIHtcbiAgICByZXR1cm4gZW52LmFkZE1hdGNoZXJzKG1hdGNoZXJzKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50bHkgYm9vdGVkIG1vY2sge0Nsb2NrfSBmb3IgdGhpcyBKYXNtaW5lIGVudmlyb25tZW50LlxuICAgKiBAbmFtZSBqYXNtaW5lLmNsb2NrXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7Q2xvY2t9XG4gICAqL1xuICBqYXNtaW5lLmNsb2NrID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGVudi5jbG9jaztcbiAgfTtcblxuICByZXR1cm4gamFzbWluZUludGVyZmFjZTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuU3B5ID0gZnVuY3Rpb24gKGokKSB7XG5cbiAgdmFyIG5leHRPcmRlciA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgb3JkZXIgPSAwO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG9yZGVyKys7XG4gICAgfTtcbiAgfSkoKTtcblxuICAvKipcbiAgICogX05vdGU6XyBEbyBub3QgY29uc3RydWN0IHRoaXMgZGlyZWN0bHksIHVzZSB7QGxpbmsgc3B5T259LCB7QGxpbmsgc3B5T25Qcm9wZXJ0eX0sIHtAbGluayBqYXNtaW5lLmNyZWF0ZVNweX0sIG9yIHtAbGluayBqYXNtaW5lLmNyZWF0ZVNweU9ian1cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBuYW1lIFNweVxuICAgKi9cbiAgZnVuY3Rpb24gU3B5KG5hbWUsIG9yaWdpbmFsRm4pIHtcbiAgICB2YXIgbnVtQXJncyA9ICh0eXBlb2Ygb3JpZ2luYWxGbiA9PT0gJ2Z1bmN0aW9uJyA/IG9yaWdpbmFsRm4ubGVuZ3RoIDogMCksXG4gICAgICB3cmFwcGVyID0gbWFrZUZ1bmMobnVtQXJncywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3B5LmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgfSksXG4gICAgICBzcHlTdHJhdGVneSA9IG5ldyBqJC5TcHlTdHJhdGVneSh7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGZuOiBvcmlnaW5hbEZuLFxuICAgICAgICBnZXRTcHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBjYWxsVHJhY2tlciA9IG5ldyBqJC5DYWxsVHJhY2tlcigpLFxuICAgICAgc3B5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgU3B5LmNhbGxEYXRhXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBvYmplY3QgLSBgdGhpc2AgY29udGV4dCBmb3IgdGhlIGludm9jYXRpb24uXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnZvY2F0aW9uT3JkZXIgLSBPcmRlciBvZiB0aGUgaW52b2NhdGlvbi5cbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheX0gYXJncyAtIFRoZSBhcmd1bWVudHMgcGFzc2VkIGZvciB0aGlzIGludm9jYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgY2FsbERhdGEgPSB7XG4gICAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICAgIGludm9jYXRpb25PcmRlcjogbmV4dE9yZGVyKCksXG4gICAgICAgICAgYXJnczogQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cylcbiAgICAgICAgfTtcblxuICAgICAgICBjYWxsVHJhY2tlci50cmFjayhjYWxsRGF0YSk7XG4gICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHNweVN0cmF0ZWd5LmV4ZWMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgY2FsbERhdGEucmV0dXJuVmFsdWUgPSByZXR1cm5WYWx1ZTtcblxuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWFrZUZ1bmMobGVuZ3RoLCBmbikge1xuICAgICAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxIDogcmV0dXJuIGZ1bmN0aW9uIChhKSB7IHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgICAgICBjYXNlIDIgOiByZXR1cm4gZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICAgICAgY2FzZSAzIDogcmV0dXJuIGZ1bmN0aW9uIChhLGIsYykgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICAgICAgY2FzZSA0IDogcmV0dXJuIGZ1bmN0aW9uIChhLGIsYyxkKSB7IHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgICAgICBjYXNlIDUgOiByZXR1cm4gZnVuY3Rpb24gKGEsYixjLGQsZSkgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICAgICAgY2FzZSA2IDogcmV0dXJuIGZ1bmN0aW9uIChhLGIsYyxkLGUsZikgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICAgICAgY2FzZSA3IDogcmV0dXJuIGZ1bmN0aW9uIChhLGIsYyxkLGUsZixnKSB7IHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgICAgICBjYXNlIDggOiByZXR1cm4gZnVuY3Rpb24gKGEsYixjLGQsZSxmLGcsaCkgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICAgICAgY2FzZSA5IDogcmV0dXJuIGZ1bmN0aW9uIChhLGIsYyxkLGUsZixnLGgsaSkgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICAgICAgZGVmYXVsdCA6IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIHByb3AgaW4gb3JpZ2luYWxGbikge1xuICAgICAgaWYgKHByb3AgPT09ICdhbmQnIHx8IHByb3AgPT09ICdjYWxscycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKYXNtaW5lIHNwaWVzIHdvdWxkIG92ZXJ3cml0ZSB0aGUgXFwnYW5kXFwnIGFuZCBcXCdjYWxsc1xcJyBwcm9wZXJ0aWVzIG9uIHRoZSBvYmplY3QgYmVpbmcgc3BpZWQgdXBvbicpO1xuICAgICAgfVxuXG4gICAgICB3cmFwcGVyW3Byb3BdID0gb3JpZ2luYWxGbltwcm9wXTtcbiAgICB9XG5cbiAgICB3cmFwcGVyLmFuZCA9IHNweVN0cmF0ZWd5O1xuICAgIHdyYXBwZXIuY2FsbHMgPSBjYWxsVHJhY2tlcjtcblxuICAgIHJldHVybiB3cmFwcGVyO1xuICB9XG5cbiAgcmV0dXJuIFNweTtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuU3B5UmVnaXN0cnkgPSBmdW5jdGlvbihqJCkge1xuXG4gIHZhciBnZXRFcnJvck1zZyA9IGokLmZvcm1hdEVycm9yTXNnKCc8c3B5T24+JywgJ3NweU9uKDxvYmplY3Q+LCA8bWV0aG9kTmFtZT4pJyk7XG5cbiAgZnVuY3Rpb24gU3B5UmVnaXN0cnkob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBnbG9iYWwgPSBvcHRpb25zLmdsb2JhbCB8fCBqJC5nZXRHbG9iYWwoKTtcbiAgICB2YXIgY3VycmVudFNwaWVzID0gb3B0aW9ucy5jdXJyZW50U3BpZXMgfHwgZnVuY3Rpb24oKSB7IHJldHVybiBbXTsgfTtcblxuICAgIHRoaXMuYWxsb3dSZXNweSA9IGZ1bmN0aW9uKGFsbG93KXtcbiAgICAgIHRoaXMucmVzcHkgPSBhbGxvdztcbiAgICB9O1xuXG4gICAgdGhpcy5zcHlPbiA9IGZ1bmN0aW9uKG9iaiwgbWV0aG9kTmFtZSkge1xuXG4gICAgICBpZiAoaiQudXRpbC5pc1VuZGVmaW5lZChvYmopIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0RXJyb3JNc2coJ2NvdWxkIG5vdCBmaW5kIGFuIG9iamVjdCB0byBzcHkgdXBvbiBmb3IgJyArIG1ldGhvZE5hbWUgKyAnKCknKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChqJC51dGlsLmlzVW5kZWZpbmVkKG1ldGhvZE5hbWUpIHx8IG1ldGhvZE5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGdldEVycm9yTXNnKCdObyBtZXRob2QgbmFtZSBzdXBwbGllZCcpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGokLnV0aWwuaXNVbmRlZmluZWQob2JqW21ldGhvZE5hbWVdKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0RXJyb3JNc2cobWV0aG9kTmFtZSArICcoKSBtZXRob2QgZG9lcyBub3QgZXhpc3QnKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmpbbWV0aG9kTmFtZV0gJiYgaiQuaXNTcHkob2JqW21ldGhvZE5hbWVdKSAgKSB7XG4gICAgICAgIGlmICggISF0aGlzLnJlc3B5ICl7XG4gICAgICAgICAgcmV0dXJuIG9ialttZXRob2ROYW1lXTtcbiAgICAgICAgfWVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRFcnJvck1zZyhtZXRob2ROYW1lICsgJyBoYXMgYWxyZWFkeSBiZWVuIHNwaWVkIHVwb24nKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGRlc2NyaXB0b3I7XG4gICAgICB0cnkge1xuICAgICAgICBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIG1ldGhvZE5hbWUpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIC8vIElFIDggZG9lc24ndCBzdXBwb3J0IGBkZWZpbmVQcm9wZXJ5YCBvbiBub24tRE9NIG5vZGVzXG4gICAgICB9XG5cbiAgICAgIGlmIChkZXNjcmlwdG9yICYmICEoZGVzY3JpcHRvci53cml0YWJsZSB8fCBkZXNjcmlwdG9yLnNldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGdldEVycm9yTXNnKG1ldGhvZE5hbWUgKyAnIGlzIG5vdCBkZWNsYXJlZCB3cml0YWJsZSBvciBoYXMgbm8gc2V0dGVyJykpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3JpZ2luYWxNZXRob2QgPSBvYmpbbWV0aG9kTmFtZV0sXG4gICAgICAgIHNwaWVkTWV0aG9kID0gaiQuY3JlYXRlU3B5KG1ldGhvZE5hbWUsIG9yaWdpbmFsTWV0aG9kKSxcbiAgICAgICAgcmVzdG9yZVN0cmF0ZWd5O1xuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgbWV0aG9kTmFtZSkgfHwgKG9iaiA9PT0gZ2xvYmFsICYmIG1ldGhvZE5hbWUgPT09ICdvbmVycm9yJykpIHtcbiAgICAgICAgcmVzdG9yZVN0cmF0ZWd5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgb2JqW21ldGhvZE5hbWVdID0gb3JpZ2luYWxNZXRob2Q7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN0b3JlU3RyYXRlZ3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoIWRlbGV0ZSBvYmpbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgICAgIG9ialttZXRob2ROYW1lXSA9IG9yaWdpbmFsTWV0aG9kO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudFNwaWVzKCkucHVzaCh7XG4gICAgICAgIHJlc3RvcmVPYmplY3RUb09yaWdpbmFsU3RhdGU6IHJlc3RvcmVTdHJhdGVneVxuICAgICAgfSk7XG5cbiAgICAgIG9ialttZXRob2ROYW1lXSA9IHNwaWVkTWV0aG9kO1xuXG4gICAgICByZXR1cm4gc3BpZWRNZXRob2Q7XG4gICAgfTtcblxuICAgIHRoaXMuc3B5T25Qcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3BlcnR5TmFtZSwgYWNjZXNzVHlwZSkge1xuICAgICAgYWNjZXNzVHlwZSA9IGFjY2Vzc1R5cGUgfHwgJ2dldCc7XG5cbiAgICAgIGlmIChqJC51dGlsLmlzVW5kZWZpbmVkKG9iaikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcHlPbiBjb3VsZCBub3QgZmluZCBhbiBvYmplY3QgdG8gc3B5IHVwb24gZm9yICcgKyBwcm9wZXJ0eU5hbWUgKyAnJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChqJC51dGlsLmlzVW5kZWZpbmVkKHByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwcm9wZXJ0eSBuYW1lIHN1cHBsaWVkJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZXNjcmlwdG9yO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGVzY3JpcHRvciA9IGokLnV0aWwuZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcGVydHlOYW1lKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAvLyBJRSA4IGRvZXNuJ3Qgc3VwcG9ydCBgZGVmaW5lUHJvcGVyeWAgb24gbm9uLURPTSBub2Rlc1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRlc2NyaXB0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb3BlcnR5TmFtZSArICcgcHJvcGVydHkgZG9lcyBub3QgZXhpc3QnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvcGVydHlOYW1lICsgJyBpcyBub3QgZGVjbGFyZWQgY29uZmlndXJhYmxlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmKCFkZXNjcmlwdG9yW2FjY2Vzc1R5cGVdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgJyArIHByb3BlcnR5TmFtZSArICcgZG9lcyBub3QgaGF2ZSBhY2Nlc3MgdHlwZSAnICsgYWNjZXNzVHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChqJC5pc1NweShkZXNjcmlwdG9yW2FjY2Vzc1R5cGVdKSkge1xuICAgICAgICAvL1RPRE8/OiBzaG91bGQgdGhpcyByZXR1cm4gdGhlIGN1cnJlbnQgc3B5PyBEb3duc2lkZTogbWF5IGNhdXNlIHVzZXIgY29uZnVzaW9uIGFib3V0IHNweSBzdGF0ZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvcGVydHlOYW1lICsgJyBoYXMgYWxyZWFkeSBiZWVuIHNwaWVkIHVwb24nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9yaWdpbmFsRGVzY3JpcHRvciA9IGokLnV0aWwuY2xvbmUoZGVzY3JpcHRvciksXG4gICAgICAgIHNweSA9IGokLmNyZWF0ZVNweShwcm9wZXJ0eU5hbWUsIGRlc2NyaXB0b3JbYWNjZXNzVHlwZV0pLFxuICAgICAgICByZXN0b3JlU3RyYXRlZ3k7XG5cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgIHJlc3RvcmVTdHJhdGVneSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3BlcnR5TmFtZSwgb3JpZ2luYWxEZXNjcmlwdG9yKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3RvcmVTdHJhdGVneSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRlbGV0ZSBvYmpbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudFNwaWVzKCkucHVzaCh7XG4gICAgICAgIHJlc3RvcmVPYmplY3RUb09yaWdpbmFsU3RhdGU6IHJlc3RvcmVTdHJhdGVneVxuICAgICAgfSk7XG5cbiAgICAgIGRlc2NyaXB0b3JbYWNjZXNzVHlwZV0gPSBzcHk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3BlcnR5TmFtZSwgZGVzY3JpcHRvcik7XG5cbiAgICAgIHJldHVybiBzcHk7XG4gICAgfTtcblxuICAgIHRoaXMuY2xlYXJTcGllcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNwaWVzID0gY3VycmVudFNwaWVzKCk7XG4gICAgICBmb3IgKHZhciBpID0gc3BpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIHNweUVudHJ5ID0gc3BpZXNbaV07XG4gICAgICAgIHNweUVudHJ5LnJlc3RvcmVPYmplY3RUb09yaWdpbmFsU3RhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIFNweVJlZ2lzdHJ5O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5TcHlTdHJhdGVneSA9IGZ1bmN0aW9uKGokKSB7XG5cbiAgLyoqXG4gICAqIEBuYW1lc3BhY2UgU3B5I2FuZFxuICAgKi9cbiAgZnVuY3Rpb24gU3B5U3RyYXRlZ3kob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGlkZW50aXR5ID0gb3B0aW9ucy5uYW1lIHx8ICd1bmtub3duJyxcbiAgICAgICAgb3JpZ2luYWxGbiA9IG9wdGlvbnMuZm4gfHwgZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgZ2V0U3B5ID0gb3B0aW9ucy5nZXRTcHkgfHwgZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgcGxhbiA9IGZ1bmN0aW9uKCkge307XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGlkZW50aWZ5aW5nIGluZm9ybWF0aW9uIGZvciB0aGUgc3B5LlxuICAgICAqIEBuYW1lIFNweSNhbmQjaWRlbnRpdHlcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuaWRlbnRpdHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSB0aGUgY3VycmVudCBzcHkgc3RyYXRlZ3kuXG4gICAgICogQG5hbWUgU3B5I2FuZCNleGVjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgdGhpcy5leGVjID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcGxhbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZWxsIHRoZSBzcHkgdG8gY2FsbCB0aHJvdWdoIHRvIHRoZSByZWFsIGltcGxlbWVudGF0aW9uIHdoZW4gaW52b2tlZC5cbiAgICAgKiBAbmFtZSBTcHkjYW5kI2NhbGxUaHJvdWdoXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgdGhpcy5jYWxsVGhyb3VnaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcGxhbiA9IG9yaWdpbmFsRm47XG4gICAgICByZXR1cm4gZ2V0U3B5KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlbGwgdGhlIHNweSB0byByZXR1cm4gdGhlIHZhbHVlIHdoZW4gaW52b2tlZC5cbiAgICAgKiBAbmFtZSBTcHkjYW5kI3JldHVyblZhbHVlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuLlxuICAgICAqL1xuICAgIHRoaXMucmV0dXJuVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcGxhbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGdldFNweSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZWxsIHRoZSBzcHkgdG8gcmV0dXJuIG9uZSBvZiB0aGUgc3BlY2lmaWVkIHZhbHVlcyAoc2VxdWVudGlhbGx5KSBlYWNoIHRpbWUgdGhlIHNweSBpcyBpbnZva2VkLlxuICAgICAqIEBuYW1lIFNweSNhbmQjcmV0dXJuVmFsdWVzXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsuLi4qfSB2YWx1ZXMgLSBWYWx1ZXMgdG8gYmUgcmV0dXJuZWQgb24gc3Vic2VxdWVudCBjYWxscyB0byB0aGUgc3B5LlxuICAgICAqL1xuICAgIHRoaXMucmV0dXJuVmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdmFsdWVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIHBsYW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXMuc2hpZnQoKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gZ2V0U3B5KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlbGwgdGhlIHNweSB0byB0aHJvdyBhbiBlcnJvciB3aGVuIGludm9rZWQuXG4gICAgICogQG5hbWUgU3B5I2FuZCN0aHJvd0Vycm9yXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtFcnJvcnxTdHJpbmd9IHNvbWV0aGluZyBUaGluZyB0byB0aHJvd1xuICAgICAqL1xuICAgIHRoaXMudGhyb3dFcnJvciA9IGZ1bmN0aW9uKHNvbWV0aGluZykge1xuICAgICAgdmFyIGVycm9yID0gKHNvbWV0aGluZyBpbnN0YW5jZW9mIEVycm9yKSA/IHNvbWV0aGluZyA6IG5ldyBFcnJvcihzb21ldGhpbmcpO1xuICAgICAgcGxhbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH07XG4gICAgICByZXR1cm4gZ2V0U3B5KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlbGwgdGhlIHNweSB0byBjYWxsIGEgZmFrZSBpbXBsZW1lbnRhdGlvbiB3aGVuIGludm9rZWQuXG4gICAgICogQG5hbWUgU3B5I2FuZCNjYWxsRmFrZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBpbnZva2Ugd2l0aCB0aGUgcGFzc2VkIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgdGhpcy5jYWxsRmFrZSA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgICBpZighKGokLmlzRnVuY3Rpb25fKGZuKSB8fCBqJC5pc0FzeW5jRnVuY3Rpb25fKGZuKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCBwYXNzZWQgdG8gY2FsbEZha2Ugc2hvdWxkIGJlIGEgZnVuY3Rpb24sIGdvdCAnICsgZm4pO1xuICAgICAgfVxuICAgICAgcGxhbiA9IGZuO1xuICAgICAgcmV0dXJuIGdldFNweSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZWxsIHRoZSBzcHkgdG8gZG8gbm90aGluZyB3aGVuIGludm9rZWQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXG4gICAgICogQG5hbWUgU3B5I2FuZCNzdHViXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgdGhpcy5zdHViID0gZnVuY3Rpb24oZm4pIHtcbiAgICAgIHBsYW4gPSBmdW5jdGlvbigpIHt9O1xuICAgICAgcmV0dXJuIGdldFNweSgpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gU3B5U3RyYXRlZ3k7XG59O1xuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlN1aXRlID0gZnVuY3Rpb24oaiQpIHtcbiAgZnVuY3Rpb24gU3VpdGUoYXR0cnMpIHtcbiAgICB0aGlzLmVudiA9IGF0dHJzLmVudjtcbiAgICB0aGlzLmlkID0gYXR0cnMuaWQ7XG4gICAgdGhpcy5wYXJlbnRTdWl0ZSA9IGF0dHJzLnBhcmVudFN1aXRlO1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBhdHRycy5kZXNjcmlwdGlvbjtcbiAgICB0aGlzLmV4cGVjdGF0aW9uRmFjdG9yeSA9IGF0dHJzLmV4cGVjdGF0aW9uRmFjdG9yeTtcbiAgICB0aGlzLmV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeSA9IGF0dHJzLmV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeTtcbiAgICB0aGlzLnRocm93T25FeHBlY3RhdGlvbkZhaWx1cmUgPSAhIWF0dHJzLnRocm93T25FeHBlY3RhdGlvbkZhaWx1cmU7XG5cbiAgICB0aGlzLmJlZm9yZUZucyA9IFtdO1xuICAgIHRoaXMuYWZ0ZXJGbnMgPSBbXTtcbiAgICB0aGlzLmJlZm9yZUFsbEZucyA9IFtdO1xuICAgIHRoaXMuYWZ0ZXJBbGxGbnMgPSBbXTtcblxuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIFN1aXRlUmVzdWx0XG4gICAgICogQHByb3BlcnR5IHtJbnR9IGlkIC0gVGhlIHVuaXF1ZSBpZCBvZiB0aGlzIHN1aXRlLlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkZXNjcmlwdGlvbiAtIFRoZSBkZXNjcmlwdGlvbiB0ZXh0IHBhc3NlZCB0byB0aGUge0BsaW5rIGRlc2NyaWJlfSB0aGF0IG1hZGUgdGhpcyBzdWl0ZS5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gZnVsbE5hbWUgLSBUaGUgZnVsbCBkZXNjcmlwdGlvbiBpbmNsdWRpbmcgYWxsIGFuY2VzdG9ycyBvZiB0aGlzIHN1aXRlLlxuICAgICAqIEBwcm9wZXJ0eSB7RXhwZWN0YXRpb25bXX0gZmFpbGVkRXhwZWN0YXRpb25zIC0gVGhlIGxpc3Qgb2YgZXhwZWN0YXRpb25zIHRoYXQgZmFpbGVkIGluIGFuIHtAbGluayBhZnRlckFsbH0gZm9yIHRoaXMgc3VpdGUuXG4gICAgICogQHByb3BlcnR5IHtFeHBlY3RhdGlvbltdfSBkZXByZWNhdGlvbldhcm5pbmdzIC0gVGhlIGxpc3Qgb2YgZGVwcmVjYXRpb24gd2FybmluZ3MgdGhhdCBvY2N1cnJlZCBvbiB0aGlzIHN1aXRlLlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzdGF0dXMgLSBPbmNlIHRoZSBzdWl0ZSBoYXMgY29tcGxldGVkLCB0aGlzIHN0cmluZyByZXByZXNlbnRzIHRoZSBwYXNzL2ZhaWwgc3RhdHVzIG9mIHRoaXMgc3VpdGUuXG4gICAgICovXG4gICAgdGhpcy5yZXN1bHQgPSB7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgZnVsbE5hbWU6IHRoaXMuZ2V0RnVsbE5hbWUoKSxcbiAgICAgIGZhaWxlZEV4cGVjdGF0aW9uczogW10sXG4gICAgICBkZXByZWNhdGlvbldhcm5pbmdzOiBbXVxuICAgIH07XG4gIH1cblxuICBTdWl0ZS5wcm90b3R5cGUuZXhwZWN0ID0gZnVuY3Rpb24oYWN0dWFsKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhwZWN0YXRpb25GYWN0b3J5KGFjdHVhbCwgdGhpcyk7XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLmdldEZ1bGxOYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZ1bGxOYW1lID0gW107XG4gICAgZm9yICh2YXIgcGFyZW50U3VpdGUgPSB0aGlzOyBwYXJlbnRTdWl0ZTsgcGFyZW50U3VpdGUgPSBwYXJlbnRTdWl0ZS5wYXJlbnRTdWl0ZSkge1xuICAgICAgaWYgKHBhcmVudFN1aXRlLnBhcmVudFN1aXRlKSB7XG4gICAgICAgIGZ1bGxOYW1lLnVuc2hpZnQocGFyZW50U3VpdGUuZGVzY3JpcHRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVsbE5hbWUuam9pbignICcpO1xuICB9O1xuXG4gIFN1aXRlLnByb3RvdHlwZS5wZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tYXJrZWRQZW5kaW5nID0gdHJ1ZTtcbiAgfTtcblxuICBTdWl0ZS5wcm90b3R5cGUuYmVmb3JlRWFjaCA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgdGhpcy5iZWZvcmVGbnMudW5zaGlmdChmbik7XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLmJlZm9yZUFsbCA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgdGhpcy5iZWZvcmVBbGxGbnMucHVzaChmbik7XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLmFmdGVyRWFjaCA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgdGhpcy5hZnRlckZucy51bnNoaWZ0KGZuKTtcbiAgfTtcblxuICBTdWl0ZS5wcm90b3R5cGUuYWZ0ZXJBbGwgPSBmdW5jdGlvbihmbikge1xuICAgIHRoaXMuYWZ0ZXJBbGxGbnMudW5zaGlmdChmbik7XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24oY2hpbGQpIHtcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICB9O1xuXG4gIFN1aXRlLnByb3RvdHlwZS5zdGF0dXMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5tYXJrZWRQZW5kaW5nKSB7XG4gICAgICByZXR1cm4gJ3BlbmRpbmcnO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuICdmYWlsZWQnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ2ZpbmlzaGVkJztcbiAgICB9XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLmlzRXhlY3V0YWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy5tYXJrZWRQZW5kaW5nO1xuICB9O1xuXG4gIFN1aXRlLnByb3RvdHlwZS5jYW5CZVJlZW50ZXJlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmJlZm9yZUFsbEZucy5sZW5ndGggPT09IDAgJiYgdGhpcy5hZnRlckFsbEZucy5sZW5ndGggPT09IDA7XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLmdldFJlc3VsdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVzdWx0LnN0YXR1cyA9IHRoaXMuc3RhdHVzKCk7XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0O1xuICB9O1xuXG4gIFN1aXRlLnByb3RvdHlwZS5zaGFyZWRVc2VyQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5zaGFyZWRDb250ZXh0KSB7XG4gICAgICB0aGlzLnNoYXJlZENvbnRleHQgPSB0aGlzLnBhcmVudFN1aXRlID8gdGhpcy5wYXJlbnRTdWl0ZS5jbG9uZWRTaGFyZWRVc2VyQ29udGV4dCgpIDogbmV3IGokLlVzZXJDb250ZXh0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2hhcmVkQ29udGV4dDtcbiAgfTtcblxuICBTdWl0ZS5wcm90b3R5cGUuY2xvbmVkU2hhcmVkVXNlckNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaiQuVXNlckNvbnRleHQuZnJvbUV4aXN0aW5nKHRoaXMuc2hhcmVkVXNlckNvbnRleHQoKSk7XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLm9uRXhjZXB0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIGokLmVycm9ycy5FeHBlY3RhdGlvbkZhaWxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmKGlzQWZ0ZXJBbGwodGhpcy5jaGlsZHJlbikpIHtcbiAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICBtYXRjaGVyTmFtZTogJycsXG4gICAgICAgIHBhc3NlZDogZmFsc2UsXG4gICAgICAgIGV4cGVjdGVkOiAnJyxcbiAgICAgICAgYWN0dWFsOiAnJyxcbiAgICAgICAgZXJyb3I6IGFyZ3VtZW50c1swXVxuICAgICAgfTtcbiAgICAgIHRoaXMucmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucy5wdXNoKHRoaXMuZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5KGRhdGEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgIGNoaWxkLm9uRXhjZXB0aW9uLmFwcGx5KGNoaWxkLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBTdWl0ZS5wcm90b3R5cGUuYWRkRXhwZWN0YXRpb25SZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoaXNBZnRlckFsbCh0aGlzLmNoaWxkcmVuKSAmJiBpc0ZhaWx1cmUoYXJndW1lbnRzKSl7XG4gICAgICB2YXIgZGF0YSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHRoaXMucmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucy5wdXNoKHRoaXMuZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5KGRhdGEpKTtcbiAgICAgIGlmKHRoaXMudGhyb3dPbkV4cGVjdGF0aW9uRmFpbHVyZSkge1xuICAgICAgICB0aHJvdyBuZXcgaiQuZXJyb3JzLkV4cGVjdGF0aW9uRmFpbGVkKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNoaWxkLmFkZEV4cGVjdGF0aW9uUmVzdWx0LmFwcGx5KGNoaWxkLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAvLyBrZWVwIGdvaW5nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU3VpdGUucHJvdG90eXBlLmFkZERlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uKG1zZykge1xuICAgIHRoaXMucmVzdWx0LmRlcHJlY2F0aW9uV2FybmluZ3MucHVzaCh0aGlzLmV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeSh7IG1lc3NhZ2U6IG1zZyB9KSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNBZnRlckFsbChjaGlsZHJlbikge1xuICAgIHJldHVybiBjaGlsZHJlbiAmJiBjaGlsZHJlblswXS5yZXN1bHQuc3RhdHVzO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNGYWlsdXJlKGFyZ3MpIHtcbiAgICByZXR1cm4gIWFyZ3NbMF07XG4gIH1cblxuICByZXR1cm4gU3VpdGU7XG59O1xuXG5pZiAodHlwZW9mIHdpbmRvdyA9PSB2b2lkIDAgJiYgdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcpIHtcbiAgZXhwb3J0cy5TdWl0ZSA9IGphc21pbmVSZXF1aXJlLlN1aXRlO1xufVxuXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlRpbWVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkZWZhdWx0Tm93ID0gKGZ1bmN0aW9uKERhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfTtcbiAgfSkoRGF0ZSk7XG5cbiAgZnVuY3Rpb24gVGltZXIob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIG5vdyA9IG9wdGlvbnMubm93IHx8IGRlZmF1bHROb3csXG4gICAgICBzdGFydFRpbWU7XG5cbiAgICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBzdGFydFRpbWUgPSBub3coKTtcbiAgICB9O1xuXG4gICAgdGhpcy5lbGFwc2VkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbm93KCkgLSBzdGFydFRpbWU7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBUaW1lcjtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuVHJlZVByb2Nlc3NvciA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBUcmVlUHJvY2Vzc29yKGF0dHJzKSB7XG4gICAgdmFyIHRyZWUgPSBhdHRycy50cmVlLFxuICAgICAgICBydW5uYWJsZUlkcyA9IGF0dHJzLnJ1bm5hYmxlSWRzLFxuICAgICAgICBxdWV1ZVJ1bm5lckZhY3RvcnkgPSBhdHRycy5xdWV1ZVJ1bm5lckZhY3RvcnksXG4gICAgICAgIG5vZGVTdGFydCA9IGF0dHJzLm5vZGVTdGFydCB8fCBmdW5jdGlvbigpIHt9LFxuICAgICAgICBub2RlQ29tcGxldGUgPSBhdHRycy5ub2RlQ29tcGxldGUgfHwgZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgb3JkZXJDaGlsZHJlbiA9IGF0dHJzLm9yZGVyQ2hpbGRyZW4gfHwgZnVuY3Rpb24obm9kZSkgeyByZXR1cm4gbm9kZS5jaGlsZHJlbjsgfSxcbiAgICAgICAgc3RhdHMgPSB7IHZhbGlkOiB0cnVlIH0sXG4gICAgICAgIHByb2Nlc3NlZCA9IGZhbHNlLFxuICAgICAgICBkZWZhdWx0TWluID0gSW5maW5pdHksXG4gICAgICAgIGRlZmF1bHRNYXggPSAxIC0gSW5maW5pdHk7XG5cbiAgICB0aGlzLnByb2Nlc3NUcmVlID0gZnVuY3Rpb24oKSB7XG4gICAgICBwcm9jZXNzTm9kZSh0cmVlLCBmYWxzZSk7XG4gICAgICBwcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHN0YXRzO1xuICAgIH07XG5cbiAgICB0aGlzLmV4ZWN1dGUgPSBmdW5jdGlvbihkb25lKSB7XG4gICAgICBpZiAoIXByb2Nlc3NlZCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NUcmVlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc3RhdHMudmFsaWQpIHtcbiAgICAgICAgdGhyb3cgJ2ludmFsaWQgb3JkZXInO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hpbGRGbnMgPSB3cmFwQ2hpbGRyZW4odHJlZSwgMCk7XG5cbiAgICAgIHF1ZXVlUnVubmVyRmFjdG9yeSh7XG4gICAgICAgIHF1ZXVlYWJsZUZuczogY2hpbGRGbnMsXG4gICAgICAgIHVzZXJDb250ZXh0OiB0cmVlLnNoYXJlZFVzZXJDb250ZXh0KCksXG4gICAgICAgIG9uRXhjZXB0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0cmVlLm9uRXhjZXB0aW9uLmFwcGx5KHRyZWUsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ29tcGxldGU6IGRvbmVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBydW5uYWJsZUluZGV4KGlkKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bm5hYmxlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChydW5uYWJsZUlkc1tpXSA9PT0gaWQpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NOb2RlKG5vZGUsIHBhcmVudEVuYWJsZWQpIHtcbiAgICAgIHZhciBleGVjdXRhYmxlSW5kZXggPSBydW5uYWJsZUluZGV4KG5vZGUuaWQpO1xuXG4gICAgICBpZiAoZXhlY3V0YWJsZUluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyZW50RW5hYmxlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHBhcmVudEVuYWJsZWQgPSBwYXJlbnRFbmFibGVkICYmIG5vZGUuaXNFeGVjdXRhYmxlKCk7XG5cbiAgICAgIGlmICghbm9kZS5jaGlsZHJlbikge1xuICAgICAgICBzdGF0c1tub2RlLmlkXSA9IHtcbiAgICAgICAgICBleGVjdXRhYmxlOiBwYXJlbnRFbmFibGVkICYmIG5vZGUuaXNFeGVjdXRhYmxlKCksXG4gICAgICAgICAgc2VnbWVudHM6IFt7XG4gICAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgICAgIG93bmVyOiBub2RlLFxuICAgICAgICAgICAgbm9kZXM6IFtub2RlXSxcbiAgICAgICAgICAgIG1pbjogc3RhcnRpbmdNaW4oZXhlY3V0YWJsZUluZGV4KSxcbiAgICAgICAgICAgIG1heDogc3RhcnRpbmdNYXgoZXhlY3V0YWJsZUluZGV4KVxuICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaGFzRXhlY3V0YWJsZUNoaWxkID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIG9yZGVyZWRDaGlsZHJlbiA9IG9yZGVyQ2hpbGRyZW4obm9kZSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlcmVkQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBvcmRlcmVkQ2hpbGRyZW5baV07XG5cbiAgICAgICAgICBwcm9jZXNzTm9kZShjaGlsZCwgcGFyZW50RW5hYmxlZCk7XG5cbiAgICAgICAgICBpZiAoIXN0YXRzLnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNoaWxkU3RhdHMgPSBzdGF0c1tjaGlsZC5pZF07XG5cbiAgICAgICAgICBoYXNFeGVjdXRhYmxlQ2hpbGQgPSBoYXNFeGVjdXRhYmxlQ2hpbGQgfHwgY2hpbGRTdGF0cy5leGVjdXRhYmxlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdHNbbm9kZS5pZF0gPSB7XG4gICAgICAgICAgZXhlY3V0YWJsZTogaGFzRXhlY3V0YWJsZUNoaWxkXG4gICAgICAgIH07XG5cbiAgICAgICAgc2VnbWVudENoaWxkcmVuKG5vZGUsIG9yZGVyZWRDaGlsZHJlbiwgc3RhdHNbbm9kZS5pZF0sIGV4ZWN1dGFibGVJbmRleCk7XG5cbiAgICAgICAgaWYgKCFub2RlLmNhbkJlUmVlbnRlcmVkKCkgJiYgc3RhdHNbbm9kZS5pZF0uc2VnbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHN0YXRzID0geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0aW5nTWluKGV4ZWN1dGFibGVJbmRleCkge1xuICAgICAgcmV0dXJuIGV4ZWN1dGFibGVJbmRleCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdE1pbiA6IGV4ZWN1dGFibGVJbmRleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydGluZ01heChleGVjdXRhYmxlSW5kZXgpIHtcbiAgICAgIHJldHVybiBleGVjdXRhYmxlSW5kZXggPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRNYXggOiBleGVjdXRhYmxlSW5kZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VnbWVudENoaWxkcmVuKG5vZGUsIG9yZGVyZWRDaGlsZHJlbiwgbm9kZVN0YXRzLCBleGVjdXRhYmxlSW5kZXgpIHtcbiAgICAgIHZhciBjdXJyZW50U2VnbWVudCA9IHsgaW5kZXg6IDAsIG93bmVyOiBub2RlLCBub2RlczogW10sIG1pbjogc3RhcnRpbmdNaW4oZXhlY3V0YWJsZUluZGV4KSwgbWF4OiBzdGFydGluZ01heChleGVjdXRhYmxlSW5kZXgpIH0sXG4gICAgICAgICAgcmVzdWx0ID0gW2N1cnJlbnRTZWdtZW50XSxcbiAgICAgICAgICBsYXN0TWF4ID0gZGVmYXVsdE1heCxcbiAgICAgICAgICBvcmRlcmVkQ2hpbGRTZWdtZW50cyA9IG9yZGVyQ2hpbGRTZWdtZW50cyhvcmRlcmVkQ2hpbGRyZW4pO1xuXG4gICAgICBmdW5jdGlvbiBpc1NlZ21lbnRCb3VuZGFyeShtaW5JbmRleCkge1xuICAgICAgICByZXR1cm4gbGFzdE1heCAhPT0gZGVmYXVsdE1heCAmJiBtaW5JbmRleCAhPT0gZGVmYXVsdE1pbiAmJiBsYXN0TWF4IDwgbWluSW5kZXggLSAxO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyZWRDaGlsZFNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZFNlZ21lbnQgPSBvcmRlcmVkQ2hpbGRTZWdtZW50c1tpXSxcbiAgICAgICAgICBtYXhJbmRleCA9IGNoaWxkU2VnbWVudC5tYXgsXG4gICAgICAgICAgbWluSW5kZXggPSBjaGlsZFNlZ21lbnQubWluO1xuXG4gICAgICAgIGlmIChpc1NlZ21lbnRCb3VuZGFyeShtaW5JbmRleCkpIHtcbiAgICAgICAgICBjdXJyZW50U2VnbWVudCA9IHtpbmRleDogcmVzdWx0Lmxlbmd0aCwgb3duZXI6IG5vZGUsIG5vZGVzOiBbXSwgbWluOiBkZWZhdWx0TWluLCBtYXg6IGRlZmF1bHRNYXh9O1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnRTZWdtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRTZWdtZW50Lm5vZGVzLnB1c2goY2hpbGRTZWdtZW50KTtcbiAgICAgICAgY3VycmVudFNlZ21lbnQubWluID0gTWF0aC5taW4oY3VycmVudFNlZ21lbnQubWluLCBtaW5JbmRleCk7XG4gICAgICAgIGN1cnJlbnRTZWdtZW50Lm1heCA9IE1hdGgubWF4KGN1cnJlbnRTZWdtZW50Lm1heCwgbWF4SW5kZXgpO1xuICAgICAgICBsYXN0TWF4ID0gbWF4SW5kZXg7XG4gICAgICB9XG5cbiAgICAgIG5vZGVTdGF0cy5zZWdtZW50cyA9IHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvcmRlckNoaWxkU2VnbWVudHMoY2hpbGRyZW4pIHtcbiAgICAgIHZhciBzcGVjaWZpZWRPcmRlciA9IFtdLFxuICAgICAgICAgIHVuc3BlY2lmaWVkT3JkZXIgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXSxcbiAgICAgICAgICAgIHNlZ21lbnRzID0gc3RhdHNbY2hpbGQuaWRdLnNlZ21lbnRzO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VnbWVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgc2VnID0gc2VnbWVudHNbal07XG5cbiAgICAgICAgICBpZiAoc2VnLm1pbiA9PT0gZGVmYXVsdE1pbikge1xuICAgICAgICAgICAgdW5zcGVjaWZpZWRPcmRlci5wdXNoKHNlZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNwZWNpZmllZE9yZGVyLnB1c2goc2VnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3BlY2lmaWVkT3JkZXIuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLm1pbiAtIGIubWluO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBzcGVjaWZpZWRPcmRlci5jb25jYXQodW5zcGVjaWZpZWRPcmRlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhlY3V0ZU5vZGUobm9kZSwgc2VnbWVudE51bWJlcikge1xuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmbjogZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgbm9kZVN0YXJ0KG5vZGUpO1xuXG4gICAgICAgICAgICBxdWV1ZVJ1bm5lckZhY3Rvcnkoe1xuICAgICAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBub2RlQ29tcGxldGUobm9kZSwgbm9kZS5nZXRSZXN1bHQoKSk7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBxdWV1ZWFibGVGbnM6IHdyYXBDaGlsZHJlbihub2RlLCBzZWdtZW50TnVtYmVyKSxcbiAgICAgICAgICAgICAgdXNlckNvbnRleHQ6IG5vZGUuc2hhcmVkVXNlckNvbnRleHQoKSxcbiAgICAgICAgICAgICAgb25FeGNlcHRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG5vZGUub25FeGNlcHRpb24uYXBwbHkobm9kZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmbjogZnVuY3Rpb24oZG9uZSkgeyBub2RlLmV4ZWN1dGUoZG9uZSwgc3RhdHNbbm9kZS5pZF0uZXhlY3V0YWJsZSk7IH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cmFwQ2hpbGRyZW4obm9kZSwgc2VnbWVudE51bWJlcikge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIHNlZ21lbnRDaGlsZHJlbiA9IHN0YXRzW25vZGUuaWRdLnNlZ21lbnRzW3NlZ21lbnROdW1iZXJdLm5vZGVzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChleGVjdXRlTm9kZShzZWdtZW50Q2hpbGRyZW5baV0ub3duZXIsIHNlZ21lbnRDaGlsZHJlbltpXS5pbmRleCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXN0YXRzW25vZGUuaWRdLmV4ZWN1dGFibGUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGUuYmVmb3JlQWxsRm5zLmNvbmNhdChyZXN1bHQpLmNvbmNhdChub2RlLmFmdGVyQWxsRm5zKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gVHJlZVByb2Nlc3Nvcjtcbn07XG5cbmdldEphc21pbmVSZXF1aXJlT2JqKCkuVXNlckNvbnRleHQgPSBmdW5jdGlvbihqJCkge1xuICBmdW5jdGlvbiBVc2VyQ29udGV4dCgpIHtcbiAgfVxuXG4gIFVzZXJDb250ZXh0LmZyb21FeGlzdGluZyA9IGZ1bmN0aW9uKG9sZENvbnRleHQpIHtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBVc2VyQ29udGV4dCgpO1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBvbGRDb250ZXh0KSB7XG4gICAgICBpZiAob2xkQ29udGV4dC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICBjb250ZXh0W3Byb3BdID0gb2xkQ29udGV4dFtwcm9wXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gIFVzZXJDb250ZXh0O1xufTtcblxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS52ZXJzaW9uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnMi45OS4wJztcbn07XG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDA4LTIwMTggUGl2b3RhbCBMYWJzXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG5cIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbndpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbmRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG50aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG5pbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbkVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbk5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkVcbkxJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cbk9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihqYXNtaW5lUmVxdWlyZSkge1xuICB2YXIgamFzbWluZSA9IGphc21pbmVSZXF1aXJlLmNvcmUoamFzbWluZVJlcXVpcmUpO1xuXG4gIHZhciBjb25zb2xlRm5zID0gcmVxdWlyZSgnLi4vY29uc29sZS9jb25zb2xlLmpzJyk7XG4gIGNvbnNvbGVGbnMuY29uc29sZShjb25zb2xlRm5zLCBqYXNtaW5lKTtcblxuICB2YXIgZW52ID0gamFzbWluZS5nZXRFbnYoKTtcblxuICB2YXIgamFzbWluZUludGVyZmFjZSA9IGphc21pbmVSZXF1aXJlLmludGVyZmFjZShqYXNtaW5lLCBlbnYpO1xuXG4gIGV4dGVuZChnbG9iYWwsIGphc21pbmVJbnRlcmZhY2UpO1xuXG4gIGZ1bmN0aW9uIGV4dGVuZChkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gc291cmNlKSBkZXN0aW5hdGlvbltwcm9wZXJ0eV0gPSBzb3VyY2VbcHJvcGVydHldO1xuICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbiAgfVxuXG4gIHJldHVybiBqYXNtaW5lO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhpdENvZGUsIHBsYXRmb3JtLCBub2RlVmVyc2lvbiwgZXhpdCwgbm9kZUV4aXQpIHtcbiAgaWYoaXNXaW5kb3dzKHBsYXRmb3JtKSAmJiBvbGRlclRoYW4xMihub2RlVmVyc2lvbikpIHtcbiAgICBub2RlRXhpdChleGl0Q29kZSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgZXhpdChleGl0Q29kZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzV2luZG93cyhwbGF0Zm9ybSkge1xuICByZXR1cm4gL153aW4vLnRlc3QocGxhdGZvcm0pO1xufVxuXG5mdW5jdGlvbiBvbGRlclRoYW4xMihub2RlVmVyc2lvbikge1xuICB2YXIgdmVyc2lvbiA9IG5vZGVWZXJzaW9uLnNwbGl0KCcuJyk7XG4gIHJldHVybiBwYXJzZUludCh2ZXJzaW9uWzBdLnN1YnN0cigxKSwgMTApIDw9IDAgJiYgcGFyc2VJbnQodmVyc2lvblsxXSwgMTApIDwgMTI7XG59IiwibW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQ29uc29sZVNwZWNGaWx0ZXI7XG5cbmZ1bmN0aW9uIENvbnNvbGVTcGVjRmlsdGVyKG9wdGlvbnMpIHtcbiAgdmFyIGZpbHRlclN0cmluZyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXJTdHJpbmc7XG4gIHZhciBmaWx0ZXJQYXR0ZXJuID0gbmV3IFJlZ0V4cChmaWx0ZXJTdHJpbmcpO1xuXG4gIHRoaXMubWF0Y2hlcyA9IGZ1bmN0aW9uKHNwZWNOYW1lKSB7XG4gICAgcmV0dXJuIGZpbHRlclBhdHRlcm4udGVzdChzcGVjTmFtZSk7XG4gIH07XG59XG4iLCJ2YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKSxcbiAgICB1dGlsID0gcmVxdWlyZSgndXRpbCcpLFxuICAgIGdsb2IgPSByZXF1aXJlKCdnbG9iJyksXG4gICAgZXhpdCA9IHJlcXVpcmUoJy4vZXhpdCcpLFxuICAgIENvbXBsZXRpb25SZXBvcnRlciA9IHJlcXVpcmUoJy4vcmVwb3J0ZXJzL2NvbXBsZXRpb25fcmVwb3J0ZXInKSxcbiAgICBDb25zb2xlU3BlY0ZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVycy9jb25zb2xlX3NwZWNfZmlsdGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gSmFzbWluZTtcbm1vZHVsZS5leHBvcnRzLkNvbnNvbGVSZXBvcnRlciA9IHJlcXVpcmUoJy4vcmVwb3J0ZXJzL2NvbnNvbGVfcmVwb3J0ZXInKTtcblxuZnVuY3Rpb24gSmFzbWluZShvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgamFzbWluZUNvcmUgPSBvcHRpb25zLmphc21pbmVDb3JlIHx8IHJlcXVpcmUoJ2phc21pbmUtY29yZScpO1xuICB0aGlzLmphc21pbmVDb3JlUGF0aCA9IHBhdGguam9pbihqYXNtaW5lQ29yZS5maWxlcy5wYXRoLCAnamFzbWluZS5qcycpO1xuICB0aGlzLmphc21pbmUgPSBqYXNtaW5lQ29yZS5ib290KGphc21pbmVDb3JlKTtcbiAgdGhpcy5wcm9qZWN0QmFzZURpciA9IG9wdGlvbnMucHJvamVjdEJhc2VEaXIgfHwgcGF0aC5yZXNvbHZlKCk7XG4gIHRoaXMucHJpbnREZXByZWNhdGlvbiA9IG9wdGlvbnMucHJpbnREZXByZWNhdGlvbiB8fCByZXF1aXJlKCcuL3ByaW50RGVwcmVjYXRpb24nKTtcbiAgdGhpcy5zcGVjRGlyID0gJyc7XG4gIHRoaXMuc3BlY0ZpbGVzID0gW107XG4gIHRoaXMuaGVscGVyRmlsZXMgPSBbXTtcbiAgdGhpcy5lbnYgPSB0aGlzLmphc21pbmUuZ2V0RW52KCk7XG4gIHRoaXMucmVwb3J0ZXJzQ291bnQgPSAwO1xuICB0aGlzLmNvbXBsZXRpb25SZXBvcnRlciA9IG5ldyBDb21wbGV0aW9uUmVwb3J0ZXIoKTtcbiAgdGhpcy5vbkNvbXBsZXRlQ2FsbGJhY2tBZGRlZCA9IGZhbHNlO1xuICB0aGlzLmV4aXQgPSBleGl0O1xuICB0aGlzLnNob3dpbmdDb2xvcnMgPSB0cnVlO1xuICB0aGlzLnJlcG9ydGVyID0gbmV3IG1vZHVsZS5leHBvcnRzLkNvbnNvbGVSZXBvcnRlcigpO1xuICB0aGlzLmFkZFJlcG9ydGVyKHRoaXMucmVwb3J0ZXIpO1xuICB0aGlzLmRlZmF1bHRSZXBvcnRlckNvbmZpZ3VyZWQgPSBmYWxzZTtcblxuICB2YXIgamFzbWluZVJ1bm5lciA9IHRoaXM7XG4gIHRoaXMuY29tcGxldGlvblJlcG9ydGVyLm9uQ29tcGxldGUoZnVuY3Rpb24ocGFzc2VkKSB7XG4gICAgamFzbWluZVJ1bm5lci5leGl0Q29kZUNvbXBsZXRpb24ocGFzc2VkKTtcbiAgfSk7XG4gIHRoaXMuY2hlY2tFeGl0ID0gY2hlY2tFeGl0KHRoaXMpO1xuXG4gIHRoaXMuY29yZVZlcnNpb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gamFzbWluZUNvcmUudmVyc2lvbigpO1xuICB9O1xufVxuXG5KYXNtaW5lLnByb3RvdHlwZS5yYW5kb21pemVUZXN0cyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHRoaXMuZW52LnJhbmRvbWl6ZVRlc3RzKHZhbHVlKTtcbn07XG5cbkphc21pbmUucHJvdG90eXBlLnNlZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLmVudi5zZWVkKHZhbHVlKTtcbn07XG5cbkphc21pbmUucHJvdG90eXBlLnNob3dDb2xvcnMgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLnNob3dpbmdDb2xvcnMgPSB2YWx1ZTtcbn07XG5cbkphc21pbmUucHJvdG90eXBlLmFkZFNwZWNGaWxlID0gZnVuY3Rpb24oZmlsZVBhdGgpIHtcbiAgdGhpcy5zcGVjRmlsZXMucHVzaChmaWxlUGF0aCk7XG59O1xuXG5KYXNtaW5lLnByb3RvdHlwZS5hZGRSZXBvcnRlciA9IGZ1bmN0aW9uKHJlcG9ydGVyKSB7XG4gIHRoaXMuZW52LmFkZFJlcG9ydGVyKHJlcG9ydGVyKTtcbiAgdGhpcy5yZXBvcnRlcnNDb3VudCsrO1xufTtcblxuSmFzbWluZS5wcm90b3R5cGUuY2xlYXJSZXBvcnRlcnMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbnYuY2xlYXJSZXBvcnRlcnMoKTtcbiAgdGhpcy5yZXBvcnRlcnNDb3VudCA9IDA7XG59O1xuXG5KYXNtaW5lLnByb3RvdHlwZS5wcm92aWRlRmFsbGJhY2tSZXBvcnRlciA9IGZ1bmN0aW9uKHJlcG9ydGVyKSB7XG4gIHRoaXMuZW52LnByb3ZpZGVGYWxsYmFja1JlcG9ydGVyKHJlcG9ydGVyKTtcbn07XG5cbkphc21pbmUucHJvdG90eXBlLmNvbmZpZ3VyZURlZmF1bHRSZXBvcnRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucy50aW1lciA9IG9wdGlvbnMudGltZXIgfHwgbmV3IHRoaXMuamFzbWluZS5UaW1lcigpO1xuICBvcHRpb25zLnByaW50ID0gb3B0aW9ucy5wcmludCB8fCBmdW5jdGlvbigpIHtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSh1dGlsLmZvcm1hdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbiAgb3B0aW9ucy5zaG93Q29sb3JzID0gb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnc2hvd0NvbG9ycycpID8gb3B0aW9ucy5zaG93Q29sb3JzIDogdHJ1ZTtcbiAgb3B0aW9ucy5qYXNtaW5lQ29yZVBhdGggPSBvcHRpb25zLmphc21pbmVDb3JlUGF0aCB8fCB0aGlzLmphc21pbmVDb3JlUGF0aDtcblxuICBpZihvcHRpb25zLm9uQ29tcGxldGUpIHtcbiAgICB0aGlzLnByaW50RGVwcmVjYXRpb24oJ1Bhc3NpbmcgaW4gYW4gb25Db21wbGV0ZSBmdW5jdGlvbiB0byBjb25maWd1cmVEZWZhdWx0UmVwb3J0ZXIgaXMgZGVwcmVjYXRlZC4nKTtcbiAgfVxuICB0aGlzLnJlcG9ydGVyLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIHRoaXMuZGVmYXVsdFJlcG9ydGVyQ29uZmlndXJlZCA9IHRydWU7XG59O1xuXG5KYXNtaW5lLnByb3RvdHlwZS5hZGRNYXRjaGVycyA9IGZ1bmN0aW9uKG1hdGNoZXJzKSB7XG4gIHRoaXMuZW52LmFkZE1hdGNoZXJzKG1hdGNoZXJzKTtcbn07XG5cbkphc21pbmUucHJvdG90eXBlLmxvYWRTcGVjcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNwZWNGaWxlcy5mb3JFYWNoKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICByZXF1aXJlKGZpbGUpO1xuICB9KTtcbn07XG5cbkphc21pbmUucHJvdG90eXBlLmxvYWRIZWxwZXJzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaGVscGVyRmlsZXMuZm9yRWFjaChmdW5jdGlvbihmaWxlKSB7XG4gICAgcmVxdWlyZShmaWxlKTtcbiAgfSk7XG59O1xuXG5KYXNtaW5lLnByb3RvdHlwZS5sb2FkQ29uZmlnRmlsZSA9IGZ1bmN0aW9uKGNvbmZpZ0ZpbGVQYXRoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFic29sdXRlQ29uZmlnRmlsZVBhdGggPSBwYXRoLnJlc29sdmUodGhpcy5wcm9qZWN0QmFzZURpciwgY29uZmlnRmlsZVBhdGggfHwgJ3NwZWMvc3VwcG9ydC9qYXNtaW5lLmpzb24nKTtcbiAgICB2YXIgY29uZmlnID0gcmVxdWlyZShhYnNvbHV0ZUNvbmZpZ0ZpbGVQYXRoKTtcbiAgICB0aGlzLmxvYWRDb25maWcoY29uZmlnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmKGNvbmZpZ0ZpbGVQYXRoIHx8IGUuY29kZSAhPSAnTU9EVUxFX05PVF9GT1VORCcpIHsgdGhyb3cgZTsgfVxuICB9XG59O1xuXG5KYXNtaW5lLnByb3RvdHlwZS5sb2FkQ29uZmlnID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gIHRoaXMuc3BlY0RpciA9IGNvbmZpZy5zcGVjX2RpciB8fCB0aGlzLnNwZWNEaXI7XG4gIHRoaXMuZW52LnRocm93T25FeHBlY3RhdGlvbkZhaWx1cmUoY29uZmlnLnN0b3BTcGVjT25FeHBlY3RhdGlvbkZhaWx1cmUpO1xuICB0aGlzLmVudi5yYW5kb21pemVUZXN0cyhjb25maWcucmFuZG9tKTtcblxuICBpZihjb25maWcuaGVscGVycykge1xuICAgIHRoaXMuYWRkSGVscGVyRmlsZXMoY29uZmlnLmhlbHBlcnMpO1xuICB9XG5cbiAgaWYoY29uZmlnLnNwZWNfZmlsZXMpIHtcbiAgICB0aGlzLmFkZFNwZWNGaWxlcyhjb25maWcuc3BlY19maWxlcyk7XG4gIH1cbn07XG5cbkphc21pbmUucHJvdG90eXBlLmFkZEhlbHBlckZpbGVzID0gYWRkRmlsZXMoJ2hlbHBlckZpbGVzJyk7XG5KYXNtaW5lLnByb3RvdHlwZS5hZGRTcGVjRmlsZXMgPSBhZGRGaWxlcygnc3BlY0ZpbGVzJyk7XG5cbmZ1bmN0aW9uIGFkZEZpbGVzKGtpbmQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChmaWxlcykge1xuICAgIHZhciBqYXNtaW5lUnVubmVyID0gdGhpcztcbiAgICB2YXIgZmlsZUFyciA9IHRoaXNba2luZF07XG5cbiAgICBmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgIGlmKCEocGF0aC5pc0Fic29sdXRlICYmIHBhdGguaXNBYnNvbHV0ZShmaWxlKSkpIHtcbiAgICAgICAgZmlsZSA9IHBhdGguam9pbihqYXNtaW5lUnVubmVyLnByb2plY3RCYXNlRGlyLCBqYXNtaW5lUnVubmVyLnNwZWNEaXIsIGZpbGUpO1xuICAgICAgfVxuICAgICAgdmFyIGZpbGVQYXRocyA9IGdsb2Iuc3luYyhmaWxlKTtcbiAgICAgIGZpbGVQYXRocy5mb3JFYWNoKGZ1bmN0aW9uKGZpbGVQYXRoKSB7XG4gICAgICAgIGlmKGZpbGVBcnIuaW5kZXhPZihmaWxlUGF0aCkgPT09IC0xKSB7XG4gICAgICAgICAgZmlsZUFyci5wdXNoKGZpbGVQYXRoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59XG5cbkphc21pbmUucHJvdG90eXBlLm9uQ29tcGxldGUgPSBmdW5jdGlvbihvbkNvbXBsZXRlQ2FsbGJhY2spIHtcbiAgdGhpcy5jb21wbGV0aW9uUmVwb3J0ZXIub25Db21wbGV0ZShvbkNvbXBsZXRlQ2FsbGJhY2spO1xufTtcblxuSmFzbWluZS5wcm90b3R5cGUuc3RvcFNwZWNPbkV4cGVjdGF0aW9uRmFpbHVyZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHRoaXMuZW52LnRocm93T25FeHBlY3RhdGlvbkZhaWx1cmUodmFsdWUpO1xufTtcblxuSmFzbWluZS5wcm90b3R5cGUuZXhpdENvZGVDb21wbGV0aW9uID0gZnVuY3Rpb24ocGFzc2VkKSB7XG4gIGlmKHBhc3NlZCkge1xuICAgIHRoaXMuZXhpdCgwLCBwcm9jZXNzLnBsYXRmb3JtLCBwcm9jZXNzLnZlcnNpb24sIHByb2Nlc3MuZXhpdCwgcmVxdWlyZSgnZXhpdCcpKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLmV4aXQoMSwgcHJvY2Vzcy5wbGF0Zm9ybSwgcHJvY2Vzcy52ZXJzaW9uLCBwcm9jZXNzLmV4aXQsIHJlcXVpcmUoJ2V4aXQnKSk7XG4gIH1cbn07XG5cbnZhciBjaGVja0V4aXQgPSBmdW5jdGlvbihqYXNtaW5lUnVubmVyKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWphc21pbmVSdW5uZXIuY29tcGxldGlvblJlcG9ydGVyLmlzQ29tcGxldGUoKSkge1xuICAgICAgcHJvY2Vzcy5leGl0Q29kZSA9IDQ7XG4gICAgfVxuICB9O1xufTtcblxuSmFzbWluZS5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKGZpbGVzLCBmaWx0ZXJTdHJpbmcpIHtcbiAgcHJvY2Vzcy5vbignZXhpdCcsIHRoaXMuY2hlY2tFeGl0KTtcblxuICB0aGlzLmxvYWRIZWxwZXJzKCk7XG4gIGlmICghdGhpcy5kZWZhdWx0UmVwb3J0ZXJDb25maWd1cmVkKSB7XG4gICAgdGhpcy5jb25maWd1cmVEZWZhdWx0UmVwb3J0ZXIoeyBzaG93Q29sb3JzOiB0aGlzLnNob3dpbmdDb2xvcnMgfSk7XG4gIH1cblxuICBpZihmaWx0ZXJTdHJpbmcpIHtcbiAgICB2YXIgc3BlY0ZpbHRlciA9IG5ldyBDb25zb2xlU3BlY0ZpbHRlcih7XG4gICAgICBmaWx0ZXJTdHJpbmc6IGZpbHRlclN0cmluZ1xuICAgIH0pO1xuICAgIHRoaXMuZW52LnNwZWNGaWx0ZXIgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgICByZXR1cm4gc3BlY0ZpbHRlci5tYXRjaGVzKHNwZWMuZ2V0RnVsbE5hbWUoKSk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChmaWxlcyAmJiBmaWxlcy5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5zcGVjRGlyID0gJyc7XG4gICAgdGhpcy5zcGVjRmlsZXMgPSBbXTtcbiAgICB0aGlzLmFkZFNwZWNGaWxlcyhmaWxlcyk7XG4gIH1cblxuICB0aGlzLmxvYWRTcGVjcygpO1xuXG4gIHRoaXMuYWRkUmVwb3J0ZXIodGhpcy5jb21wbGV0aW9uUmVwb3J0ZXIpO1xuICB0aGlzLmVudi5leGVjdXRlKCk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gd2FybmluZzogJyArIG1lc3NhZ2UpO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0cyA9IHRydWU7XG4gIHZhciBvbkNvbXBsZXRlQ2FsbGJhY2sgPSBmdW5jdGlvbigpIHt9O1xuICB2YXIgY29tcGxldGVkID0gZmFsc2U7XG5cbiAgdGhpcy5vbkNvbXBsZXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBvbkNvbXBsZXRlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfTtcblxuICB0aGlzLmphc21pbmVEb25lID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgY29tcGxldGVkID0gdHJ1ZTtcbiAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMgJiYgcmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHRzID0gZmFsc2U7XG4gICAgfVxuICAgIG9uQ29tcGxldGVDYWxsYmFjayhyZXN1bHRzKTtcbiAgfTtcblxuICB0aGlzLmlzQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29tcGxldGVkO1xuICB9O1xuXG4gIHRoaXMuc3BlY0RvbmUgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICBpZihyZXN1bHQuc3RhdHVzID09PSAnZmFpbGVkJykge1xuICAgICAgcmVzdWx0cyA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLnN1aXRlRG9uZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zICYmIHJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0cyA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBDb25zb2xlUmVwb3J0ZXI7XG5cbnZhciBub29wVGltZXIgPSB7XG4gIHN0YXJ0OiBmdW5jdGlvbigpe30sXG4gIGVsYXBzZWQ6IGZ1bmN0aW9uKCl7IHJldHVybiAwOyB9XG59O1xuXG5mdW5jdGlvbiBDb25zb2xlUmVwb3J0ZXIoKSB7XG4gIHZhciBwcmludCA9IGZ1bmN0aW9uKCkge30sXG4gICAgc2hvd0NvbG9ycyA9IGZhbHNlLFxuICAgIHRpbWVyID0gbm9vcFRpbWVyLFxuICAgIGphc21pbmVDb3JlUGF0aCA9IG51bGwsXG4gICAgcHJpbnREZXByZWNhdGlvbiA9IGZ1bmN0aW9uKCkge30sXG4gICAgc3BlY0NvdW50LFxuICAgIGV4ZWN1dGFibGVTcGVjQ291bnQsXG4gICAgZmFpbHVyZUNvdW50LFxuICAgIGZhaWxlZFNwZWNzID0gW10sXG4gICAgcGVuZGluZ1NwZWNzID0gW10sXG4gICAgYW5zaSA9IHtcbiAgICAgIGdyZWVuOiAnXFx4MUJbMzJtJyxcbiAgICAgIHJlZDogJ1xceDFCWzMxbScsXG4gICAgICB5ZWxsb3c6ICdcXHgxQlszM20nLFxuICAgICAgbm9uZTogJ1xceDFCWzBtJ1xuICAgIH0sXG4gICAgZmFpbGVkU3VpdGVzID0gW10sXG4gICAgc3RhY2tGaWx0ZXIgPSBkZWZhdWx0U3RhY2tGaWx0ZXIsXG4gICAgb25Db21wbGV0ZSA9IGZ1bmN0aW9uKCkge307XG5cbiAgdGhpcy5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnByaW50KSB7XG4gICAgICBwcmludCA9IG9wdGlvbnMucHJpbnQ7XG4gICAgfVxuICAgIHNob3dDb2xvcnMgPSBvcHRpb25zLnNob3dDb2xvcnMgfHwgZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMudGltZXIpIHtcbiAgICAgIHRpbWVyID0gb3B0aW9ucy50aW1lcjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuamFzbWluZUNvcmVQYXRoKSB7XG4gICAgICBqYXNtaW5lQ29yZVBhdGggPSBvcHRpb25zLmphc21pbmVDb3JlUGF0aDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucHJpbnREZXByZWNhdGlvbikge1xuICAgICAgcHJpbnREZXByZWNhdGlvbiA9IG9wdGlvbnMucHJpbnREZXByZWNhdGlvbjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc3RhY2tGaWx0ZXIpIHtcbiAgICAgIHN0YWNrRmlsdGVyID0gb3B0aW9ucy5zdGFja0ZpbHRlcjtcbiAgICB9XG5cbiAgICBpZihvcHRpb25zLm9uQ29tcGxldGUpIHtcbiAgICAgIHByaW50RGVwcmVjYXRpb24oJ1Bhc3NpbmcgaW4gYW4gb25Db21wbGV0ZSBmdW5jdGlvbiB0byB0aGUgQ29uc29sZVJlcG9ydGVyIGlzIGRlcHJlY2F0ZWQuJyk7XG4gICAgICBvbkNvbXBsZXRlID0gb3B0aW9ucy5vbkNvbXBsZXRlO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLmphc21pbmVTdGFydGVkID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHNwZWNDb3VudCA9IDA7XG4gICAgZXhlY3V0YWJsZVNwZWNDb3VudCA9IDA7XG4gICAgZmFpbHVyZUNvdW50ID0gMDtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyICYmIG9wdGlvbnMub3JkZXIucmFuZG9tKSB7XG4gICAgICBwcmludCgnUmFuZG9taXplZCB3aXRoIHNlZWQgJyArIG9wdGlvbnMub3JkZXIuc2VlZCk7XG4gICAgICBwcmludE5ld2xpbmUoKTtcbiAgICB9XG4gICAgcHJpbnQoJ1N0YXJ0ZWQnKTtcbiAgICBwcmludE5ld2xpbmUoKTtcbiAgICB0aW1lci5zdGFydCgpO1xuICB9O1xuXG4gIHRoaXMuamFzbWluZURvbmUgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICBwcmludE5ld2xpbmUoKTtcbiAgICBwcmludE5ld2xpbmUoKTtcbiAgICBpZihmYWlsZWRTcGVjcy5sZW5ndGggPiAwKSB7XG4gICAgICBwcmludCgnRmFpbHVyZXM6Jyk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmFpbGVkU3BlY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNwZWNGYWlsdXJlRGV0YWlscyhmYWlsZWRTcGVjc1tpXSwgaSArIDEpO1xuICAgIH1cblxuICAgIGlmIChwZW5kaW5nU3BlY3MubGVuZ3RoID4gMCkge1xuICAgICAgcHJpbnQoXCJQZW5kaW5nOlwiKTtcbiAgICB9XG4gICAgZm9yKGkgPSAwOyBpIDwgcGVuZGluZ1NwZWNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwZW5kaW5nU3BlY0RldGFpbHMocGVuZGluZ1NwZWNzW2ldLCBpICsgMSk7XG4gICAgfVxuXG4gICAgaWYoc3BlY0NvdW50ID4gMCkge1xuICAgICAgcHJpbnROZXdsaW5lKCk7XG5cbiAgICAgIGlmKGV4ZWN1dGFibGVTcGVjQ291bnQgIT09IHNwZWNDb3VudCkge1xuICAgICAgICBwcmludCgnUmFuICcgKyBleGVjdXRhYmxlU3BlY0NvdW50ICsgJyBvZiAnICsgc3BlY0NvdW50ICsgcGx1cmFsKCcgc3BlYycsIHNwZWNDb3VudCkpO1xuICAgICAgICBwcmludE5ld2xpbmUoKTtcbiAgICAgIH1cbiAgICAgIHZhciBzcGVjQ291bnRzID0gZXhlY3V0YWJsZVNwZWNDb3VudCArICcgJyArIHBsdXJhbCgnc3BlYycsIGV4ZWN1dGFibGVTcGVjQ291bnQpICsgJywgJyArXG4gICAgICAgIGZhaWx1cmVDb3VudCArICcgJyArIHBsdXJhbCgnZmFpbHVyZScsIGZhaWx1cmVDb3VudCk7XG5cbiAgICAgIGlmIChwZW5kaW5nU3BlY3MubGVuZ3RoKSB7XG4gICAgICAgIHNwZWNDb3VudHMgKz0gJywgJyArIHBlbmRpbmdTcGVjcy5sZW5ndGggKyAnIHBlbmRpbmcgJyArIHBsdXJhbCgnc3BlYycsIHBlbmRpbmdTcGVjcy5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBwcmludChzcGVjQ291bnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJpbnQoJ05vIHNwZWNzIGZvdW5kJyk7XG4gICAgfVxuXG4gICAgcHJpbnROZXdsaW5lKCk7XG4gICAgdmFyIHNlY29uZHMgPSB0aW1lci5lbGFwc2VkKCkgLyAxMDAwO1xuICAgIHByaW50KCdGaW5pc2hlZCBpbiAnICsgc2Vjb25kcyArICcgJyArIHBsdXJhbCgnc2Vjb25kJywgc2Vjb25kcykpO1xuICAgIHByaW50TmV3bGluZSgpO1xuXG4gICAgZm9yKGkgPSAwOyBpIDwgZmFpbGVkU3VpdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdWl0ZUZhaWx1cmVEZXRhaWxzKGZhaWxlZFN1aXRlc1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zKSB7XG4gICAgICBzdWl0ZUZhaWx1cmVEZXRhaWxzKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdCAmJiByZXN1bHQub3JkZXIgJiYgcmVzdWx0Lm9yZGVyLnJhbmRvbSkge1xuICAgICAgcHJpbnQoJ1JhbmRvbWl6ZWQgd2l0aCBzZWVkICcgKyByZXN1bHQub3JkZXIuc2VlZCk7XG4gICAgICBwcmludE5ld2xpbmUoKTtcbiAgICB9XG5cbiAgICBvbkNvbXBsZXRlKGZhaWx1cmVDb3VudCA9PT0gMCk7XG4gIH07XG5cbiAgdGhpcy5zcGVjRG9uZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIHNwZWNDb3VudCsrO1xuXG4gICAgaWYgKHJlc3VsdC5zdGF0dXMgPT0gJ3BlbmRpbmcnKSB7XG4gICAgICBwZW5kaW5nU3BlY3MucHVzaChyZXN1bHQpO1xuICAgICAgZXhlY3V0YWJsZVNwZWNDb3VudCsrO1xuICAgICAgcHJpbnQoY29sb3JlZCgneWVsbG93JywgJyonKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5zdGF0dXMgPT0gJ3Bhc3NlZCcpIHtcbiAgICAgIGV4ZWN1dGFibGVTcGVjQ291bnQrKztcbiAgICAgIHByaW50KGNvbG9yZWQoJ2dyZWVuJywgJy4nKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5zdGF0dXMgPT0gJ2ZhaWxlZCcpIHtcbiAgICAgIGZhaWx1cmVDb3VudCsrO1xuICAgICAgZmFpbGVkU3BlY3MucHVzaChyZXN1bHQpO1xuICAgICAgZXhlY3V0YWJsZVNwZWNDb3VudCsrO1xuICAgICAgcHJpbnQoY29sb3JlZCgncmVkJywgJ0YnKSk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuc3VpdGVEb25lID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMgJiYgcmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBmYWlsdXJlQ291bnQrKztcbiAgICAgIGZhaWxlZFN1aXRlcy5wdXNoKHJlc3VsdCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xuXG4gIGZ1bmN0aW9uIHByaW50TmV3bGluZSgpIHtcbiAgICBwcmludCgnXFxuJyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb2xvcmVkKGNvbG9yLCBzdHIpIHtcbiAgICByZXR1cm4gc2hvd0NvbG9ycyA/IChhbnNpW2NvbG9yXSArIHN0ciArIGFuc2kubm9uZSkgOiBzdHI7XG4gIH1cblxuICBmdW5jdGlvbiBwbHVyYWwoc3RyLCBjb3VudCkge1xuICAgIHJldHVybiBjb3VudCA9PSAxID8gc3RyIDogc3RyICsgJ3MnO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwZWF0KHRoaW5nLCB0aW1lcykge1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbWVzOyBpKyspIHtcbiAgICAgIGFyci5wdXNoKHRoaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluZGVudChzdHIsIHNwYWNlcykge1xuICAgIHZhciBsaW5lcyA9IChzdHIgfHwgJycpLnNwbGl0KCdcXG4nKTtcbiAgICB2YXIgbmV3QXJyID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgbmV3QXJyLnB1c2gocmVwZWF0KCcgJywgc3BhY2VzKS5qb2luKCcnKSArIGxpbmVzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0Fyci5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHRTdGFja0ZpbHRlcihzdGFjaykge1xuICAgIGlmICghc3RhY2spIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICB2YXIgZmlsdGVyZWRTdGFjayA9IHN0YWNrLnNwbGl0KCdcXG4nKS5maWx0ZXIoZnVuY3Rpb24oc3RhY2tMaW5lKSB7XG4gICAgICByZXR1cm4gc3RhY2tMaW5lLmluZGV4T2YoamFzbWluZUNvcmVQYXRoKSA9PT0gLTE7XG4gICAgfSkuam9pbignXFxuJyk7XG4gICAgcmV0dXJuIGZpbHRlcmVkU3RhY2s7XG4gIH1cblxuICBmdW5jdGlvbiBzcGVjRmFpbHVyZURldGFpbHMocmVzdWx0LCBmYWlsZWRTcGVjTnVtYmVyKSB7XG4gICAgcHJpbnROZXdsaW5lKCk7XG4gICAgcHJpbnQoZmFpbGVkU3BlY051bWJlciArICcpICcpO1xuICAgIHByaW50KHJlc3VsdC5mdWxsTmFtZSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBmYWlsZWRFeHBlY3RhdGlvbiA9IHJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnNbaV07XG4gICAgICBwcmludE5ld2xpbmUoKTtcbiAgICAgIHByaW50KGluZGVudCgnTWVzc2FnZTonLCAyKSk7XG4gICAgICBwcmludE5ld2xpbmUoKTtcbiAgICAgIHByaW50KGNvbG9yZWQoJ3JlZCcsIGluZGVudChmYWlsZWRFeHBlY3RhdGlvbi5tZXNzYWdlLCA0KSkpO1xuICAgICAgcHJpbnROZXdsaW5lKCk7XG4gICAgICBwcmludChpbmRlbnQoJ1N0YWNrOicsIDIpKTtcbiAgICAgIHByaW50TmV3bGluZSgpO1xuICAgICAgcHJpbnQoaW5kZW50KHN0YWNrRmlsdGVyKGZhaWxlZEV4cGVjdGF0aW9uLnN0YWNrKSwgNCkpO1xuICAgIH1cblxuICAgIHByaW50TmV3bGluZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3VpdGVGYWlsdXJlRGV0YWlscyhyZXN1bHQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByaW50TmV3bGluZSgpO1xuICAgICAgcHJpbnQoY29sb3JlZCgncmVkJywgJ0FuIGVycm9yIHdhcyB0aHJvd24gaW4gYW4gYWZ0ZXJBbGwnKSk7XG4gICAgICBwcmludE5ld2xpbmUoKTtcbiAgICAgIHByaW50KGNvbG9yZWQoJ3JlZCcsICdBZnRlckFsbCAnICsgcmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9uc1tpXS5tZXNzYWdlKSk7XG5cbiAgICB9XG4gICAgcHJpbnROZXdsaW5lKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZW5kaW5nU3BlY0RldGFpbHMocmVzdWx0LCBwZW5kaW5nU3BlY051bWJlcikge1xuICAgIHByaW50TmV3bGluZSgpO1xuICAgIHByaW50TmV3bGluZSgpO1xuICAgIHByaW50KHBlbmRpbmdTcGVjTnVtYmVyICsgJykgJyk7XG4gICAgcHJpbnQocmVzdWx0LmZ1bGxOYW1lKTtcbiAgICBwcmludE5ld2xpbmUoKTtcbiAgICB2YXIgcGVuZGluZ1JlYXNvbiA9IFwiTm8gcmVhc29uIGdpdmVuXCI7XG4gICAgaWYgKHJlc3VsdC5wZW5kaW5nUmVhc29uICYmIHJlc3VsdC5wZW5kaW5nUmVhc29uICE9PSAnJykge1xuICAgICAgcGVuZGluZ1JlYXNvbiA9IHJlc3VsdC5wZW5kaW5nUmVhc29uO1xuICAgIH1cbiAgICBwcmludChpbmRlbnQoY29sb3JlZCgneWVsbG93JywgcGVuZGluZ1JlYXNvbiksIDIpKTtcbiAgICBwcmludE5ld2xpbmUoKTtcbiAgfVxufVxuIiwiZXhwb3J0cy5zZXRvcHRzID0gc2V0b3B0c1xuZXhwb3J0cy5vd25Qcm9wID0gb3duUHJvcFxuZXhwb3J0cy5tYWtlQWJzID0gbWFrZUFic1xuZXhwb3J0cy5maW5pc2ggPSBmaW5pc2hcbmV4cG9ydHMubWFyayA9IG1hcmtcbmV4cG9ydHMuaXNJZ25vcmVkID0gaXNJZ25vcmVkXG5leHBvcnRzLmNoaWxkcmVuSWdub3JlZCA9IGNoaWxkcmVuSWdub3JlZFxuXG5mdW5jdGlvbiBvd25Qcm9wIChvYmosIGZpZWxkKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBmaWVsZClcbn1cblxudmFyIHBhdGggPSByZXF1aXJlKFwicGF0aFwiKVxudmFyIG1pbmltYXRjaCA9IHJlcXVpcmUoXCJtaW5pbWF0Y2hcIilcbnZhciBpc0Fic29sdXRlID0gcmVxdWlyZShcInBhdGgtaXMtYWJzb2x1dGVcIilcbnZhciBNaW5pbWF0Y2ggPSBtaW5pbWF0Y2guTWluaW1hdGNoXG5cbmZ1bmN0aW9uIGFscGhhc29ydCAoYSwgYikge1xuICByZXR1cm4gYS5sb2NhbGVDb21wYXJlKGIsICdlbicpXG59XG5cbmZ1bmN0aW9uIHNldHVwSWdub3JlcyAoc2VsZiwgb3B0aW9ucykge1xuICBzZWxmLmlnbm9yZSA9IG9wdGlvbnMuaWdub3JlIHx8IFtdXG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHNlbGYuaWdub3JlKSlcbiAgICBzZWxmLmlnbm9yZSA9IFtzZWxmLmlnbm9yZV1cblxuICBpZiAoc2VsZi5pZ25vcmUubGVuZ3RoKSB7XG4gICAgc2VsZi5pZ25vcmUgPSBzZWxmLmlnbm9yZS5tYXAoaWdub3JlTWFwKVxuICB9XG59XG5cbi8vIGlnbm9yZSBwYXR0ZXJucyBhcmUgYWx3YXlzIGluIGRvdDp0cnVlIG1vZGUuXG5mdW5jdGlvbiBpZ25vcmVNYXAgKHBhdHRlcm4pIHtcbiAgdmFyIGdtYXRjaGVyID0gbnVsbFxuICBpZiAocGF0dGVybi5zbGljZSgtMykgPT09ICcvKionKSB7XG4gICAgdmFyIGdwYXR0ZXJuID0gcGF0dGVybi5yZXBsYWNlKC8oXFwvXFwqXFwqKSskLywgJycpXG4gICAgZ21hdGNoZXIgPSBuZXcgTWluaW1hdGNoKGdwYXR0ZXJuLCB7IGRvdDogdHJ1ZSB9KVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtYXRjaGVyOiBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIHsgZG90OiB0cnVlIH0pLFxuICAgIGdtYXRjaGVyOiBnbWF0Y2hlclxuICB9XG59XG5cbmZ1bmN0aW9uIHNldG9wdHMgKHNlbGYsIHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKVxuICAgIG9wdGlvbnMgPSB7fVxuXG4gIC8vIGJhc2UtbWF0Y2hpbmc6IGp1c3QgdXNlIGdsb2JzdGFyIGZvciB0aGF0LlxuICBpZiAob3B0aW9ucy5tYXRjaEJhc2UgJiYgLTEgPT09IHBhdHRlcm4uaW5kZXhPZihcIi9cIikpIHtcbiAgICBpZiAob3B0aW9ucy5ub2dsb2JzdGFyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYXNlIG1hdGNoaW5nIHJlcXVpcmVzIGdsb2JzdGFyXCIpXG4gICAgfVxuICAgIHBhdHRlcm4gPSBcIioqL1wiICsgcGF0dGVyblxuICB9XG5cbiAgc2VsZi5zaWxlbnQgPSAhIW9wdGlvbnMuc2lsZW50XG4gIHNlbGYucGF0dGVybiA9IHBhdHRlcm5cbiAgc2VsZi5zdHJpY3QgPSBvcHRpb25zLnN0cmljdCAhPT0gZmFsc2VcbiAgc2VsZi5yZWFscGF0aCA9ICEhb3B0aW9ucy5yZWFscGF0aFxuICBzZWxmLnJlYWxwYXRoQ2FjaGUgPSBvcHRpb25zLnJlYWxwYXRoQ2FjaGUgfHwgT2JqZWN0LmNyZWF0ZShudWxsKVxuICBzZWxmLmZvbGxvdyA9ICEhb3B0aW9ucy5mb2xsb3dcbiAgc2VsZi5kb3QgPSAhIW9wdGlvbnMuZG90XG4gIHNlbGYubWFyayA9ICEhb3B0aW9ucy5tYXJrXG4gIHNlbGYubm9kaXIgPSAhIW9wdGlvbnMubm9kaXJcbiAgaWYgKHNlbGYubm9kaXIpXG4gICAgc2VsZi5tYXJrID0gdHJ1ZVxuICBzZWxmLnN5bmMgPSAhIW9wdGlvbnMuc3luY1xuICBzZWxmLm5vdW5pcXVlID0gISFvcHRpb25zLm5vdW5pcXVlXG4gIHNlbGYubm9udWxsID0gISFvcHRpb25zLm5vbnVsbFxuICBzZWxmLm5vc29ydCA9ICEhb3B0aW9ucy5ub3NvcnRcbiAgc2VsZi5ub2Nhc2UgPSAhIW9wdGlvbnMubm9jYXNlXG4gIHNlbGYuc3RhdCA9ICEhb3B0aW9ucy5zdGF0XG4gIHNlbGYubm9wcm9jZXNzID0gISFvcHRpb25zLm5vcHJvY2Vzc1xuICBzZWxmLmFic29sdXRlID0gISFvcHRpb25zLmFic29sdXRlXG5cbiAgc2VsZi5tYXhMZW5ndGggPSBvcHRpb25zLm1heExlbmd0aCB8fCBJbmZpbml0eVxuICBzZWxmLmNhY2hlID0gb3B0aW9ucy5jYWNoZSB8fCBPYmplY3QuY3JlYXRlKG51bGwpXG4gIHNlbGYuc3RhdENhY2hlID0gb3B0aW9ucy5zdGF0Q2FjaGUgfHwgT2JqZWN0LmNyZWF0ZShudWxsKVxuICBzZWxmLnN5bWxpbmtzID0gb3B0aW9ucy5zeW1saW5rcyB8fCBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgc2V0dXBJZ25vcmVzKHNlbGYsIG9wdGlvbnMpXG5cbiAgc2VsZi5jaGFuZ2VkQ3dkID0gZmFsc2VcbiAgdmFyIGN3ZCA9IHByb2Nlc3MuY3dkKClcbiAgaWYgKCFvd25Qcm9wKG9wdGlvbnMsIFwiY3dkXCIpKVxuICAgIHNlbGYuY3dkID0gY3dkXG4gIGVsc2Uge1xuICAgIHNlbGYuY3dkID0gcGF0aC5yZXNvbHZlKG9wdGlvbnMuY3dkKVxuICAgIHNlbGYuY2hhbmdlZEN3ZCA9IHNlbGYuY3dkICE9PSBjd2RcbiAgfVxuXG4gIHNlbGYucm9vdCA9IG9wdGlvbnMucm9vdCB8fCBwYXRoLnJlc29sdmUoc2VsZi5jd2QsIFwiL1wiKVxuICBzZWxmLnJvb3QgPSBwYXRoLnJlc29sdmUoc2VsZi5yb290KVxuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKVxuICAgIHNlbGYucm9vdCA9IHNlbGYucm9vdC5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKVxuXG4gIC8vIFRPRE86IGlzIGFuIGFic29sdXRlIGBjd2RgIHN1cHBvc2VkIHRvIGJlIHJlc29sdmVkIGFnYWluc3QgYHJvb3RgP1xuICAvLyBlLmcuIHsgY3dkOiAnL3Rlc3QnLCByb290OiBfX2Rpcm5hbWUgfSA9PT0gcGF0aC5qb2luKF9fZGlybmFtZSwgJy90ZXN0JylcbiAgc2VsZi5jd2RBYnMgPSBpc0Fic29sdXRlKHNlbGYuY3dkKSA/IHNlbGYuY3dkIDogbWFrZUFicyhzZWxmLCBzZWxmLmN3ZClcbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIilcbiAgICBzZWxmLmN3ZEFicyA9IHNlbGYuY3dkQWJzLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpXG4gIHNlbGYubm9tb3VudCA9ICEhb3B0aW9ucy5ub21vdW50XG5cbiAgLy8gZGlzYWJsZSBjb21tZW50cyBhbmQgbmVnYXRpb24gaW4gTWluaW1hdGNoLlxuICAvLyBOb3RlIHRoYXQgdGhleSBhcmUgbm90IHN1cHBvcnRlZCBpbiBHbG9iIGl0c2VsZiBhbnl3YXkuXG4gIG9wdGlvbnMubm9uZWdhdGUgPSB0cnVlXG4gIG9wdGlvbnMubm9jb21tZW50ID0gdHJ1ZVxuXG4gIHNlbGYubWluaW1hdGNoID0gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKVxuICBzZWxmLm9wdGlvbnMgPSBzZWxmLm1pbmltYXRjaC5vcHRpb25zXG59XG5cbmZ1bmN0aW9uIGZpbmlzaCAoc2VsZikge1xuICB2YXIgbm91ID0gc2VsZi5ub3VuaXF1ZVxuICB2YXIgYWxsID0gbm91ID8gW10gOiBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzZWxmLm1hdGNoZXMubGVuZ3RoOyBpIDwgbDsgaSArKykge1xuICAgIHZhciBtYXRjaGVzID0gc2VsZi5tYXRjaGVzW2ldXG4gICAgaWYgKCFtYXRjaGVzIHx8IE9iamVjdC5rZXlzKG1hdGNoZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHNlbGYubm9udWxsKSB7XG4gICAgICAgIC8vIGRvIGxpa2UgdGhlIHNoZWxsLCBhbmQgc3BpdCBvdXQgdGhlIGxpdGVyYWwgZ2xvYlxuICAgICAgICB2YXIgbGl0ZXJhbCA9IHNlbGYubWluaW1hdGNoLmdsb2JTZXRbaV1cbiAgICAgICAgaWYgKG5vdSlcbiAgICAgICAgICBhbGwucHVzaChsaXRlcmFsKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYWxsW2xpdGVyYWxdID0gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYWQgbWF0Y2hlc1xuICAgICAgdmFyIG0gPSBPYmplY3Qua2V5cyhtYXRjaGVzKVxuICAgICAgaWYgKG5vdSlcbiAgICAgICAgYWxsLnB1c2guYXBwbHkoYWxsLCBtKVxuICAgICAgZWxzZVxuICAgICAgICBtLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICBhbGxbbV0gPSB0cnVlXG4gICAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgaWYgKCFub3UpXG4gICAgYWxsID0gT2JqZWN0LmtleXMoYWxsKVxuXG4gIGlmICghc2VsZi5ub3NvcnQpXG4gICAgYWxsID0gYWxsLnNvcnQoYWxwaGFzb3J0KVxuXG4gIC8vIGF0ICpzb21lKiBwb2ludCB3ZSBzdGF0dGVkIGFsbCBvZiB0aGVzZVxuICBpZiAoc2VsZi5tYXJrKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFsbFtpXSA9IHNlbGYuX21hcmsoYWxsW2ldKVxuICAgIH1cbiAgICBpZiAoc2VsZi5ub2Rpcikge1xuICAgICAgYWxsID0gYWxsLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgbm90RGlyID0gISgvXFwvJC8udGVzdChlKSlcbiAgICAgICAgdmFyIGMgPSBzZWxmLmNhY2hlW2VdIHx8IHNlbGYuY2FjaGVbbWFrZUFicyhzZWxmLCBlKV1cbiAgICAgICAgaWYgKG5vdERpciAmJiBjKVxuICAgICAgICAgIG5vdERpciA9IGMgIT09ICdESVInICYmICFBcnJheS5pc0FycmF5KGMpXG4gICAgICAgIHJldHVybiBub3REaXJcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgaWYgKHNlbGYuaWdub3JlLmxlbmd0aClcbiAgICBhbGwgPSBhbGwuZmlsdGVyKGZ1bmN0aW9uKG0pIHtcbiAgICAgIHJldHVybiAhaXNJZ25vcmVkKHNlbGYsIG0pXG4gICAgfSlcblxuICBzZWxmLmZvdW5kID0gYWxsXG59XG5cbmZ1bmN0aW9uIG1hcmsgKHNlbGYsIHApIHtcbiAgdmFyIGFicyA9IG1ha2VBYnMoc2VsZiwgcClcbiAgdmFyIGMgPSBzZWxmLmNhY2hlW2Fic11cbiAgdmFyIG0gPSBwXG4gIGlmIChjKSB7XG4gICAgdmFyIGlzRGlyID0gYyA9PT0gJ0RJUicgfHwgQXJyYXkuaXNBcnJheShjKVxuICAgIHZhciBzbGFzaCA9IHAuc2xpY2UoLTEpID09PSAnLydcblxuICAgIGlmIChpc0RpciAmJiAhc2xhc2gpXG4gICAgICBtICs9ICcvJ1xuICAgIGVsc2UgaWYgKCFpc0RpciAmJiBzbGFzaClcbiAgICAgIG0gPSBtLnNsaWNlKDAsIC0xKVxuXG4gICAgaWYgKG0gIT09IHApIHtcbiAgICAgIHZhciBtYWJzID0gbWFrZUFicyhzZWxmLCBtKVxuICAgICAgc2VsZi5zdGF0Q2FjaGVbbWFic10gPSBzZWxmLnN0YXRDYWNoZVthYnNdXG4gICAgICBzZWxmLmNhY2hlW21hYnNdID0gc2VsZi5jYWNoZVthYnNdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1cbn1cblxuLy8gbG90dGEgc2l0dXBzLi4uXG5mdW5jdGlvbiBtYWtlQWJzIChzZWxmLCBmKSB7XG4gIHZhciBhYnMgPSBmXG4gIGlmIChmLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgYWJzID0gcGF0aC5qb2luKHNlbGYucm9vdCwgZilcbiAgfSBlbHNlIGlmIChpc0Fic29sdXRlKGYpIHx8IGYgPT09ICcnKSB7XG4gICAgYWJzID0gZlxuICB9IGVsc2UgaWYgKHNlbGYuY2hhbmdlZEN3ZCkge1xuICAgIGFicyA9IHBhdGgucmVzb2x2ZShzZWxmLmN3ZCwgZilcbiAgfSBlbHNlIHtcbiAgICBhYnMgPSBwYXRoLnJlc29sdmUoZilcbiAgfVxuXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKVxuICAgIGFicyA9IGFicy5yZXBsYWNlKC9cXFxcL2csICcvJylcblxuICByZXR1cm4gYWJzXG59XG5cblxuLy8gUmV0dXJuIHRydWUsIGlmIHBhdHRlcm4gZW5kcyB3aXRoIGdsb2JzdGFyICcqKicsIGZvciB0aGUgYWNjb21wYW55aW5nIHBhcmVudCBkaXJlY3RvcnkuXG4vLyBFeDotIElmIG5vZGVfbW9kdWxlcy8qKiBpcyB0aGUgcGF0dGVybiwgYWRkICdub2RlX21vZHVsZXMnIHRvIGlnbm9yZSBsaXN0IGFsb25nIHdpdGggaXQncyBjb250ZW50c1xuZnVuY3Rpb24gaXNJZ25vcmVkIChzZWxmLCBwYXRoKSB7XG4gIGlmICghc2VsZi5pZ25vcmUubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIHJldHVybiBzZWxmLmlnbm9yZS5zb21lKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS5tYXRjaGVyLm1hdGNoKHBhdGgpIHx8ICEhKGl0ZW0uZ21hdGNoZXIgJiYgaXRlbS5nbWF0Y2hlci5tYXRjaChwYXRoKSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gY2hpbGRyZW5JZ25vcmVkIChzZWxmLCBwYXRoKSB7XG4gIGlmICghc2VsZi5pZ25vcmUubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIHJldHVybiBzZWxmLmlnbm9yZS5zb21lKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gISEoaXRlbS5nbWF0Y2hlciAmJiBpdGVtLmdtYXRjaGVyLm1hdGNoKHBhdGgpKVxuICB9KVxufVxuIiwiLy8gQXBwcm9hY2g6XG4vL1xuLy8gMS4gR2V0IHRoZSBtaW5pbWF0Y2ggc2V0XG4vLyAyLiBGb3IgZWFjaCBwYXR0ZXJuIGluIHRoZSBzZXQsIFBST0NFU1MocGF0dGVybiwgZmFsc2UpXG4vLyAzLiBTdG9yZSBtYXRjaGVzIHBlci1zZXQsIHRoZW4gdW5pcSB0aGVtXG4vL1xuLy8gUFJPQ0VTUyhwYXR0ZXJuLCBpbkdsb2JTdGFyKVxuLy8gR2V0IHRoZSBmaXJzdCBbbl0gaXRlbXMgZnJvbSBwYXR0ZXJuIHRoYXQgYXJlIGFsbCBzdHJpbmdzXG4vLyBKb2luIHRoZXNlIHRvZ2V0aGVyLiAgVGhpcyBpcyBQUkVGSVguXG4vLyAgIElmIHRoZXJlIGlzIG5vIG1vcmUgcmVtYWluaW5nLCB0aGVuIHN0YXQoUFJFRklYKSBhbmRcbi8vICAgYWRkIHRvIG1hdGNoZXMgaWYgaXQgc3VjY2VlZHMuICBFTkQuXG4vL1xuLy8gSWYgaW5HbG9iU3RhciBhbmQgUFJFRklYIGlzIHN5bWxpbmsgYW5kIHBvaW50cyB0byBkaXJcbi8vICAgc2V0IEVOVFJJRVMgPSBbXVxuLy8gZWxzZSByZWFkZGlyKFBSRUZJWCkgYXMgRU5UUklFU1xuLy8gICBJZiBmYWlsLCBFTkRcbi8vXG4vLyB3aXRoIEVOVFJJRVNcbi8vICAgSWYgcGF0dGVybltuXSBpcyBHTE9CU1RBUlxuLy8gICAgIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgZ2xvYnN0YXIgbWF0Y2ggaXMgZW1wdHlcbi8vICAgICAvLyBieSBwcnVuaW5nIGl0IG91dCwgYW5kIHRlc3RpbmcgdGhlIHJlc3VsdGluZyBwYXR0ZXJuXG4vLyAgICAgUFJPQ0VTUyhwYXR0ZXJuWzAuLm5dICsgcGF0dGVybltuKzEgLi4gJF0sIGZhbHNlKVxuLy8gICAgIC8vIGhhbmRsZSBvdGhlciBjYXNlcy5cbi8vICAgICBmb3IgRU5UUlkgaW4gRU5UUklFUyAobm90IGRvdGZpbGVzKVxuLy8gICAgICAgLy8gYXR0YWNoIGdsb2JzdGFyICsgdGFpbCBvbnRvIHRoZSBlbnRyeVxuLy8gICAgICAgLy8gTWFyayB0aGF0IHRoaXMgZW50cnkgaXMgYSBnbG9ic3RhciBtYXRjaFxuLy8gICAgICAgUFJPQ0VTUyhwYXR0ZXJuWzAuLm5dICsgRU5UUlkgKyBwYXR0ZXJuW24gLi4gJF0sIHRydWUpXG4vL1xuLy8gICBlbHNlIC8vIG5vdCBnbG9ic3RhclxuLy8gICAgIGZvciBFTlRSWSBpbiBFTlRSSUVTIChub3QgZG90ZmlsZXMsIHVubGVzcyBwYXR0ZXJuW25dIGlzIGRvdClcbi8vICAgICAgIFRlc3QgRU5UUlkgYWdhaW5zdCBwYXR0ZXJuW25dXG4vLyAgICAgICBJZiBmYWlscywgY29udGludWVcbi8vICAgICAgIElmIHBhc3NlcywgUFJPQ0VTUyhwYXR0ZXJuWzAuLm5dICsgaXRlbSArIHBhdHRlcm5bbisxIC4uICRdKVxuLy9cbi8vIENhdmVhdDpcbi8vICAgQ2FjaGUgYWxsIHN0YXRzIGFuZCByZWFkZGlycyByZXN1bHRzIHRvIG1pbmltaXplIHN5c2NhbGwuICBTaW5jZSBhbGxcbi8vICAgd2UgZXZlciBjYXJlIGFib3V0IGlzIGV4aXN0ZW5jZSBhbmQgZGlyZWN0b3J5LW5lc3MsIHdlIGNhbiBqdXN0IGtlZXBcbi8vICAgYHRydWVgIGZvciBmaWxlcywgYW5kIFtjaGlsZHJlbiwuLi5dIGZvciBkaXJlY3Rvcmllcywgb3IgYGZhbHNlYCBmb3Jcbi8vICAgdGhpbmdzIHRoYXQgZG9uJ3QgZXhpc3QuXG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYlxuXG52YXIgZnMgPSByZXF1aXJlKCdmcycpXG52YXIgcnAgPSByZXF1aXJlKCdmcy5yZWFscGF0aCcpXG52YXIgbWluaW1hdGNoID0gcmVxdWlyZSgnbWluaW1hdGNoJylcbnZhciBNaW5pbWF0Y2ggPSBtaW5pbWF0Y2guTWluaW1hdGNoXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbnZhciBpc0Fic29sdXRlID0gcmVxdWlyZSgncGF0aC1pcy1hYnNvbHV0ZScpXG52YXIgZ2xvYlN5bmMgPSByZXF1aXJlKCcuL3N5bmMuanMnKVxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uLmpzJylcbnZhciBzZXRvcHRzID0gY29tbW9uLnNldG9wdHNcbnZhciBvd25Qcm9wID0gY29tbW9uLm93blByb3BcbnZhciBpbmZsaWdodCA9IHJlcXVpcmUoJ2luZmxpZ2h0JylcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG52YXIgY2hpbGRyZW5JZ25vcmVkID0gY29tbW9uLmNoaWxkcmVuSWdub3JlZFxudmFyIGlzSWdub3JlZCA9IGNvbW1vbi5pc0lnbm9yZWRcblxudmFyIG9uY2UgPSByZXF1aXJlKCdvbmNlJylcblxuZnVuY3Rpb24gZ2xvYiAocGF0dGVybiwgb3B0aW9ucywgY2IpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSBjYiA9IG9wdGlvbnMsIG9wdGlvbnMgPSB7fVxuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fVxuXG4gIGlmIChvcHRpb25zLnN5bmMpIHtcbiAgICBpZiAoY2IpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBwcm92aWRlZCB0byBzeW5jIGdsb2InKVxuICAgIHJldHVybiBnbG9iU3luYyhwYXR0ZXJuLCBvcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBHbG9iKHBhdHRlcm4sIG9wdGlvbnMsIGNiKVxufVxuXG5nbG9iLnN5bmMgPSBnbG9iU3luY1xudmFyIEdsb2JTeW5jID0gZ2xvYi5HbG9iU3luYyA9IGdsb2JTeW5jLkdsb2JTeW5jXG5cbi8vIG9sZCBhcGkgc3VyZmFjZVxuZ2xvYi5nbG9iID0gZ2xvYlxuXG5mdW5jdGlvbiBleHRlbmQgKG9yaWdpbiwgYWRkKSB7XG4gIGlmIChhZGQgPT09IG51bGwgfHwgdHlwZW9mIGFkZCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb3JpZ2luXG4gIH1cblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZClcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aFxuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dXG4gIH1cbiAgcmV0dXJuIG9yaWdpblxufVxuXG5nbG9iLmhhc01hZ2ljID0gZnVuY3Rpb24gKHBhdHRlcm4sIG9wdGlvbnNfKSB7XG4gIHZhciBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zXylcbiAgb3B0aW9ucy5ub3Byb2Nlc3MgPSB0cnVlXG5cbiAgdmFyIGcgPSBuZXcgR2xvYihwYXR0ZXJuLCBvcHRpb25zKVxuICB2YXIgc2V0ID0gZy5taW5pbWF0Y2guc2V0XG5cbiAgaWYgKCFwYXR0ZXJuKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIGlmIChzZXQubGVuZ3RoID4gMSlcbiAgICByZXR1cm4gdHJ1ZVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgc2V0WzBdLmxlbmd0aDsgaisrKSB7XG4gICAgaWYgKHR5cGVvZiBzZXRbMF1bal0gIT09ICdzdHJpbmcnKVxuICAgICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG5nbG9iLkdsb2IgPSBHbG9iXG5pbmhlcml0cyhHbG9iLCBFRSlcbmZ1bmN0aW9uIEdsb2IgKHBhdHRlcm4sIG9wdGlvbnMsIGNiKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBudWxsXG4gIH1cblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnN5bmMpIHtcbiAgICBpZiAoY2IpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBwcm92aWRlZCB0byBzeW5jIGdsb2InKVxuICAgIHJldHVybiBuZXcgR2xvYlN5bmMocGF0dGVybiwgb3B0aW9ucylcbiAgfVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBHbG9iKSlcbiAgICByZXR1cm4gbmV3IEdsb2IocGF0dGVybiwgb3B0aW9ucywgY2IpXG5cbiAgc2V0b3B0cyh0aGlzLCBwYXR0ZXJuLCBvcHRpb25zKVxuICB0aGlzLl9kaWRSZWFsUGF0aCA9IGZhbHNlXG5cbiAgLy8gcHJvY2VzcyBlYWNoIHBhdHRlcm4gaW4gdGhlIG1pbmltYXRjaCBzZXRcbiAgdmFyIG4gPSB0aGlzLm1pbmltYXRjaC5zZXQubGVuZ3RoXG5cbiAgLy8gVGhlIG1hdGNoZXMgYXJlIHN0b3JlZCBhcyB7PGZpbGVuYW1lPjogdHJ1ZSwuLi59IHNvIHRoYXRcbiAgLy8gZHVwbGljYXRlcyBhcmUgYXV0b21hZ2ljYWxseSBwcnVuZWQuXG4gIC8vIExhdGVyLCB3ZSBkbyBhbiBPYmplY3Qua2V5cygpIG9uIHRoZXNlLlxuICAvLyBLZWVwIHRoZW0gYXMgYSBsaXN0IHNvIHdlIGNhbiBmaWxsIGluIHdoZW4gbm9udWxsIGlzIHNldC5cbiAgdGhpcy5tYXRjaGVzID0gbmV3IEFycmF5KG4pXG5cbiAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb25jZShjYilcbiAgICB0aGlzLm9uKCdlcnJvcicsIGNiKVxuICAgIHRoaXMub24oJ2VuZCcsIGZ1bmN0aW9uIChtYXRjaGVzKSB7XG4gICAgICBjYihudWxsLCBtYXRjaGVzKVxuICAgIH0pXG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpcy5fcHJvY2Vzc2luZyA9IDBcblxuICB0aGlzLl9lbWl0UXVldWUgPSBbXVxuICB0aGlzLl9wcm9jZXNzUXVldWUgPSBbXVxuICB0aGlzLnBhdXNlZCA9IGZhbHNlXG5cbiAgaWYgKHRoaXMubm9wcm9jZXNzKVxuICAgIHJldHVybiB0aGlzXG5cbiAgaWYgKG4gPT09IDApXG4gICAgcmV0dXJuIGRvbmUoKVxuXG4gIHZhciBzeW5jID0gdHJ1ZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkgKyspIHtcbiAgICB0aGlzLl9wcm9jZXNzKHRoaXMubWluaW1hdGNoLnNldFtpXSwgaSwgZmFsc2UsIGRvbmUpXG4gIH1cbiAgc3luYyA9IGZhbHNlXG5cbiAgZnVuY3Rpb24gZG9uZSAoKSB7XG4gICAgLS1zZWxmLl9wcm9jZXNzaW5nXG4gICAgaWYgKHNlbGYuX3Byb2Nlc3NpbmcgPD0gMCkge1xuICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi5fZmluaXNoKClcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuX2ZpbmlzaCgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbkdsb2IucHJvdG90eXBlLl9maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gIGFzc2VydCh0aGlzIGluc3RhbmNlb2YgR2xvYilcbiAgaWYgKHRoaXMuYWJvcnRlZClcbiAgICByZXR1cm5cblxuICBpZiAodGhpcy5yZWFscGF0aCAmJiAhdGhpcy5fZGlkUmVhbHBhdGgpXG4gICAgcmV0dXJuIHRoaXMuX3JlYWxwYXRoKClcblxuICBjb21tb24uZmluaXNoKHRoaXMpXG4gIHRoaXMuZW1pdCgnZW5kJywgdGhpcy5mb3VuZClcbn1cblxuR2xvYi5wcm90b3R5cGUuX3JlYWxwYXRoID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fZGlkUmVhbHBhdGgpXG4gICAgcmV0dXJuXG5cbiAgdGhpcy5fZGlkUmVhbHBhdGggPSB0cnVlXG5cbiAgdmFyIG4gPSB0aGlzLm1hdGNoZXMubGVuZ3RoXG4gIGlmIChuID09PSAwKVxuICAgIHJldHVybiB0aGlzLl9maW5pc2goKVxuXG4gIHZhciBzZWxmID0gdGhpc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWF0Y2hlcy5sZW5ndGg7IGkrKylcbiAgICB0aGlzLl9yZWFscGF0aFNldChpLCBuZXh0KVxuXG4gIGZ1bmN0aW9uIG5leHQgKCkge1xuICAgIGlmICgtLW4gPT09IDApXG4gICAgICBzZWxmLl9maW5pc2goKVxuICB9XG59XG5cbkdsb2IucHJvdG90eXBlLl9yZWFscGF0aFNldCA9IGZ1bmN0aW9uIChpbmRleCwgY2IpIHtcbiAgdmFyIG1hdGNoc2V0ID0gdGhpcy5tYXRjaGVzW2luZGV4XVxuICBpZiAoIW1hdGNoc2V0KVxuICAgIHJldHVybiBjYigpXG5cbiAgdmFyIGZvdW5kID0gT2JqZWN0LmtleXMobWF0Y2hzZXQpXG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgbiA9IGZvdW5kLmxlbmd0aFxuXG4gIGlmIChuID09PSAwKVxuICAgIHJldHVybiBjYigpXG5cbiAgdmFyIHNldCA9IHRoaXMubWF0Y2hlc1tpbmRleF0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIGZvdW5kLmZvckVhY2goZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAvLyBJZiB0aGVyZSdzIGEgcHJvYmxlbSB3aXRoIHRoZSBzdGF0LCB0aGVuIGl0IG1lYW5zIHRoYXRcbiAgICAvLyBvbmUgb3IgbW9yZSBvZiB0aGUgbGlua3MgaW4gdGhlIHJlYWxwYXRoIGNvdWxkbid0IGJlXG4gICAgLy8gcmVzb2x2ZWQuICBqdXN0IHJldHVybiB0aGUgYWJzIHZhbHVlIGluIHRoYXQgY2FzZS5cbiAgICBwID0gc2VsZi5fbWFrZUFicyhwKVxuICAgIHJwLnJlYWxwYXRoKHAsIHNlbGYucmVhbHBhdGhDYWNoZSwgZnVuY3Rpb24gKGVyLCByZWFsKSB7XG4gICAgICBpZiAoIWVyKVxuICAgICAgICBzZXRbcmVhbF0gPSB0cnVlXG4gICAgICBlbHNlIGlmIChlci5zeXNjYWxsID09PSAnc3RhdCcpXG4gICAgICAgIHNldFtwXSA9IHRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVyKSAvLyBzcnNseSB3dGYgcmlnaHQgaGVyZVxuXG4gICAgICBpZiAoLS1uID09PSAwKSB7XG4gICAgICAgIHNlbGYubWF0Y2hlc1tpbmRleF0gPSBzZXRcbiAgICAgICAgY2IoKVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG59XG5cbkdsb2IucHJvdG90eXBlLl9tYXJrID0gZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIGNvbW1vbi5tYXJrKHRoaXMsIHApXG59XG5cbkdsb2IucHJvdG90eXBlLl9tYWtlQWJzID0gZnVuY3Rpb24gKGYpIHtcbiAgcmV0dXJuIGNvbW1vbi5tYWtlQWJzKHRoaXMsIGYpXG59XG5cbkdsb2IucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmFib3J0ZWQgPSB0cnVlXG4gIHRoaXMuZW1pdCgnYWJvcnQnKVxufVxuXG5HbG9iLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnBhdXNlZCkge1xuICAgIHRoaXMucGF1c2VkID0gdHJ1ZVxuICAgIHRoaXMuZW1pdCgncGF1c2UnKVxuICB9XG59XG5cbkdsb2IucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgdGhpcy5lbWl0KCdyZXN1bWUnKVxuICAgIHRoaXMucGF1c2VkID0gZmFsc2VcbiAgICBpZiAodGhpcy5fZW1pdFF1ZXVlLmxlbmd0aCkge1xuICAgICAgdmFyIGVxID0gdGhpcy5fZW1pdFF1ZXVlLnNsaWNlKDApXG4gICAgICB0aGlzLl9lbWl0UXVldWUubGVuZ3RoID0gMFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlcS5sZW5ndGg7IGkgKyspIHtcbiAgICAgICAgdmFyIGUgPSBlcVtpXVxuICAgICAgICB0aGlzLl9lbWl0TWF0Y2goZVswXSwgZVsxXSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX3Byb2Nlc3NRdWV1ZS5sZW5ndGgpIHtcbiAgICAgIHZhciBwcSA9IHRoaXMuX3Byb2Nlc3NRdWV1ZS5zbGljZSgwKVxuICAgICAgdGhpcy5fcHJvY2Vzc1F1ZXVlLmxlbmd0aCA9IDBcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHEubGVuZ3RoOyBpICsrKSB7XG4gICAgICAgIHZhciBwID0gcHFbaV1cbiAgICAgICAgdGhpcy5fcHJvY2Vzc2luZy0tXG4gICAgICAgIHRoaXMuX3Byb2Nlc3MocFswXSwgcFsxXSwgcFsyXSwgcFszXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuR2xvYi5wcm90b3R5cGUuX3Byb2Nlc3MgPSBmdW5jdGlvbiAocGF0dGVybiwgaW5kZXgsIGluR2xvYlN0YXIsIGNiKSB7XG4gIGFzc2VydCh0aGlzIGluc3RhbmNlb2YgR2xvYilcbiAgYXNzZXJ0KHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcblxuICBpZiAodGhpcy5hYm9ydGVkKVxuICAgIHJldHVyblxuXG4gIHRoaXMuX3Byb2Nlc3NpbmcrK1xuICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICB0aGlzLl9wcm9jZXNzUXVldWUucHVzaChbcGF0dGVybiwgaW5kZXgsIGluR2xvYlN0YXIsIGNiXSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vY29uc29sZS5lcnJvcignUFJPQ0VTUyAlZCcsIHRoaXMuX3Byb2Nlc3NpbmcsIHBhdHRlcm4pXG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBbbl0gcGFydHMgb2YgcGF0dGVybiB0aGF0IGFyZSBhbGwgc3RyaW5ncy5cbiAgdmFyIG4gPSAwXG4gIHdoaWxlICh0eXBlb2YgcGF0dGVybltuXSA9PT0gJ3N0cmluZycpIHtcbiAgICBuICsrXG4gIH1cbiAgLy8gbm93IG4gaXMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBvbmUgdGhhdCBpcyAqbm90KiBhIHN0cmluZy5cblxuICAvLyBzZWUgaWYgdGhlcmUncyBhbnl0aGluZyBlbHNlXG4gIHZhciBwcmVmaXhcbiAgc3dpdGNoIChuKSB7XG4gICAgLy8gaWYgbm90LCB0aGVuIHRoaXMgaXMgcmF0aGVyIHNpbXBsZVxuICAgIGNhc2UgcGF0dGVybi5sZW5ndGg6XG4gICAgICB0aGlzLl9wcm9jZXNzU2ltcGxlKHBhdHRlcm4uam9pbignLycpLCBpbmRleCwgY2IpXG4gICAgICByZXR1cm5cblxuICAgIGNhc2UgMDpcbiAgICAgIC8vIHBhdHRlcm4gKnN0YXJ0cyogd2l0aCBzb21lIG5vbi10cml2aWFsIGl0ZW0uXG4gICAgICAvLyBnb2luZyB0byByZWFkZGlyKGN3ZCksIGJ1dCBub3QgaW5jbHVkZSB0aGUgcHJlZml4IGluIG1hdGNoZXMuXG4gICAgICBwcmVmaXggPSBudWxsXG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIHBhdHRlcm4gaGFzIHNvbWUgc3RyaW5nIGJpdHMgaW4gdGhlIGZyb250LlxuICAgICAgLy8gd2hhdGV2ZXIgaXQgc3RhcnRzIHdpdGgsIHdoZXRoZXIgdGhhdCdzICdhYnNvbHV0ZScgbGlrZSAvZm9vL2JhcixcbiAgICAgIC8vIG9yICdyZWxhdGl2ZScgbGlrZSAnLi4vYmF6J1xuICAgICAgcHJlZml4ID0gcGF0dGVybi5zbGljZSgwLCBuKS5qb2luKCcvJylcbiAgICAgIGJyZWFrXG4gIH1cblxuICB2YXIgcmVtYWluID0gcGF0dGVybi5zbGljZShuKVxuXG4gIC8vIGdldCB0aGUgbGlzdCBvZiBlbnRyaWVzLlxuICB2YXIgcmVhZFxuICBpZiAocHJlZml4ID09PSBudWxsKVxuICAgIHJlYWQgPSAnLidcbiAgZWxzZSBpZiAoaXNBYnNvbHV0ZShwcmVmaXgpIHx8IGlzQWJzb2x1dGUocGF0dGVybi5qb2luKCcvJykpKSB7XG4gICAgaWYgKCFwcmVmaXggfHwgIWlzQWJzb2x1dGUocHJlZml4KSlcbiAgICAgIHByZWZpeCA9ICcvJyArIHByZWZpeFxuICAgIHJlYWQgPSBwcmVmaXhcbiAgfSBlbHNlXG4gICAgcmVhZCA9IHByZWZpeFxuXG4gIHZhciBhYnMgPSB0aGlzLl9tYWtlQWJzKHJlYWQpXG5cbiAgLy9pZiBpZ25vcmVkLCBza2lwIF9wcm9jZXNzaW5nXG4gIGlmIChjaGlsZHJlbklnbm9yZWQodGhpcywgcmVhZCkpXG4gICAgcmV0dXJuIGNiKClcblxuICB2YXIgaXNHbG9iU3RhciA9IHJlbWFpblswXSA9PT0gbWluaW1hdGNoLkdMT0JTVEFSXG4gIGlmIChpc0dsb2JTdGFyKVxuICAgIHRoaXMuX3Byb2Nlc3NHbG9iU3RhcihwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgY2IpXG4gIGVsc2VcbiAgICB0aGlzLl9wcm9jZXNzUmVhZGRpcihwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgY2IpXG59XG5cbkdsb2IucHJvdG90eXBlLl9wcm9jZXNzUmVhZGRpciA9IGZ1bmN0aW9uIChwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuX3JlYWRkaXIoYWJzLCBpbkdsb2JTdGFyLCBmdW5jdGlvbiAoZXIsIGVudHJpZXMpIHtcbiAgICByZXR1cm4gc2VsZi5fcHJvY2Vzc1JlYWRkaXIyKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyLCBlbnRyaWVzLCBjYilcbiAgfSlcbn1cblxuR2xvYi5wcm90b3R5cGUuX3Byb2Nlc3NSZWFkZGlyMiA9IGZ1bmN0aW9uIChwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgZW50cmllcywgY2IpIHtcblxuICAvLyBpZiB0aGUgYWJzIGlzbid0IGEgZGlyLCB0aGVuIG5vdGhpbmcgY2FuIG1hdGNoIVxuICBpZiAoIWVudHJpZXMpXG4gICAgcmV0dXJuIGNiKClcblxuICAvLyBJdCB3aWxsIG9ubHkgbWF0Y2ggZG90IGVudHJpZXMgaWYgaXQgc3RhcnRzIHdpdGggYSBkb3QsIG9yIGlmXG4gIC8vIGRvdCBpcyBzZXQuICBTdHVmZiBsaWtlIEAoLmZvb3wuYmFyKSBpc24ndCBhbGxvd2VkLlxuICB2YXIgcG4gPSByZW1haW5bMF1cbiAgdmFyIG5lZ2F0ZSA9ICEhdGhpcy5taW5pbWF0Y2gubmVnYXRlXG4gIHZhciByYXdHbG9iID0gcG4uX2dsb2JcbiAgdmFyIGRvdE9rID0gdGhpcy5kb3QgfHwgcmF3R2xvYi5jaGFyQXQoMCkgPT09ICcuJ1xuXG4gIHZhciBtYXRjaGVkRW50cmllcyA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlID0gZW50cmllc1tpXVxuICAgIGlmIChlLmNoYXJBdCgwKSAhPT0gJy4nIHx8IGRvdE9rKSB7XG4gICAgICB2YXIgbVxuICAgICAgaWYgKG5lZ2F0ZSAmJiAhcHJlZml4KSB7XG4gICAgICAgIG0gPSAhZS5tYXRjaChwbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG0gPSBlLm1hdGNoKHBuKVxuICAgICAgfVxuICAgICAgaWYgKG0pXG4gICAgICAgIG1hdGNoZWRFbnRyaWVzLnB1c2goZSlcbiAgICB9XG4gIH1cblxuICAvL2NvbnNvbGUuZXJyb3IoJ3ByZDInLCBwcmVmaXgsIGVudHJpZXMsIHJlbWFpblswXS5fZ2xvYiwgbWF0Y2hlZEVudHJpZXMpXG5cbiAgdmFyIGxlbiA9IG1hdGNoZWRFbnRyaWVzLmxlbmd0aFxuICAvLyBJZiB0aGVyZSBhcmUgbm8gbWF0Y2hlZCBlbnRyaWVzLCB0aGVuIG5vdGhpbmcgbWF0Y2hlcy5cbiAgaWYgKGxlbiA9PT0gMClcbiAgICByZXR1cm4gY2IoKVxuXG4gIC8vIGlmIHRoaXMgaXMgdGhlIGxhc3QgcmVtYWluaW5nIHBhdHRlcm4gYml0LCB0aGVuIG5vIG5lZWQgZm9yXG4gIC8vIGFuIGFkZGl0aW9uYWwgc3RhdCAqdW5sZXNzKiB0aGUgdXNlciBoYXMgc3BlY2lmaWVkIG1hcmsgb3JcbiAgLy8gc3RhdCBleHBsaWNpdGx5LiAgV2Uga25vdyB0aGV5IGV4aXN0LCBzaW5jZSByZWFkZGlyIHJldHVybmVkXG4gIC8vIHRoZW0uXG5cbiAgaWYgKHJlbWFpbi5sZW5ndGggPT09IDEgJiYgIXRoaXMubWFyayAmJiAhdGhpcy5zdGF0KSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoZXNbaW5kZXhdKVxuICAgICAgdGhpcy5tYXRjaGVzW2luZGV4XSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICsrKSB7XG4gICAgICB2YXIgZSA9IG1hdGNoZWRFbnRyaWVzW2ldXG4gICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgIGlmIChwcmVmaXggIT09ICcvJylcbiAgICAgICAgICBlID0gcHJlZml4ICsgJy8nICsgZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZSA9IHByZWZpeCArIGVcbiAgICAgIH1cblxuICAgICAgaWYgKGUuY2hhckF0KDApID09PSAnLycgJiYgIXRoaXMubm9tb3VudCkge1xuICAgICAgICBlID0gcGF0aC5qb2luKHRoaXMucm9vdCwgZSlcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VtaXRNYXRjaChpbmRleCwgZSlcbiAgICB9XG4gICAgLy8gVGhpcyB3YXMgdGhlIGxhc3Qgb25lLCBhbmQgbm8gc3RhdHMgd2VyZSBuZWVkZWRcbiAgICByZXR1cm4gY2IoKVxuICB9XG5cbiAgLy8gbm93IHRlc3QgYWxsIG1hdGNoZWQgZW50cmllcyBhcyBzdGFuZC1pbnMgZm9yIHRoYXQgcGFydFxuICAvLyBvZiB0aGUgcGF0dGVybi5cbiAgcmVtYWluLnNoaWZ0KClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKyspIHtcbiAgICB2YXIgZSA9IG1hdGNoZWRFbnRyaWVzW2ldXG4gICAgdmFyIG5ld1BhdHRlcm5cbiAgICBpZiAocHJlZml4KSB7XG4gICAgICBpZiAocHJlZml4ICE9PSAnLycpXG4gICAgICAgIGUgPSBwcmVmaXggKyAnLycgKyBlXG4gICAgICBlbHNlXG4gICAgICAgIGUgPSBwcmVmaXggKyBlXG4gICAgfVxuICAgIHRoaXMuX3Byb2Nlc3MoW2VdLmNvbmNhdChyZW1haW4pLCBpbmRleCwgaW5HbG9iU3RhciwgY2IpXG4gIH1cbiAgY2IoKVxufVxuXG5HbG9iLnByb3RvdHlwZS5fZW1pdE1hdGNoID0gZnVuY3Rpb24gKGluZGV4LCBlKSB7XG4gIGlmICh0aGlzLmFib3J0ZWQpXG4gICAgcmV0dXJuXG5cbiAgaWYgKGlzSWdub3JlZCh0aGlzLCBlKSlcbiAgICByZXR1cm5cblxuICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICB0aGlzLl9lbWl0UXVldWUucHVzaChbaW5kZXgsIGVdKVxuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGFicyA9IGlzQWJzb2x1dGUoZSkgPyBlIDogdGhpcy5fbWFrZUFicyhlKVxuXG4gIGlmICh0aGlzLm1hcmspXG4gICAgZSA9IHRoaXMuX21hcmsoZSlcblxuICBpZiAodGhpcy5hYnNvbHV0ZSlcbiAgICBlID0gYWJzXG5cbiAgaWYgKHRoaXMubWF0Y2hlc1tpbmRleF1bZV0pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHRoaXMubm9kaXIpIHtcbiAgICB2YXIgYyA9IHRoaXMuY2FjaGVbYWJzXVxuICAgIGlmIChjID09PSAnRElSJyB8fCBBcnJheS5pc0FycmF5KGMpKVxuICAgICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLm1hdGNoZXNbaW5kZXhdW2VdID0gdHJ1ZVxuXG4gIHZhciBzdCA9IHRoaXMuc3RhdENhY2hlW2Fic11cbiAgaWYgKHN0KVxuICAgIHRoaXMuZW1pdCgnc3RhdCcsIGUsIHN0KVxuXG4gIHRoaXMuZW1pdCgnbWF0Y2gnLCBlKVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcmVhZGRpckluR2xvYlN0YXIgPSBmdW5jdGlvbiAoYWJzLCBjYikge1xuICBpZiAodGhpcy5hYm9ydGVkKVxuICAgIHJldHVyblxuXG4gIC8vIGZvbGxvdyBhbGwgc3ltbGlua2VkIGRpcmVjdG9yaWVzIGZvcmV2ZXJcbiAgLy8ganVzdCBwcm9jZWVkIGFzIGlmIHRoaXMgaXMgYSBub24tZ2xvYnN0YXIgc2l0dWF0aW9uXG4gIGlmICh0aGlzLmZvbGxvdylcbiAgICByZXR1cm4gdGhpcy5fcmVhZGRpcihhYnMsIGZhbHNlLCBjYilcblxuICB2YXIgbHN0YXRrZXkgPSAnbHN0YXRcXDAnICsgYWJzXG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgbHN0YXRjYiA9IGluZmxpZ2h0KGxzdGF0a2V5LCBsc3RhdGNiXylcblxuICBpZiAobHN0YXRjYilcbiAgICBmcy5sc3RhdChhYnMsIGxzdGF0Y2IpXG5cbiAgZnVuY3Rpb24gbHN0YXRjYl8gKGVyLCBsc3RhdCkge1xuICAgIGlmIChlciAmJiBlci5jb2RlID09PSAnRU5PRU5UJylcbiAgICAgIHJldHVybiBjYigpXG5cbiAgICB2YXIgaXNTeW0gPSBsc3RhdCAmJiBsc3RhdC5pc1N5bWJvbGljTGluaygpXG4gICAgc2VsZi5zeW1saW5rc1thYnNdID0gaXNTeW1cblxuICAgIC8vIElmIGl0J3Mgbm90IGEgc3ltbGluayBvciBhIGRpciwgdGhlbiBpdCdzIGRlZmluaXRlbHkgYSByZWd1bGFyIGZpbGUuXG4gICAgLy8gZG9uJ3QgYm90aGVyIGRvaW5nIGEgcmVhZGRpciBpbiB0aGF0IGNhc2UuXG4gICAgaWYgKCFpc1N5bSAmJiBsc3RhdCAmJiAhbHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgc2VsZi5jYWNoZVthYnNdID0gJ0ZJTEUnXG4gICAgICBjYigpXG4gICAgfSBlbHNlXG4gICAgICBzZWxmLl9yZWFkZGlyKGFicywgZmFsc2UsIGNiKVxuICB9XG59XG5cbkdsb2IucHJvdG90eXBlLl9yZWFkZGlyID0gZnVuY3Rpb24gKGFicywgaW5HbG9iU3RhciwgY2IpIHtcbiAgaWYgKHRoaXMuYWJvcnRlZClcbiAgICByZXR1cm5cblxuICBjYiA9IGluZmxpZ2h0KCdyZWFkZGlyXFwwJythYnMrJ1xcMCcraW5HbG9iU3RhciwgY2IpXG4gIGlmICghY2IpXG4gICAgcmV0dXJuXG5cbiAgLy9jb25zb2xlLmVycm9yKCdSRCAlaiAlaicsICtpbkdsb2JTdGFyLCBhYnMpXG4gIGlmIChpbkdsb2JTdGFyICYmICFvd25Qcm9wKHRoaXMuc3ltbGlua3MsIGFicykpXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRkaXJJbkdsb2JTdGFyKGFicywgY2IpXG5cbiAgaWYgKG93blByb3AodGhpcy5jYWNoZSwgYWJzKSkge1xuICAgIHZhciBjID0gdGhpcy5jYWNoZVthYnNdXG4gICAgaWYgKCFjIHx8IGMgPT09ICdGSUxFJylcbiAgICAgIHJldHVybiBjYigpXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIHJldHVybiBjYihudWxsLCBjKVxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGZzLnJlYWRkaXIoYWJzLCByZWFkZGlyQ2IodGhpcywgYWJzLCBjYikpXG59XG5cbmZ1bmN0aW9uIHJlYWRkaXJDYiAoc2VsZiwgYWJzLCBjYikge1xuICByZXR1cm4gZnVuY3Rpb24gKGVyLCBlbnRyaWVzKSB7XG4gICAgaWYgKGVyKVxuICAgICAgc2VsZi5fcmVhZGRpckVycm9yKGFicywgZXIsIGNiKVxuICAgIGVsc2VcbiAgICAgIHNlbGYuX3JlYWRkaXJFbnRyaWVzKGFicywgZW50cmllcywgY2IpXG4gIH1cbn1cblxuR2xvYi5wcm90b3R5cGUuX3JlYWRkaXJFbnRyaWVzID0gZnVuY3Rpb24gKGFicywgZW50cmllcywgY2IpIHtcbiAgaWYgKHRoaXMuYWJvcnRlZClcbiAgICByZXR1cm5cblxuICAvLyBpZiB3ZSBoYXZlbid0IGFza2VkIHRvIHN0YXQgZXZlcnl0aGluZywgdGhlbiBqdXN0XG4gIC8vIGFzc3VtZSB0aGF0IGV2ZXJ5dGhpbmcgaW4gdGhlcmUgZXhpc3RzLCBzbyB3ZSBjYW4gYXZvaWRcbiAgLy8gaGF2aW5nIHRvIHN0YXQgaXQgYSBzZWNvbmQgdGltZS5cbiAgaWYgKCF0aGlzLm1hcmsgJiYgIXRoaXMuc3RhdCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkgKyspIHtcbiAgICAgIHZhciBlID0gZW50cmllc1tpXVxuICAgICAgaWYgKGFicyA9PT0gJy8nKVxuICAgICAgICBlID0gYWJzICsgZVxuICAgICAgZWxzZVxuICAgICAgICBlID0gYWJzICsgJy8nICsgZVxuICAgICAgdGhpcy5jYWNoZVtlXSA9IHRydWVcbiAgICB9XG4gIH1cblxuICB0aGlzLmNhY2hlW2Fic10gPSBlbnRyaWVzXG4gIHJldHVybiBjYihudWxsLCBlbnRyaWVzKVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcmVhZGRpckVycm9yID0gZnVuY3Rpb24gKGYsIGVyLCBjYikge1xuICBpZiAodGhpcy5hYm9ydGVkKVxuICAgIHJldHVyblxuXG4gIC8vIGhhbmRsZSBlcnJvcnMsIGFuZCBjYWNoZSB0aGUgaW5mb3JtYXRpb25cbiAgc3dpdGNoIChlci5jb2RlKSB7XG4gICAgY2FzZSAnRU5PVFNVUCc6IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3Mvbm9kZS1nbG9iL2lzc3Vlcy8yMDVcbiAgICBjYXNlICdFTk9URElSJzogLy8gdG90YWxseSBub3JtYWwuIG1lYW5zIGl0ICpkb2VzKiBleGlzdC5cbiAgICAgIHZhciBhYnMgPSB0aGlzLl9tYWtlQWJzKGYpXG4gICAgICB0aGlzLmNhY2hlW2Fic10gPSAnRklMRSdcbiAgICAgIGlmIChhYnMgPT09IHRoaXMuY3dkQWJzKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihlci5jb2RlICsgJyBpbnZhbGlkIGN3ZCAnICsgdGhpcy5jd2QpXG4gICAgICAgIGVycm9yLnBhdGggPSB0aGlzLmN3ZFxuICAgICAgICBlcnJvci5jb2RlID0gZXIuY29kZVxuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpXG4gICAgICAgIHRoaXMuYWJvcnQoKVxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgJ0VOT0VOVCc6IC8vIG5vdCB0ZXJyaWJseSB1bnVzdWFsXG4gICAgY2FzZSAnRUxPT1AnOlxuICAgIGNhc2UgJ0VOQU1FVE9PTE9ORyc6XG4gICAgY2FzZSAnVU5LTk9XTic6XG4gICAgICB0aGlzLmNhY2hlW3RoaXMuX21ha2VBYnMoZildID0gZmFsc2VcbiAgICAgIGJyZWFrXG5cbiAgICBkZWZhdWx0OiAvLyBzb21lIHVudXN1YWwgZXJyb3IuICBUcmVhdCBhcyBmYWlsdXJlLlxuICAgICAgdGhpcy5jYWNoZVt0aGlzLl9tYWtlQWJzKGYpXSA9IGZhbHNlXG4gICAgICBpZiAodGhpcy5zdHJpY3QpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgICAgICAvLyBJZiB0aGUgZXJyb3IgaXMgaGFuZGxlZCwgdGhlbiB3ZSBhYm9ydFxuICAgICAgICAvLyBpZiBub3QsIHdlIHRocmV3IG91dCBvZiBoZXJlXG4gICAgICAgIHRoaXMuYWJvcnQoKVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnNpbGVudClcbiAgICAgICAgY29uc29sZS5lcnJvcignZ2xvYiBlcnJvcicsIGVyKVxuICAgICAgYnJlYWtcbiAgfVxuXG4gIHJldHVybiBjYigpXG59XG5cbkdsb2IucHJvdG90eXBlLl9wcm9jZXNzR2xvYlN0YXIgPSBmdW5jdGlvbiAocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLl9yZWFkZGlyKGFicywgaW5HbG9iU3RhciwgZnVuY3Rpb24gKGVyLCBlbnRyaWVzKSB7XG4gICAgc2VsZi5fcHJvY2Vzc0dsb2JTdGFyMihwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgZW50cmllcywgY2IpXG4gIH0pXG59XG5cblxuR2xvYi5wcm90b3R5cGUuX3Byb2Nlc3NHbG9iU3RhcjIgPSBmdW5jdGlvbiAocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIsIGVudHJpZXMsIGNiKSB7XG4gIC8vY29uc29sZS5lcnJvcigncGdzMicsIHByZWZpeCwgcmVtYWluWzBdLCBlbnRyaWVzKVxuXG4gIC8vIG5vIGVudHJpZXMgbWVhbnMgbm90IGEgZGlyLCBzbyBpdCBjYW4gbmV2ZXIgaGF2ZSBtYXRjaGVzXG4gIC8vIGZvby50eHQvKiogZG9lc24ndCBtYXRjaCBmb28udHh0XG4gIGlmICghZW50cmllcylcbiAgICByZXR1cm4gY2IoKVxuXG4gIC8vIHRlc3Qgd2l0aG91dCB0aGUgZ2xvYnN0YXIsIGFuZCB3aXRoIGV2ZXJ5IGNoaWxkIGJvdGggYmVsb3dcbiAgLy8gYW5kIHJlcGxhY2luZyB0aGUgZ2xvYnN0YXIuXG4gIHZhciByZW1haW5XaXRob3V0R2xvYlN0YXIgPSByZW1haW4uc2xpY2UoMSlcbiAgdmFyIGdzcHJlZiA9IHByZWZpeCA/IFsgcHJlZml4IF0gOiBbXVxuICB2YXIgbm9HbG9iU3RhciA9IGdzcHJlZi5jb25jYXQocmVtYWluV2l0aG91dEdsb2JTdGFyKVxuXG4gIC8vIHRoZSBub0dsb2JTdGFyIHBhdHRlcm4gZXhpdHMgdGhlIGluR2xvYlN0YXIgc3RhdGVcbiAgdGhpcy5fcHJvY2Vzcyhub0dsb2JTdGFyLCBpbmRleCwgZmFsc2UsIGNiKVxuXG4gIHZhciBpc1N5bSA9IHRoaXMuc3ltbGlua3NbYWJzXVxuICB2YXIgbGVuID0gZW50cmllcy5sZW5ndGhcblxuICAvLyBJZiBpdCdzIGEgc3ltbGluaywgYW5kIHdlJ3JlIGluIGEgZ2xvYnN0YXIsIHRoZW4gc3RvcFxuICBpZiAoaXNTeW0gJiYgaW5HbG9iU3RhcilcbiAgICByZXR1cm4gY2IoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgZSA9IGVudHJpZXNbaV1cbiAgICBpZiAoZS5jaGFyQXQoMCkgPT09ICcuJyAmJiAhdGhpcy5kb3QpXG4gICAgICBjb250aW51ZVxuXG4gICAgLy8gdGhlc2UgdHdvIGNhc2VzIGVudGVyIHRoZSBpbkdsb2JTdGFyIHN0YXRlXG4gICAgdmFyIGluc3RlYWQgPSBnc3ByZWYuY29uY2F0KGVudHJpZXNbaV0sIHJlbWFpbldpdGhvdXRHbG9iU3RhcilcbiAgICB0aGlzLl9wcm9jZXNzKGluc3RlYWQsIGluZGV4LCB0cnVlLCBjYilcblxuICAgIHZhciBiZWxvdyA9IGdzcHJlZi5jb25jYXQoZW50cmllc1tpXSwgcmVtYWluKVxuICAgIHRoaXMuX3Byb2Nlc3MoYmVsb3csIGluZGV4LCB0cnVlLCBjYilcbiAgfVxuXG4gIGNiKClcbn1cblxuR2xvYi5wcm90b3R5cGUuX3Byb2Nlc3NTaW1wbGUgPSBmdW5jdGlvbiAocHJlZml4LCBpbmRleCwgY2IpIHtcbiAgLy8gWFhYIHJldmlldyB0aGlzLiAgU2hvdWxkbid0IGl0IGJlIGRvaW5nIHRoZSBtb3VudGluZyBldGNcbiAgLy8gYmVmb3JlIGRvaW5nIHN0YXQ/ICBraW5kYSB3ZWlyZD9cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuX3N0YXQocHJlZml4LCBmdW5jdGlvbiAoZXIsIGV4aXN0cykge1xuICAgIHNlbGYuX3Byb2Nlc3NTaW1wbGUyKHByZWZpeCwgaW5kZXgsIGVyLCBleGlzdHMsIGNiKVxuICB9KVxufVxuR2xvYi5wcm90b3R5cGUuX3Byb2Nlc3NTaW1wbGUyID0gZnVuY3Rpb24gKHByZWZpeCwgaW5kZXgsIGVyLCBleGlzdHMsIGNiKSB7XG5cbiAgLy9jb25zb2xlLmVycm9yKCdwczInLCBwcmVmaXgsIGV4aXN0cylcblxuICBpZiAoIXRoaXMubWF0Y2hlc1tpbmRleF0pXG4gICAgdGhpcy5tYXRjaGVzW2luZGV4XSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICAvLyBJZiBpdCBkb2Vzbid0IGV4aXN0LCB0aGVuIGp1c3QgbWFyayB0aGUgbGFjayBvZiByZXN1bHRzXG4gIGlmICghZXhpc3RzKVxuICAgIHJldHVybiBjYigpXG5cbiAgaWYgKHByZWZpeCAmJiBpc0Fic29sdXRlKHByZWZpeCkgJiYgIXRoaXMubm9tb3VudCkge1xuICAgIHZhciB0cmFpbCA9IC9bXFwvXFxcXF0kLy50ZXN0KHByZWZpeClcbiAgICBpZiAocHJlZml4LmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICBwcmVmaXggPSBwYXRoLmpvaW4odGhpcy5yb290LCBwcmVmaXgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpeCA9IHBhdGgucmVzb2x2ZSh0aGlzLnJvb3QsIHByZWZpeClcbiAgICAgIGlmICh0cmFpbClcbiAgICAgICAgcHJlZml4ICs9ICcvJ1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKVxuICAgIHByZWZpeCA9IHByZWZpeC5yZXBsYWNlKC9cXFxcL2csICcvJylcblxuICAvLyBNYXJrIHRoaXMgYXMgYSBtYXRjaFxuICB0aGlzLl9lbWl0TWF0Y2goaW5kZXgsIHByZWZpeClcbiAgY2IoKVxufVxuXG4vLyBSZXR1cm5zIGVpdGhlciAnRElSJywgJ0ZJTEUnLCBvciBmYWxzZVxuR2xvYi5wcm90b3R5cGUuX3N0YXQgPSBmdW5jdGlvbiAoZiwgY2IpIHtcbiAgdmFyIGFicyA9IHRoaXMuX21ha2VBYnMoZilcbiAgdmFyIG5lZWREaXIgPSBmLnNsaWNlKC0xKSA9PT0gJy8nXG5cbiAgaWYgKGYubGVuZ3RoID4gdGhpcy5tYXhMZW5ndGgpXG4gICAgcmV0dXJuIGNiKClcblxuICBpZiAoIXRoaXMuc3RhdCAmJiBvd25Qcm9wKHRoaXMuY2FjaGUsIGFicykpIHtcbiAgICB2YXIgYyA9IHRoaXMuY2FjaGVbYWJzXVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpXG4gICAgICBjID0gJ0RJUidcblxuICAgIC8vIEl0IGV4aXN0cywgYnV0IG1heWJlIG5vdCBob3cgd2UgbmVlZCBpdFxuICAgIGlmICghbmVlZERpciB8fCBjID09PSAnRElSJylcbiAgICAgIHJldHVybiBjYihudWxsLCBjKVxuXG4gICAgaWYgKG5lZWREaXIgJiYgYyA9PT0gJ0ZJTEUnKVxuICAgICAgcmV0dXJuIGNiKClcblxuICAgIC8vIG90aGVyd2lzZSB3ZSBoYXZlIHRvIHN0YXQsIGJlY2F1c2UgbWF5YmUgYz10cnVlXG4gICAgLy8gaWYgd2Uga25vdyBpdCBleGlzdHMsIGJ1dCBub3Qgd2hhdCBpdCBpcy5cbiAgfVxuXG4gIHZhciBleGlzdHNcbiAgdmFyIHN0YXQgPSB0aGlzLnN0YXRDYWNoZVthYnNdXG4gIGlmIChzdGF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoc3RhdCA9PT0gZmFsc2UpXG4gICAgICByZXR1cm4gY2IobnVsbCwgc3RhdClcbiAgICBlbHNlIHtcbiAgICAgIHZhciB0eXBlID0gc3RhdC5pc0RpcmVjdG9yeSgpID8gJ0RJUicgOiAnRklMRSdcbiAgICAgIGlmIChuZWVkRGlyICYmIHR5cGUgPT09ICdGSUxFJylcbiAgICAgICAgcmV0dXJuIGNiKClcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIHR5cGUsIHN0YXQpXG4gICAgfVxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBzdGF0Y2IgPSBpbmZsaWdodCgnc3RhdFxcMCcgKyBhYnMsIGxzdGF0Y2JfKVxuICBpZiAoc3RhdGNiKVxuICAgIGZzLmxzdGF0KGFicywgc3RhdGNiKVxuXG4gIGZ1bmN0aW9uIGxzdGF0Y2JfIChlciwgbHN0YXQpIHtcbiAgICBpZiAobHN0YXQgJiYgbHN0YXQuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgLy8gSWYgaXQncyBhIHN5bWxpbmssIHRoZW4gdHJlYXQgaXQgYXMgdGhlIHRhcmdldCwgdW5sZXNzXG4gICAgICAvLyB0aGUgdGFyZ2V0IGRvZXMgbm90IGV4aXN0LCB0aGVuIHRyZWF0IGl0IGFzIGEgZmlsZS5cbiAgICAgIHJldHVybiBmcy5zdGF0KGFicywgZnVuY3Rpb24gKGVyLCBzdGF0KSB7XG4gICAgICAgIGlmIChlcilcbiAgICAgICAgICBzZWxmLl9zdGF0MihmLCBhYnMsIG51bGwsIGxzdGF0LCBjYilcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHNlbGYuX3N0YXQyKGYsIGFicywgZXIsIHN0YXQsIGNiKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5fc3RhdDIoZiwgYWJzLCBlciwgbHN0YXQsIGNiKVxuICAgIH1cbiAgfVxufVxuXG5HbG9iLnByb3RvdHlwZS5fc3RhdDIgPSBmdW5jdGlvbiAoZiwgYWJzLCBlciwgc3RhdCwgY2IpIHtcbiAgaWYgKGVyICYmIChlci5jb2RlID09PSAnRU5PRU5UJyB8fCBlci5jb2RlID09PSAnRU5PVERJUicpKSB7XG4gICAgdGhpcy5zdGF0Q2FjaGVbYWJzXSA9IGZhbHNlXG4gICAgcmV0dXJuIGNiKClcbiAgfVxuXG4gIHZhciBuZWVkRGlyID0gZi5zbGljZSgtMSkgPT09ICcvJ1xuICB0aGlzLnN0YXRDYWNoZVthYnNdID0gc3RhdFxuXG4gIGlmIChhYnMuc2xpY2UoLTEpID09PSAnLycgJiYgc3RhdCAmJiAhc3RhdC5pc0RpcmVjdG9yeSgpKVxuICAgIHJldHVybiBjYihudWxsLCBmYWxzZSwgc3RhdClcblxuICB2YXIgYyA9IHRydWVcbiAgaWYgKHN0YXQpXG4gICAgYyA9IHN0YXQuaXNEaXJlY3RvcnkoKSA/ICdESVInIDogJ0ZJTEUnXG4gIHRoaXMuY2FjaGVbYWJzXSA9IHRoaXMuY2FjaGVbYWJzXSB8fCBjXG5cbiAgaWYgKG5lZWREaXIgJiYgYyA9PT0gJ0ZJTEUnKVxuICAgIHJldHVybiBjYigpXG5cbiAgcmV0dXJuIGNiKG51bGwsIGMsIHN0YXQpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGdsb2JTeW5jXG5nbG9iU3luYy5HbG9iU3luYyA9IEdsb2JTeW5jXG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcbnZhciBycCA9IHJlcXVpcmUoJ2ZzLnJlYWxwYXRoJylcbnZhciBtaW5pbWF0Y2ggPSByZXF1aXJlKCdtaW5pbWF0Y2gnKVxudmFyIE1pbmltYXRjaCA9IG1pbmltYXRjaC5NaW5pbWF0Y2hcbnZhciBHbG9iID0gcmVxdWlyZSgnLi9nbG9iLmpzJykuR2xvYlxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbnZhciBpc0Fic29sdXRlID0gcmVxdWlyZSgncGF0aC1pcy1hYnNvbHV0ZScpXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24uanMnKVxudmFyIHNldG9wdHMgPSBjb21tb24uc2V0b3B0c1xudmFyIG93blByb3AgPSBjb21tb24ub3duUHJvcFxudmFyIGNoaWxkcmVuSWdub3JlZCA9IGNvbW1vbi5jaGlsZHJlbklnbm9yZWRcbnZhciBpc0lnbm9yZWQgPSBjb21tb24uaXNJZ25vcmVkXG5cbmZ1bmN0aW9uIGdsb2JTeW5jIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAzKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIHByb3ZpZGVkIHRvIHN5bmMgZ2xvYlxcbicrXG4gICAgICAgICAgICAgICAgICAgICAgICAnU2VlOiBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL25vZGUtZ2xvYi9pc3N1ZXMvMTY3JylcblxuICByZXR1cm4gbmV3IEdsb2JTeW5jKHBhdHRlcm4sIG9wdGlvbnMpLmZvdW5kXG59XG5cbmZ1bmN0aW9uIEdsb2JTeW5jIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICghcGF0dGVybilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3QgcHJvdmlkZSBwYXR0ZXJuJylcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBwcm92aWRlZCB0byBzeW5jIGdsb2JcXG4nK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZTogaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ub2RlLWdsb2IvaXNzdWVzLzE2NycpXG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEdsb2JTeW5jKSlcbiAgICByZXR1cm4gbmV3IEdsb2JTeW5jKHBhdHRlcm4sIG9wdGlvbnMpXG5cbiAgc2V0b3B0cyh0aGlzLCBwYXR0ZXJuLCBvcHRpb25zKVxuXG4gIGlmICh0aGlzLm5vcHJvY2VzcylcbiAgICByZXR1cm4gdGhpc1xuXG4gIHZhciBuID0gdGhpcy5taW5pbWF0Y2guc2V0Lmxlbmd0aFxuICB0aGlzLm1hdGNoZXMgPSBuZXcgQXJyYXkobilcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpICsrKSB7XG4gICAgdGhpcy5fcHJvY2Vzcyh0aGlzLm1pbmltYXRjaC5zZXRbaV0sIGksIGZhbHNlKVxuICB9XG4gIHRoaXMuX2ZpbmlzaCgpXG59XG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICBhc3NlcnQodGhpcyBpbnN0YW5jZW9mIEdsb2JTeW5jKVxuICBpZiAodGhpcy5yZWFscGF0aCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHRoaXMubWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uIChtYXRjaHNldCwgaW5kZXgpIHtcbiAgICAgIHZhciBzZXQgPSBzZWxmLm1hdGNoZXNbaW5kZXhdID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgICAgZm9yICh2YXIgcCBpbiBtYXRjaHNldCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHAgPSBzZWxmLl9tYWtlQWJzKHApXG4gICAgICAgICAgdmFyIHJlYWwgPSBycC5yZWFscGF0aFN5bmMocCwgc2VsZi5yZWFscGF0aENhY2hlKVxuICAgICAgICAgIHNldFtyZWFsXSA9IHRydWVcbiAgICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgICBpZiAoZXIuc3lzY2FsbCA9PT0gJ3N0YXQnKVxuICAgICAgICAgICAgc2V0W3NlbGYuX21ha2VBYnMocCldID0gdHJ1ZVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IGVyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIGNvbW1vbi5maW5pc2godGhpcylcbn1cblxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3Byb2Nlc3MgPSBmdW5jdGlvbiAocGF0dGVybiwgaW5kZXgsIGluR2xvYlN0YXIpIHtcbiAgYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBHbG9iU3luYylcblxuICAvLyBHZXQgdGhlIGZpcnN0IFtuXSBwYXJ0cyBvZiBwYXR0ZXJuIHRoYXQgYXJlIGFsbCBzdHJpbmdzLlxuICB2YXIgbiA9IDBcbiAgd2hpbGUgKHR5cGVvZiBwYXR0ZXJuW25dID09PSAnc3RyaW5nJykge1xuICAgIG4gKytcbiAgfVxuICAvLyBub3cgbiBpcyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG9uZSB0aGF0IGlzICpub3QqIGEgc3RyaW5nLlxuXG4gIC8vIFNlZSBpZiB0aGVyZSdzIGFueXRoaW5nIGVsc2VcbiAgdmFyIHByZWZpeFxuICBzd2l0Y2ggKG4pIHtcbiAgICAvLyBpZiBub3QsIHRoZW4gdGhpcyBpcyByYXRoZXIgc2ltcGxlXG4gICAgY2FzZSBwYXR0ZXJuLmxlbmd0aDpcbiAgICAgIHRoaXMuX3Byb2Nlc3NTaW1wbGUocGF0dGVybi5qb2luKCcvJyksIGluZGV4KVxuICAgICAgcmV0dXJuXG5cbiAgICBjYXNlIDA6XG4gICAgICAvLyBwYXR0ZXJuICpzdGFydHMqIHdpdGggc29tZSBub24tdHJpdmlhbCBpdGVtLlxuICAgICAgLy8gZ29pbmcgdG8gcmVhZGRpcihjd2QpLCBidXQgbm90IGluY2x1ZGUgdGhlIHByZWZpeCBpbiBtYXRjaGVzLlxuICAgICAgcHJlZml4ID0gbnVsbFxuICAgICAgYnJlYWtcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBwYXR0ZXJuIGhhcyBzb21lIHN0cmluZyBiaXRzIGluIHRoZSBmcm9udC5cbiAgICAgIC8vIHdoYXRldmVyIGl0IHN0YXJ0cyB3aXRoLCB3aGV0aGVyIHRoYXQncyAnYWJzb2x1dGUnIGxpa2UgL2Zvby9iYXIsXG4gICAgICAvLyBvciAncmVsYXRpdmUnIGxpa2UgJy4uL2JheidcbiAgICAgIHByZWZpeCA9IHBhdHRlcm4uc2xpY2UoMCwgbikuam9pbignLycpXG4gICAgICBicmVha1xuICB9XG5cbiAgdmFyIHJlbWFpbiA9IHBhdHRlcm4uc2xpY2UobilcblxuICAvLyBnZXQgdGhlIGxpc3Qgb2YgZW50cmllcy5cbiAgdmFyIHJlYWRcbiAgaWYgKHByZWZpeCA9PT0gbnVsbClcbiAgICByZWFkID0gJy4nXG4gIGVsc2UgaWYgKGlzQWJzb2x1dGUocHJlZml4KSB8fCBpc0Fic29sdXRlKHBhdHRlcm4uam9pbignLycpKSkge1xuICAgIGlmICghcHJlZml4IHx8ICFpc0Fic29sdXRlKHByZWZpeCkpXG4gICAgICBwcmVmaXggPSAnLycgKyBwcmVmaXhcbiAgICByZWFkID0gcHJlZml4XG4gIH0gZWxzZVxuICAgIHJlYWQgPSBwcmVmaXhcblxuICB2YXIgYWJzID0gdGhpcy5fbWFrZUFicyhyZWFkKVxuXG4gIC8vaWYgaWdub3JlZCwgc2tpcCBwcm9jZXNzaW5nXG4gIGlmIChjaGlsZHJlbklnbm9yZWQodGhpcywgcmVhZCkpXG4gICAgcmV0dXJuXG5cbiAgdmFyIGlzR2xvYlN0YXIgPSByZW1haW5bMF0gPT09IG1pbmltYXRjaC5HTE9CU1RBUlxuICBpZiAoaXNHbG9iU3RhcilcbiAgICB0aGlzLl9wcm9jZXNzR2xvYlN0YXIocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIpXG4gIGVsc2VcbiAgICB0aGlzLl9wcm9jZXNzUmVhZGRpcihwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3Rhcilcbn1cblxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3Byb2Nlc3NSZWFkZGlyID0gZnVuY3Rpb24gKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyKSB7XG4gIHZhciBlbnRyaWVzID0gdGhpcy5fcmVhZGRpcihhYnMsIGluR2xvYlN0YXIpXG5cbiAgLy8gaWYgdGhlIGFicyBpc24ndCBhIGRpciwgdGhlbiBub3RoaW5nIGNhbiBtYXRjaCFcbiAgaWYgKCFlbnRyaWVzKVxuICAgIHJldHVyblxuXG4gIC8vIEl0IHdpbGwgb25seSBtYXRjaCBkb3QgZW50cmllcyBpZiBpdCBzdGFydHMgd2l0aCBhIGRvdCwgb3IgaWZcbiAgLy8gZG90IGlzIHNldC4gIFN0dWZmIGxpa2UgQCguZm9vfC5iYXIpIGlzbid0IGFsbG93ZWQuXG4gIHZhciBwbiA9IHJlbWFpblswXVxuICB2YXIgbmVnYXRlID0gISF0aGlzLm1pbmltYXRjaC5uZWdhdGVcbiAgdmFyIHJhd0dsb2IgPSBwbi5fZ2xvYlxuICB2YXIgZG90T2sgPSB0aGlzLmRvdCB8fCByYXdHbG9iLmNoYXJBdCgwKSA9PT0gJy4nXG5cbiAgdmFyIG1hdGNoZWRFbnRyaWVzID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGUgPSBlbnRyaWVzW2ldXG4gICAgaWYgKGUuY2hhckF0KDApICE9PSAnLicgfHwgZG90T2spIHtcbiAgICAgIHZhciBtXG4gICAgICBpZiAobmVnYXRlICYmICFwcmVmaXgpIHtcbiAgICAgICAgbSA9ICFlLm1hdGNoKHBuKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbSA9IGUubWF0Y2gocG4pXG4gICAgICB9XG4gICAgICBpZiAobSlcbiAgICAgICAgbWF0Y2hlZEVudHJpZXMucHVzaChlKVxuICAgIH1cbiAgfVxuXG4gIHZhciBsZW4gPSBtYXRjaGVkRW50cmllcy5sZW5ndGhcbiAgLy8gSWYgdGhlcmUgYXJlIG5vIG1hdGNoZWQgZW50cmllcywgdGhlbiBub3RoaW5nIG1hdGNoZXMuXG4gIGlmIChsZW4gPT09IDApXG4gICAgcmV0dXJuXG5cbiAgLy8gaWYgdGhpcyBpcyB0aGUgbGFzdCByZW1haW5pbmcgcGF0dGVybiBiaXQsIHRoZW4gbm8gbmVlZCBmb3JcbiAgLy8gYW4gYWRkaXRpb25hbCBzdGF0ICp1bmxlc3MqIHRoZSB1c2VyIGhhcyBzcGVjaWZpZWQgbWFyayBvclxuICAvLyBzdGF0IGV4cGxpY2l0bHkuICBXZSBrbm93IHRoZXkgZXhpc3QsIHNpbmNlIHJlYWRkaXIgcmV0dXJuZWRcbiAgLy8gdGhlbS5cblxuICBpZiAocmVtYWluLmxlbmd0aCA9PT0gMSAmJiAhdGhpcy5tYXJrICYmICF0aGlzLnN0YXQpIHtcbiAgICBpZiAoIXRoaXMubWF0Y2hlc1tpbmRleF0pXG4gICAgICB0aGlzLm1hdGNoZXNbaW5kZXhdID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKyspIHtcbiAgICAgIHZhciBlID0gbWF0Y2hlZEVudHJpZXNbaV1cbiAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgaWYgKHByZWZpeC5zbGljZSgtMSkgIT09ICcvJylcbiAgICAgICAgICBlID0gcHJlZml4ICsgJy8nICsgZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZSA9IHByZWZpeCArIGVcbiAgICAgIH1cblxuICAgICAgaWYgKGUuY2hhckF0KDApID09PSAnLycgJiYgIXRoaXMubm9tb3VudCkge1xuICAgICAgICBlID0gcGF0aC5qb2luKHRoaXMucm9vdCwgZSlcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VtaXRNYXRjaChpbmRleCwgZSlcbiAgICB9XG4gICAgLy8gVGhpcyB3YXMgdGhlIGxhc3Qgb25lLCBhbmQgbm8gc3RhdHMgd2VyZSBuZWVkZWRcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIG5vdyB0ZXN0IGFsbCBtYXRjaGVkIGVudHJpZXMgYXMgc3RhbmQtaW5zIGZvciB0aGF0IHBhcnRcbiAgLy8gb2YgdGhlIHBhdHRlcm4uXG4gIHJlbWFpbi5zaGlmdCgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICsrKSB7XG4gICAgdmFyIGUgPSBtYXRjaGVkRW50cmllc1tpXVxuICAgIHZhciBuZXdQYXR0ZXJuXG4gICAgaWYgKHByZWZpeClcbiAgICAgIG5ld1BhdHRlcm4gPSBbcHJlZml4LCBlXVxuICAgIGVsc2VcbiAgICAgIG5ld1BhdHRlcm4gPSBbZV1cbiAgICB0aGlzLl9wcm9jZXNzKG5ld1BhdHRlcm4uY29uY2F0KHJlbWFpbiksIGluZGV4LCBpbkdsb2JTdGFyKVxuICB9XG59XG5cblxuR2xvYlN5bmMucHJvdG90eXBlLl9lbWl0TWF0Y2ggPSBmdW5jdGlvbiAoaW5kZXgsIGUpIHtcbiAgaWYgKGlzSWdub3JlZCh0aGlzLCBlKSlcbiAgICByZXR1cm5cblxuICB2YXIgYWJzID0gdGhpcy5fbWFrZUFicyhlKVxuXG4gIGlmICh0aGlzLm1hcmspXG4gICAgZSA9IHRoaXMuX21hcmsoZSlcblxuICBpZiAodGhpcy5hYnNvbHV0ZSkge1xuICAgIGUgPSBhYnNcbiAgfVxuXG4gIGlmICh0aGlzLm1hdGNoZXNbaW5kZXhdW2VdKVxuICAgIHJldHVyblxuXG4gIGlmICh0aGlzLm5vZGlyKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNhY2hlW2Fic11cbiAgICBpZiAoYyA9PT0gJ0RJUicgfHwgQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIHJldHVyblxuICB9XG5cbiAgdGhpcy5tYXRjaGVzW2luZGV4XVtlXSA9IHRydWVcblxuICBpZiAodGhpcy5zdGF0KVxuICAgIHRoaXMuX3N0YXQoZSlcbn1cblxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3JlYWRkaXJJbkdsb2JTdGFyID0gZnVuY3Rpb24gKGFicykge1xuICAvLyBmb2xsb3cgYWxsIHN5bWxpbmtlZCBkaXJlY3RvcmllcyBmb3JldmVyXG4gIC8vIGp1c3QgcHJvY2VlZCBhcyBpZiB0aGlzIGlzIGEgbm9uLWdsb2JzdGFyIHNpdHVhdGlvblxuICBpZiAodGhpcy5mb2xsb3cpXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRkaXIoYWJzLCBmYWxzZSlcblxuICB2YXIgZW50cmllc1xuICB2YXIgbHN0YXRcbiAgdmFyIHN0YXRcbiAgdHJ5IHtcbiAgICBsc3RhdCA9IGZzLmxzdGF0U3luYyhhYnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgaWYgKGVyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAvLyBsc3RhdCBmYWlsZWQsIGRvZXNuJ3QgZXhpc3RcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgdmFyIGlzU3ltID0gbHN0YXQgJiYgbHN0YXQuaXNTeW1ib2xpY0xpbmsoKVxuICB0aGlzLnN5bWxpbmtzW2Fic10gPSBpc1N5bVxuXG4gIC8vIElmIGl0J3Mgbm90IGEgc3ltbGluayBvciBhIGRpciwgdGhlbiBpdCdzIGRlZmluaXRlbHkgYSByZWd1bGFyIGZpbGUuXG4gIC8vIGRvbid0IGJvdGhlciBkb2luZyBhIHJlYWRkaXIgaW4gdGhhdCBjYXNlLlxuICBpZiAoIWlzU3ltICYmIGxzdGF0ICYmICFsc3RhdC5pc0RpcmVjdG9yeSgpKVxuICAgIHRoaXMuY2FjaGVbYWJzXSA9ICdGSUxFJ1xuICBlbHNlXG4gICAgZW50cmllcyA9IHRoaXMuX3JlYWRkaXIoYWJzLCBmYWxzZSlcblxuICByZXR1cm4gZW50cmllc1xufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3JlYWRkaXIgPSBmdW5jdGlvbiAoYWJzLCBpbkdsb2JTdGFyKSB7XG4gIHZhciBlbnRyaWVzXG5cbiAgaWYgKGluR2xvYlN0YXIgJiYgIW93blByb3AodGhpcy5zeW1saW5rcywgYWJzKSlcbiAgICByZXR1cm4gdGhpcy5fcmVhZGRpckluR2xvYlN0YXIoYWJzKVxuXG4gIGlmIChvd25Qcm9wKHRoaXMuY2FjaGUsIGFicykpIHtcbiAgICB2YXIgYyA9IHRoaXMuY2FjaGVbYWJzXVxuICAgIGlmICghYyB8fCBjID09PSAnRklMRScpXG4gICAgICByZXR1cm4gbnVsbFxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpXG4gICAgICByZXR1cm4gY1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGRpckVudHJpZXMoYWJzLCBmcy5yZWFkZGlyU3luYyhhYnMpKVxuICB9IGNhdGNoIChlcikge1xuICAgIHRoaXMuX3JlYWRkaXJFcnJvcihhYnMsIGVyKVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuR2xvYlN5bmMucHJvdG90eXBlLl9yZWFkZGlyRW50cmllcyA9IGZ1bmN0aW9uIChhYnMsIGVudHJpZXMpIHtcbiAgLy8gaWYgd2UgaGF2ZW4ndCBhc2tlZCB0byBzdGF0IGV2ZXJ5dGhpbmcsIHRoZW4ganVzdFxuICAvLyBhc3N1bWUgdGhhdCBldmVyeXRoaW5nIGluIHRoZXJlIGV4aXN0cywgc28gd2UgY2FuIGF2b2lkXG4gIC8vIGhhdmluZyB0byBzdGF0IGl0IGEgc2Vjb25kIHRpbWUuXG4gIGlmICghdGhpcy5tYXJrICYmICF0aGlzLnN0YXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpICsrKSB7XG4gICAgICB2YXIgZSA9IGVudHJpZXNbaV1cbiAgICAgIGlmIChhYnMgPT09ICcvJylcbiAgICAgICAgZSA9IGFicyArIGVcbiAgICAgIGVsc2VcbiAgICAgICAgZSA9IGFicyArICcvJyArIGVcbiAgICAgIHRoaXMuY2FjaGVbZV0gPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgdGhpcy5jYWNoZVthYnNdID0gZW50cmllc1xuXG4gIC8vIG1hcmsgYW5kIGNhY2hlIGRpci1uZXNzXG4gIHJldHVybiBlbnRyaWVzXG59XG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fcmVhZGRpckVycm9yID0gZnVuY3Rpb24gKGYsIGVyKSB7XG4gIC8vIGhhbmRsZSBlcnJvcnMsIGFuZCBjYWNoZSB0aGUgaW5mb3JtYXRpb25cbiAgc3dpdGNoIChlci5jb2RlKSB7XG4gICAgY2FzZSAnRU5PVFNVUCc6IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3Mvbm9kZS1nbG9iL2lzc3Vlcy8yMDVcbiAgICBjYXNlICdFTk9URElSJzogLy8gdG90YWxseSBub3JtYWwuIG1lYW5zIGl0ICpkb2VzKiBleGlzdC5cbiAgICAgIHZhciBhYnMgPSB0aGlzLl9tYWtlQWJzKGYpXG4gICAgICB0aGlzLmNhY2hlW2Fic10gPSAnRklMRSdcbiAgICAgIGlmIChhYnMgPT09IHRoaXMuY3dkQWJzKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihlci5jb2RlICsgJyBpbnZhbGlkIGN3ZCAnICsgdGhpcy5jd2QpXG4gICAgICAgIGVycm9yLnBhdGggPSB0aGlzLmN3ZFxuICAgICAgICBlcnJvci5jb2RlID0gZXIuY29kZVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgJ0VOT0VOVCc6IC8vIG5vdCB0ZXJyaWJseSB1bnVzdWFsXG4gICAgY2FzZSAnRUxPT1AnOlxuICAgIGNhc2UgJ0VOQU1FVE9PTE9ORyc6XG4gICAgY2FzZSAnVU5LTk9XTic6XG4gICAgICB0aGlzLmNhY2hlW3RoaXMuX21ha2VBYnMoZildID0gZmFsc2VcbiAgICAgIGJyZWFrXG5cbiAgICBkZWZhdWx0OiAvLyBzb21lIHVudXN1YWwgZXJyb3IuICBUcmVhdCBhcyBmYWlsdXJlLlxuICAgICAgdGhpcy5jYWNoZVt0aGlzLl9tYWtlQWJzKGYpXSA9IGZhbHNlXG4gICAgICBpZiAodGhpcy5zdHJpY3QpXG4gICAgICAgIHRocm93IGVyXG4gICAgICBpZiAoIXRoaXMuc2lsZW50KVxuICAgICAgICBjb25zb2xlLmVycm9yKCdnbG9iIGVycm9yJywgZXIpXG4gICAgICBicmVha1xuICB9XG59XG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fcHJvY2Vzc0dsb2JTdGFyID0gZnVuY3Rpb24gKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyKSB7XG5cbiAgdmFyIGVudHJpZXMgPSB0aGlzLl9yZWFkZGlyKGFicywgaW5HbG9iU3RhcilcblxuICAvLyBubyBlbnRyaWVzIG1lYW5zIG5vdCBhIGRpciwgc28gaXQgY2FuIG5ldmVyIGhhdmUgbWF0Y2hlc1xuICAvLyBmb28udHh0LyoqIGRvZXNuJ3QgbWF0Y2ggZm9vLnR4dFxuICBpZiAoIWVudHJpZXMpXG4gICAgcmV0dXJuXG5cbiAgLy8gdGVzdCB3aXRob3V0IHRoZSBnbG9ic3RhciwgYW5kIHdpdGggZXZlcnkgY2hpbGQgYm90aCBiZWxvd1xuICAvLyBhbmQgcmVwbGFjaW5nIHRoZSBnbG9ic3Rhci5cbiAgdmFyIHJlbWFpbldpdGhvdXRHbG9iU3RhciA9IHJlbWFpbi5zbGljZSgxKVxuICB2YXIgZ3NwcmVmID0gcHJlZml4ID8gWyBwcmVmaXggXSA6IFtdXG4gIHZhciBub0dsb2JTdGFyID0gZ3NwcmVmLmNvbmNhdChyZW1haW5XaXRob3V0R2xvYlN0YXIpXG5cbiAgLy8gdGhlIG5vR2xvYlN0YXIgcGF0dGVybiBleGl0cyB0aGUgaW5HbG9iU3RhciBzdGF0ZVxuICB0aGlzLl9wcm9jZXNzKG5vR2xvYlN0YXIsIGluZGV4LCBmYWxzZSlcblxuICB2YXIgbGVuID0gZW50cmllcy5sZW5ndGhcbiAgdmFyIGlzU3ltID0gdGhpcy5zeW1saW5rc1thYnNdXG5cbiAgLy8gSWYgaXQncyBhIHN5bWxpbmssIGFuZCB3ZSdyZSBpbiBhIGdsb2JzdGFyLCB0aGVuIHN0b3BcbiAgaWYgKGlzU3ltICYmIGluR2xvYlN0YXIpXG4gICAgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBlID0gZW50cmllc1tpXVxuICAgIGlmIChlLmNoYXJBdCgwKSA9PT0gJy4nICYmICF0aGlzLmRvdClcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAvLyB0aGVzZSB0d28gY2FzZXMgZW50ZXIgdGhlIGluR2xvYlN0YXIgc3RhdGVcbiAgICB2YXIgaW5zdGVhZCA9IGdzcHJlZi5jb25jYXQoZW50cmllc1tpXSwgcmVtYWluV2l0aG91dEdsb2JTdGFyKVxuICAgIHRoaXMuX3Byb2Nlc3MoaW5zdGVhZCwgaW5kZXgsIHRydWUpXG5cbiAgICB2YXIgYmVsb3cgPSBnc3ByZWYuY29uY2F0KGVudHJpZXNbaV0sIHJlbWFpbilcbiAgICB0aGlzLl9wcm9jZXNzKGJlbG93LCBpbmRleCwgdHJ1ZSlcbiAgfVxufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3Byb2Nlc3NTaW1wbGUgPSBmdW5jdGlvbiAocHJlZml4LCBpbmRleCkge1xuICAvLyBYWFggcmV2aWV3IHRoaXMuICBTaG91bGRuJ3QgaXQgYmUgZG9pbmcgdGhlIG1vdW50aW5nIGV0Y1xuICAvLyBiZWZvcmUgZG9pbmcgc3RhdD8gIGtpbmRhIHdlaXJkP1xuICB2YXIgZXhpc3RzID0gdGhpcy5fc3RhdChwcmVmaXgpXG5cbiAgaWYgKCF0aGlzLm1hdGNoZXNbaW5kZXhdKVxuICAgIHRoaXMubWF0Y2hlc1tpbmRleF0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgLy8gSWYgaXQgZG9lc24ndCBleGlzdCwgdGhlbiBqdXN0IG1hcmsgdGhlIGxhY2sgb2YgcmVzdWx0c1xuICBpZiAoIWV4aXN0cylcbiAgICByZXR1cm5cblxuICBpZiAocHJlZml4ICYmIGlzQWJzb2x1dGUocHJlZml4KSAmJiAhdGhpcy5ub21vdW50KSB7XG4gICAgdmFyIHRyYWlsID0gL1tcXC9cXFxcXSQvLnRlc3QocHJlZml4KVxuICAgIGlmIChwcmVmaXguY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgIHByZWZpeCA9IHBhdGguam9pbih0aGlzLnJvb3QsIHByZWZpeClcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZml4ID0gcGF0aC5yZXNvbHZlKHRoaXMucm9vdCwgcHJlZml4KVxuICAgICAgaWYgKHRyYWlsKVxuICAgICAgICBwcmVmaXggKz0gJy8nXG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpXG4gICAgcHJlZml4ID0gcHJlZml4LnJlcGxhY2UoL1xcXFwvZywgJy8nKVxuXG4gIC8vIE1hcmsgdGhpcyBhcyBhIG1hdGNoXG4gIHRoaXMuX2VtaXRNYXRjaChpbmRleCwgcHJlZml4KVxufVxuXG4vLyBSZXR1cm5zIGVpdGhlciAnRElSJywgJ0ZJTEUnLCBvciBmYWxzZVxuR2xvYlN5bmMucHJvdG90eXBlLl9zdGF0ID0gZnVuY3Rpb24gKGYpIHtcbiAgdmFyIGFicyA9IHRoaXMuX21ha2VBYnMoZilcbiAgdmFyIG5lZWREaXIgPSBmLnNsaWNlKC0xKSA9PT0gJy8nXG5cbiAgaWYgKGYubGVuZ3RoID4gdGhpcy5tYXhMZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgaWYgKCF0aGlzLnN0YXQgJiYgb3duUHJvcCh0aGlzLmNhY2hlLCBhYnMpKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNhY2hlW2Fic11cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKVxuICAgICAgYyA9ICdESVInXG5cbiAgICAvLyBJdCBleGlzdHMsIGJ1dCBtYXliZSBub3QgaG93IHdlIG5lZWQgaXRcbiAgICBpZiAoIW5lZWREaXIgfHwgYyA9PT0gJ0RJUicpXG4gICAgICByZXR1cm4gY1xuXG4gICAgaWYgKG5lZWREaXIgJiYgYyA9PT0gJ0ZJTEUnKVxuICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICAvLyBvdGhlcndpc2Ugd2UgaGF2ZSB0byBzdGF0LCBiZWNhdXNlIG1heWJlIGM9dHJ1ZVxuICAgIC8vIGlmIHdlIGtub3cgaXQgZXhpc3RzLCBidXQgbm90IHdoYXQgaXQgaXMuXG4gIH1cblxuICB2YXIgZXhpc3RzXG4gIHZhciBzdGF0ID0gdGhpcy5zdGF0Q2FjaGVbYWJzXVxuICBpZiAoIXN0YXQpIHtcbiAgICB2YXIgbHN0YXRcbiAgICB0cnkge1xuICAgICAgbHN0YXQgPSBmcy5sc3RhdFN5bmMoYWJzKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICBpZiAoZXIgJiYgKGVyLmNvZGUgPT09ICdFTk9FTlQnIHx8IGVyLmNvZGUgPT09ICdFTk9URElSJykpIHtcbiAgICAgICAgdGhpcy5zdGF0Q2FjaGVbYWJzXSA9IGZhbHNlXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsc3RhdCAmJiBsc3RhdC5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGF0ID0gZnMuc3RhdFN5bmMoYWJzKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgc3RhdCA9IGxzdGF0XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXQgPSBsc3RhdFxuICAgIH1cbiAgfVxuXG4gIHRoaXMuc3RhdENhY2hlW2Fic10gPSBzdGF0XG5cbiAgdmFyIGMgPSB0cnVlXG4gIGlmIChzdGF0KVxuICAgIGMgPSBzdGF0LmlzRGlyZWN0b3J5KCkgPyAnRElSJyA6ICdGSUxFJ1xuXG4gIHRoaXMuY2FjaGVbYWJzXSA9IHRoaXMuY2FjaGVbYWJzXSB8fCBjXG5cbiAgaWYgKG5lZWREaXIgJiYgYyA9PT0gJ0ZJTEUnKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIHJldHVybiBjXG59XG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fbWFyayA9IGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBjb21tb24ubWFyayh0aGlzLCBwKVxufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX21ha2VBYnMgPSBmdW5jdGlvbiAoZikge1xuICByZXR1cm4gY29tbW9uLm1ha2VBYnModGhpcywgZilcbn1cbiIsImV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2xpYi9wYXJzZScpO1xuZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2xpYi9zdHJpbmdpZnknKTtcbiIsInZhciBhdCwgLy8gVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGNoYXJhY3RlclxuICAgIGNoLCAvLyBUaGUgY3VycmVudCBjaGFyYWN0ZXJcbiAgICBlc2NhcGVlID0ge1xuICAgICAgICAnXCInOiAgJ1wiJyxcbiAgICAgICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgICAgICcvJzogICcvJyxcbiAgICAgICAgYjogICAgJ1xcYicsXG4gICAgICAgIGY6ICAgICdcXGYnLFxuICAgICAgICBuOiAgICAnXFxuJyxcbiAgICAgICAgcjogICAgJ1xccicsXG4gICAgICAgIHQ6ICAgICdcXHQnXG4gICAgfSxcbiAgICB0ZXh0LFxuXG4gICAgZXJyb3IgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICAvLyBDYWxsIGVycm9yIHdoZW4gc29tZXRoaW5nIGlzIHdyb25nLlxuICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICBuYW1lOiAgICAnU3ludGF4RXJyb3InLFxuICAgICAgICAgICAgbWVzc2FnZTogbSxcbiAgICAgICAgICAgIGF0OiAgICAgIGF0LFxuICAgICAgICAgICAgdGV4dDogICAgdGV4dFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgXG4gICAgbmV4dCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIC8vIElmIGEgYyBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIHZlcmlmeSB0aGF0IGl0IG1hdGNoZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyLlxuICAgICAgICBpZiAoYyAmJiBjICE9PSBjaCkge1xuICAgICAgICAgICAgZXJyb3IoXCJFeHBlY3RlZCAnXCIgKyBjICsgXCInIGluc3RlYWQgb2YgJ1wiICsgY2ggKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEdldCB0aGUgbmV4dCBjaGFyYWN0ZXIuIFdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgY2hhcmFjdGVycyxcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICAgIFxuICAgICAgICBjaCA9IHRleHQuY2hhckF0KGF0KTtcbiAgICAgICAgYXQgKz0gMTtcbiAgICAgICAgcmV0dXJuIGNoO1xuICAgIH0sXG4gICAgXG4gICAgbnVtYmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQYXJzZSBhIG51bWJlciB2YWx1ZS5cbiAgICAgICAgdmFyIG51bWJlcixcbiAgICAgICAgICAgIHN0cmluZyA9ICcnO1xuICAgICAgICBcbiAgICAgICAgaWYgKGNoID09PSAnLScpIHtcbiAgICAgICAgICAgIHN0cmluZyA9ICctJztcbiAgICAgICAgICAgIG5leHQoJy0nKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gJy4nO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQoKSAmJiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG51bWJlciA9ICtzdHJpbmc7XG4gICAgICAgIGlmICghaXNGaW5pdGUobnVtYmVyKSkge1xuICAgICAgICAgICAgZXJyb3IoXCJCYWQgbnVtYmVyXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgc3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQYXJzZSBhIHN0cmluZyB2YWx1ZS5cbiAgICAgICAgdmFyIGhleCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBzdHJpbmcgPSAnJyxcbiAgICAgICAgICAgIHVmZmZmO1xuICAgICAgICBcbiAgICAgICAgLy8gV2hlbiBwYXJzaW5nIGZvciBzdHJpbmcgdmFsdWVzLCB3ZSBtdXN0IGxvb2sgZm9yIFwiIGFuZCBcXCBjaGFyYWN0ZXJzLlxuICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgIHdoaWxlIChuZXh0KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1ZmZmZiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGV4ID0gcGFyc2VJbnQobmV4dCgpLCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShoZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ZmZmZiA9IHVmZmZmICogMTYgKyBoZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1ZmZmZik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVzY2FwZWVbY2hdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGVzY2FwZWVbY2hdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiQmFkIHN0cmluZ1wiKTtcbiAgICB9LFxuXG4gICAgd2hpdGUgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFNraXAgd2hpdGVzcGFjZS5cblxuICAgICAgICB3aGlsZSAoY2ggJiYgY2ggPD0gJyAnKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgd29yZCA9IGZ1bmN0aW9uICgpIHtcblxuLy8gdHJ1ZSwgZmFsc2UsIG9yIG51bGwuXG5cbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgIG5leHQoJ3QnKTtcbiAgICAgICAgICAgIG5leHQoJ3InKTtcbiAgICAgICAgICAgIG5leHQoJ3UnKTtcbiAgICAgICAgICAgIG5leHQoJ2UnKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgIG5leHQoJ2YnKTtcbiAgICAgICAgICAgIG5leHQoJ2EnKTtcbiAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgIG5leHQoJ3MnKTtcbiAgICAgICAgICAgIG5leHQoJ2UnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICBuZXh0KCduJyk7XG4gICAgICAgICAgICBuZXh0KCd1Jyk7XG4gICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIlVuZXhwZWN0ZWQgJ1wiICsgY2ggKyBcIidcIik7XG4gICAgfSxcblxuICAgIHZhbHVlLCAgLy8gUGxhY2UgaG9sZGVyIGZvciB0aGUgdmFsdWUgZnVuY3Rpb24uXG5cbiAgICBhcnJheSA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYW4gYXJyYXkgdmFsdWUuXG5cbiAgICAgICAgdmFyIGFycmF5ID0gW107XG5cbiAgICAgICAgaWYgKGNoID09PSAnWycpIHtcbiAgICAgICAgICAgIG5leHQoJ1snKTtcbiAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgIG5leHQoJ10nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7ICAgLy8gZW1wdHkgYXJyYXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgIGFycmF5LnB1c2godmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCddJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCgnLCcpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IoXCJCYWQgYXJyYXlcIik7XG4gICAgfSxcblxuICAgIG9iamVjdCA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYW4gb2JqZWN0IHZhbHVlLlxuXG4gICAgICAgIHZhciBrZXksXG4gICAgICAgICAgICBvYmplY3QgPSB7fTtcblxuICAgICAgICBpZiAoY2ggPT09ICd7Jykge1xuICAgICAgICAgICAgbmV4dCgneycpO1xuICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgnfScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7ICAgLy8gZW1wdHkgb2JqZWN0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBzdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIG5leHQoJzonKTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKCdEdXBsaWNhdGUga2V5IFwiJyArIGtleSArICdcIicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlKCk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCd9Jyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQoJywnKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiQmFkIG9iamVjdFwiKTtcbiAgICB9O1xuXG52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYSBKU09OIHZhbHVlLiBJdCBjb3VsZCBiZSBhbiBvYmplY3QsIGFuIGFycmF5LCBhIHN0cmluZywgYSBudW1iZXIsXG4vLyBvciBhIHdvcmQuXG5cbiAgICB3aGl0ZSgpO1xuICAgIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlICd7JzpcbiAgICAgICAgcmV0dXJuIG9iamVjdCgpO1xuICAgIGNhc2UgJ1snOlxuICAgICAgICByZXR1cm4gYXJyYXkoKTtcbiAgICBjYXNlICdcIic6XG4gICAgICAgIHJldHVybiBzdHJpbmcoKTtcbiAgICBjYXNlICctJzpcbiAgICAgICAgcmV0dXJuIG51bWJlcigpO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknID8gbnVtYmVyKCkgOiB3b3JkKCk7XG4gICAgfVxufTtcblxuLy8gUmV0dXJuIHRoZSBqc29uX3BhcnNlIGZ1bmN0aW9uLiBJdCB3aWxsIGhhdmUgYWNjZXNzIHRvIGFsbCBvZiB0aGUgYWJvdmVcbi8vIGZ1bmN0aW9ucyBhbmQgdmFyaWFibGVzLlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzb3VyY2UsIHJldml2ZXIpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIFxuICAgIHRleHQgPSBzb3VyY2U7XG4gICAgYXQgPSAwO1xuICAgIGNoID0gJyAnO1xuICAgIHJlc3VsdCA9IHZhbHVlKCk7XG4gICAgd2hpdGUoKTtcbiAgICBpZiAoY2gpIHtcbiAgICAgICAgZXJyb3IoXCJTeW50YXggZXJyb3JcIik7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSByZXZpdmVyIGZ1bmN0aW9uLCB3ZSByZWN1cnNpdmVseSB3YWxrIHRoZSBuZXcgc3RydWN0dXJlLFxuICAgIC8vIHBhc3NpbmcgZWFjaCBuYW1lL3ZhbHVlIHBhaXIgdG8gdGhlIHJldml2ZXIgZnVuY3Rpb24gZm9yIHBvc3NpYmxlXG4gICAgLy8gdHJhbnNmb3JtYXRpb24sIHN0YXJ0aW5nIHdpdGggYSB0ZW1wb3Jhcnkgcm9vdCBvYmplY3QgdGhhdCBob2xkcyB0aGUgcmVzdWx0XG4gICAgLy8gaW4gYW4gZW1wdHkga2V5LiBJZiB0aGVyZSBpcyBub3QgYSByZXZpdmVyIGZ1bmN0aW9uLCB3ZSBzaW1wbHkgcmV0dXJuIHRoZVxuICAgIC8vIHJlc3VsdC5cblxuICAgIHJldHVybiB0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJyA/IChmdW5jdGlvbiB3YWxrKGhvbGRlciwga2V5KSB7XG4gICAgICAgIHZhciBrLCB2LCB2YWx1ZSA9IGhvbGRlcltrZXldO1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IHdhbGsodmFsdWUsIGspO1xuICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldml2ZXIuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgIH0oeycnOiByZXN1bHR9LCAnJykpIDogcmVzdWx0O1xufTtcbiIsInZhciBjeCA9IC9bXFx1MDAwMFxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgIGVzY2FwYWJsZSA9IC9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxceDlmXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAgZ2FwLFxuICAgIGluZGVudCxcbiAgICBtZXRhID0geyAgICAvLyB0YWJsZSBvZiBjaGFyYWN0ZXIgc3Vic3RpdHV0aW9uc1xuICAgICAgICAnXFxiJzogJ1xcXFxiJyxcbiAgICAgICAgJ1xcdCc6ICdcXFxcdCcsXG4gICAgICAgICdcXG4nOiAnXFxcXG4nLFxuICAgICAgICAnXFxmJzogJ1xcXFxmJyxcbiAgICAgICAgJ1xccic6ICdcXFxccicsXG4gICAgICAgICdcIicgOiAnXFxcXFwiJyxcbiAgICAgICAgJ1xcXFwnOiAnXFxcXFxcXFwnXG4gICAgfSxcbiAgICByZXA7XG5cbmZ1bmN0aW9uIHF1b3RlKHN0cmluZykge1xuICAgIC8vIElmIHRoZSBzdHJpbmcgY29udGFpbnMgbm8gY29udHJvbCBjaGFyYWN0ZXJzLCBubyBxdW90ZSBjaGFyYWN0ZXJzLCBhbmQgbm9cbiAgICAvLyBiYWNrc2xhc2ggY2hhcmFjdGVycywgdGhlbiB3ZSBjYW4gc2FmZWx5IHNsYXAgc29tZSBxdW90ZXMgYXJvdW5kIGl0LlxuICAgIC8vIE90aGVyd2lzZSB3ZSBtdXN0IGFsc28gcmVwbGFjZSB0aGUgb2ZmZW5kaW5nIGNoYXJhY3RlcnMgd2l0aCBzYWZlIGVzY2FwZVxuICAgIC8vIHNlcXVlbmNlcy5cbiAgICBcbiAgICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKSA/ICdcIicgKyBzdHJpbmcucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBjID0gbWV0YVthXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSAnc3RyaW5nJyA/IGMgOlxuICAgICAgICAgICAgJ1xcXFx1JyArICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgfSkgKyAnXCInIDogJ1wiJyArIHN0cmluZyArICdcIic7XG59XG5cbmZ1bmN0aW9uIHN0cihrZXksIGhvbGRlcikge1xuICAgIC8vIFByb2R1Y2UgYSBzdHJpbmcgZnJvbSBob2xkZXJba2V5XS5cbiAgICB2YXIgaSwgICAgICAgICAgLy8gVGhlIGxvb3AgY291bnRlci5cbiAgICAgICAgaywgICAgICAgICAgLy8gVGhlIG1lbWJlciBrZXkuXG4gICAgICAgIHYsICAgICAgICAgIC8vIFRoZSBtZW1iZXIgdmFsdWUuXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgbWluZCA9IGdhcCxcbiAgICAgICAgcGFydGlhbCxcbiAgICAgICAgdmFsdWUgPSBob2xkZXJba2V5XTtcbiAgICBcbiAgICAvLyBJZiB0aGUgdmFsdWUgaGFzIGEgdG9KU09OIG1ldGhvZCwgY2FsbCBpdCB0byBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiB3ZSB3ZXJlIGNhbGxlZCB3aXRoIGEgcmVwbGFjZXIgZnVuY3Rpb24sIHRoZW4gY2FsbCB0aGUgcmVwbGFjZXIgdG9cbiAgICAvLyBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cbiAgICBpZiAodHlwZW9mIHJlcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IHJlcC5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFdoYXQgaGFwcGVucyBuZXh0IGRlcGVuZHMgb24gdGhlIHZhbHVlJ3MgdHlwZS5cbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlKHZhbHVlKTtcbiAgICAgICAgXG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIEVuY29kZSBub24tZmluaXRlIG51bWJlcnMgYXMgbnVsbC5cbiAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogJ251bGwnO1xuICAgICAgICBcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiBvciBudWxsLCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLiBOb3RlOlxuICAgICAgICAgICAgLy8gdHlwZW9mIG51bGwgZG9lcyBub3QgcHJvZHVjZSAnbnVsbCcuIFRoZSBjYXNlIGlzIGluY2x1ZGVkIGhlcmUgaW5cbiAgICAgICAgICAgIC8vIHRoZSByZW1vdGUgY2hhbmNlIHRoYXQgdGhpcyBnZXRzIGZpeGVkIHNvbWVkYXkuXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIFxuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuICdudWxsJztcbiAgICAgICAgICAgIGdhcCArPSBpbmRlbnQ7XG4gICAgICAgICAgICBwYXJ0aWFsID0gW107XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFycmF5LmlzQXJyYXlcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbFtpXSA9IHN0cihpLCB2YWx1ZSkgfHwgJ251bGwnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBKb2luIGFsbCBvZiB0aGUgZWxlbWVudHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcywgYW5kXG4gICAgICAgICAgICAgICAgLy8gd3JhcCB0aGVtIGluIGJyYWNrZXRzLlxuICAgICAgICAgICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICdbXScgOiBnYXAgP1xuICAgICAgICAgICAgICAgICAgICAnW1xcbicgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oJyxcXG4nICsgZ2FwKSArICdcXG4nICsgbWluZCArICddJyA6XG4gICAgICAgICAgICAgICAgICAgICdbJyArIHBhcnRpYWwuam9pbignLCcpICsgJ10nO1xuICAgICAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIElmIHRoZSByZXBsYWNlciBpcyBhbiBhcnJheSwgdXNlIGl0IHRvIHNlbGVjdCB0aGUgbWVtYmVycyB0byBiZVxuICAgICAgICAgICAgLy8gc3RyaW5naWZpZWQuXG4gICAgICAgICAgICBpZiAocmVwICYmIHR5cGVvZiByZXAgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gcmVwLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgayA9IHJlcFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBrZXlzIGluIHRoZSBvYmplY3QuXG4gICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKGdhcCA/ICc6ICcgOiAnOicpICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgLy8gSm9pbiBhbGwgb2YgdGhlIG1lbWJlciB0ZXh0cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLFxuICAgICAgICAvLyBhbmQgd3JhcCB0aGVtIGluIGJyYWNlcy5cblxuICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAne30nIDogZ2FwID9cbiAgICAgICAgICAgICd7XFxuJyArIGdhcCArIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgKyBtaW5kICsgJ30nIDpcbiAgICAgICAgICAgICd7JyArIHBhcnRpYWwuam9pbignLCcpICsgJ30nO1xuICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcbiAgICB2YXIgaTtcbiAgICBnYXAgPSAnJztcbiAgICBpbmRlbnQgPSAnJztcbiAgICBcbiAgICAvLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbnVtYmVyLCBtYWtlIGFuIGluZGVudCBzdHJpbmcgY29udGFpbmluZyB0aGF0XG4gICAgLy8gbWFueSBzcGFjZXMuXG4gICAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYWNlOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGluZGVudCArPSAnICc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbmRlbnQgc3RyaW5nLlxuICAgIGVsc2UgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaW5kZW50ID0gc3BhY2U7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSByZXBsYWNlciwgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIGFycmF5LlxuICAgIC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3IuXG4gICAgcmVwID0gcmVwbGFjZXI7XG4gICAgaWYgKHJlcGxhY2VyICYmIHR5cGVvZiByZXBsYWNlciAhPT0gJ2Z1bmN0aW9uJ1xuICAgICYmICh0eXBlb2YgcmVwbGFjZXIgIT09ICdvYmplY3QnIHx8IHR5cGVvZiByZXBsYWNlci5sZW5ndGggIT09ICdudW1iZXInKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pTT04uc3RyaW5naWZ5Jyk7XG4gICAgfVxuICAgIFxuICAgIC8vIE1ha2UgYSBmYWtlIHJvb3Qgb2JqZWN0IGNvbnRhaW5pbmcgb3VyIHZhbHVlIHVuZGVyIHRoZSBrZXkgb2YgJycuXG4gICAgLy8gUmV0dXJuIHRoZSByZXN1bHQgb2Ygc3RyaW5naWZ5aW5nIHRoZSB2YWx1ZS5cbiAgICByZXR1cm4gc3RyKCcnLCB7Jyc6IHZhbHVlfSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBtaW5pbWF0Y2hcbm1pbmltYXRjaC5NaW5pbWF0Y2ggPSBNaW5pbWF0Y2hcblxudmFyIHBhdGggPSB7IHNlcDogJy8nIH1cbnRyeSB7XG4gIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbn0gY2F0Y2ggKGVyKSB7fVxuXG52YXIgR0xPQlNUQVIgPSBtaW5pbWF0Y2guR0xPQlNUQVIgPSBNaW5pbWF0Y2guR0xPQlNUQVIgPSB7fVxudmFyIGV4cGFuZCA9IHJlcXVpcmUoJ2JyYWNlLWV4cGFuc2lvbicpXG5cbnZhciBwbFR5cGVzID0ge1xuICAnISc6IHsgb3BlbjogJyg/Oig/ISg/OicsIGNsb3NlOiAnKSlbXi9dKj8pJ30sXG4gICc/JzogeyBvcGVuOiAnKD86JywgY2xvc2U6ICcpPycgfSxcbiAgJysnOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJykrJyB9LFxuICAnKic6IHsgb3BlbjogJyg/OicsIGNsb3NlOiAnKSonIH0sXG4gICdAJzogeyBvcGVuOiAnKD86JywgY2xvc2U6ICcpJyB9XG59XG5cbi8vIGFueSBzaW5nbGUgdGhpbmcgb3RoZXIgdGhhbiAvXG4vLyBkb24ndCBuZWVkIHRvIGVzY2FwZSAvIHdoZW4gdXNpbmcgbmV3IFJlZ0V4cCgpXG52YXIgcW1hcmsgPSAnW14vXSdcblxuLy8gKiA9PiBhbnkgbnVtYmVyIG9mIGNoYXJhY3RlcnNcbnZhciBzdGFyID0gcW1hcmsgKyAnKj8nXG5cbi8vICoqIHdoZW4gZG90cyBhcmUgYWxsb3dlZC4gIEFueXRoaW5nIGdvZXMsIGV4Y2VwdCAuLiBhbmQgLlxuLy8gbm90ICheIG9yIC8gZm9sbG93ZWQgYnkgb25lIG9yIHR3byBkb3RzIGZvbGxvd2VkIGJ5ICQgb3IgLyksXG4vLyBmb2xsb3dlZCBieSBhbnl0aGluZywgYW55IG51bWJlciBvZiB0aW1lcy5cbnZhciB0d29TdGFyRG90ID0gJyg/Oig/ISg/OlxcXFxcXC98XikoPzpcXFxcLnsxLDJ9KSgkfFxcXFxcXC8pKS4pKj8nXG5cbi8vIG5vdCBhIF4gb3IgLyBmb2xsb3dlZCBieSBhIGRvdCxcbi8vIGZvbGxvd2VkIGJ5IGFueXRoaW5nLCBhbnkgbnVtYmVyIG9mIHRpbWVzLlxudmFyIHR3b1N0YXJOb0RvdCA9ICcoPzooPyEoPzpcXFxcXFwvfF4pXFxcXC4pLikqPydcblxuLy8gY2hhcmFjdGVycyB0aGF0IG5lZWQgdG8gYmUgZXNjYXBlZCBpbiBSZWdFeHAuXG52YXIgcmVTcGVjaWFscyA9IGNoYXJTZXQoJygpLip7fSs/W11eJFxcXFwhJylcblxuLy8gXCJhYmNcIiAtPiB7IGE6dHJ1ZSwgYjp0cnVlLCBjOnRydWUgfVxuZnVuY3Rpb24gY2hhclNldCAocykge1xuICByZXR1cm4gcy5zcGxpdCgnJykucmVkdWNlKGZ1bmN0aW9uIChzZXQsIGMpIHtcbiAgICBzZXRbY10gPSB0cnVlXG4gICAgcmV0dXJuIHNldFxuICB9LCB7fSlcbn1cblxuLy8gbm9ybWFsaXplcyBzbGFzaGVzLlxudmFyIHNsYXNoU3BsaXQgPSAvXFwvKy9cblxubWluaW1hdGNoLmZpbHRlciA9IGZpbHRlclxuZnVuY3Rpb24gZmlsdGVyIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHJldHVybiBmdW5jdGlvbiAocCwgaSwgbGlzdCkge1xuICAgIHJldHVybiBtaW5pbWF0Y2gocCwgcGF0dGVybiwgb3B0aW9ucylcbiAgfVxufVxuXG5mdW5jdGlvbiBleHQgKGEsIGIpIHtcbiAgYSA9IGEgfHwge31cbiAgYiA9IGIgfHwge31cbiAgdmFyIHQgPSB7fVxuICBPYmplY3Qua2V5cyhiKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgdFtrXSA9IGJba11cbiAgfSlcbiAgT2JqZWN0LmtleXMoYSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIHRba10gPSBhW2tdXG4gIH0pXG4gIHJldHVybiB0XG59XG5cbm1pbmltYXRjaC5kZWZhdWx0cyA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgaWYgKCFkZWYgfHwgIU9iamVjdC5rZXlzKGRlZikubGVuZ3RoKSByZXR1cm4gbWluaW1hdGNoXG5cbiAgdmFyIG9yaWcgPSBtaW5pbWF0Y2hcblxuICB2YXIgbSA9IGZ1bmN0aW9uIG1pbmltYXRjaCAocCwgcGF0dGVybiwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcmlnLm1pbmltYXRjaChwLCBwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSlcbiAgfVxuXG4gIG0uTWluaW1hdGNoID0gZnVuY3Rpb24gTWluaW1hdGNoIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBvcmlnLk1pbmltYXRjaChwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSlcbiAgfVxuXG4gIHJldHVybiBtXG59XG5cbk1pbmltYXRjaC5kZWZhdWx0cyA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgaWYgKCFkZWYgfHwgIU9iamVjdC5rZXlzKGRlZikubGVuZ3RoKSByZXR1cm4gTWluaW1hdGNoXG4gIHJldHVybiBtaW5pbWF0Y2guZGVmYXVsdHMoZGVmKS5NaW5pbWF0Y2hcbn1cblxuZnVuY3Rpb24gbWluaW1hdGNoIChwLCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdnbG9iIHBhdHRlcm4gc3RyaW5nIHJlcXVpcmVkJylcbiAgfVxuXG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9XG5cbiAgLy8gc2hvcnRjdXQ6IGNvbW1lbnRzIG1hdGNoIG5vdGhpbmcuXG4gIGlmICghb3B0aW9ucy5ub2NvbW1lbnQgJiYgcGF0dGVybi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gXCJcIiBvbmx5IG1hdGNoZXMgXCJcIlxuICBpZiAocGF0dGVybi50cmltKCkgPT09ICcnKSByZXR1cm4gcCA9PT0gJydcblxuICByZXR1cm4gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKS5tYXRjaChwKVxufVxuXG5mdW5jdGlvbiBNaW5pbWF0Y2ggKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1pbmltYXRjaCkpIHtcbiAgICByZXR1cm4gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dsb2IgcGF0dGVybiBzdHJpbmcgcmVxdWlyZWQnKVxuICB9XG5cbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge31cbiAgcGF0dGVybiA9IHBhdHRlcm4udHJpbSgpXG5cbiAgLy8gd2luZG93cyBzdXBwb3J0OiBuZWVkIHRvIHVzZSAvLCBub3QgXFxcbiAgaWYgKHBhdGguc2VwICE9PSAnLycpIHtcbiAgICBwYXR0ZXJuID0gcGF0dGVybi5zcGxpdChwYXRoLnNlcCkuam9pbignLycpXG4gIH1cblxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gIHRoaXMuc2V0ID0gW11cbiAgdGhpcy5wYXR0ZXJuID0gcGF0dGVyblxuICB0aGlzLnJlZ2V4cCA9IG51bGxcbiAgdGhpcy5uZWdhdGUgPSBmYWxzZVxuICB0aGlzLmNvbW1lbnQgPSBmYWxzZVxuICB0aGlzLmVtcHR5ID0gZmFsc2VcblxuICAvLyBtYWtlIHRoZSBzZXQgb2YgcmVnZXhwcyBldGMuXG4gIHRoaXMubWFrZSgpXG59XG5cbk1pbmltYXRjaC5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAoKSB7fVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLm1ha2UgPSBtYWtlXG5mdW5jdGlvbiBtYWtlICgpIHtcbiAgLy8gZG9uJ3QgZG8gaXQgbW9yZSB0aGFuIG9uY2UuXG4gIGlmICh0aGlzLl9tYWRlKSByZXR1cm5cblxuICB2YXIgcGF0dGVybiA9IHRoaXMucGF0dGVyblxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gIC8vIGVtcHR5IHBhdHRlcm5zIGFuZCBjb21tZW50cyBtYXRjaCBub3RoaW5nLlxuICBpZiAoIW9wdGlvbnMubm9jb21tZW50ICYmIHBhdHRlcm4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICB0aGlzLmNvbW1lbnQgPSB0cnVlXG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFwYXR0ZXJuKSB7XG4gICAgdGhpcy5lbXB0eSA9IHRydWVcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIHN0ZXAgMTogZmlndXJlIG91dCBuZWdhdGlvbiwgZXRjLlxuICB0aGlzLnBhcnNlTmVnYXRlKClcblxuICAvLyBzdGVwIDI6IGV4cGFuZCBicmFjZXNcbiAgdmFyIHNldCA9IHRoaXMuZ2xvYlNldCA9IHRoaXMuYnJhY2VFeHBhbmQoKVxuXG4gIGlmIChvcHRpb25zLmRlYnVnKSB0aGlzLmRlYnVnID0gY29uc29sZS5lcnJvclxuXG4gIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCBzZXQpXG5cbiAgLy8gc3RlcCAzOiBub3cgd2UgaGF2ZSBhIHNldCwgc28gdHVybiBlYWNoIG9uZSBpbnRvIGEgc2VyaWVzIG9mIHBhdGgtcG9ydGlvblxuICAvLyBtYXRjaGluZyBwYXR0ZXJucy5cbiAgLy8gVGhlc2Ugd2lsbCBiZSByZWdleHBzLCBleGNlcHQgaW4gdGhlIGNhc2Ugb2YgXCIqKlwiLCB3aGljaCBpc1xuICAvLyBzZXQgdG8gdGhlIEdMT0JTVEFSIG9iamVjdCBmb3IgZ2xvYnN0YXIgYmVoYXZpb3IsXG4gIC8vIGFuZCB3aWxsIG5vdCBjb250YWluIGFueSAvIGNoYXJhY3RlcnNcbiAgc2V0ID0gdGhpcy5nbG9iUGFydHMgPSBzZXQubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHMuc3BsaXQoc2xhc2hTcGxpdClcbiAgfSlcblxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KVxuXG4gIC8vIGdsb2IgLS0+IHJlZ2V4cHNcbiAgc2V0ID0gc2V0Lm1hcChmdW5jdGlvbiAocywgc2ksIHNldCkge1xuICAgIHJldHVybiBzLm1hcCh0aGlzLnBhcnNlLCB0aGlzKVxuICB9LCB0aGlzKVxuXG4gIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCBzZXQpXG5cbiAgLy8gZmlsdGVyIG91dCBldmVyeXRoaW5nIHRoYXQgZGlkbid0IGNvbXBpbGUgcHJvcGVybHkuXG4gIHNldCA9IHNldC5maWx0ZXIoZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gcy5pbmRleE9mKGZhbHNlKSA9PT0gLTFcbiAgfSlcblxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KVxuXG4gIHRoaXMuc2V0ID0gc2V0XG59XG5cbk1pbmltYXRjaC5wcm90b3R5cGUucGFyc2VOZWdhdGUgPSBwYXJzZU5lZ2F0ZVxuZnVuY3Rpb24gcGFyc2VOZWdhdGUgKCkge1xuICB2YXIgcGF0dGVybiA9IHRoaXMucGF0dGVyblxuICB2YXIgbmVnYXRlID0gZmFsc2VcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcbiAgdmFyIG5lZ2F0ZU9mZnNldCA9IDBcblxuICBpZiAob3B0aW9ucy5ub25lZ2F0ZSkgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXR0ZXJuLmxlbmd0aFxuICAgIDsgaSA8IGwgJiYgcGF0dGVybi5jaGFyQXQoaSkgPT09ICchJ1xuICAgIDsgaSsrKSB7XG4gICAgbmVnYXRlID0gIW5lZ2F0ZVxuICAgIG5lZ2F0ZU9mZnNldCsrXG4gIH1cblxuICBpZiAobmVnYXRlT2Zmc2V0KSB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuLnN1YnN0cihuZWdhdGVPZmZzZXQpXG4gIHRoaXMubmVnYXRlID0gbmVnYXRlXG59XG5cbi8vIEJyYWNlIGV4cGFuc2lvbjpcbi8vIGF7YixjfWQgLT4gYWJkIGFjZFxuLy8gYXtiLH1jIC0+IGFiYyBhY1xuLy8gYXswLi4zfWQgLT4gYTBkIGExZCBhMmQgYTNkXG4vLyBhe2IsY3tkLGV9Zn1nIC0+IGFiZyBhY2RmZyBhY2VmZ1xuLy8gYXtiLGN9ZHtlLGZ9ZyAtPiBhYmRlZyBhY2RlZyBhYmRlZyBhYmRmZ1xuLy9cbi8vIEludmFsaWQgc2V0cyBhcmUgbm90IGV4cGFuZGVkLlxuLy8gYXsyLi59YiAtPiBhezIuLn1iXG4vLyBhe2J9YyAtPiBhe2J9Y1xubWluaW1hdGNoLmJyYWNlRXhwYW5kID0gZnVuY3Rpb24gKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGJyYWNlRXhwYW5kKHBhdHRlcm4sIG9wdGlvbnMpXG59XG5cbk1pbmltYXRjaC5wcm90b3R5cGUuYnJhY2VFeHBhbmQgPSBicmFjZUV4cGFuZFxuXG5mdW5jdGlvbiBicmFjZUV4cGFuZCAocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIE1pbmltYXRjaCkge1xuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG4gIH1cblxuICBwYXR0ZXJuID0gdHlwZW9mIHBhdHRlcm4gPT09ICd1bmRlZmluZWQnXG4gICAgPyB0aGlzLnBhdHRlcm4gOiBwYXR0ZXJuXG5cbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VuZGVmaW5lZCBwYXR0ZXJuJylcbiAgfVxuXG4gIGlmIChvcHRpb25zLm5vYnJhY2UgfHxcbiAgICAhcGF0dGVybi5tYXRjaCgvXFx7LipcXH0vKSkge1xuICAgIC8vIHNob3J0Y3V0LiBubyBuZWVkIHRvIGV4cGFuZC5cbiAgICByZXR1cm4gW3BhdHRlcm5dXG4gIH1cblxuICByZXR1cm4gZXhwYW5kKHBhdHRlcm4pXG59XG5cbi8vIHBhcnNlIGEgY29tcG9uZW50IG9mIHRoZSBleHBhbmRlZCBzZXQuXG4vLyBBdCB0aGlzIHBvaW50LCBubyBwYXR0ZXJuIG1heSBjb250YWluIFwiL1wiIGluIGl0XG4vLyBzbyB3ZSdyZSBnb2luZyB0byByZXR1cm4gYSAyZCBhcnJheSwgd2hlcmUgZWFjaCBlbnRyeSBpcyB0aGUgZnVsbFxuLy8gcGF0dGVybiwgc3BsaXQgb24gJy8nLCBhbmQgdGhlbiB0dXJuZWQgaW50byBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbi8vIEEgcmVnZXhwIGlzIG1hZGUgYXQgdGhlIGVuZCB3aGljaCBqb2lucyBlYWNoIGFycmF5IHdpdGggYW5cbi8vIGVzY2FwZWQgLywgYW5kIGFub3RoZXIgZnVsbCBvbmUgd2hpY2ggam9pbnMgZWFjaCByZWdleHAgd2l0aCB8LlxuLy9cbi8vIEZvbGxvd2luZyB0aGUgbGVhZCBvZiBCYXNoIDQuMSwgbm90ZSB0aGF0IFwiKipcIiBvbmx5IGhhcyBzcGVjaWFsIG1lYW5pbmdcbi8vIHdoZW4gaXQgaXMgdGhlICpvbmx5KiB0aGluZyBpbiBhIHBhdGggcG9ydGlvbi4gIE90aGVyd2lzZSwgYW55IHNlcmllc1xuLy8gb2YgKiBpcyBlcXVpdmFsZW50IHRvIGEgc2luZ2xlICouICBHbG9ic3RhciBiZWhhdmlvciBpcyBlbmFibGVkIGJ5XG4vLyBkZWZhdWx0LCBhbmQgY2FuIGJlIGRpc2FibGVkIGJ5IHNldHRpbmcgb3B0aW9ucy5ub2dsb2JzdGFyLlxuTWluaW1hdGNoLnByb3RvdHlwZS5wYXJzZSA9IHBhcnNlXG52YXIgU1VCUEFSU0UgPSB7fVxuZnVuY3Rpb24gcGFyc2UgKHBhdHRlcm4sIGlzU3ViKSB7XG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+IDEwMjQgKiA2NCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhdHRlcm4gaXMgdG9vIGxvbmcnKVxuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblxuICAvLyBzaG9ydGN1dHNcbiAgaWYgKCFvcHRpb25zLm5vZ2xvYnN0YXIgJiYgcGF0dGVybiA9PT0gJyoqJykgcmV0dXJuIEdMT0JTVEFSXG4gIGlmIChwYXR0ZXJuID09PSAnJykgcmV0dXJuICcnXG5cbiAgdmFyIHJlID0gJydcbiAgdmFyIGhhc01hZ2ljID0gISFvcHRpb25zLm5vY2FzZVxuICB2YXIgZXNjYXBpbmcgPSBmYWxzZVxuICAvLyA/ID0+IG9uZSBzaW5nbGUgY2hhcmFjdGVyXG4gIHZhciBwYXR0ZXJuTGlzdFN0YWNrID0gW11cbiAgdmFyIG5lZ2F0aXZlTGlzdHMgPSBbXVxuICB2YXIgc3RhdGVDaGFyXG4gIHZhciBpbkNsYXNzID0gZmFsc2VcbiAgdmFyIHJlQ2xhc3NTdGFydCA9IC0xXG4gIHZhciBjbGFzc1N0YXJ0ID0gLTFcbiAgLy8gLiBhbmQgLi4gbmV2ZXIgbWF0Y2ggYW55dGhpbmcgdGhhdCBkb2Vzbid0IHN0YXJ0IHdpdGggLixcbiAgLy8gZXZlbiB3aGVuIG9wdGlvbnMuZG90IGlzIHNldC5cbiAgdmFyIHBhdHRlcm5TdGFydCA9IHBhdHRlcm4uY2hhckF0KDApID09PSAnLicgPyAnJyAvLyBhbnl0aGluZ1xuICAvLyBub3QgKHN0YXJ0IG9yIC8gZm9sbG93ZWQgYnkgLiBvciAuLiBmb2xsb3dlZCBieSAvIG9yIGVuZClcbiAgOiBvcHRpb25zLmRvdCA/ICcoPyEoPzpefFxcXFxcXC8pXFxcXC57MSwyfSg/OiR8XFxcXFxcLykpJ1xuICA6ICcoPyFcXFxcLiknXG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGZ1bmN0aW9uIGNsZWFyU3RhdGVDaGFyICgpIHtcbiAgICBpZiAoc3RhdGVDaGFyKSB7XG4gICAgICAvLyB3ZSBoYWQgc29tZSBzdGF0ZS10cmFja2luZyBjaGFyYWN0ZXJcbiAgICAgIC8vIHRoYXQgd2Fzbid0IGNvbnN1bWVkIGJ5IHRoaXMgcGFzcy5cbiAgICAgIHN3aXRjaCAoc3RhdGVDaGFyKSB7XG4gICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgIHJlICs9IHN0YXJcbiAgICAgICAgICBoYXNNYWdpYyA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnPyc6XG4gICAgICAgICAgcmUgKz0gcW1hcmtcbiAgICAgICAgICBoYXNNYWdpYyA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZSArPSAnXFxcXCcgKyBzdGF0ZUNoYXJcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHNlbGYuZGVidWcoJ2NsZWFyU3RhdGVDaGFyICVqICVqJywgc3RhdGVDaGFyLCByZSlcbiAgICAgIHN0YXRlQ2hhciA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhdHRlcm4ubGVuZ3RoLCBjXG4gICAgOyAoaSA8IGxlbikgJiYgKGMgPSBwYXR0ZXJuLmNoYXJBdChpKSlcbiAgICA7IGkrKykge1xuICAgIHRoaXMuZGVidWcoJyVzXFx0JXMgJXMgJWonLCBwYXR0ZXJuLCBpLCByZSwgYylcblxuICAgIC8vIHNraXAgb3ZlciBhbnkgdGhhdCBhcmUgZXNjYXBlZC5cbiAgICBpZiAoZXNjYXBpbmcgJiYgcmVTcGVjaWFsc1tjXSkge1xuICAgICAgcmUgKz0gJ1xcXFwnICsgY1xuICAgICAgZXNjYXBpbmcgPSBmYWxzZVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGMpIHtcbiAgICAgIGNhc2UgJy8nOlxuICAgICAgICAvLyBjb21wbGV0ZWx5IG5vdCBhbGxvd2VkLCBldmVuIGVzY2FwZWQuXG4gICAgICAgIC8vIFNob3VsZCBhbHJlYWR5IGJlIHBhdGgtc3BsaXQgYnkgbm93LlxuICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgICAgZXNjYXBpbmcgPSB0cnVlXG4gICAgICBjb250aW51ZVxuXG4gICAgICAvLyB0aGUgdmFyaW91cyBzdGF0ZUNoYXIgdmFsdWVzXG4gICAgICAvLyBmb3IgdGhlIFwiZXh0Z2xvYlwiIHN0dWZmLlxuICAgICAgY2FzZSAnPyc6XG4gICAgICBjYXNlICcqJzpcbiAgICAgIGNhc2UgJysnOlxuICAgICAgY2FzZSAnQCc6XG4gICAgICBjYXNlICchJzpcbiAgICAgICAgdGhpcy5kZWJ1ZygnJXNcXHQlcyAlcyAlaiA8LS0gc3RhdGVDaGFyJywgcGF0dGVybiwgaSwgcmUsIGMpXG5cbiAgICAgICAgLy8gYWxsIG9mIHRob3NlIGFyZSBsaXRlcmFscyBpbnNpZGUgYSBjbGFzcywgZXhjZXB0IHRoYXRcbiAgICAgICAgLy8gdGhlIGdsb2IgWyFhXSBtZWFucyBbXmFdIGluIHJlZ2V4cFxuICAgICAgICBpZiAoaW5DbGFzcykge1xuICAgICAgICAgIHRoaXMuZGVidWcoJyAgaW4gY2xhc3MnKVxuICAgICAgICAgIGlmIChjID09PSAnIScgJiYgaSA9PT0gY2xhc3NTdGFydCArIDEpIGMgPSAnXidcbiAgICAgICAgICByZSArPSBjXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIGFscmVhZHkgaGF2ZSBhIHN0YXRlQ2hhciwgdGhlbiBpdCBtZWFuc1xuICAgICAgICAvLyB0aGF0IHRoZXJlIHdhcyBzb21ldGhpbmcgbGlrZSAqKiBvciArPyBpbiB0aGVyZS5cbiAgICAgICAgLy8gSGFuZGxlIHRoZSBzdGF0ZUNoYXIsIHRoZW4gcHJvY2VlZCB3aXRoIHRoaXMgb25lLlxuICAgICAgICBzZWxmLmRlYnVnKCdjYWxsIGNsZWFyU3RhdGVDaGFyICVqJywgc3RhdGVDaGFyKVxuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG4gICAgICAgIHN0YXRlQ2hhciA9IGNcbiAgICAgICAgLy8gaWYgZXh0Z2xvYiBpcyBkaXNhYmxlZCwgdGhlbiArKGFzZGZ8Zm9vKSBpc24ndCBhIHRoaW5nLlxuICAgICAgICAvLyBqdXN0IGNsZWFyIHRoZSBzdGF0ZWNoYXIgKm5vdyosIHJhdGhlciB0aGFuIGV2ZW4gZGl2aW5nIGludG9cbiAgICAgICAgLy8gdGhlIHBhdHRlcm5MaXN0IHN0dWZmLlxuICAgICAgICBpZiAob3B0aW9ucy5ub2V4dCkgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgY29udGludWVcblxuICAgICAgY2FzZSAnKCc6XG4gICAgICAgIGlmIChpbkNsYXNzKSB7XG4gICAgICAgICAgcmUgKz0gJygnXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc3RhdGVDaGFyKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFwoJ1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBwYXR0ZXJuTGlzdFN0YWNrLnB1c2goe1xuICAgICAgICAgIHR5cGU6IHN0YXRlQ2hhcixcbiAgICAgICAgICBzdGFydDogaSAtIDEsXG4gICAgICAgICAgcmVTdGFydDogcmUubGVuZ3RoLFxuICAgICAgICAgIG9wZW46IHBsVHlwZXNbc3RhdGVDaGFyXS5vcGVuLFxuICAgICAgICAgIGNsb3NlOiBwbFR5cGVzW3N0YXRlQ2hhcl0uY2xvc2VcbiAgICAgICAgfSlcbiAgICAgICAgLy8gbmVnYXRpb24gaXMgKD86KD8hanMpW14vXSopXG4gICAgICAgIHJlICs9IHN0YXRlQ2hhciA9PT0gJyEnID8gJyg/Oig/ISg/OicgOiAnKD86J1xuICAgICAgICB0aGlzLmRlYnVnKCdwbFR5cGUgJWogJWonLCBzdGF0ZUNoYXIsIHJlKVxuICAgICAgICBzdGF0ZUNoYXIgPSBmYWxzZVxuICAgICAgY29udGludWVcblxuICAgICAgY2FzZSAnKSc6XG4gICAgICAgIGlmIChpbkNsYXNzIHx8ICFwYXR0ZXJuTGlzdFN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgIHJlICs9ICdcXFxcKSdcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgICBoYXNNYWdpYyA9IHRydWVcbiAgICAgICAgdmFyIHBsID0gcGF0dGVybkxpc3RTdGFjay5wb3AoKVxuICAgICAgICAvLyBuZWdhdGlvbiBpcyAoPzooPyFqcylbXi9dKilcbiAgICAgICAgLy8gVGhlIG90aGVycyBhcmUgKD86PHBhdHRlcm4+KTx0eXBlPlxuICAgICAgICByZSArPSBwbC5jbG9zZVxuICAgICAgICBpZiAocGwudHlwZSA9PT0gJyEnKSB7XG4gICAgICAgICAgbmVnYXRpdmVMaXN0cy5wdXNoKHBsKVxuICAgICAgICB9XG4gICAgICAgIHBsLnJlRW5kID0gcmUubGVuZ3RoXG4gICAgICBjb250aW51ZVxuXG4gICAgICBjYXNlICd8JzpcbiAgICAgICAgaWYgKGluQ2xhc3MgfHwgIXBhdHRlcm5MaXN0U3RhY2subGVuZ3RoIHx8IGVzY2FwaW5nKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFx8J1xuICAgICAgICAgIGVzY2FwaW5nID0gZmFsc2VcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgICByZSArPSAnfCdcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIC8vIHRoZXNlIGFyZSBtb3N0bHkgdGhlIHNhbWUgaW4gcmVnZXhwIGFuZCBnbG9iXG4gICAgICBjYXNlICdbJzpcbiAgICAgICAgLy8gc3dhbGxvdyBhbnkgc3RhdGUtdHJhY2tpbmcgY2hhciBiZWZvcmUgdGhlIFtcbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuXG4gICAgICAgIGlmIChpbkNsYXNzKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFwnICsgY1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBpbkNsYXNzID0gdHJ1ZVxuICAgICAgICBjbGFzc1N0YXJ0ID0gaVxuICAgICAgICByZUNsYXNzU3RhcnQgPSByZS5sZW5ndGhcbiAgICAgICAgcmUgKz0gY1xuICAgICAgY29udGludWVcblxuICAgICAgY2FzZSAnXSc6XG4gICAgICAgIC8vICBhIHJpZ2h0IGJyYWNrZXQgc2hhbGwgbG9zZSBpdHMgc3BlY2lhbFxuICAgICAgICAvLyAgbWVhbmluZyBhbmQgcmVwcmVzZW50IGl0c2VsZiBpblxuICAgICAgICAvLyAgYSBicmFja2V0IGV4cHJlc3Npb24gaWYgaXQgb2NjdXJzXG4gICAgICAgIC8vICBmaXJzdCBpbiB0aGUgbGlzdC4gIC0tIFBPU0lYLjIgMi44LjMuMlxuICAgICAgICBpZiAoaSA9PT0gY2xhc3NTdGFydCArIDEgfHwgIWluQ2xhc3MpIHtcbiAgICAgICAgICByZSArPSAnXFxcXCcgKyBjXG4gICAgICAgICAgZXNjYXBpbmcgPSBmYWxzZVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgbGVmdCBhIGNsYXNzIG9wZW4uXG4gICAgICAgIC8vIFwiW3otYV1cIiBpcyB2YWxpZCwgZXF1aXZhbGVudCB0byBcIlxcW3otYVxcXVwiXG4gICAgICAgIGlmIChpbkNsYXNzKSB7XG4gICAgICAgICAgLy8gc3BsaXQgd2hlcmUgdGhlIGxhc3QgWyB3YXMsIG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlXG4gICAgICAgICAgLy8gYW4gaW52YWxpZCByZS4gaWYgc28sIHJlLXdhbGsgdGhlIGNvbnRlbnRzIG9mIHRoZVxuICAgICAgICAgIC8vIHdvdWxkLWJlIGNsYXNzIHRvIHJlLXRyYW5zbGF0ZSBhbnkgY2hhcmFjdGVycyB0aGF0XG4gICAgICAgICAgLy8gd2VyZSBwYXNzZWQgdGhyb3VnaCBhcy1pc1xuICAgICAgICAgIC8vIFRPRE86IEl0IHdvdWxkIHByb2JhYmx5IGJlIGZhc3RlciB0byBkZXRlcm1pbmUgdGhpc1xuICAgICAgICAgIC8vIHdpdGhvdXQgYSB0cnkvY2F0Y2ggYW5kIGEgbmV3IFJlZ0V4cCwgYnV0IGl0J3MgdHJpY2t5XG4gICAgICAgICAgLy8gdG8gZG8gc2FmZWx5LiAgRm9yIG5vdywgdGhpcyBpcyBzYWZlIGFuZCB3b3Jrcy5cbiAgICAgICAgICB2YXIgY3MgPSBwYXR0ZXJuLnN1YnN0cmluZyhjbGFzc1N0YXJ0ICsgMSwgaSlcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgUmVnRXhwKCdbJyArIGNzICsgJ10nKVxuICAgICAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgICAvLyBub3QgYSB2YWxpZCBjbGFzcyFcbiAgICAgICAgICAgIHZhciBzcCA9IHRoaXMucGFyc2UoY3MsIFNVQlBBUlNFKVxuICAgICAgICAgICAgcmUgPSByZS5zdWJzdHIoMCwgcmVDbGFzc1N0YXJ0KSArICdcXFxcWycgKyBzcFswXSArICdcXFxcXSdcbiAgICAgICAgICAgIGhhc01hZ2ljID0gaGFzTWFnaWMgfHwgc3BbMV1cbiAgICAgICAgICAgIGluQ2xhc3MgPSBmYWxzZVxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5pc2ggdXAgdGhlIGNsYXNzLlxuICAgICAgICBoYXNNYWdpYyA9IHRydWVcbiAgICAgICAgaW5DbGFzcyA9IGZhbHNlXG4gICAgICAgIHJlICs9IGNcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIHN3YWxsb3cgYW55IHN0YXRlIGNoYXIgdGhhdCB3YXNuJ3QgY29uc3VtZWRcbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuXG4gICAgICAgIGlmIChlc2NhcGluZykge1xuICAgICAgICAgIC8vIG5vIG5lZWRcbiAgICAgICAgICBlc2NhcGluZyA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSBpZiAocmVTcGVjaWFsc1tjXVxuICAgICAgICAgICYmICEoYyA9PT0gJ14nICYmIGluQ2xhc3MpKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFwnXG4gICAgICAgIH1cblxuICAgICAgICByZSArPSBjXG5cbiAgICB9IC8vIHN3aXRjaFxuICB9IC8vIGZvclxuXG4gIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB3ZSBsZWZ0IGEgY2xhc3Mgb3Blbi5cbiAgLy8gXCJbYWJjXCIgaXMgdmFsaWQsIGVxdWl2YWxlbnQgdG8gXCJcXFthYmNcIlxuICBpZiAoaW5DbGFzcykge1xuICAgIC8vIHNwbGl0IHdoZXJlIHRoZSBsYXN0IFsgd2FzLCBhbmQgZXNjYXBlIGl0XG4gICAgLy8gdGhpcyBpcyBhIGh1Z2UgcGl0YS4gIFdlIG5vdyBoYXZlIHRvIHJlLXdhbGtcbiAgICAvLyB0aGUgY29udGVudHMgb2YgdGhlIHdvdWxkLWJlIGNsYXNzIHRvIHJlLXRyYW5zbGF0ZVxuICAgIC8vIGFueSBjaGFyYWN0ZXJzIHRoYXQgd2VyZSBwYXNzZWQgdGhyb3VnaCBhcy1pc1xuICAgIGNzID0gcGF0dGVybi5zdWJzdHIoY2xhc3NTdGFydCArIDEpXG4gICAgc3AgPSB0aGlzLnBhcnNlKGNzLCBTVUJQQVJTRSlcbiAgICByZSA9IHJlLnN1YnN0cigwLCByZUNsYXNzU3RhcnQpICsgJ1xcXFxbJyArIHNwWzBdXG4gICAgaGFzTWFnaWMgPSBoYXNNYWdpYyB8fCBzcFsxXVxuICB9XG5cbiAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHdlIGhhZCBhICsoIHRoaW5nIGF0IHRoZSAqZW5kKlxuICAvLyBvZiB0aGUgcGF0dGVybi5cbiAgLy8gZWFjaCBwYXR0ZXJuIGxpc3Qgc3RhY2sgYWRkcyAzIGNoYXJzLCBhbmQgd2UgbmVlZCB0byBnbyB0aHJvdWdoXG4gIC8vIGFuZCBlc2NhcGUgYW55IHwgY2hhcnMgdGhhdCB3ZXJlIHBhc3NlZCB0aHJvdWdoIGFzLWlzIGZvciB0aGUgcmVnZXhwLlxuICAvLyBHbyB0aHJvdWdoIGFuZCBlc2NhcGUgdGhlbSwgdGFraW5nIGNhcmUgbm90IHRvIGRvdWJsZS1lc2NhcGUgYW55XG4gIC8vIHwgY2hhcnMgdGhhdCB3ZXJlIGFscmVhZHkgZXNjYXBlZC5cbiAgZm9yIChwbCA9IHBhdHRlcm5MaXN0U3RhY2sucG9wKCk7IHBsOyBwbCA9IHBhdHRlcm5MaXN0U3RhY2sucG9wKCkpIHtcbiAgICB2YXIgdGFpbCA9IHJlLnNsaWNlKHBsLnJlU3RhcnQgKyBwbC5vcGVuLmxlbmd0aClcbiAgICB0aGlzLmRlYnVnKCdzZXR0aW5nIHRhaWwnLCByZSwgcGwpXG4gICAgLy8gbWF5YmUgc29tZSBldmVuIG51bWJlciBvZiBcXCwgdGhlbiBtYXliZSAxIFxcLCBmb2xsb3dlZCBieSBhIHxcbiAgICB0YWlsID0gdGFpbC5yZXBsYWNlKC8oKD86XFxcXHsyfSl7MCw2NH0pKFxcXFw/KVxcfC9nLCBmdW5jdGlvbiAoXywgJDEsICQyKSB7XG4gICAgICBpZiAoISQyKSB7XG4gICAgICAgIC8vIHRoZSB8IGlzbid0IGFscmVhZHkgZXNjYXBlZCwgc28gZXNjYXBlIGl0LlxuICAgICAgICAkMiA9ICdcXFxcJ1xuICAgICAgfVxuXG4gICAgICAvLyBuZWVkIHRvIGVzY2FwZSBhbGwgdGhvc2Ugc2xhc2hlcyAqYWdhaW4qLCB3aXRob3V0IGVzY2FwaW5nIHRoZVxuICAgICAgLy8gb25lIHRoYXQgd2UgbmVlZCBmb3IgZXNjYXBpbmcgdGhlIHwgY2hhcmFjdGVyLiAgQXMgaXQgd29ya3Mgb3V0LFxuICAgICAgLy8gZXNjYXBpbmcgYW4gZXZlbiBudW1iZXIgb2Ygc2xhc2hlcyBjYW4gYmUgZG9uZSBieSBzaW1wbHkgcmVwZWF0aW5nXG4gICAgICAvLyBpdCBleGFjdGx5IGFmdGVyIGl0c2VsZi4gIFRoYXQncyB3aHkgdGhpcyB0cmljayB3b3Jrcy5cbiAgICAgIC8vXG4gICAgICAvLyBJIGFtIHNvcnJ5IHRoYXQgeW91IGhhdmUgdG8gc2VlIHRoaXMuXG4gICAgICByZXR1cm4gJDEgKyAkMSArICQyICsgJ3wnXG4gICAgfSlcblxuICAgIHRoaXMuZGVidWcoJ3RhaWw9JWpcXG4gICAlcycsIHRhaWwsIHRhaWwsIHBsLCByZSlcbiAgICB2YXIgdCA9IHBsLnR5cGUgPT09ICcqJyA/IHN0YXJcbiAgICAgIDogcGwudHlwZSA9PT0gJz8nID8gcW1hcmtcbiAgICAgIDogJ1xcXFwnICsgcGwudHlwZVxuXG4gICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgcmUgPSByZS5zbGljZSgwLCBwbC5yZVN0YXJ0KSArIHQgKyAnXFxcXCgnICsgdGFpbFxuICB9XG5cbiAgLy8gaGFuZGxlIHRyYWlsaW5nIHRoaW5ncyB0aGF0IG9ubHkgbWF0dGVyIGF0IHRoZSB2ZXJ5IGVuZC5cbiAgY2xlYXJTdGF0ZUNoYXIoKVxuICBpZiAoZXNjYXBpbmcpIHtcbiAgICAvLyB0cmFpbGluZyBcXFxcXG4gICAgcmUgKz0gJ1xcXFxcXFxcJ1xuICB9XG5cbiAgLy8gb25seSBuZWVkIHRvIGFwcGx5IHRoZSBub2RvdCBzdGFydCBpZiB0aGUgcmUgc3RhcnRzIHdpdGhcbiAgLy8gc29tZXRoaW5nIHRoYXQgY291bGQgY29uY2VpdmFibHkgY2FwdHVyZSBhIGRvdFxuICB2YXIgYWRkUGF0dGVyblN0YXJ0ID0gZmFsc2VcbiAgc3dpdGNoIChyZS5jaGFyQXQoMCkpIHtcbiAgICBjYXNlICcuJzpcbiAgICBjYXNlICdbJzpcbiAgICBjYXNlICcoJzogYWRkUGF0dGVyblN0YXJ0ID0gdHJ1ZVxuICB9XG5cbiAgLy8gSGFjayB0byB3b3JrIGFyb3VuZCBsYWNrIG9mIG5lZ2F0aXZlIGxvb2tiZWhpbmQgaW4gSlNcbiAgLy8gQSBwYXR0ZXJuIGxpa2U6ICouISh4KS4hKHl8eikgbmVlZHMgdG8gZW5zdXJlIHRoYXQgYSBuYW1lXG4gIC8vIGxpa2UgJ2EueHl6Lnl6JyBkb2Vzbid0IG1hdGNoLiAgU28sIHRoZSBmaXJzdCBuZWdhdGl2ZVxuICAvLyBsb29rYWhlYWQsIGhhcyB0byBsb29rIEFMTCB0aGUgd2F5IGFoZWFkLCB0byB0aGUgZW5kIG9mXG4gIC8vIHRoZSBwYXR0ZXJuLlxuICBmb3IgKHZhciBuID0gbmVnYXRpdmVMaXN0cy5sZW5ndGggLSAxOyBuID4gLTE7IG4tLSkge1xuICAgIHZhciBubCA9IG5lZ2F0aXZlTGlzdHNbbl1cblxuICAgIHZhciBubEJlZm9yZSA9IHJlLnNsaWNlKDAsIG5sLnJlU3RhcnQpXG4gICAgdmFyIG5sRmlyc3QgPSByZS5zbGljZShubC5yZVN0YXJ0LCBubC5yZUVuZCAtIDgpXG4gICAgdmFyIG5sTGFzdCA9IHJlLnNsaWNlKG5sLnJlRW5kIC0gOCwgbmwucmVFbmQpXG4gICAgdmFyIG5sQWZ0ZXIgPSByZS5zbGljZShubC5yZUVuZClcblxuICAgIG5sTGFzdCArPSBubEFmdGVyXG5cbiAgICAvLyBIYW5kbGUgbmVzdGVkIHN0dWZmIGxpa2UgKigqLmpzfCEoKi5qc29uKSksIHdoZXJlIG9wZW4gcGFyZW5zXG4gICAgLy8gbWVhbiB0aGF0IHdlIHNob3VsZCAqbm90KiBpbmNsdWRlIHRoZSApIGluIHRoZSBiaXQgdGhhdCBpcyBjb25zaWRlcmVkXG4gICAgLy8gXCJhZnRlclwiIHRoZSBuZWdhdGVkIHNlY3Rpb24uXG4gICAgdmFyIG9wZW5QYXJlbnNCZWZvcmUgPSBubEJlZm9yZS5zcGxpdCgnKCcpLmxlbmd0aCAtIDFcbiAgICB2YXIgY2xlYW5BZnRlciA9IG5sQWZ0ZXJcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3BlblBhcmVuc0JlZm9yZTsgaSsrKSB7XG4gICAgICBjbGVhbkFmdGVyID0gY2xlYW5BZnRlci5yZXBsYWNlKC9cXClbKyo/XT8vLCAnJylcbiAgICB9XG4gICAgbmxBZnRlciA9IGNsZWFuQWZ0ZXJcblxuICAgIHZhciBkb2xsYXIgPSAnJ1xuICAgIGlmIChubEFmdGVyID09PSAnJyAmJiBpc1N1YiAhPT0gU1VCUEFSU0UpIHtcbiAgICAgIGRvbGxhciA9ICckJ1xuICAgIH1cbiAgICB2YXIgbmV3UmUgPSBubEJlZm9yZSArIG5sRmlyc3QgKyBubEFmdGVyICsgZG9sbGFyICsgbmxMYXN0XG4gICAgcmUgPSBuZXdSZVxuICB9XG5cbiAgLy8gaWYgdGhlIHJlIGlzIG5vdCBcIlwiIGF0IHRoaXMgcG9pbnQsIHRoZW4gd2UgbmVlZCB0byBtYWtlIHN1cmVcbiAgLy8gaXQgZG9lc24ndCBtYXRjaCBhZ2FpbnN0IGFuIGVtcHR5IHBhdGggcGFydC5cbiAgLy8gT3RoZXJ3aXNlIGEvKiB3aWxsIG1hdGNoIGEvLCB3aGljaCBpdCBzaG91bGQgbm90LlxuICBpZiAocmUgIT09ICcnICYmIGhhc01hZ2ljKSB7XG4gICAgcmUgPSAnKD89LiknICsgcmVcbiAgfVxuXG4gIGlmIChhZGRQYXR0ZXJuU3RhcnQpIHtcbiAgICByZSA9IHBhdHRlcm5TdGFydCArIHJlXG4gIH1cblxuICAvLyBwYXJzaW5nIGp1c3QgYSBwaWVjZSBvZiBhIGxhcmdlciBwYXR0ZXJuLlxuICBpZiAoaXNTdWIgPT09IFNVQlBBUlNFKSB7XG4gICAgcmV0dXJuIFtyZSwgaGFzTWFnaWNdXG4gIH1cblxuICAvLyBza2lwIHRoZSByZWdleHAgZm9yIG5vbi1tYWdpY2FsIHBhdHRlcm5zXG4gIC8vIHVuZXNjYXBlIGFueXRoaW5nIGluIGl0LCB0aG91Z2gsIHNvIHRoYXQgaXQnbGwgYmVcbiAgLy8gYW4gZXhhY3QgbWF0Y2ggYWdhaW5zdCBhIGZpbGUgZXRjLlxuICBpZiAoIWhhc01hZ2ljKSB7XG4gICAgcmV0dXJuIGdsb2JVbmVzY2FwZShwYXR0ZXJuKVxuICB9XG5cbiAgdmFyIGZsYWdzID0gb3B0aW9ucy5ub2Nhc2UgPyAnaScgOiAnJ1xuICB0cnkge1xuICAgIHZhciByZWdFeHAgPSBuZXcgUmVnRXhwKCdeJyArIHJlICsgJyQnLCBmbGFncylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICAvLyBJZiBpdCB3YXMgYW4gaW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24sIHRoZW4gaXQgY2FuJ3QgbWF0Y2hcbiAgICAvLyBhbnl0aGluZy4gIFRoaXMgdHJpY2sgbG9va3MgZm9yIGEgY2hhcmFjdGVyIGFmdGVyIHRoZSBlbmQgb2ZcbiAgICAvLyB0aGUgc3RyaW5nLCB3aGljaCBpcyBvZiBjb3Vyc2UgaW1wb3NzaWJsZSwgZXhjZXB0IGluIG11bHRpLWxpbmVcbiAgICAvLyBtb2RlLCBidXQgaXQncyBub3QgYSAvbSByZWdleC5cbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnJC4nKVxuICB9XG5cbiAgcmVnRXhwLl9nbG9iID0gcGF0dGVyblxuICByZWdFeHAuX3NyYyA9IHJlXG5cbiAgcmV0dXJuIHJlZ0V4cFxufVxuXG5taW5pbWF0Y2gubWFrZVJlID0gZnVuY3Rpb24gKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucyB8fCB7fSkubWFrZVJlKClcbn1cblxuTWluaW1hdGNoLnByb3RvdHlwZS5tYWtlUmUgPSBtYWtlUmVcbmZ1bmN0aW9uIG1ha2VSZSAoKSB7XG4gIGlmICh0aGlzLnJlZ2V4cCB8fCB0aGlzLnJlZ2V4cCA9PT0gZmFsc2UpIHJldHVybiB0aGlzLnJlZ2V4cFxuXG4gIC8vIGF0IHRoaXMgcG9pbnQsIHRoaXMuc2V0IGlzIGEgMmQgYXJyYXkgb2YgcGFydGlhbFxuICAvLyBwYXR0ZXJuIHN0cmluZ3MsIG9yIFwiKipcIi5cbiAgLy9cbiAgLy8gSXQncyBiZXR0ZXIgdG8gdXNlIC5tYXRjaCgpLiAgVGhpcyBmdW5jdGlvbiBzaG91bGRuJ3RcbiAgLy8gYmUgdXNlZCwgcmVhbGx5LCBidXQgaXQncyBwcmV0dHkgY29udmVuaWVudCBzb21ldGltZXMsXG4gIC8vIHdoZW4geW91IGp1c3Qgd2FudCB0byB3b3JrIHdpdGggYSByZWdleC5cbiAgdmFyIHNldCA9IHRoaXMuc2V0XG5cbiAgaWYgKCFzZXQubGVuZ3RoKSB7XG4gICAgdGhpcy5yZWdleHAgPSBmYWxzZVxuICAgIHJldHVybiB0aGlzLnJlZ2V4cFxuICB9XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgdmFyIHR3b1N0YXIgPSBvcHRpb25zLm5vZ2xvYnN0YXIgPyBzdGFyXG4gICAgOiBvcHRpb25zLmRvdCA/IHR3b1N0YXJEb3RcbiAgICA6IHR3b1N0YXJOb0RvdFxuICB2YXIgZmxhZ3MgPSBvcHRpb25zLm5vY2FzZSA/ICdpJyA6ICcnXG5cbiAgdmFyIHJlID0gc2V0Lm1hcChmdW5jdGlvbiAocGF0dGVybikge1xuICAgIHJldHVybiBwYXR0ZXJuLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIChwID09PSBHTE9CU1RBUikgPyB0d29TdGFyXG4gICAgICA6ICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpID8gcmVnRXhwRXNjYXBlKHApXG4gICAgICA6IHAuX3NyY1xuICAgIH0pLmpvaW4oJ1xcXFxcXC8nKVxuICB9KS5qb2luKCd8JylcblxuICAvLyBtdXN0IG1hdGNoIGVudGlyZSBwYXR0ZXJuXG4gIC8vIGVuZGluZyBpbiBhICogb3IgKiogd2lsbCBtYWtlIGl0IGxlc3Mgc3RyaWN0LlxuICByZSA9ICdeKD86JyArIHJlICsgJykkJ1xuXG4gIC8vIGNhbiBtYXRjaCBhbnl0aGluZywgYXMgbG9uZyBhcyBpdCdzIG5vdCB0aGlzLlxuICBpZiAodGhpcy5uZWdhdGUpIHJlID0gJ14oPyEnICsgcmUgKyAnKS4qJCdcblxuICB0cnkge1xuICAgIHRoaXMucmVnZXhwID0gbmV3IFJlZ0V4cChyZSwgZmxhZ3MpXG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgdGhpcy5yZWdleHAgPSBmYWxzZVxuICB9XG4gIHJldHVybiB0aGlzLnJlZ2V4cFxufVxuXG5taW5pbWF0Y2gubWF0Y2ggPSBmdW5jdGlvbiAobGlzdCwgcGF0dGVybiwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgbW0gPSBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpXG4gIGxpc3QgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBtbS5tYXRjaChmKVxuICB9KVxuICBpZiAobW0ub3B0aW9ucy5ub251bGwgJiYgIWxpc3QubGVuZ3RoKSB7XG4gICAgbGlzdC5wdXNoKHBhdHRlcm4pXG4gIH1cbiAgcmV0dXJuIGxpc3Rcbn1cblxuTWluaW1hdGNoLnByb3RvdHlwZS5tYXRjaCA9IG1hdGNoXG5mdW5jdGlvbiBtYXRjaCAoZiwgcGFydGlhbCkge1xuICB0aGlzLmRlYnVnKCdtYXRjaCcsIGYsIHRoaXMucGF0dGVybilcbiAgLy8gc2hvcnQtY2lyY3VpdCBpbiB0aGUgY2FzZSBvZiBidXN0ZWQgdGhpbmdzLlxuICAvLyBjb21tZW50cywgZXRjLlxuICBpZiAodGhpcy5jb21tZW50KSByZXR1cm4gZmFsc2VcbiAgaWYgKHRoaXMuZW1wdHkpIHJldHVybiBmID09PSAnJ1xuXG4gIGlmIChmID09PSAnLycgJiYgcGFydGlhbCkgcmV0dXJuIHRydWVcblxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gIC8vIHdpbmRvd3M6IG5lZWQgdG8gdXNlIC8sIG5vdCBcXFxuICBpZiAocGF0aC5zZXAgIT09ICcvJykge1xuICAgIGYgPSBmLnNwbGl0KHBhdGguc2VwKS5qb2luKCcvJylcbiAgfVxuXG4gIC8vIHRyZWF0IHRoZSB0ZXN0IHBhdGggYXMgYSBzZXQgb2YgcGF0aHBhcnRzLlxuICBmID0gZi5zcGxpdChzbGFzaFNwbGl0KVxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgJ3NwbGl0JywgZilcblxuICAvLyBqdXN0IE9ORSBvZiB0aGUgcGF0dGVybiBzZXRzIGluIHRoaXMuc2V0IG5lZWRzIHRvIG1hdGNoXG4gIC8vIGluIG9yZGVyIGZvciBpdCB0byBiZSB2YWxpZC4gIElmIG5lZ2F0aW5nLCB0aGVuIGp1c3Qgb25lXG4gIC8vIG1hdGNoIG1lYW5zIHRoYXQgd2UgaGF2ZSBmYWlsZWQuXG4gIC8vIEVpdGhlciB3YXksIHJldHVybiBvbiB0aGUgZmlyc3QgaGl0LlxuXG4gIHZhciBzZXQgPSB0aGlzLnNldFxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgJ3NldCcsIHNldClcblxuICAvLyBGaW5kIHRoZSBiYXNlbmFtZSBvZiB0aGUgcGF0aCBieSBsb29raW5nIGZvciB0aGUgbGFzdCBub24tZW1wdHkgc2VnbWVudFxuICB2YXIgZmlsZW5hbWVcbiAgdmFyIGlcbiAgZm9yIChpID0gZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGZpbGVuYW1lID0gZltpXVxuICAgIGlmIChmaWxlbmFtZSkgYnJlYWtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGF0dGVybiA9IHNldFtpXVxuICAgIHZhciBmaWxlID0gZlxuICAgIGlmIChvcHRpb25zLm1hdGNoQmFzZSAmJiBwYXR0ZXJuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZmlsZSA9IFtmaWxlbmFtZV1cbiAgICB9XG4gICAgdmFyIGhpdCA9IHRoaXMubWF0Y2hPbmUoZmlsZSwgcGF0dGVybiwgcGFydGlhbClcbiAgICBpZiAoaGl0KSB7XG4gICAgICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSByZXR1cm4gdHJ1ZVxuICAgICAgcmV0dXJuICF0aGlzLm5lZ2F0ZVxuICAgIH1cbiAgfVxuXG4gIC8vIGRpZG4ndCBnZXQgYW55IGhpdHMuICB0aGlzIGlzIHN1Y2Nlc3MgaWYgaXQncyBhIG5lZ2F0aXZlXG4gIC8vIHBhdHRlcm4sIGZhaWx1cmUgb3RoZXJ3aXNlLlxuICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSByZXR1cm4gZmFsc2VcbiAgcmV0dXJuIHRoaXMubmVnYXRlXG59XG5cbi8vIHNldCBwYXJ0aWFsIHRvIHRydWUgdG8gdGVzdCBpZiwgZm9yIGV4YW1wbGUsXG4vLyBcIi9hL2JcIiBtYXRjaGVzIHRoZSBzdGFydCBvZiBcIi8qL2IvKi9kXCJcbi8vIFBhcnRpYWwgbWVhbnMsIGlmIHlvdSBydW4gb3V0IG9mIGZpbGUgYmVmb3JlIHlvdSBydW5cbi8vIG91dCBvZiBwYXR0ZXJuLCB0aGVuIHRoYXQncyBmaW5lLCBhcyBsb25nIGFzIGFsbFxuLy8gdGhlIHBhcnRzIG1hdGNoLlxuTWluaW1hdGNoLnByb3RvdHlwZS5tYXRjaE9uZSA9IGZ1bmN0aW9uIChmaWxlLCBwYXR0ZXJuLCBwYXJ0aWFsKSB7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUnLFxuICAgIHsgJ3RoaXMnOiB0aGlzLCBmaWxlOiBmaWxlLCBwYXR0ZXJuOiBwYXR0ZXJuIH0pXG5cbiAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUnLCBmaWxlLmxlbmd0aCwgcGF0dGVybi5sZW5ndGgpXG5cbiAgZm9yICh2YXIgZmkgPSAwLFxuICAgICAgcGkgPSAwLFxuICAgICAgZmwgPSBmaWxlLmxlbmd0aCxcbiAgICAgIHBsID0gcGF0dGVybi5sZW5ndGhcbiAgICAgIDsgKGZpIDwgZmwpICYmIChwaSA8IHBsKVxuICAgICAgOyBmaSsrLCBwaSsrKSB7XG4gICAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUgbG9vcCcpXG4gICAgdmFyIHAgPSBwYXR0ZXJuW3BpXVxuICAgIHZhciBmID0gZmlsZVtmaV1cblxuICAgIHRoaXMuZGVidWcocGF0dGVybiwgcCwgZilcblxuICAgIC8vIHNob3VsZCBiZSBpbXBvc3NpYmxlLlxuICAgIC8vIHNvbWUgaW52YWxpZCByZWdleHAgc3R1ZmYgaW4gdGhlIHNldC5cbiAgICBpZiAocCA9PT0gZmFsc2UpIHJldHVybiBmYWxzZVxuXG4gICAgaWYgKHAgPT09IEdMT0JTVEFSKSB7XG4gICAgICB0aGlzLmRlYnVnKCdHTE9CU1RBUicsIFtwYXR0ZXJuLCBwLCBmXSlcblxuICAgICAgLy8gXCIqKlwiXG4gICAgICAvLyBhLyoqL2IvKiovYyB3b3VsZCBtYXRjaCB0aGUgZm9sbG93aW5nOlxuICAgICAgLy8gYS9iL3gveS96L2NcbiAgICAgIC8vIGEveC95L3ovYi9jXG4gICAgICAvLyBhL2IveC9iL3gvY1xuICAgICAgLy8gYS9iL2NcbiAgICAgIC8vIFRvIGRvIHRoaXMsIHRha2UgdGhlIHJlc3Qgb2YgdGhlIHBhdHRlcm4gYWZ0ZXJcbiAgICAgIC8vIHRoZSAqKiwgYW5kIHNlZSBpZiBpdCB3b3VsZCBtYXRjaCB0aGUgZmlsZSByZW1haW5kZXIuXG4gICAgICAvLyBJZiBzbywgcmV0dXJuIHN1Y2Nlc3MuXG4gICAgICAvLyBJZiBub3QsIHRoZSAqKiBcInN3YWxsb3dzXCIgYSBzZWdtZW50LCBhbmQgdHJ5IGFnYWluLlxuICAgICAgLy8gVGhpcyBpcyByZWN1cnNpdmVseSBhd2Z1bC5cbiAgICAgIC8vXG4gICAgICAvLyBhLyoqL2IvKiovYyBtYXRjaGluZyBhL2IveC95L3ovY1xuICAgICAgLy8gLSBhIG1hdGNoZXMgYVxuICAgICAgLy8gLSBkb3VibGVzdGFyXG4gICAgICAvLyAgIC0gbWF0Y2hPbmUoYi94L3kvei9jLCBiLyoqL2MpXG4gICAgICAvLyAgICAgLSBiIG1hdGNoZXMgYlxuICAgICAgLy8gICAgIC0gZG91Ymxlc3RhclxuICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh4L3kvei9jLCBjKSAtPiBub1xuICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh5L3ovYywgYykgLT4gbm9cbiAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoei9jLCBjKSAtPiBub1xuICAgICAgLy8gICAgICAgLSBtYXRjaE9uZShjLCBjKSB5ZXMsIGhpdFxuICAgICAgdmFyIGZyID0gZmlcbiAgICAgIHZhciBwciA9IHBpICsgMVxuICAgICAgaWYgKHByID09PSBwbCkge1xuICAgICAgICB0aGlzLmRlYnVnKCcqKiBhdCB0aGUgZW5kJylcbiAgICAgICAgLy8gYSAqKiBhdCB0aGUgZW5kIHdpbGwganVzdCBzd2FsbG93IHRoZSByZXN0LlxuICAgICAgICAvLyBXZSBoYXZlIGZvdW5kIGEgbWF0Y2guXG4gICAgICAgIC8vIGhvd2V2ZXIsIGl0IHdpbGwgbm90IHN3YWxsb3cgLy54LCB1bmxlc3NcbiAgICAgICAgLy8gb3B0aW9ucy5kb3QgaXMgc2V0LlxuICAgICAgICAvLyAuIGFuZCAuLiBhcmUgKm5ldmVyKiBtYXRjaGVkIGJ5ICoqLCBmb3IgZXhwbG9zaXZlbHlcbiAgICAgICAgLy8gZXhwb25lbnRpYWwgcmVhc29ucy5cbiAgICAgICAgZm9yICg7IGZpIDwgZmw7IGZpKyspIHtcbiAgICAgICAgICBpZiAoZmlsZVtmaV0gPT09ICcuJyB8fCBmaWxlW2ZpXSA9PT0gJy4uJyB8fFxuICAgICAgICAgICAgKCFvcHRpb25zLmRvdCAmJiBmaWxlW2ZpXS5jaGFyQXQoMCkgPT09ICcuJykpIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIC8vIG9rLCBsZXQncyBzZWUgaWYgd2UgY2FuIHN3YWxsb3cgd2hhdGV2ZXIgd2UgY2FuLlxuICAgICAgd2hpbGUgKGZyIDwgZmwpIHtcbiAgICAgICAgdmFyIHN3YWxsb3dlZSA9IGZpbGVbZnJdXG5cbiAgICAgICAgdGhpcy5kZWJ1ZygnXFxuZ2xvYnN0YXIgd2hpbGUnLCBmaWxlLCBmciwgcGF0dGVybiwgcHIsIHN3YWxsb3dlZSlcblxuICAgICAgICAvLyBYWFggcmVtb3ZlIHRoaXMgc2xpY2UuICBKdXN0IHBhc3MgdGhlIHN0YXJ0IGluZGV4LlxuICAgICAgICBpZiAodGhpcy5tYXRjaE9uZShmaWxlLnNsaWNlKGZyKSwgcGF0dGVybi5zbGljZShwciksIHBhcnRpYWwpKSB7XG4gICAgICAgICAgdGhpcy5kZWJ1ZygnZ2xvYnN0YXIgZm91bmQgbWF0Y2ghJywgZnIsIGZsLCBzd2FsbG93ZWUpXG4gICAgICAgICAgLy8gZm91bmQgYSBtYXRjaC5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNhbid0IHN3YWxsb3cgXCIuXCIgb3IgXCIuLlwiIGV2ZXIuXG4gICAgICAgICAgLy8gY2FuIG9ubHkgc3dhbGxvdyBcIi5mb29cIiB3aGVuIGV4cGxpY2l0bHkgYXNrZWQuXG4gICAgICAgICAgaWYgKHN3YWxsb3dlZSA9PT0gJy4nIHx8IHN3YWxsb3dlZSA9PT0gJy4uJyB8fFxuICAgICAgICAgICAgKCFvcHRpb25zLmRvdCAmJiBzd2FsbG93ZWUuY2hhckF0KDApID09PSAnLicpKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKCdkb3QgZGV0ZWN0ZWQhJywgZmlsZSwgZnIsIHBhdHRlcm4sIHByKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAqKiBzd2FsbG93cyBhIHNlZ21lbnQsIGFuZCBjb250aW51ZS5cbiAgICAgICAgICB0aGlzLmRlYnVnKCdnbG9ic3RhciBzd2FsbG93IGEgc2VnbWVudCwgYW5kIGNvbnRpbnVlJylcbiAgICAgICAgICBmcisrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbm8gbWF0Y2ggd2FzIGZvdW5kLlxuICAgICAgLy8gSG93ZXZlciwgaW4gcGFydGlhbCBtb2RlLCB3ZSBjYW4ndCBzYXkgdGhpcyBpcyBuZWNlc3NhcmlseSBvdmVyLlxuICAgICAgLy8gSWYgdGhlcmUncyBtb3JlICpwYXR0ZXJuKiBsZWZ0LCB0aGVuXG4gICAgICBpZiAocGFydGlhbCkge1xuICAgICAgICAvLyByYW4gb3V0IG9mIGZpbGVcbiAgICAgICAgdGhpcy5kZWJ1ZygnXFxuPj4+IG5vIG1hdGNoLCBwYXJ0aWFsPycsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwcilcbiAgICAgICAgaWYgKGZyID09PSBmbCkgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIHNvbWV0aGluZyBvdGhlciB0aGFuICoqXG4gICAgLy8gbm9uLW1hZ2ljIHBhdHRlcm5zIGp1c3QgaGF2ZSB0byBtYXRjaCBleGFjdGx5XG4gICAgLy8gcGF0dGVybnMgd2l0aCBtYWdpYyBoYXZlIGJlZW4gdHVybmVkIGludG8gcmVnZXhwcy5cbiAgICB2YXIgaGl0XG4gICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKG9wdGlvbnMubm9jYXNlKSB7XG4gICAgICAgIGhpdCA9IGYudG9Mb3dlckNhc2UoKSA9PT0gcC50b0xvd2VyQ2FzZSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoaXQgPSBmID09PSBwXG4gICAgICB9XG4gICAgICB0aGlzLmRlYnVnKCdzdHJpbmcgbWF0Y2gnLCBwLCBmLCBoaXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGhpdCA9IGYubWF0Y2gocClcbiAgICAgIHRoaXMuZGVidWcoJ3BhdHRlcm4gbWF0Y2gnLCBwLCBmLCBoaXQpXG4gICAgfVxuXG4gICAgaWYgKCFoaXQpIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gTm90ZTogZW5kaW5nIGluIC8gbWVhbnMgdGhhdCB3ZSdsbCBnZXQgYSBmaW5hbCBcIlwiXG4gIC8vIGF0IHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4uICBUaGlzIGNhbiBvbmx5IG1hdGNoIGFcbiAgLy8gY29ycmVzcG9uZGluZyBcIlwiIGF0IHRoZSBlbmQgb2YgdGhlIGZpbGUuXG4gIC8vIElmIHRoZSBmaWxlIGVuZHMgaW4gLywgdGhlbiBpdCBjYW4gb25seSBtYXRjaCBhXG4gIC8vIGEgcGF0dGVybiB0aGF0IGVuZHMgaW4gLywgdW5sZXNzIHRoZSBwYXR0ZXJuIGp1c3RcbiAgLy8gZG9lc24ndCBoYXZlIGFueSBtb3JlIGZvciBpdC4gQnV0LCBhL2IvIHNob3VsZCAqbm90KlxuICAvLyBtYXRjaCBcImEvYi8qXCIsIGV2ZW4gdGhvdWdoIFwiXCIgbWF0Y2hlcyBhZ2FpbnN0IHRoZVxuICAvLyBbXi9dKj8gcGF0dGVybiwgZXhjZXB0IGluIHBhcnRpYWwgbW9kZSwgd2hlcmUgaXQgbWlnaHRcbiAgLy8gc2ltcGx5IG5vdCBiZSByZWFjaGVkIHlldC5cbiAgLy8gSG93ZXZlciwgYS9iLyBzaG91bGQgc3RpbGwgc2F0aXNmeSBhLypcblxuICAvLyBub3cgZWl0aGVyIHdlIGZlbGwgb2ZmIHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4sIG9yIHdlJ3JlIGRvbmUuXG4gIGlmIChmaSA9PT0gZmwgJiYgcGkgPT09IHBsKSB7XG4gICAgLy8gcmFuIG91dCBvZiBwYXR0ZXJuIGFuZCBmaWxlbmFtZSBhdCB0aGUgc2FtZSB0aW1lLlxuICAgIC8vIGFuIGV4YWN0IGhpdCFcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYgKGZpID09PSBmbCkge1xuICAgIC8vIHJhbiBvdXQgb2YgZmlsZSwgYnV0IHN0aWxsIGhhZCBwYXR0ZXJuIGxlZnQuXG4gICAgLy8gdGhpcyBpcyBvayBpZiB3ZSdyZSBkb2luZyB0aGUgbWF0Y2ggYXMgcGFydCBvZlxuICAgIC8vIGEgZ2xvYiBmcyB0cmF2ZXJzYWwuXG4gICAgcmV0dXJuIHBhcnRpYWxcbiAgfSBlbHNlIGlmIChwaSA9PT0gcGwpIHtcbiAgICAvLyByYW4gb3V0IG9mIHBhdHRlcm4sIHN0aWxsIGhhdmUgZmlsZSBsZWZ0LlxuICAgIC8vIHRoaXMgaXMgb25seSBhY2NlcHRhYmxlIGlmIHdlJ3JlIG9uIHRoZSB2ZXJ5IGxhc3RcbiAgICAvLyBlbXB0eSBzZWdtZW50IG9mIGEgZmlsZSB3aXRoIGEgdHJhaWxpbmcgc2xhc2guXG4gICAgLy8gYS8qIHNob3VsZCBtYXRjaCBhL2IvXG4gICAgdmFyIGVtcHR5RmlsZUVuZCA9IChmaSA9PT0gZmwgLSAxKSAmJiAoZmlsZVtmaV0gPT09ICcnKVxuICAgIHJldHVybiBlbXB0eUZpbGVFbmRcbiAgfVxuXG4gIC8vIHNob3VsZCBiZSB1bnJlYWNoYWJsZS5cbiAgdGhyb3cgbmV3IEVycm9yKCd3dGY/Jylcbn1cblxuLy8gcmVwbGFjZSBzdHVmZiBsaWtlIFxcKiB3aXRoICpcbmZ1bmN0aW9uIGdsb2JVbmVzY2FwZSAocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9cXFxcKC4pL2csICckMScpXG59XG5cbmZ1bmN0aW9uIHJlZ0V4cEVzY2FwZSAocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpXG59XG4iLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuIiwidmFyIHdyYXBweSA9IHJlcXVpcmUoJ3dyYXBweScpXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBweShvbmNlKVxubW9kdWxlLmV4cG9ydHMuc3RyaWN0ID0gd3JhcHB5KG9uY2VTdHJpY3QpXG5cbm9uY2UucHJvdG8gPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ29uY2UnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvbmNlKHRoaXMpXG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCAnb25jZVN0cmljdCcsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9uY2VTdHJpY3QodGhpcylcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxufSlcblxuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGYuY2FsbGVkKSByZXR1cm4gZi52YWx1ZVxuICAgIGYuY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmLnZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIGYuY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZcbn1cblxuZnVuY3Rpb24gb25jZVN0cmljdCAoZm4pIHtcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGYuY2FsbGVkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGYub25jZUVycm9yKVxuICAgIGYuY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmLnZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIHZhciBuYW1lID0gZm4ubmFtZSB8fCAnRnVuY3Rpb24gd3JhcHBlZCB3aXRoIGBvbmNlYCdcbiAgZi5vbmNlRXJyb3IgPSBuYW1lICsgXCIgc2hvdWxkbid0IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZVwiXG4gIGYuY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZcbn1cbiIsIi8vIC5kaXJuYW1lLCAuYmFzZW5hbWUsIGFuZCAuZXh0bmFtZSBtZXRob2RzIGFyZSBleHRyYWN0ZWQgZnJvbSBOb2RlLmpzIHY4LjExLjEsXG4vLyBiYWNrcG9ydGVkIGFuZCB0cmFuc3BsaXRlZCB3aXRoIEJhYmVsLCB3aXRoIGJhY2t3YXJkcy1jb21wYXQgZml4ZXNcblxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gJy4nO1xuICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgdmFyIGhhc1Jvb3QgPSBjb2RlID09PSA0NyAvKi8qLztcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcbiAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiBoYXNSb290ID8gJy8nIDogJy4nO1xuICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpIHtcbiAgICAvLyByZXR1cm4gJy8vJztcbiAgICAvLyBCYWNrd2FyZHMtY29tcGF0IGZpeDpcbiAgICByZXR1cm4gJy8nO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBiYXNlbmFtZShwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG5cbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gcGF0aCBjb21wb25lbnRcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgZW5kID0gaSArIDE7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiAnJztcbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XG59XG5cbi8vIFVzZXMgYSBtaXhlZCBhcHByb2FjaCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIGFzIGV4dCBiZWhhdmlvciBjaGFuZ2VkXG4vLyBpbiBuZXcgTm9kZS5qcyB2ZXJzaW9ucywgc28gb25seSBiYXNlbmFtZSgpIGFib3ZlIGlzIGJhY2twb3J0ZWQgaGVyZVxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uIChwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBiYXNlbmFtZShwYXRoKTtcbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG4gIHZhciBzdGFydERvdCA9IC0xO1xuICB2YXIgc3RhcnRQYXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICB2YXIgcHJlRG90U3RhdGUgPSAwO1xuICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIGVuZCA9IGkgKyAxO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gNDYgLyouKi8pIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgZG90LCBtYXJrIGl0IGFzIHRoZSBzdGFydCBvZiBvdXIgZXh0ZW5zaW9uXG4gICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpXG4gICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSlcbiAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXG4gICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHxcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxuICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgICAgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHBvc2l4KHBhdGgpIHtcblx0cmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59XG5cbmZ1bmN0aW9uIHdpbjMyKHBhdGgpIHtcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvYjNmY2MyNDVmYjI1NTM5OTA5ZWYxZDVlYWEwMWRiZjkyZTE2ODYzMy9saWIvcGF0aC5qcyNMNTZcblx0dmFyIHNwbGl0RGV2aWNlUmUgPSAvXihbYS16QS1aXTp8W1xcXFxcXC9dezJ9W15cXFxcXFwvXStbXFxcXFxcL10rW15cXFxcXFwvXSspPyhbXFxcXFxcL10pPyhbXFxzXFxTXSo/KSQvO1xuXHR2YXIgcmVzdWx0ID0gc3BsaXREZXZpY2VSZS5leGVjKHBhdGgpO1xuXHR2YXIgZGV2aWNlID0gcmVzdWx0WzFdIHx8ICcnO1xuXHR2YXIgaXNVbmMgPSBCb29sZWFuKGRldmljZSAmJiBkZXZpY2UuY2hhckF0KDEpICE9PSAnOicpO1xuXG5cdC8vIFVOQyBwYXRocyBhcmUgYWx3YXlzIGFic29sdXRlXG5cdHJldHVybiBCb29sZWFuKHJlc3VsdFsyXSB8fCBpc1VuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IHdpbjMyIDogcG9zaXg7XG5tb2R1bGUuZXhwb3J0cy5wb3NpeCA9IHBvc2l4O1xubW9kdWxlLmV4cG9ydHMud2luMzIgPSB3aW4zMjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fFxuICAgICFwcm9jZXNzLnZlcnNpb24gfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjAuJykgPT09IDAgfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7IG5leHRUaWNrOiBuZXh0VGljayB9O1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzLCBpO1xuICBzd2l0Y2ggKGxlbikge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xuICAgIH0pO1xuICBjYXNlIDM6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcbiAgICB9KTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9KTtcbiAgZGVmYXVsdDpcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbn1cblxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuNC4xJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykge1xuXHRcdFx0Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gYXZvaWQgc2NvcGUgY3JlZXAsIHRoZSBrZXlzIGFycmF5IGNhbiB0aGVuIGJlIGNvbGxlY3RlZFxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcG5hLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgdGhpcy5lbmQoKTtcblxuICBwbmEubmV4dFRpY2soY2IsIGVycik7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVidWcgPSB2b2lkIDA7XG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTtcbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG5cbiAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgcmVhZGFibGVId20gPSBvcHRpb25zLnJlYWRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmIChyZWFkYWJsZUh3bSB8fCByZWFkYWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHJlYWRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICBjYihlcnIpO1xufTtcblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICAgIGlmIChlcikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50JykpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKSBwbmEubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHBuYS5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxuICAvLyBpbiBvbmRhdGEgYWdhaW4uIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byBpbmNyZWFzZSBhd2FpdERyYWluIG9uY2UgYmVjYXVzZVxuICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLlxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXG4gIHZhciBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0ICYmICFpbmNyZWFzZWRBd2FpdERyYWluKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdW5waXBlSW5mbyA9IHsgaGFzVW5waXBlZDogZmFsc2UgfTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICB9cmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gU3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHBuYS5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufVxuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgX3RoaXMucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgdGhpcy5lbWl0LmJpbmQodGhpcywga1Byb3h5RXZlbnRzW25dKSk7XG4gIH1cblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcbiAgdmFyIHJldDtcbiAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xuICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7XG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxuICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGFcbi8vIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkge1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICB2YXIgcmV0ID0gcC5kYXRhO1xuICBuIC09IHJldC5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xuICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICBwLmRhdGEuY29weShyZXQpO1xuICBuIC09IHAuZGF0YS5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYikge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSBjYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTtcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2IoZXJyMik7XG4gICAgX3RoaXMyLmVtaXQoJ2Nsb3NlJyk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qIDxyZXBsYWNlbWVudD4gKi9cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcG5hLm5leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgd3JpdGFibGVId20gPSBvcHRpb25zLndyaXRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmICh3cml0YWJsZUh3bSB8fCB3cml0YWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHdyaXRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTtcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIGlmICghcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHtcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB9XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHBuYS5uZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG4gICAgcG5hLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tO1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcG5hLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwbmEubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfVxuICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGNvcmtSZXE7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLmVuZCgpO1xuICBjYihlcnIpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgc3JjLmNvcHkodGFyZ2V0LCBvZmZzZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG5cbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2godikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAtLXRoaXMubGVuZ3RoO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihzKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgICB9cmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQobikge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAocCkge1xuICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICBwID0gcC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpO1xuXG5pZiAodXRpbCAmJiB1dGlsLmluc3BlY3QgJiYgdXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICBtb2R1bGUuZXhwb3J0cy5wcm90b3R5cGVbdXRpbC5pbnNwZWN0LmN1c3RvbV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHV0aWwuaW5zcGVjdCh7IGxlbmd0aDogdGhpcy5sZW5ndGggfSk7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZSArICcgJyArIG9iajtcbiAgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyICYmICghdGhpcy5fd3JpdGFibGVTdGF0ZSB8fCAhdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCBfdGhpcywgZXJyKTtcbiAgICAgIGlmIChfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XG4gIHZhciByZXRyaWVkO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuICd1dGY4JztcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xuICByZXR1cm4gbmVuYyB8fCBlbmM7XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy5cbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XG4gIHZhciBuYjtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcbiAgICAgIG5iID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcbiAgICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcbn1cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciByO1xuICB2YXIgaTtcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XG4gIHJldHVybiByIHx8ICcnO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcblxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59O1xuXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXG4vLyBjb250aW51YXRpb24gYnl0ZS4gSWYgYW4gaW52YWxpZCBieXRlIGlzIGRldGVjdGVkLCAtMiBpcyByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcbiAgcmV0dXJuIGJ5dGUgPj4gNiA9PT0gMHgwMiA/IC0xIDogLTI7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIGEgc2luZ2xlIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoJ1xcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcbi8vIGxvb3AuXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XG4gICAgcmV0dXJuICdcXHVmZmZkJztcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgfVxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcbiAgICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBhZGRlZCB3aGVuIGVuZGluZyBvbiBhIHBhcnRpYWxcbi8vIGNoYXJhY3Rlci5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5QYXNzVGhyb3VnaFxuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlRyYW5zZm9ybVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwidmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xudmFyIHNvY2tqcyA9IHJlcXVpcmUoJ3NvY2tqcy1jbGllbnQnKTtcbnZhciByZXNvbHZlID0gcmVxdWlyZSgndXJsJykucmVzb2x2ZTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJ3VybCcpLnBhcnNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1LCBjYikge1xuICAgIHZhciB1cmkgPSBwYXJzZSh1KS5wcm90b2NvbCA/IHUgOiByZXNvbHZlKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCB1KTtcbiAgICBcbiAgICB2YXIgc3RyZWFtID0gbmV3IFN0cmVhbTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSB0cnVlO1xuICAgIHN0cmVhbS53cml0YWJsZSA9IHRydWU7XG4gICAgXG4gICAgdmFyIHJlYWR5ID0gZmFsc2U7XG4gICAgdmFyIGJ1ZmZlciA9IFtdO1xuICAgIFxuICAgIHZhciBzb2NrID0gc29ja2pzKHVyaSk7XG4gICAgc3RyZWFtLnNvY2sgPSBzb2NrO1xuICAgIFxuICAgIHN0cmVhbS53cml0ZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgaWYgKCFyZWFkeSB8fCBidWZmZXIubGVuZ3RoKSBidWZmZXIucHVzaChtc2cpXG4gICAgICAgIGVsc2Ugc29jay5zZW5kKG1zZylcbiAgICB9O1xuICAgIFxuICAgIHN0cmVhbS5lbmQgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIGlmIChtc2cgIT09IHVuZGVmaW5lZCkgc3RyZWFtLndyaXRlKG1zZyk7XG4gICAgICAgIGlmICghcmVhZHkpIHtcbiAgICAgICAgICAgIHN0cmVhbS5fZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICBzb2NrLmNsb3NlKCk7XG4gICAgfTtcbiAgICBcbiAgICBzdHJlYW0uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3RyZWFtLl9lbmRlZCA9IHRydWU7XG4gICAgICAgIHN0cmVhbS53cml0YWJsZSA9IHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgICBidWZmZXIubGVuZ3RoID0gMFxuICAgICAgICBzb2NrLmNsb3NlKCk7XG4gICAgfTtcbiAgICBcbiAgICBzb2NrLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykgY2IoKTtcbiAgICAgICAgcmVhZHkgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc29jay5zZW5kKGJ1ZmZlcltpXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyID0gW107XG4gICAgICAgIHN0cmVhbS5lbWl0KCdjb25uZWN0Jyk7XG4gICAgICAgIGlmIChzdHJlYW0uX2VuZGVkKSBzdHJlYW0uZW5kKCk7XG4gICAgfTtcbiAgICBcbiAgICBzb2NrLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgZS5kYXRhKTtcbiAgICB9O1xuICAgIFxuICAgIHNvY2sub25jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICAgICAgICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gc3RyZWFtO1xufTtcbiIsIi8qIFNvY2tKUyBjbGllbnQsIHZlcnNpb24gMC4zLjEuNy5nYTY3Zi5kaXJ0eSwgaHR0cDovL3NvY2tqcy5vcmcsIE1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuXG4qL1xuXG4vLyBKU09OMiBieSBEb3VnbGFzIENyb2NrZm9yZCAobWluaWZpZWQpLlxudmFyIEpTT047SlNPTnx8KEpTT049e30pLGZ1bmN0aW9uKCl7ZnVuY3Rpb24gc3RyKGEsYil7dmFyIGMsZCxlLGYsZz1nYXAsaCxpPWJbYV07aSYmdHlwZW9mIGk9PVwib2JqZWN0XCImJnR5cGVvZiBpLnRvSlNPTj09XCJmdW5jdGlvblwiJiYoaT1pLnRvSlNPTihhKSksdHlwZW9mIHJlcD09XCJmdW5jdGlvblwiJiYoaT1yZXAuY2FsbChiLGEsaSkpO3N3aXRjaCh0eXBlb2YgaSl7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIHF1b3RlKGkpO2Nhc2VcIm51bWJlclwiOnJldHVybiBpc0Zpbml0ZShpKT9TdHJpbmcoaSk6XCJudWxsXCI7Y2FzZVwiYm9vbGVhblwiOmNhc2VcIm51bGxcIjpyZXR1cm4gU3RyaW5nKGkpO2Nhc2VcIm9iamVjdFwiOmlmKCFpKXJldHVyblwibnVsbFwiO2dhcCs9aW5kZW50LGg9W107aWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShpKT09PVwiW29iamVjdCBBcnJheV1cIil7Zj1pLmxlbmd0aDtmb3IoYz0wO2M8ZjtjKz0xKWhbY109c3RyKGMsaSl8fFwibnVsbFwiO2U9aC5sZW5ndGg9PT0wP1wiW11cIjpnYXA/XCJbXFxuXCIrZ2FwK2guam9pbihcIixcXG5cIitnYXApK1wiXFxuXCIrZytcIl1cIjpcIltcIitoLmpvaW4oXCIsXCIpK1wiXVwiLGdhcD1nO3JldHVybiBlfWlmKHJlcCYmdHlwZW9mIHJlcD09XCJvYmplY3RcIil7Zj1yZXAubGVuZ3RoO2ZvcihjPTA7YzxmO2MrPTEpdHlwZW9mIHJlcFtjXT09XCJzdHJpbmdcIiYmKGQ9cmVwW2NdLGU9c3RyKGQsaSksZSYmaC5wdXNoKHF1b3RlKGQpKyhnYXA/XCI6IFwiOlwiOlwiKStlKSl9ZWxzZSBmb3IoZCBpbiBpKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLGQpJiYoZT1zdHIoZCxpKSxlJiZoLnB1c2gocXVvdGUoZCkrKGdhcD9cIjogXCI6XCI6XCIpK2UpKTtlPWgubGVuZ3RoPT09MD9cInt9XCI6Z2FwP1wie1xcblwiK2dhcCtoLmpvaW4oXCIsXFxuXCIrZ2FwKStcIlxcblwiK2crXCJ9XCI6XCJ7XCIraC5qb2luKFwiLFwiKStcIn1cIixnYXA9ZztyZXR1cm4gZX19ZnVuY3Rpb24gcXVvdGUoYSl7ZXNjYXBhYmxlLmxhc3RJbmRleD0wO3JldHVybiBlc2NhcGFibGUudGVzdChhKT8nXCInK2EucmVwbGFjZShlc2NhcGFibGUsZnVuY3Rpb24oYSl7dmFyIGI9bWV0YVthXTtyZXR1cm4gdHlwZW9mIGI9PVwic3RyaW5nXCI/YjpcIlxcXFx1XCIrKFwiMDAwMFwiK2EuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KX0pKydcIic6J1wiJythKydcIid9ZnVuY3Rpb24gZihhKXtyZXR1cm4gYTwxMD9cIjBcIithOmF9XCJ1c2Ugc3RyaWN0XCIsdHlwZW9mIERhdGUucHJvdG90eXBlLnRvSlNPTiE9XCJmdW5jdGlvblwiJiYoRGF0ZS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKGEpe3JldHVybiBpc0Zpbml0ZSh0aGlzLnZhbHVlT2YoKSk/dGhpcy5nZXRVVENGdWxsWWVhcigpK1wiLVwiK2YodGhpcy5nZXRVVENNb250aCgpKzEpK1wiLVwiK2YodGhpcy5nZXRVVENEYXRlKCkpK1wiVFwiK2YodGhpcy5nZXRVVENIb3VycygpKStcIjpcIitmKHRoaXMuZ2V0VVRDTWludXRlcygpKStcIjpcIitmKHRoaXMuZ2V0VVRDU2Vjb25kcygpKStcIlpcIjpudWxsfSxTdHJpbmcucHJvdG90eXBlLnRvSlNPTj1OdW1iZXIucHJvdG90eXBlLnRvSlNPTj1Cb29sZWFuLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMudmFsdWVPZigpfSk7dmFyIGN4PS9bXFx1MDAwMFxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLGVzY2FwYWJsZT0vW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHg5ZlxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLGdhcCxpbmRlbnQsbWV0YT17XCJcXGJcIjpcIlxcXFxiXCIsXCJcXHRcIjpcIlxcXFx0XCIsXCJcXG5cIjpcIlxcXFxuXCIsXCJcXGZcIjpcIlxcXFxmXCIsXCJcXHJcIjpcIlxcXFxyXCIsJ1wiJzonXFxcXFwiJyxcIlxcXFxcIjpcIlxcXFxcXFxcXCJ9LHJlcDt0eXBlb2YgSlNPTi5zdHJpbmdpZnkhPVwiZnVuY3Rpb25cIiYmKEpTT04uc3RyaW5naWZ5PWZ1bmN0aW9uKGEsYixjKXt2YXIgZDtnYXA9XCJcIixpbmRlbnQ9XCJcIjtpZih0eXBlb2YgYz09XCJudW1iZXJcIilmb3IoZD0wO2Q8YztkKz0xKWluZGVudCs9XCIgXCI7ZWxzZSB0eXBlb2YgYz09XCJzdHJpbmdcIiYmKGluZGVudD1jKTtyZXA9YjtpZighYnx8dHlwZW9mIGI9PVwiZnVuY3Rpb25cInx8dHlwZW9mIGI9PVwib2JqZWN0XCImJnR5cGVvZiBiLmxlbmd0aD09XCJudW1iZXJcIilyZXR1cm4gc3RyKFwiXCIse1wiXCI6YX0pO3Rocm93IG5ldyBFcnJvcihcIkpTT04uc3RyaW5naWZ5XCIpfSksdHlwZW9mIEpTT04ucGFyc2UhPVwiZnVuY3Rpb25cIiYmKEpTT04ucGFyc2U9ZnVuY3Rpb24odGV4dCxyZXZpdmVyKXtmdW5jdGlvbiB3YWxrKGEsYil7dmFyIGMsZCxlPWFbYl07aWYoZSYmdHlwZW9mIGU9PVwib2JqZWN0XCIpZm9yKGMgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxjKSYmKGQ9d2FsayhlLGMpLGQhPT11bmRlZmluZWQ/ZVtjXT1kOmRlbGV0ZSBlW2NdKTtyZXR1cm4gcmV2aXZlci5jYWxsKGEsYixlKX12YXIgajt0ZXh0PVN0cmluZyh0ZXh0KSxjeC5sYXN0SW5kZXg9MCxjeC50ZXN0KHRleHQpJiYodGV4dD10ZXh0LnJlcGxhY2UoY3gsZnVuY3Rpb24oYSl7cmV0dXJuXCJcXFxcdVwiKyhcIjAwMDBcIithLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCl9KSk7aWYoL15bXFxdLDp7fVxcc10qJC8udGVzdCh0ZXh0LnJlcGxhY2UoL1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbMC05YS1mQS1GXXs0fSkvZyxcIkBcIikucmVwbGFjZSgvXCJbXlwiXFxcXFxcblxccl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2csXCJdXCIpLnJlcGxhY2UoLyg/Ol58OnwsKSg/OlxccypcXFspKy9nLFwiXCIpKSl7aj1ldmFsKFwiKFwiK3RleHQrXCIpXCIpO3JldHVybiB0eXBlb2YgcmV2aXZlcj09XCJmdW5jdGlvblwiP3dhbGsoe1wiXCI6an0sXCJcIik6an10aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJKU09OLnBhcnNlXCIpfSl9KClcblxuXG4vLyAgICAgWypdIEluY2x1ZGluZyBsaWIvaW5kZXguanNcbi8vIFB1YmxpYyBvYmplY3RcbnZhciBTb2NrSlMgPSAoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgdmFyIF9kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICAgICAgICB2YXIgX3dpbmRvdyA9IHdpbmRvdztcbiAgICAgICAgICAgICAgdmFyIHV0aWxzID0ge307XG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi9yZXZlbnR0YXJnZXQuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbi8qIFNpbXBsaWZpZWQgaW1wbGVtZW50YXRpb24gb2YgRE9NMiBFdmVudFRhcmdldC5cbiAqICAgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItRXZlbnRzL2V2ZW50cy5odG1sI0V2ZW50cy1FdmVudFRhcmdldFxuICovXG52YXIgUkV2ZW50VGFyZ2V0ID0gZnVuY3Rpb24oKSB7fTtcblJFdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYoIXRoaXMuX2xpc3RlbmVycykge1xuICAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgfVxuICAgIGlmKCEoZXZlbnRUeXBlIGluIHRoaXMuX2xpc3RlbmVycykpIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV0gPSBbXTtcbiAgICB9XG4gICAgdmFyIGFyciA9IHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICAgIGlmKHV0aWxzLmFyckluZGV4T2YoYXJyLCBsaXN0ZW5lcikgPT09IC0xKSB7XG4gICAgICAgIGFyci5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgcmV0dXJuO1xufTtcblxuUkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZighKHRoaXMuX2xpc3RlbmVycyAmJiAoZXZlbnRUeXBlIGluIHRoaXMuX2xpc3RlbmVycykpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGFyciA9IHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICAgIHZhciBpZHggPSB1dGlscy5hcnJJbmRleE9mKGFyciwgbGlzdGVuZXIpO1xuICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgIGlmKGFyci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IGFyci5zbGljZSgwLCBpZHgpLmNvbmNhdCggYXJyLnNsaWNlKGlkeCsxKSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuO1xufTtcblxuUkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHQgPSBldmVudC50eXBlO1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICBpZiAodGhpc1snb24nK3RdKSB7XG4gICAgICAgIHRoaXNbJ29uJyt0XS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpc3RlbmVycyAmJiB0IGluIHRoaXMuX2xpc3RlbmVycykge1xuICAgICAgICBmb3IodmFyIGk9MDsgaSA8IHRoaXMuX2xpc3RlbmVyc1t0XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW3RdW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvcmV2ZW50dGFyZ2V0LmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi9zaW1wbGVldmVudC5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxudmFyIFNpbXBsZUV2ZW50ID0gZnVuY3Rpb24odHlwZSwgb2JqKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZm9yKHZhciBrIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoaykpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpc1trXSA9IG9ialtrXTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblNpbXBsZUV2ZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByID0gW107XG4gICAgZm9yKHZhciBrIGluIHRoaXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KGspKSBjb250aW51ZTtcbiAgICAgICAgdmFyIHYgPSB0aGlzW2tdO1xuICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdmdW5jdGlvbicpIHYgPSAnW2Z1bmN0aW9uXSc7XG4gICAgICAgIHIucHVzaChrICsgJz0nICsgdik7XG4gICAgfVxuICAgIHJldHVybiAnU2ltcGxlRXZlbnQoJyArIHIuam9pbignLCAnKSArICcpJztcbn07XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL3NpbXBsZWV2ZW50LmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi9ldmVudGVtaXR0ZXIuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbnZhciBFdmVudEVtaXR0ZXIgPSBmdW5jdGlvbihldmVudHMpIHtcbiAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cyB8fCBbXTtcbn07XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBpZiAoIXRoYXQubnVrZWQgJiYgdGhhdFsnb24nK3R5cGVdKSB7XG4gICAgICAgIHRoYXRbJ29uJyt0eXBlXS5hcHBseSh0aGF0LCBhcmdzKTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmFyckluZGV4T2YodGhhdC5ldmVudHMsIHR5cGUpID09PSAtMSkge1xuICAgICAgICB1dGlscy5sb2coJ0V2ZW50ICcgKyBKU09OLnN0cmluZ2lmeSh0eXBlKSArXG4gICAgICAgICAgICAgICAgICAnIG5vdCBsaXN0ZWQgJyArIEpTT04uc3RyaW5naWZ5KHRoYXQuZXZlbnRzKSArXG4gICAgICAgICAgICAgICAgICAnIGluICcgKyB0aGF0KTtcbiAgICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm51a2UgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoYXQubnVrZWQgPSB0cnVlO1xuICAgIGZvcih2YXIgaT0wOyBpPHRoYXQuZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlbGV0ZSB0aGF0W3RoYXQuZXZlbnRzW2ldXTtcbiAgICB9XG59O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi9ldmVudGVtaXR0ZXIuanNcblxuXG4vLyAgICAgICAgIFsqXSBJbmNsdWRpbmcgbGliL3V0aWxzLmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG52YXIgcmFuZG9tX3N0cmluZ19jaGFycyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlfJztcbnV0aWxzLnJhbmRvbV9zdHJpbmcgPSBmdW5jdGlvbihsZW5ndGgsIG1heCkge1xuICAgIG1heCA9IG1heCB8fCByYW5kb21fc3RyaW5nX2NoYXJzLmxlbmd0aDtcbiAgICB2YXIgaSwgcmV0ID0gW107XG4gICAgZm9yKGk9MDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJldC5wdXNoKCByYW5kb21fc3RyaW5nX2NoYXJzLnN1YnN0cihNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXgpLDEpICk7XG4gICAgfVxuICAgIHJldHVybiByZXQuam9pbignJyk7XG59O1xudXRpbHMucmFuZG9tX251bWJlciA9IGZ1bmN0aW9uKG1heCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXgpO1xufTtcbnV0aWxzLnJhbmRvbV9udW1iZXJfc3RyaW5nID0gZnVuY3Rpb24obWF4KSB7XG4gICAgdmFyIHQgPSAoJycrKG1heCAtIDEpKS5sZW5ndGg7XG4gICAgdmFyIHAgPSBBcnJheSh0KzEpLmpvaW4oJzAnKTtcbiAgICByZXR1cm4gKHAgKyB1dGlscy5yYW5kb21fbnVtYmVyKG1heCkpLnNsaWNlKC10KTtcbn07XG5cbi8vIEFzc3VtaW5nIHRoYXQgdXJsIGxvb2tzIGxpa2U6IGh0dHA6Ly9hc2Rhc2Q6MTExL2FzZFxudXRpbHMuZ2V0T3JpZ2luID0gZnVuY3Rpb24odXJsKSB7XG4gICAgdXJsICs9ICcvJztcbiAgICB2YXIgcGFydHMgPSB1cmwuc3BsaXQoJy8nKS5zbGljZSgwLCAzKTtcbiAgICByZXR1cm4gcGFydHMuam9pbignLycpO1xufTtcblxudXRpbHMuaXNTYW1lT3JpZ2luVXJsID0gZnVuY3Rpb24odXJsX2EsIHVybF9iKSB7XG4gICAgLy8gbG9jYXRpb24ub3JpZ2luIHdvdWxkIGRvLCBidXQgaXQncyBub3QgYWx3YXlzIGF2YWlsYWJsZS5cbiAgICBpZiAoIXVybF9iKSB1cmxfYiA9IF93aW5kb3cubG9jYXRpb24uaHJlZjtcblxuICAgIHJldHVybiAodXJsX2Euc3BsaXQoJy8nKS5zbGljZSgwLDMpLmpvaW4oJy8nKVxuICAgICAgICAgICAgICAgID09PVxuICAgICAgICAgICAgdXJsX2Iuc3BsaXQoJy8nKS5zbGljZSgwLDMpLmpvaW4oJy8nKSk7XG59O1xuXG51dGlscy5nZXRQYXJlbnREb21haW4gPSBmdW5jdGlvbih1cmwpIHtcbiAgICAvLyBpcHY0IGlwIGFkZHJlc3NcbiAgICBpZiAoL15bMC05Ll0qJC8udGVzdCh1cmwpKSByZXR1cm4gdXJsO1xuICAgIC8vIGlwdjYgaXAgYWRkcmVzc1xuICAgIGlmICgvXlxcWy8udGVzdCh1cmwpKSByZXR1cm4gdXJsO1xuICAgIC8vIG5vIGRvdHNcbiAgICBpZiAoISgvWy5dLy50ZXN0KHVybCkpKSByZXR1cm4gdXJsO1xuXG4gICAgdmFyIHBhcnRzID0gdXJsLnNwbGl0KCcuJykuc2xpY2UoMSk7XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJy4nKTtcbn07XG5cbnV0aWxzLm9iamVjdEV4dGVuZCA9IGZ1bmN0aW9uKGRzdCwgc3JjKSB7XG4gICAgZm9yKHZhciBrIGluIHNyYykge1xuICAgICAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICBkc3Rba10gPSBzcmNba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRzdDtcbn07XG5cbnZhciBXUHJlZml4ID0gJ19qcCc7XG5cbnV0aWxzLnBvbGx1dGVHbG9iYWxOYW1lc3BhY2UgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIShXUHJlZml4IGluIF93aW5kb3cpKSB7XG4gICAgICAgIF93aW5kb3dbV1ByZWZpeF0gPSB7fTtcbiAgICB9XG59O1xuXG51dGlscy5jbG9zZUZyYW1lID0gZnVuY3Rpb24gKGNvZGUsIHJlYXNvbikge1xuICAgIHJldHVybiAnYycrSlNPTi5zdHJpbmdpZnkoW2NvZGUsIHJlYXNvbl0pO1xufTtcblxudXRpbHMudXNlclNldENvZGUgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09PSAxMDAwIHx8IChjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5KTtcbn07XG5cbi8vIFNlZTogaHR0cDovL3d3dy5lcmcuYWJkbi5hYy51ay9+Z2Vycml0L2RjY3Avbm90ZXMvY2NpZDIvcnRvX2VzdGltYXRvci9cbi8vIGFuZCBSRkMgMjk4OC5cbnV0aWxzLmNvdW50UlRPID0gZnVuY3Rpb24gKHJ0dCkge1xuICAgIHZhciBydG87XG4gICAgaWYgKHJ0dCA+IDEwMCkge1xuICAgICAgICBydG8gPSAzICogcnR0OyAvLyBydG8gPiAzMDBtc2VjXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcnRvID0gcnR0ICsgMjAwOyAvLyAyMDBtc2VjIDwgcnRvIDw9IDMwMG1zZWNcbiAgICB9XG4gICAgcmV0dXJuIHJ0bztcbn1cblxudXRpbHMubG9nID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKF93aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLmxvZyAmJiBjb25zb2xlLmxvZy5hcHBseSkge1xuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgIH1cbn07XG5cbnV0aWxzLmJpbmQgPSBmdW5jdGlvbihmdW4sIHRoYXQpIHtcbiAgICBpZiAoZnVuLmJpbmQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bi5iaW5kKHRoYXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG51dGlscy5mbGF0VXJsID0gZnVuY3Rpb24odXJsKSB7XG4gICAgcmV0dXJuIHVybC5pbmRleE9mKCc/JykgPT09IC0xICYmIHVybC5pbmRleE9mKCcjJykgPT09IC0xO1xufTtcblxudXRpbHMuYW1lbmRVcmwgPSBmdW5jdGlvbih1cmwpIHtcbiAgICB2YXIgZGwgPSBfZG9jdW1lbnQubG9jYXRpb247XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyB1cmwgZm9yIFNvY2tKUycpO1xuICAgIH1cbiAgICBpZiAoIXV0aWxzLmZsYXRVcmwodXJsKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgYmFzaWMgdXJscyBhcmUgc3VwcG9ydGVkIGluIFNvY2tKUycpO1xuICAgIH1cblxuICAgIC8vICAnLy9hYmMnIC0tPiAnaHR0cDovL2FiYydcbiAgICBpZiAodXJsLmluZGV4T2YoJy8vJykgPT09IDApIHtcbiAgICAgICAgdXJsID0gZGwucHJvdG9jb2wgKyB1cmw7XG4gICAgfVxuICAgIC8vICcvYWJjJyAtLT4gJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAvYWJjJ1xuICAgIGlmICh1cmwuaW5kZXhPZignLycpID09PSAwKSB7XG4gICAgICAgIHVybCA9IGRsLnByb3RvY29sICsgJy8vJyArIGRsLmhvc3QgKyB1cmw7XG4gICAgfVxuICAgIC8vIHN0cmlwIHRyYWlsaW5nIHNsYXNoZXNcbiAgICB1cmwgPSB1cmwucmVwbGFjZSgvWy9dKyQvLCcnKTtcbiAgICByZXR1cm4gdXJsO1xufTtcblxuLy8gSUUgZG9lc24ndCBzdXBwb3J0IFtdLmluZGV4T2YuXG51dGlscy5hcnJJbmRleE9mID0gZnVuY3Rpb24oYXJyLCBvYmope1xuICAgIGZvcih2YXIgaT0wOyBpIDwgYXJyLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYoYXJyW2ldID09PSBvYmope1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcblxudXRpbHMuYXJyU2tpcCA9IGZ1bmN0aW9uKGFyciwgb2JqKSB7XG4gICAgdmFyIGlkeCA9IHV0aWxzLmFyckluZGV4T2YoYXJyLCBvYmopO1xuICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBhcnIuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZHN0ID0gYXJyLnNsaWNlKDAsIGlkeCk7XG4gICAgICAgIHJldHVybiBkc3QuY29uY2F0KGFyci5zbGljZShpZHgrMSkpO1xuICAgIH1cbn07XG5cbi8vIFZpYTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTEzMzEyMi8yMTIxYzYwMWM1NTQ5MTU1NDgzZjUwYmUzZGE1MzA1ZTgzYjhjNWRmXG51dGlscy5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB7fS50b1N0cmluZy5jYWxsKHZhbHVlKS5pbmRleE9mKCdBcnJheScpID49IDBcbn07XG5cbnV0aWxzLmRlbGF5ID0gZnVuY3Rpb24odCwgZnVuKSB7XG4gICAgaWYodHlwZW9mIHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZnVuID0gdDtcbiAgICAgICAgdCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgdCk7XG59O1xuXG5cbi8vIENoYXJzIHdvcnRoIGVzY2FwaW5nLCBhcyBkZWZpbmVkIGJ5IERvdWdsYXMgQ3JvY2tmb3JkOlxuLy8gICBodHRwczovL2dpdGh1Yi5jb20vZG91Z2xhc2Nyb2NrZm9yZC9KU09OLWpzL2Jsb2IvNDdhOTg4MmNkZGViMWU4NTI5ZTA3YWY5NzM2MjE4MDc1MzcyYjhhYy9qc29uMi5qcyNMMTk2XG52YXIganNvbl9lc2NhcGFibGUgPSAvW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHg5ZlxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgIGpzb25fbG9va3VwID0ge1xuXCJcXHUwMDAwXCI6XCJcXFxcdTAwMDBcIixcIlxcdTAwMDFcIjpcIlxcXFx1MDAwMVwiLFwiXFx1MDAwMlwiOlwiXFxcXHUwMDAyXCIsXCJcXHUwMDAzXCI6XCJcXFxcdTAwMDNcIixcblwiXFx1MDAwNFwiOlwiXFxcXHUwMDA0XCIsXCJcXHUwMDA1XCI6XCJcXFxcdTAwMDVcIixcIlxcdTAwMDZcIjpcIlxcXFx1MDAwNlwiLFwiXFx1MDAwN1wiOlwiXFxcXHUwMDA3XCIsXG5cIlxcYlwiOlwiXFxcXGJcIixcIlxcdFwiOlwiXFxcXHRcIixcIlxcblwiOlwiXFxcXG5cIixcIlxcdTAwMGJcIjpcIlxcXFx1MDAwYlwiLFwiXFxmXCI6XCJcXFxcZlwiLFwiXFxyXCI6XCJcXFxcclwiLFxuXCJcXHUwMDBlXCI6XCJcXFxcdTAwMGVcIixcIlxcdTAwMGZcIjpcIlxcXFx1MDAwZlwiLFwiXFx1MDAxMFwiOlwiXFxcXHUwMDEwXCIsXCJcXHUwMDExXCI6XCJcXFxcdTAwMTFcIixcblwiXFx1MDAxMlwiOlwiXFxcXHUwMDEyXCIsXCJcXHUwMDEzXCI6XCJcXFxcdTAwMTNcIixcIlxcdTAwMTRcIjpcIlxcXFx1MDAxNFwiLFwiXFx1MDAxNVwiOlwiXFxcXHUwMDE1XCIsXG5cIlxcdTAwMTZcIjpcIlxcXFx1MDAxNlwiLFwiXFx1MDAxN1wiOlwiXFxcXHUwMDE3XCIsXCJcXHUwMDE4XCI6XCJcXFxcdTAwMThcIixcIlxcdTAwMTlcIjpcIlxcXFx1MDAxOVwiLFxuXCJcXHUwMDFhXCI6XCJcXFxcdTAwMWFcIixcIlxcdTAwMWJcIjpcIlxcXFx1MDAxYlwiLFwiXFx1MDAxY1wiOlwiXFxcXHUwMDFjXCIsXCJcXHUwMDFkXCI6XCJcXFxcdTAwMWRcIixcblwiXFx1MDAxZVwiOlwiXFxcXHUwMDFlXCIsXCJcXHUwMDFmXCI6XCJcXFxcdTAwMWZcIixcIlxcXCJcIjpcIlxcXFxcXFwiXCIsXCJcXFxcXCI6XCJcXFxcXFxcXFwiLFxuXCJcXHUwMDdmXCI6XCJcXFxcdTAwN2ZcIixcIlxcdTAwODBcIjpcIlxcXFx1MDA4MFwiLFwiXFx1MDA4MVwiOlwiXFxcXHUwMDgxXCIsXCJcXHUwMDgyXCI6XCJcXFxcdTAwODJcIixcblwiXFx1MDA4M1wiOlwiXFxcXHUwMDgzXCIsXCJcXHUwMDg0XCI6XCJcXFxcdTAwODRcIixcIlxcdTAwODVcIjpcIlxcXFx1MDA4NVwiLFwiXFx1MDA4NlwiOlwiXFxcXHUwMDg2XCIsXG5cIlxcdTAwODdcIjpcIlxcXFx1MDA4N1wiLFwiXFx1MDA4OFwiOlwiXFxcXHUwMDg4XCIsXCJcXHUwMDg5XCI6XCJcXFxcdTAwODlcIixcIlxcdTAwOGFcIjpcIlxcXFx1MDA4YVwiLFxuXCJcXHUwMDhiXCI6XCJcXFxcdTAwOGJcIixcIlxcdTAwOGNcIjpcIlxcXFx1MDA4Y1wiLFwiXFx1MDA4ZFwiOlwiXFxcXHUwMDhkXCIsXCJcXHUwMDhlXCI6XCJcXFxcdTAwOGVcIixcblwiXFx1MDA4ZlwiOlwiXFxcXHUwMDhmXCIsXCJcXHUwMDkwXCI6XCJcXFxcdTAwOTBcIixcIlxcdTAwOTFcIjpcIlxcXFx1MDA5MVwiLFwiXFx1MDA5MlwiOlwiXFxcXHUwMDkyXCIsXG5cIlxcdTAwOTNcIjpcIlxcXFx1MDA5M1wiLFwiXFx1MDA5NFwiOlwiXFxcXHUwMDk0XCIsXCJcXHUwMDk1XCI6XCJcXFxcdTAwOTVcIixcIlxcdTAwOTZcIjpcIlxcXFx1MDA5NlwiLFxuXCJcXHUwMDk3XCI6XCJcXFxcdTAwOTdcIixcIlxcdTAwOThcIjpcIlxcXFx1MDA5OFwiLFwiXFx1MDA5OVwiOlwiXFxcXHUwMDk5XCIsXCJcXHUwMDlhXCI6XCJcXFxcdTAwOWFcIixcblwiXFx1MDA5YlwiOlwiXFxcXHUwMDliXCIsXCJcXHUwMDljXCI6XCJcXFxcdTAwOWNcIixcIlxcdTAwOWRcIjpcIlxcXFx1MDA5ZFwiLFwiXFx1MDA5ZVwiOlwiXFxcXHUwMDllXCIsXG5cIlxcdTAwOWZcIjpcIlxcXFx1MDA5ZlwiLFwiXFx1MDBhZFwiOlwiXFxcXHUwMGFkXCIsXCJcXHUwNjAwXCI6XCJcXFxcdTA2MDBcIixcIlxcdTA2MDFcIjpcIlxcXFx1MDYwMVwiLFxuXCJcXHUwNjAyXCI6XCJcXFxcdTA2MDJcIixcIlxcdTA2MDNcIjpcIlxcXFx1MDYwM1wiLFwiXFx1MDYwNFwiOlwiXFxcXHUwNjA0XCIsXCJcXHUwNzBmXCI6XCJcXFxcdTA3MGZcIixcblwiXFx1MTdiNFwiOlwiXFxcXHUxN2I0XCIsXCJcXHUxN2I1XCI6XCJcXFxcdTE3YjVcIixcIlxcdTIwMGNcIjpcIlxcXFx1MjAwY1wiLFwiXFx1MjAwZFwiOlwiXFxcXHUyMDBkXCIsXG5cIlxcdTIwMGVcIjpcIlxcXFx1MjAwZVwiLFwiXFx1MjAwZlwiOlwiXFxcXHUyMDBmXCIsXCJcXHUyMDI4XCI6XCJcXFxcdTIwMjhcIixcIlxcdTIwMjlcIjpcIlxcXFx1MjAyOVwiLFxuXCJcXHUyMDJhXCI6XCJcXFxcdTIwMmFcIixcIlxcdTIwMmJcIjpcIlxcXFx1MjAyYlwiLFwiXFx1MjAyY1wiOlwiXFxcXHUyMDJjXCIsXCJcXHUyMDJkXCI6XCJcXFxcdTIwMmRcIixcblwiXFx1MjAyZVwiOlwiXFxcXHUyMDJlXCIsXCJcXHUyMDJmXCI6XCJcXFxcdTIwMmZcIixcIlxcdTIwNjBcIjpcIlxcXFx1MjA2MFwiLFwiXFx1MjA2MVwiOlwiXFxcXHUyMDYxXCIsXG5cIlxcdTIwNjJcIjpcIlxcXFx1MjA2MlwiLFwiXFx1MjA2M1wiOlwiXFxcXHUyMDYzXCIsXCJcXHUyMDY0XCI6XCJcXFxcdTIwNjRcIixcIlxcdTIwNjVcIjpcIlxcXFx1MjA2NVwiLFxuXCJcXHUyMDY2XCI6XCJcXFxcdTIwNjZcIixcIlxcdTIwNjdcIjpcIlxcXFx1MjA2N1wiLFwiXFx1MjA2OFwiOlwiXFxcXHUyMDY4XCIsXCJcXHUyMDY5XCI6XCJcXFxcdTIwNjlcIixcblwiXFx1MjA2YVwiOlwiXFxcXHUyMDZhXCIsXCJcXHUyMDZiXCI6XCJcXFxcdTIwNmJcIixcIlxcdTIwNmNcIjpcIlxcXFx1MjA2Y1wiLFwiXFx1MjA2ZFwiOlwiXFxcXHUyMDZkXCIsXG5cIlxcdTIwNmVcIjpcIlxcXFx1MjA2ZVwiLFwiXFx1MjA2ZlwiOlwiXFxcXHUyMDZmXCIsXCJcXHVmZWZmXCI6XCJcXFxcdWZlZmZcIixcIlxcdWZmZjBcIjpcIlxcXFx1ZmZmMFwiLFxuXCJcXHVmZmYxXCI6XCJcXFxcdWZmZjFcIixcIlxcdWZmZjJcIjpcIlxcXFx1ZmZmMlwiLFwiXFx1ZmZmM1wiOlwiXFxcXHVmZmYzXCIsXCJcXHVmZmY0XCI6XCJcXFxcdWZmZjRcIixcblwiXFx1ZmZmNVwiOlwiXFxcXHVmZmY1XCIsXCJcXHVmZmY2XCI6XCJcXFxcdWZmZjZcIixcIlxcdWZmZjdcIjpcIlxcXFx1ZmZmN1wiLFwiXFx1ZmZmOFwiOlwiXFxcXHVmZmY4XCIsXG5cIlxcdWZmZjlcIjpcIlxcXFx1ZmZmOVwiLFwiXFx1ZmZmYVwiOlwiXFxcXHVmZmZhXCIsXCJcXHVmZmZiXCI6XCJcXFxcdWZmZmJcIixcIlxcdWZmZmNcIjpcIlxcXFx1ZmZmY1wiLFxuXCJcXHVmZmZkXCI6XCJcXFxcdWZmZmRcIixcIlxcdWZmZmVcIjpcIlxcXFx1ZmZmZVwiLFwiXFx1ZmZmZlwiOlwiXFxcXHVmZmZmXCJ9O1xuXG4vLyBTb21lIGV4dHJhIGNoYXJhY3RlcnMgdGhhdCBDaHJvbWUgZ2V0cyB3cm9uZywgYW5kIHN1YnN0aXR1dGVzIHdpdGhcbi8vIHNvbWV0aGluZyBlbHNlIG9uIHRoZSB3aXJlLlxudmFyIGV4dHJhX2VzY2FwYWJsZSA9IC9bXFx4MDAtXFx4MWZcXHVkODAwLVxcdWRmZmZcXHVmZmZlXFx1ZmZmZlxcdTAzMDAtXFx1MDMzM1xcdTAzM2QtXFx1MDM0NlxcdTAzNGEtXFx1MDM0Y1xcdTAzNTAtXFx1MDM1MlxcdTAzNTctXFx1MDM1OFxcdTAzNWMtXFx1MDM2MlxcdTAzNzRcXHUwMzdlXFx1MDM4N1xcdTA1OTEtXFx1MDVhZlxcdTA1YzRcXHUwNjEwLVxcdTA2MTdcXHUwNjUzLVxcdTA2NTRcXHUwNjU3LVxcdTA2NWJcXHUwNjVkLVxcdTA2NWVcXHUwNmRmLVxcdTA2ZTJcXHUwNmViLVxcdTA2ZWNcXHUwNzMwXFx1MDczMi1cXHUwNzMzXFx1MDczNS1cXHUwNzM2XFx1MDczYVxcdTA3M2RcXHUwNzNmLVxcdTA3NDFcXHUwNzQzXFx1MDc0NVxcdTA3NDdcXHUwN2ViLVxcdTA3ZjFcXHUwOTUxXFx1MDk1OC1cXHUwOTVmXFx1MDlkYy1cXHUwOWRkXFx1MDlkZlxcdTBhMzNcXHUwYTM2XFx1MGE1OS1cXHUwYTViXFx1MGE1ZVxcdTBiNWMtXFx1MGI1ZFxcdTBlMzgtXFx1MGUzOVxcdTBmNDNcXHUwZjRkXFx1MGY1MlxcdTBmNTdcXHUwZjVjXFx1MGY2OVxcdTBmNzItXFx1MGY3NlxcdTBmNzhcXHUwZjgwLVxcdTBmODNcXHUwZjkzXFx1MGY5ZFxcdTBmYTJcXHUwZmE3XFx1MGZhY1xcdTBmYjlcXHUxOTM5LVxcdTE5M2FcXHUxYTE3XFx1MWI2YlxcdTFjZGEtXFx1MWNkYlxcdTFkYzAtXFx1MWRjZlxcdTFkZmNcXHUxZGZlXFx1MWY3MVxcdTFmNzNcXHUxZjc1XFx1MWY3N1xcdTFmNzlcXHUxZjdiXFx1MWY3ZFxcdTFmYmJcXHUxZmJlXFx1MWZjOVxcdTFmY2JcXHUxZmQzXFx1MWZkYlxcdTFmZTNcXHUxZmViXFx1MWZlZS1cXHUxZmVmXFx1MWZmOVxcdTFmZmJcXHUxZmZkXFx1MjAwMC1cXHUyMDAxXFx1MjBkMC1cXHUyMGQxXFx1MjBkNC1cXHUyMGQ3XFx1MjBlNy1cXHUyMGU5XFx1MjEyNlxcdTIxMmEtXFx1MjEyYlxcdTIzMjktXFx1MjMyYVxcdTJhZGNcXHUzMDJiLVxcdTMwMmNcXHVhYWIyLVxcdWFhYjNcXHVmOTAwLVxcdWZhMGRcXHVmYTEwXFx1ZmExMlxcdWZhMTUtXFx1ZmExZVxcdWZhMjBcXHVmYTIyXFx1ZmEyNS1cXHVmYTI2XFx1ZmEyYS1cXHVmYTJkXFx1ZmEzMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIxZFxcdWZiMWZcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MC1cXHVmYjQxXFx1ZmI0My1cXHVmYjQ0XFx1ZmI0Ni1cXHVmYjRlXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgIGV4dHJhX2xvb2t1cDtcblxuLy8gSlNPTiBRdW90ZSBzdHJpbmcuIFVzZSBuYXRpdmUgaW1wbGVtZW50YXRpb24gd2hlbiBwb3NzaWJsZS5cbnZhciBKU09OUXVvdGUgPSAoSlNPTiAmJiBKU09OLnN0cmluZ2lmeSkgfHwgZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAganNvbl9lc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICBpZiAoanNvbl9lc2NhcGFibGUudGVzdChzdHJpbmcpKSB7XG4gICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGpzb25fZXNjYXBhYmxlLCBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICByZXR1cm4ganNvbl9sb29rdXBbYV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gJ1wiJyArIHN0cmluZyArICdcIic7XG59O1xuXG4vLyBUaGlzIG1heSBiZSBxdWl0ZSBzbG93LCBzbyBsZXQncyBkZWxheSB1bnRpbCB1c2VyIGFjdHVhbGx5IHVzZXMgYmFkXG4vLyBjaGFyYWN0ZXJzLlxudmFyIHVucm9sbF9sb29rdXAgPSBmdW5jdGlvbihlc2NhcGFibGUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgdW5yb2xsZWQgPSB7fVxuICAgIHZhciBjID0gW11cbiAgICBmb3IoaT0wOyBpPDY1NTM2OyBpKyspIHtcbiAgICAgICAgYy5wdXNoKCBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpICk7XG4gICAgfVxuICAgIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgIGMuam9pbignJykucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHVucm9sbGVkWyBhIF0gPSAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0pO1xuICAgIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiB1bnJvbGxlZDtcbn07XG5cbi8vIFF1b3RlIHN0cmluZywgYWxzbyB0YWtpbmcgY2FyZSBvZiB1bmljb2RlIGNoYXJhY3RlcnMgdGhhdCBicm93c2Vyc1xuLy8gb2Z0ZW4gYnJlYWsuIEVzcGVjaWFsbHksIHRha2UgY2FyZSBvZiB1bmljb2RlIHN1cnJvZ2F0ZXM6XG4vLyAgICBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hcHBpbmdfb2ZfVW5pY29kZV9jaGFyYWN0ZXJzI1N1cnJvZ2F0ZXNcbnV0aWxzLnF1b3RlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIHF1b3RlZCA9IEpTT05RdW90ZShzdHJpbmcpO1xuXG4gICAgLy8gSW4gbW9zdCBjYXNlcyB0aGlzIHNob3VsZCBiZSB2ZXJ5IGZhc3QgYW5kIGdvb2QgZW5vdWdoLlxuICAgIGV4dHJhX2VzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgIGlmKCFleHRyYV9lc2NhcGFibGUudGVzdChxdW90ZWQpKSB7XG4gICAgICAgIHJldHVybiBxdW90ZWQ7XG4gICAgfVxuXG4gICAgaWYoIWV4dHJhX2xvb2t1cCkgZXh0cmFfbG9va3VwID0gdW5yb2xsX2xvb2t1cChleHRyYV9lc2NhcGFibGUpO1xuXG4gICAgcmV0dXJuIHF1b3RlZC5yZXBsYWNlKGV4dHJhX2VzY2FwYWJsZSwgZnVuY3Rpb24oYSkge1xuICAgICAgICByZXR1cm4gZXh0cmFfbG9va3VwW2FdO1xuICAgIH0pO1xufVxuXG52YXIgX2FsbF9wcm90b2NvbHMgPSBbJ3dlYnNvY2tldCcsXG4gICAgICAgICAgICAgICAgICAgICAgJ3hkci1zdHJlYW1pbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICd4aHItc3RyZWFtaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAnaWZyYW1lLWV2ZW50c291cmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAnaWZyYW1lLWh0bWxmaWxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAneGRyLXBvbGxpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICd4aHItcG9sbGluZycsXG4gICAgICAgICAgICAgICAgICAgICAgJ2lmcmFtZS14aHItcG9sbGluZycsXG4gICAgICAgICAgICAgICAgICAgICAgJ2pzb25wLXBvbGxpbmcnXTtcblxudXRpbHMucHJvYmVQcm90b2NvbHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcHJvYmVkID0ge307XG4gICAgZm9yKHZhciBpPTA7IGk8X2FsbF9wcm90b2NvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3RvY29sID0gX2FsbF9wcm90b2NvbHNbaV07XG4gICAgICAgIC8vIFVzZXIgY2FuIGhhdmUgYSB0eXBvIGluIHByb3RvY29sIG5hbWUuXG4gICAgICAgIHByb2JlZFtwcm90b2NvbF0gPSBTb2NrSlNbcHJvdG9jb2xdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBTb2NrSlNbcHJvdG9jb2xdLmVuYWJsZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2JlZDtcbn07XG5cbnV0aWxzLmRldGVjdFByb3RvY29scyA9IGZ1bmN0aW9uKHByb2JlZCwgcHJvdG9jb2xzX3doaXRlbGlzdCwgaW5mbykge1xuICAgIHZhciBwZSA9IHt9LFxuICAgICAgICBwcm90b2NvbHMgPSBbXTtcbiAgICBpZiAoIXByb3RvY29sc193aGl0ZWxpc3QpIHByb3RvY29sc193aGl0ZWxpc3QgPSBfYWxsX3Byb3RvY29scztcbiAgICBmb3IodmFyIGk9MDsgaTxwcm90b2NvbHNfd2hpdGVsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm90b2NvbCA9IHByb3RvY29sc193aGl0ZWxpc3RbaV07XG4gICAgICAgIHBlW3Byb3RvY29sXSA9IHByb2JlZFtwcm90b2NvbF07XG4gICAgfVxuICAgIHZhciBtYXliZV9wdXNoID0gZnVuY3Rpb24ocHJvdG9zKSB7XG4gICAgICAgIHZhciBwcm90byA9IHByb3Rvcy5zaGlmdCgpO1xuICAgICAgICBpZiAocGVbcHJvdG9dKSB7XG4gICAgICAgICAgICBwcm90b2NvbHMucHVzaChwcm90byk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJvdG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBtYXliZV9wdXNoKHByb3Rvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAxLiBXZWJzb2NrZXRcbiAgICBpZiAoaW5mby53ZWJzb2NrZXQgIT09IGZhbHNlKSB7XG4gICAgICAgIG1heWJlX3B1c2goWyd3ZWJzb2NrZXQnXSk7XG4gICAgfVxuXG4gICAgLy8gMi4gU3RyZWFtaW5nXG4gICAgaWYgKHBlWyd4aHItc3RyZWFtaW5nJ10gJiYgIWluZm8ubnVsbF9vcmlnaW4pIHtcbiAgICAgICAgcHJvdG9jb2xzLnB1c2goJ3hoci1zdHJlYW1pbmcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocGVbJ3hkci1zdHJlYW1pbmcnXSAmJiAhaW5mby5jb29raWVfbmVlZGVkICYmICFpbmZvLm51bGxfb3JpZ2luKSB7XG4gICAgICAgICAgICBwcm90b2NvbHMucHVzaCgneGRyLXN0cmVhbWluZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF5YmVfcHVzaChbJ2lmcmFtZS1ldmVudHNvdXJjZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaWZyYW1lLWh0bWxmaWxlJ10pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gMy4gUG9sbGluZ1xuICAgIGlmIChwZVsneGhyLXBvbGxpbmcnXSAmJiAhaW5mby5udWxsX29yaWdpbikge1xuICAgICAgICBwcm90b2NvbHMucHVzaCgneGhyLXBvbGxpbmcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocGVbJ3hkci1wb2xsaW5nJ10gJiYgIWluZm8uY29va2llX25lZWRlZCAmJiAhaW5mby5udWxsX29yaWdpbikge1xuICAgICAgICAgICAgcHJvdG9jb2xzLnB1c2goJ3hkci1wb2xsaW5nJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXliZV9wdXNoKFsnaWZyYW1lLXhoci1wb2xsaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdqc29ucC1wb2xsaW5nJ10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm90b2NvbHM7XG59XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL3V0aWxzLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi9kb20uanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbi8vIE1heSBiZSB1c2VkIGJ5IGh0bWxmaWxlIGpzb25wIGFuZCB0cmFuc3BvcnRzLlxudmFyIE1QcmVmaXggPSAnX3NvY2tqc19nbG9iYWwnO1xudXRpbHMuY3JlYXRlSG9vayA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB3aW5kb3dfaWQgPSAnYScgKyB1dGlscy5yYW5kb21fc3RyaW5nKDgpO1xuICAgIGlmICghKE1QcmVmaXggaW4gX3dpbmRvdykpIHtcbiAgICAgICAgdmFyIG1hcCA9IHt9O1xuICAgICAgICBfd2luZG93W01QcmVmaXhdID0gZnVuY3Rpb24od2luZG93X2lkKSB7XG4gICAgICAgICAgICBpZiAoISh3aW5kb3dfaWQgaW4gbWFwKSkge1xuICAgICAgICAgICAgICAgIG1hcFt3aW5kb3dfaWRdID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogd2luZG93X2lkLFxuICAgICAgICAgICAgICAgICAgICBkZWw6IGZ1bmN0aW9uKCkge2RlbGV0ZSBtYXBbd2luZG93X2lkXTt9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXBbd2luZG93X2lkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX3dpbmRvd1tNUHJlZml4XSh3aW5kb3dfaWQpO1xufTtcblxuXG5cbnV0aWxzLmF0dGFjaE1lc3NhZ2UgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgIHV0aWxzLmF0dGFjaEV2ZW50KCdtZXNzYWdlJywgbGlzdGVuZXIpO1xufTtcbnV0aWxzLmF0dGFjaEV2ZW50ID0gZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBfd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIF93aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJRSBxdWlya3MuXG4gICAgICAgIC8vIEFjY29yZGluZyB0bzogaHR0cDovL3N0ZXZlc291ZGVycy5jb20vbWlzYy90ZXN0LXBvc3RtZXNzYWdlLnBocFxuICAgICAgICAvLyB0aGUgbWVzc2FnZSBnZXRzIGRlbGl2ZXJlZCBvbmx5IHRvICdkb2N1bWVudCcsIG5vdCAnd2luZG93Jy5cbiAgICAgICAgX2RvY3VtZW50LmF0dGFjaEV2ZW50KFwib25cIiArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIC8vIEkgZ2V0ICd3aW5kb3cnIGZvciBpZTguXG4gICAgICAgIF93aW5kb3cuYXR0YWNoRXZlbnQoXCJvblwiICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG59O1xuXG51dGlscy5kZXRhY2hNZXNzYWdlID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICB1dGlscy5kZXRhY2hFdmVudCgnbWVzc2FnZScsIGxpc3RlbmVyKTtcbn07XG51dGlscy5kZXRhY2hFdmVudCA9IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgX3dpbmRvdy5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBfd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2RvY3VtZW50LmRldGFjaEV2ZW50KFwib25cIiArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIF93aW5kb3cuZGV0YWNoRXZlbnQoXCJvblwiICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG59O1xuXG5cbnZhciBvbl91bmxvYWQgPSB7fTtcbi8vIFRoaW5ncyByZWdpc3RlcmVkIGFmdGVyIGJlZm9yZXVubG9hZCBhcmUgdG8gYmUgY2FsbGVkIGltbWVkaWF0ZWx5LlxudmFyIGFmdGVyX3VubG9hZCA9IGZhbHNlO1xuXG52YXIgdHJpZ2dlcl91bmxvYWRfY2FsbGJhY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yKHZhciByZWYgaW4gb25fdW5sb2FkKSB7XG4gICAgICAgIG9uX3VubG9hZFtyZWZdKCk7XG4gICAgICAgIGRlbGV0ZSBvbl91bmxvYWRbcmVmXTtcbiAgICB9O1xufTtcblxudmFyIHVubG9hZF90cmlnZ2VyZWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZihhZnRlcl91bmxvYWQpIHJldHVybjtcbiAgICBhZnRlcl91bmxvYWQgPSB0cnVlO1xuICAgIHRyaWdnZXJfdW5sb2FkX2NhbGxiYWNrcygpO1xufTtcblxuLy8gT25iZWZvcmV1bmxvYWQgYWxvbmUgaXMgbm90IHJlbGlhYmxlLiBXZSBjb3VsZCB1c2Ugb25seSAndW5sb2FkJ1xuLy8gYnV0IGl0J3Mgbm90IHdvcmtpbmcgaW4gb3BlcmEgd2l0aGluIGFuIGlmcmFtZS4gTGV0J3MgdXNlIGJvdGguXG51dGlscy5hdHRhY2hFdmVudCgnYmVmb3JldW5sb2FkJywgdW5sb2FkX3RyaWdnZXJlZCk7XG51dGlscy5hdHRhY2hFdmVudCgndW5sb2FkJywgdW5sb2FkX3RyaWdnZXJlZCk7XG5cbnV0aWxzLnVubG9hZF9hZGQgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgIHZhciByZWYgPSB1dGlscy5yYW5kb21fc3RyaW5nKDgpO1xuICAgIG9uX3VubG9hZFtyZWZdID0gbGlzdGVuZXI7XG4gICAgaWYgKGFmdGVyX3VubG9hZCkge1xuICAgICAgICB1dGlscy5kZWxheSh0cmlnZ2VyX3VubG9hZF9jYWxsYmFja3MpO1xuICAgIH1cbiAgICByZXR1cm4gcmVmO1xufTtcbnV0aWxzLnVubG9hZF9kZWwgPSBmdW5jdGlvbihyZWYpIHtcbiAgICBpZiAocmVmIGluIG9uX3VubG9hZClcbiAgICAgICAgZGVsZXRlIG9uX3VubG9hZFtyZWZdO1xufTtcblxuXG51dGlscy5jcmVhdGVJZnJhbWUgPSBmdW5jdGlvbiAoaWZyYW1lX3VybCwgZXJyb3JfY2FsbGJhY2spIHtcbiAgICB2YXIgaWZyYW1lID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIHZhciB0cmVmLCB1bmxvYWRfcmVmO1xuICAgIHZhciB1bmF0dGFjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICAgIC8vIEV4cGxvcmVyIGhhZCBwcm9ibGVtcyB3aXRoIHRoYXQuXG4gICAgICAgIHRyeSB7aWZyYW1lLm9ubG9hZCA9IG51bGw7fSBjYXRjaCAoeCkge31cbiAgICAgICAgaWZyYW1lLm9uZXJyb3IgPSBudWxsO1xuICAgIH07XG4gICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICAgICAgdW5hdHRhY2goKTtcbiAgICAgICAgICAgIC8vIFRoaXMgdGltZW91dCBtYWtlcyBjaHJvbWUgZmlyZSBvbmJlZm9yZXVubG9hZCBldmVudFxuICAgICAgICAgICAgLy8gd2l0aGluIGlmcmFtZS4gV2l0aG91dCB0aGUgdGltZW91dCBpdCBnb2VzIHN0cmFpZ2h0IHRvXG4gICAgICAgICAgICAvLyBvbnVubG9hZC5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYoaWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmcmFtZSA9IG51bGw7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIHV0aWxzLnVubG9hZF9kZWwodW5sb2FkX3JlZik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24ocikge1xuICAgICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICBlcnJvcl9jYWxsYmFjayhyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHBvc3QgPSBmdW5jdGlvbihtc2csIG9yaWdpbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgICAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cbiAgICAgICAgICAgIGlmIChpZnJhbWUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgICAgICBpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtc2csIG9yaWdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKHgpIHt9O1xuICAgIH07XG5cbiAgICBpZnJhbWUuc3JjID0gaWZyYW1lX3VybDtcbiAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBpZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKXtvbmVycm9yKCdvbmVycm9yJyk7fTtcbiAgICBpZnJhbWUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGBvbmxvYWRgIGlzIHRyaWdnZXJlZCBiZWZvcmUgc2NyaXB0cyBvbiB0aGUgaWZyYW1lIGFyZVxuICAgICAgICAvLyBleGVjdXRlZC4gR2l2ZSBpdCBmZXcgc2Vjb25kcyB0byBhY3R1YWxseSBsb2FkIHN0dWZmLlxuICAgICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7b25lcnJvcignb25sb2FkIHRpbWVvdXQnKTt9LCAyMDAwKTtcbiAgICB9O1xuICAgIF9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtvbmVycm9yKCd0aW1lb3V0Jyk7fSwgMTUwMDApO1xuICAgIHVubG9hZF9yZWYgPSB1dGlscy51bmxvYWRfYWRkKGNsZWFudXApO1xuICAgIHJldHVybiB7XG4gICAgICAgIHBvc3Q6IHBvc3QsXG4gICAgICAgIGNsZWFudXA6IGNsZWFudXAsXG4gICAgICAgIGxvYWRlZDogdW5hdHRhY2hcbiAgICB9O1xufTtcblxudXRpbHMuY3JlYXRlSHRtbGZpbGUgPSBmdW5jdGlvbiAoaWZyYW1lX3VybCwgZXJyb3JfY2FsbGJhY2spIHtcbiAgICB2YXIgZG9jID0gbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG4gICAgdmFyIHRyZWYsIHVubG9hZF9yZWY7XG4gICAgdmFyIGlmcmFtZTtcbiAgICB2YXIgdW5hdHRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgIH07XG4gICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGRvYykge1xuICAgICAgICAgICAgdW5hdHRhY2goKTtcbiAgICAgICAgICAgIHV0aWxzLnVubG9hZF9kZWwodW5sb2FkX3JlZik7XG4gICAgICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICAgICAgaWZyYW1lID0gZG9jID0gbnVsbDtcbiAgICAgICAgICAgIENvbGxlY3RHYXJiYWdlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24ocikgIHtcbiAgICAgICAgaWYgKGRvYykge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgZXJyb3JfY2FsbGJhY2socik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwb3N0ID0gZnVuY3Rpb24obXNnLCBvcmlnaW4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIGlmcmFtZSBpcyBub3QgbG9hZGVkLCBJRSByYWlzZXMgYW4gZXhjZXB0aW9uXG4gICAgICAgICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICAgICAgICBpZiAoaWZyYW1lICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCBvcmlnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoICh4KSB7fTtcbiAgICB9O1xuXG4gICAgZG9jLm9wZW4oKTtcbiAgICBkb2Mud3JpdGUoJzxodG1sPjxzJyArICdjcmlwdD4nICtcbiAgICAgICAgICAgICAgJ2RvY3VtZW50LmRvbWFpbj1cIicgKyBkb2N1bWVudC5kb21haW4gKyAnXCI7JyArXG4gICAgICAgICAgICAgICc8L3MnICsgJ2NyaXB0PjwvaHRtbD4nKTtcbiAgICBkb2MuY2xvc2UoKTtcbiAgICBkb2MucGFyZW50V2luZG93W1dQcmVmaXhdID0gX3dpbmRvd1tXUHJlZml4XTtcbiAgICB2YXIgYyA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb2MuYm9keS5hcHBlbmRDaGlsZChjKTtcbiAgICBpZnJhbWUgPSBkb2MuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgYy5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIGlmcmFtZS5zcmMgPSBpZnJhbWVfdXJsO1xuICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7b25lcnJvcigndGltZW91dCcpO30sIDE1MDAwKTtcbiAgICB1bmxvYWRfcmVmID0gdXRpbHMudW5sb2FkX2FkZChjbGVhbnVwKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb3N0OiBwb3N0LFxuICAgICAgICBjbGVhbnVwOiBjbGVhbnVwLFxuICAgICAgICBsb2FkZWQ6IHVuYXR0YWNoXG4gICAgfTtcbn07XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL2RvbS5qc1xuXG5cbi8vICAgICAgICAgWypdIEluY2x1ZGluZyBsaWIvZG9tMi5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxudmFyIEFic3RyYWN0WEhST2JqZWN0ID0gZnVuY3Rpb24oKXt9O1xuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlID0gbmV3IEV2ZW50RW1pdHRlcihbJ2NodW5rJywgJ2ZpbmlzaCddKTtcblxuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgdGhhdC54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9IGNhdGNoKHgpIHt9O1xuXG4gICAgaWYgKCF0aGF0Lnhocikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhhdC54aHIgPSBuZXcgX3dpbmRvdy5BY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICAgICAgICB9IGNhdGNoKHgpIHt9O1xuICAgIH1cbiAgICBpZiAoX3dpbmRvdy5BY3RpdmVYT2JqZWN0IHx8IF93aW5kb3cuWERvbWFpblJlcXVlc3QpIHtcbiAgICAgICAgLy8gSUU4IGNhY2hlcyBldmVuIFBPU1RzXG4gICAgICAgIHVybCArPSAoKHVybC5pbmRleE9mKCc/JykgPT09IC0xKSA/ICc/JyA6ICcmJykgKyAndD0nKygrbmV3IERhdGUpO1xuICAgIH1cblxuICAgIC8vIEV4cGxvcmVyIHRlbmRzIHRvIGtlZXAgY29ubmVjdGlvbiBvcGVuLCBldmVuIGFmdGVyIHRoZVxuICAgIC8vIHRhYiBnZXRzIGNsb3NlZDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNTI4MFxuICAgIHRoYXQudW5sb2FkX3JlZiA9IHV0aWxzLnVubG9hZF9hZGQoZnVuY3Rpb24oKXt0aGF0Ll9jbGVhbnVwKHRydWUpO30pO1xuICAgIHRyeSB7XG4gICAgICAgIHRoYXQueGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAvLyBJRSByYWlzZXMgYW4gZXhjZXB0aW9uIG9uIHdyb25nIHBvcnQuXG4gICAgICAgIHRoYXQuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICAgICAgICB0aGF0Ll9jbGVhbnVwKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuXG4gICAgaWYgKCFvcHRzIHx8ICFvcHRzLm5vX2NyZWRlbnRpYWxzKSB7XG4gICAgICAgIC8vIE1vemlsbGEgZG9jcyBzYXlzIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL1hNTEh0dHBSZXF1ZXN0IDpcbiAgICAgICAgLy8gXCJUaGlzIG5ldmVyIGFmZmVjdHMgc2FtZS1zaXRlIHJlcXVlc3RzLlwiXG4gICAgICAgIHRoYXQueGhyLndpdGhDcmVkZW50aWFscyA9ICd0cnVlJztcbiAgICB9XG4gICAgaWYgKG9wdHMgJiYgb3B0cy5oZWFkZXJzKSB7XG4gICAgICAgIGZvcih2YXIga2V5IGluIG9wdHMuaGVhZGVycykge1xuICAgICAgICAgICAgdGhhdC54aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIG9wdHMuaGVhZGVyc1trZXldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoYXQueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhhdC54aHIpIHtcbiAgICAgICAgICAgIHZhciB4ID0gdGhhdC54aHI7XG4gICAgICAgICAgICBzd2l0Y2ggKHgucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIC8vIElFIGRvZXNuJ3QgbGlrZSBwZWVraW5nIGludG8gcmVzcG9uc2VUZXh0IG9yIHN0YXR1c1xuICAgICAgICAgICAgICAgIC8vIG9uIE1pY3Jvc29mdC5YTUxIVFRQIGFuZCByZWFkeXN0YXRlPTNcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdHVzID0geC5zdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0geC5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge307XG4gICAgICAgICAgICAgICAgLy8gSUUgZG9lcyByZXR1cm4gcmVhZHlzdGF0ZSA9PSAzIGZvciA0MDQgYW5zd2Vycy5cbiAgICAgICAgICAgICAgICBpZiAodGV4dCAmJiB0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5lbWl0KCdjaHVuaycsIHN0YXR1cywgdGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHRoYXQuZW1pdCgnZmluaXNoJywgeC5zdGF0dXMsIHgucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICB0aGF0Ll9jbGVhbnVwKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhhdC54aHIuc2VuZChwYXlsb2FkKTtcbn07XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKGFib3J0KSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIGlmICghdGhhdC54aHIpIHJldHVybjtcbiAgICB1dGlscy51bmxvYWRfZGVsKHRoYXQudW5sb2FkX3JlZik7XG5cbiAgICAvLyBJRSBuZWVkcyB0aGlzIGZpZWxkIHRvIGJlIGEgZnVuY3Rpb25cbiAgICB0aGF0Lnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe307XG5cbiAgICBpZiAoYWJvcnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoYXQueGhyLmFib3J0KCk7XG4gICAgICAgIH0gY2F0Y2goeCkge307XG4gICAgfVxuICAgIHRoYXQudW5sb2FkX3JlZiA9IHRoYXQueGhyID0gbnVsbDtcbn07XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0Lm51a2UoKTtcbiAgICB0aGF0Ll9jbGVhbnVwKHRydWUpO1xufTtcblxudmFyIFhIUkNvcnNPYmplY3QgPSB1dGlscy5YSFJDb3JzT2JqZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgIHV0aWxzLmRlbGF5KGZ1bmN0aW9uKCl7dGhhdC5fc3RhcnQuYXBwbHkodGhhdCwgYXJncyk7fSk7XG59O1xuWEhSQ29yc09iamVjdC5wcm90b3R5cGUgPSBuZXcgQWJzdHJhY3RYSFJPYmplY3QoKTtcblxudmFyIFhIUkxvY2FsT2JqZWN0ID0gdXRpbHMuWEhSTG9jYWxPYmplY3QgPSBmdW5jdGlvbihtZXRob2QsIHVybCwgcGF5bG9hZCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB1dGlscy5kZWxheShmdW5jdGlvbigpe1xuICAgICAgICB0aGF0Ll9zdGFydChtZXRob2QsIHVybCwgcGF5bG9hZCwge1xuICAgICAgICAgICAgbm9fY3JlZGVudGlhbHM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuWEhSTG9jYWxPYmplY3QucHJvdG90eXBlID0gbmV3IEFic3RyYWN0WEhST2JqZWN0KCk7XG5cblxuXG4vLyBSZWZlcmVuY2VzOlxuLy8gICBodHRwOi8vYWpheGlhbi5jb20vYXJjaGl2ZXMvMTAwLWxpbmUtYWpheC13cmFwcGVyXG4vLyAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9jYzI4ODA2MCh2PVZTLjg1KS5hc3B4XG52YXIgWERST2JqZWN0ID0gdXRpbHMuWERST2JqZWN0ID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIHBheWxvYWQpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdXRpbHMuZGVsYXkoZnVuY3Rpb24oKXt0aGF0Ll9zdGFydChtZXRob2QsIHVybCwgcGF5bG9hZCk7fSk7XG59O1xuWERST2JqZWN0LnByb3RvdHlwZSA9IG5ldyBFdmVudEVtaXR0ZXIoWydjaHVuaycsICdmaW5pc2gnXSk7XG5YRFJPYmplY3QucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBwYXlsb2FkKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciB4ZHIgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICAvLyBJRSBjYWNoZXMgZXZlbiBQT1NUc1xuICAgIHVybCArPSAoKHVybC5pbmRleE9mKCc/JykgPT09IC0xKSA/ICc/JyA6ICcmJykgKyAndD0nKygrbmV3IERhdGUpO1xuXG4gICAgdmFyIG9uZXJyb3IgPSB4ZHIub250aW1lb3V0ID0geGRyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgICAgIHRoYXQuX2NsZWFudXAoZmFsc2UpO1xuICAgIH07XG4gICAgeGRyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5lbWl0KCdjaHVuaycsIDIwMCwgeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgfTtcbiAgICB4ZHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoYXQuZW1pdCgnZmluaXNoJywgMjAwLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgdGhhdC5fY2xlYW51cChmYWxzZSk7XG4gICAgfTtcbiAgICB0aGF0LnhkciA9IHhkcjtcbiAgICB0aGF0LnVubG9hZF9yZWYgPSB1dGlscy51bmxvYWRfYWRkKGZ1bmN0aW9uKCl7dGhhdC5fY2xlYW51cCh0cnVlKTt9KTtcbiAgICB0cnkge1xuICAgICAgICAvLyBGYWlscyB3aXRoIEFjY2Vzc0RlbmllZCBpZiBwb3J0IG51bWJlciBpcyBib2d1c1xuICAgICAgICB0aGF0Lnhkci5vcGVuKG1ldGhvZCwgdXJsKTtcbiAgICAgICAgdGhhdC54ZHIuc2VuZChwYXlsb2FkKTtcbiAgICB9IGNhdGNoKHgpIHtcbiAgICAgICAgb25lcnJvcigpO1xuICAgIH1cbn07XG5cblhEUk9iamVjdC5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbihhYm9ydCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBpZiAoIXRoYXQueGRyKSByZXR1cm47XG4gICAgdXRpbHMudW5sb2FkX2RlbCh0aGF0LnVubG9hZF9yZWYpO1xuXG4gICAgdGhhdC54ZHIub250aW1lb3V0ID0gdGhhdC54ZHIub25lcnJvciA9IHRoYXQueGRyLm9ucHJvZ3Jlc3MgPVxuICAgICAgICB0aGF0Lnhkci5vbmxvYWQgPSBudWxsO1xuICAgIGlmIChhYm9ydCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhhdC54ZHIuYWJvcnQoKTtcbiAgICAgICAgfSBjYXRjaCh4KSB7fTtcbiAgICB9XG4gICAgdGhhdC51bmxvYWRfcmVmID0gdGhhdC54ZHIgPSBudWxsO1xufTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0Lm51a2UoKTtcbiAgICB0aGF0Ll9jbGVhbnVwKHRydWUpO1xufTtcblxuLy8gMS4gSXMgbmF0aXZlbHkgdmlhIFhIUlxuLy8gMi4gSXMgbmF0aXZlbHkgdmlhIFhEUlxuLy8gMy4gTm9wZSwgYnV0IHBvc3RNZXNzYWdlIGlzIHRoZXJlIHNvIGl0IHNob3VsZCB3b3JrIHZpYSB0aGUgSWZyYW1lLlxuLy8gNC4gTm9wZSwgc29ycnkuXG51dGlscy5pc1hIUkNvcnNDYXBhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKF93aW5kb3cuWE1MSHR0cFJlcXVlc3QgJiYgJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIC8vIFhEb21haW5SZXF1ZXN0IGRvZXNuJ3Qgd29yayBpZiBwYWdlIGlzIHNlcnZlZCBmcm9tIGZpbGU6Ly9cbiAgICBpZiAoX3dpbmRvdy5YRG9tYWluUmVxdWVzdCAmJiBfZG9jdW1lbnQuZG9tYWluKSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICBpZiAoSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gMztcbiAgICB9XG4gICAgcmV0dXJuIDQ7XG59O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi9kb20yLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi9zb2NranMuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbnZhciBTb2NrSlMgPSBmdW5jdGlvbih1cmwsIGRlcF9wcm90b2NvbHNfd2hpdGVsaXN0LCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMgPT09IHdpbmRvdykge1xuICAgICAgICAvLyBtYWtlcyBgbmV3YCBvcHRpb25hbFxuICAgICAgICByZXR1cm4gbmV3IFNvY2tKUyh1cmwsIGRlcF9wcm90b2NvbHNfd2hpdGVsaXN0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgXG4gICAgdmFyIHRoYXQgPSB0aGlzLCBwcm90b2NvbHNfd2hpdGVsaXN0O1xuICAgIHRoYXQuX29wdGlvbnMgPSB7ZGV2ZWw6IGZhbHNlLCBkZWJ1ZzogZmFsc2UsIHByb3RvY29sc193aGl0ZWxpc3Q6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgaW5mbzogdW5kZWZpbmVkLCBydHQ6IHVuZGVmaW5lZH07XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgdXRpbHMub2JqZWN0RXh0ZW5kKHRoYXQuX29wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICB0aGF0Ll9iYXNlX3VybCA9IHV0aWxzLmFtZW5kVXJsKHVybCk7XG4gICAgdGhhdC5fc2VydmVyID0gdGhhdC5fb3B0aW9ucy5zZXJ2ZXIgfHwgdXRpbHMucmFuZG9tX251bWJlcl9zdHJpbmcoMTAwMCk7XG4gICAgaWYgKHRoYXQuX29wdGlvbnMucHJvdG9jb2xzX3doaXRlbGlzdCAmJlxuICAgICAgICB0aGF0Ll9vcHRpb25zLnByb3RvY29sc193aGl0ZWxpc3QubGVuZ3RoKSB7XG4gICAgICAgIHByb3RvY29sc193aGl0ZWxpc3QgPSB0aGF0Ll9vcHRpb25zLnByb3RvY29sc193aGl0ZWxpc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRGVwcmVjYXRlZCBBUElcbiAgICAgICAgaWYgKHR5cGVvZiBkZXBfcHJvdG9jb2xzX3doaXRlbGlzdCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIGRlcF9wcm90b2NvbHNfd2hpdGVsaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHByb3RvY29sc193aGl0ZWxpc3QgPSBbZGVwX3Byb3RvY29sc193aGl0ZWxpc3RdO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzQXJyYXkoZGVwX3Byb3RvY29sc193aGl0ZWxpc3QpKSB7XG4gICAgICAgICAgICBwcm90b2NvbHNfd2hpdGVsaXN0ID0gZGVwX3Byb3RvY29sc193aGl0ZWxpc3RcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3RvY29sc193aGl0ZWxpc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm90b2NvbHNfd2hpdGVsaXN0KSB7XG4gICAgICAgICAgICB0aGF0Ll9kZWJ1ZygnRGVwcmVjYXRlZCBBUEk6IFVzZSBcInByb3RvY29sc193aGl0ZWxpc3RcIiBvcHRpb24gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5zdGVhZCBvZiBzdXBwbHlpbmcgcHJvdG9jb2wgbGlzdCBhcyBhIHNlY29uZCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdwYXJhbWV0ZXIgdG8gU29ja0pTIGNvbnN0cnVjdG9yLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoYXQuX3Byb3RvY29scyA9IFtdO1xuICAgIHRoYXQucHJvdG9jb2wgPSBudWxsO1xuICAgIHRoYXQucmVhZHlTdGF0ZSA9IFNvY2tKUy5DT05ORUNUSU5HO1xuICAgIHRoYXQuX2lyID0gY3JlYXRlSW5mb1JlY2VpdmVyKHRoYXQuX2Jhc2VfdXJsKTtcbiAgICB0aGF0Ll9pci5vbmZpbmlzaCA9IGZ1bmN0aW9uKGluZm8sIHJ0dCkge1xuICAgICAgICB0aGF0Ll9pciA9IG51bGw7XG4gICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICBpZiAodGhhdC5fb3B0aW9ucy5pbmZvKSB7XG4gICAgICAgICAgICAgICAgLy8gT3ZlcnJpZGUgaWYgdXNlciBzdXBwbGllcyB0aGUgb3B0aW9uXG4gICAgICAgICAgICAgICAgaW5mbyA9IHV0aWxzLm9iamVjdEV4dGVuZChpbmZvLCB0aGF0Ll9vcHRpb25zLmluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoYXQuX29wdGlvbnMucnR0KSB7XG4gICAgICAgICAgICAgICAgcnR0ID0gdGhhdC5fb3B0aW9ucy5ydHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGF0Ll9hcHBseUluZm8oaW5mbywgcnR0LCBwcm90b2NvbHNfd2hpdGVsaXN0KTtcbiAgICAgICAgICAgIHRoYXQuX2RpZENsb3NlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGF0Ll9kaWRDbG9zZSgxMDAyLCAnQ2FuXFwndCBjb25uZWN0IHRvIHNlcnZlcicsIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4vLyBJbmhlcml0YW5jZVxuU29ja0pTLnByb3RvdHlwZSA9IG5ldyBSRXZlbnRUYXJnZXQoKTtcblxuU29ja0pTLnZlcnNpb24gPSBcIjAuMy4xLjcuZ2E2N2YuZGlydHlcIjtcblxuU29ja0pTLkNPTk5FQ1RJTkcgPSAwO1xuU29ja0pTLk9QRU4gPSAxO1xuU29ja0pTLkNMT1NJTkcgPSAyO1xuU29ja0pTLkNMT1NFRCA9IDM7XG5cblNvY2tKUy5wcm90b3R5cGUuX2RlYnVnID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuZGVidWcpXG4gICAgICAgIHV0aWxzLmxvZy5hcHBseSh1dGlscywgYXJndW1lbnRzKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX2Rpc3BhdGNoT3BlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBpZiAodGhhdC5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgICAgICBpZiAodGhhdC5fdHJhbnNwb3J0X3RyZWYpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGF0Ll90cmFuc3BvcnRfdHJlZik7XG4gICAgICAgICAgICB0aGF0Ll90cmFuc3BvcnRfdHJlZiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5yZWFkeVN0YXRlID0gU29ja0pTLk9QRU47XG4gICAgICAgIHRoYXQuZGlzcGF0Y2hFdmVudChuZXcgU2ltcGxlRXZlbnQoXCJvcGVuXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgc2VydmVyIG1pZ2h0IGhhdmUgYmVlbiByZXN0YXJ0ZWQsIGFuZCBsb3N0IHRyYWNrIG9mIG91clxuICAgICAgICAvLyBjb25uZWN0aW9uLlxuICAgICAgICB0aGF0Ll9kaWRDbG9zZSgxMDA2LCBcIlNlcnZlciBsb3N0IHNlc3Npb25cIik7XG4gICAgfVxufTtcblxuU29ja0pTLnByb3RvdHlwZS5fZGlzcGF0Y2hNZXNzYWdlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBpZiAodGhhdC5yZWFkeVN0YXRlICE9PSBTb2NrSlMuT1BFTilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICB0aGF0LmRpc3BhdGNoRXZlbnQobmV3IFNpbXBsZUV2ZW50KFwibWVzc2FnZVwiLCB7ZGF0YTogZGF0YX0pKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX2Rpc3BhdGNoSGVhcnRiZWF0ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBpZiAodGhhdC5yZWFkeVN0YXRlICE9PSBTb2NrSlMuT1BFTilcbiAgICAgICAgcmV0dXJuO1xuICAgIHRoYXQuZGlzcGF0Y2hFdmVudChuZXcgU2ltcGxlRXZlbnQoJ2hlYXJ0YmVhdCcsIHt9KSk7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9kaWRDbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbiwgZm9yY2UpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgaWYgKHRoYXQucmVhZHlTdGF0ZSAhPT0gU29ja0pTLkNPTk5FQ1RJTkcgJiZcbiAgICAgICAgdGhhdC5yZWFkeVN0YXRlICE9PSBTb2NrSlMuT1BFTiAmJlxuICAgICAgICB0aGF0LnJlYWR5U3RhdGUgIT09IFNvY2tKUy5DTE9TSU5HKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJTlZBTElEX1NUQVRFX0VSUicpO1xuICAgIGlmICh0aGF0Ll9pcikge1xuICAgICAgICB0aGF0Ll9pci5udWtlKCk7XG4gICAgICAgIHRoYXQuX2lyID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhhdC5fdHJhbnNwb3J0KSB7XG4gICAgICAgIHRoYXQuX3RyYW5zcG9ydC5kb0NsZWFudXAoKTtcbiAgICAgICAgdGhhdC5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgY2xvc2VfZXZlbnQgPSBuZXcgU2ltcGxlRXZlbnQoXCJjbG9zZVwiLCB7XG4gICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgIHJlYXNvbjogcmVhc29uLFxuICAgICAgICB3YXNDbGVhbjogdXRpbHMudXNlclNldENvZGUoY29kZSl9KTtcblxuICAgIGlmICghdXRpbHMudXNlclNldENvZGUoY29kZSkgJiZcbiAgICAgICAgdGhhdC5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORyAmJiAhZm9yY2UpIHtcbiAgICAgICAgaWYgKHRoYXQuX3RyeV9uZXh0X3Byb3RvY29sKGNsb3NlX2V2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNsb3NlX2V2ZW50ID0gbmV3IFNpbXBsZUV2ZW50KFwiY2xvc2VcIiwge2NvZGU6IDIwMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IFwiQWxsIHRyYW5zcG9ydHMgZmFpbGVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXNDbGVhbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0X2V2ZW50OiBjbG9zZV9ldmVudH0pO1xuICAgIH1cbiAgICB0aGF0LnJlYWR5U3RhdGUgPSBTb2NrSlMuQ0xPU0VEO1xuXG4gICAgdXRpbHMuZGVsYXkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgdGhhdC5kaXNwYXRjaEV2ZW50KGNsb3NlX2V2ZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX2RpZE1lc3NhZ2UgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciB0eXBlID0gZGF0YS5zbGljZSgwLCAxKTtcbiAgICBzd2l0Y2godHlwZSkge1xuICAgIGNhc2UgJ28nOlxuICAgICAgICB0aGF0Ll9kaXNwYXRjaE9wZW4oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYSc6XG4gICAgICAgIHZhciBwYXlsb2FkID0gSlNPTi5wYXJzZShkYXRhLnNsaWNlKDEpIHx8ICdbXScpO1xuICAgICAgICBmb3IodmFyIGk9MDsgaSA8IHBheWxvYWQubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdGhhdC5fZGlzcGF0Y2hNZXNzYWdlKHBheWxvYWRbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ20nOlxuICAgICAgICB2YXIgcGF5bG9hZCA9IEpTT04ucGFyc2UoZGF0YS5zbGljZSgxKSB8fCAnbnVsbCcpO1xuICAgICAgICB0aGF0Ll9kaXNwYXRjaE1lc3NhZ2UocGF5bG9hZCk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2MnOlxuICAgICAgICB2YXIgcGF5bG9hZCA9IEpTT04ucGFyc2UoZGF0YS5zbGljZSgxKSB8fCAnW10nKTtcbiAgICAgICAgdGhhdC5fZGlkQ2xvc2UocGF5bG9hZFswXSwgcGF5bG9hZFsxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2gnOlxuICAgICAgICB0aGF0Ll9kaXNwYXRjaEhlYXJ0YmVhdCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cnlfbmV4dF9wcm90b2NvbCA9IGZ1bmN0aW9uKGNsb3NlX2V2ZW50KSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIGlmICh0aGF0LnByb3RvY29sKSB7XG4gICAgICAgIHRoYXQuX2RlYnVnKCdDbG9zZWQgdHJhbnNwb3J0OicsIHRoYXQucHJvdG9jb2wsICcnK2Nsb3NlX2V2ZW50KTtcbiAgICAgICAgdGhhdC5wcm90b2NvbCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGF0Ll90cmFuc3BvcnRfdHJlZikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhhdC5fdHJhbnNwb3J0X3RyZWYpO1xuICAgICAgICB0aGF0Ll90cmFuc3BvcnRfdHJlZiA9IG51bGw7XG4gICAgfVxuXG4gICAgd2hpbGUoMSkge1xuICAgICAgICB2YXIgcHJvdG9jb2wgPSB0aGF0LnByb3RvY29sID0gdGhhdC5fcHJvdG9jb2xzLnNoaWZ0KCk7XG4gICAgICAgIGlmICghcHJvdG9jb2wpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb21lIHByb3RvY29scyByZXF1aXJlIGFjY2VzcyB0byBgYm9keWAsIHdoYXQgaWYgd2VyZSBpblxuICAgICAgICAvLyB0aGUgYGhlYWRgP1xuICAgICAgICBpZiAoU29ja0pTW3Byb3RvY29sXSAmJlxuICAgICAgICAgICAgU29ja0pTW3Byb3RvY29sXS5uZWVkX2JvZHkgPT09IHRydWUgJiZcbiAgICAgICAgICAgICghX2RvY3VtZW50LmJvZHkgfHxcbiAgICAgICAgICAgICAodHlwZW9mIF9kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAmJiBfZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2NvbXBsZXRlJykpKSB7XG4gICAgICAgICAgICB0aGF0Ll9wcm90b2NvbHMudW5zaGlmdChwcm90b2NvbCk7XG4gICAgICAgICAgICB0aGF0LnByb3RvY29sID0gJ3dhaXRpbmctZm9yLWxvYWQnO1xuICAgICAgICAgICAgdXRpbHMuYXR0YWNoRXZlbnQoJ2xvYWQnLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHRoYXQuX3RyeV9uZXh0X3Byb3RvY29sKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFTb2NrSlNbcHJvdG9jb2xdIHx8XG4gICAgICAgICAgICAgICFTb2NrSlNbcHJvdG9jb2xdLmVuYWJsZWQodGhhdC5fb3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRoYXQuX2RlYnVnKCdTa2lwcGluZyB0cmFuc3BvcnQ6JywgcHJvdG9jb2wpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJvdW5kVHJpcHMgPSBTb2NrSlNbcHJvdG9jb2xdLnJvdW5kVHJpcHMgfHwgMTtcbiAgICAgICAgICAgIHZhciB0byA9ICgodGhhdC5fb3B0aW9ucy5ydG8gfHwgMCkgKiByb3VuZFRyaXBzKSB8fCA1MDAwO1xuICAgICAgICAgICAgdGhhdC5fdHJhbnNwb3J0X3RyZWYgPSB1dGlscy5kZWxheSh0bywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoYXQucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSSBjYW4ndCB1bmRlcnN0YW5kIGhvdyBpdCBpcyBwb3NzaWJsZSB0byBydW5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB0aW1lciwgd2hlbiB0aGUgc3RhdGUgaXMgQ0xPU0VELCBidXRcbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwYXJlbnRseSBpbiBJRSBldmVyeXRoaW4gaXMgcG9zc2libGUuXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX2RpZENsb3NlKDIwMDcsIFwiVHJhbnNwb3J0IHRpbWVvdXRlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGNvbm5pZCA9IHV0aWxzLnJhbmRvbV9zdHJpbmcoOCk7XG4gICAgICAgICAgICB2YXIgdHJhbnNfdXJsID0gdGhhdC5fYmFzZV91cmwgKyAnLycgKyB0aGF0Ll9zZXJ2ZXIgKyAnLycgKyBjb25uaWQ7XG4gICAgICAgICAgICB0aGF0Ll9kZWJ1ZygnT3BlbmluZyB0cmFuc3BvcnQ6JywgcHJvdG9jb2wsICcgdXJsOicrdHJhbnNfdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgJyBSVE86Jyt0aGF0Ll9vcHRpb25zLnJ0byk7XG4gICAgICAgICAgICB0aGF0Ll90cmFuc3BvcnQgPSBuZXcgU29ja0pTW3Byb3RvY29sXSh0aGF0LCB0cmFuc191cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9iYXNlX3VybCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgaWYgKGNvZGUgJiYgIXV0aWxzLnVzZXJTZXRDb2RlKGNvZGUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJTlZBTElEX0FDQ0VTU19FUlJcIik7XG4gICAgaWYodGhhdC5yZWFkeVN0YXRlICE9PSBTb2NrSlMuQ09OTkVDVElORyAmJlxuICAgICAgIHRoYXQucmVhZHlTdGF0ZSAhPT0gU29ja0pTLk9QRU4pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGF0LnJlYWR5U3RhdGUgPSBTb2NrSlMuQ0xPU0lORztcbiAgICB0aGF0Ll9kaWRDbG9zZShjb2RlIHx8IDEwMDAsIHJlYXNvbiB8fCBcIk5vcm1hbCBjbG9zdXJlXCIpO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBpZiAodGhhdC5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJTlZBTElEX1NUQVRFX0VSUicpO1xuICAgIGlmICh0aGF0LnJlYWR5U3RhdGUgPT09IFNvY2tKUy5PUEVOKSB7XG4gICAgICAgIHRoYXQuX3RyYW5zcG9ydC5kb1NlbmQodXRpbHMucXVvdGUoJycgKyBkYXRhKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fYXBwbHlJbmZvID0gZnVuY3Rpb24oaW5mbywgcnR0LCBwcm90b2NvbHNfd2hpdGVsaXN0KSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoYXQuX29wdGlvbnMuaW5mbyA9IGluZm87XG4gICAgdGhhdC5fb3B0aW9ucy5ydHQgPSBydHQ7XG4gICAgdGhhdC5fb3B0aW9ucy5ydG8gPSB1dGlscy5jb3VudFJUTyhydHQpO1xuICAgIHRoYXQuX29wdGlvbnMuaW5mby5udWxsX29yaWdpbiA9ICFfZG9jdW1lbnQuZG9tYWluO1xuICAgIHZhciBwcm9iZWQgPSB1dGlscy5wcm9iZVByb3RvY29scygpO1xuICAgIHRoYXQuX3Byb3RvY29scyA9IHV0aWxzLmRldGVjdFByb3RvY29scyhwcm9iZWQsIHByb3RvY29sc193aGl0ZWxpc3QsIGluZm8pO1xufTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvc29ja2pzLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi90cmFucy13ZWJzb2NrZXQuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbnZhciBXZWJTb2NrZXRUcmFuc3BvcnQgPSBTb2NrSlMud2Vic29ja2V0ID0gZnVuY3Rpb24ocmksIHRyYW5zX3VybCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgdXJsID0gdHJhbnNfdXJsICsgJy93ZWJzb2NrZXQnO1xuICAgIGlmICh1cmwuc2xpY2UoMCwgNSkgPT09ICdodHRwcycpIHtcbiAgICAgICAgdXJsID0gJ3dzcycgKyB1cmwuc2xpY2UoNSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdXJsID0gJ3dzJyArIHVybC5zbGljZSg0KTtcbiAgICB9XG4gICAgdGhhdC5yaSA9IHJpO1xuICAgIHRoYXQudXJsID0gdXJsO1xuICAgIHZhciBDb25zdHJ1Y3RvciA9IF93aW5kb3cuV2ViU29ja2V0IHx8IF93aW5kb3cuTW96V2ViU29ja2V0O1xuXG4gICAgdGhhdC53cyA9IG5ldyBDb25zdHJ1Y3Rvcih0aGF0LnVybCk7XG4gICAgdGhhdC53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoYXQucmkuX2RpZE1lc3NhZ2UoZS5kYXRhKTtcbiAgICB9O1xuICAgIC8vIEZpcmVmb3ggaGFzIGFuIGludGVyZXN0aW5nIGJ1Zy4gSWYgYSB3ZWJzb2NrZXQgY29ubmVjdGlvbiBpc1xuICAgIC8vIGNyZWF0ZWQgYWZ0ZXIgb25iZWZvcmV1bmxvYWQsIGl0IHN0YXlzIGFsaXZlIGV2ZW4gd2hlbiB1c2VyXG4gICAgLy8gbmF2aWdhdGVzIGF3YXkgZnJvbSB0aGUgcGFnZS4gSW4gc3VjaCBzaXR1YXRpb24gbGV0J3MgbGllIC1cbiAgICAvLyBsZXQncyBub3Qgb3BlbiB0aGUgd3MgY29ubmVjdGlvbiBhdCBhbGwuIFNlZTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc29ja2pzL3NvY2tqcy1jbGllbnQvaXNzdWVzLzI4XG4gICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk2MDg1XG4gICAgdGhhdC51bmxvYWRfcmVmID0gdXRpbHMudW5sb2FkX2FkZChmdW5jdGlvbigpe3RoYXQud3MuY2xvc2UoKX0pO1xuICAgIHRoYXQud3Mub25jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGF0LnJpLl9kaWRNZXNzYWdlKHV0aWxzLmNsb3NlRnJhbWUoMTAwNiwgXCJXZWJTb2NrZXQgY29ubmVjdGlvbiBicm9rZW5cIikpO1xuICAgIH07XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLmRvU2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB0aGlzLndzLnNlbmQoJ1snICsgZGF0YSArICddJyk7XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLmRvQ2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgd3MgPSB0aGF0LndzO1xuICAgIGlmICh3cykge1xuICAgICAgICB3cy5vbm1lc3NhZ2UgPSB3cy5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgd3MuY2xvc2UoKTtcbiAgICAgICAgdXRpbHMudW5sb2FkX2RlbCh0aGF0LnVubG9hZF9yZWYpO1xuICAgICAgICB0aGF0LnVubG9hZF9yZWYgPSB0aGF0LnJpID0gdGhhdC53cyA9IG51bGw7XG4gICAgfVxufTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gISEoX3dpbmRvdy5XZWJTb2NrZXQgfHwgX3dpbmRvdy5Nb3pXZWJTb2NrZXQpO1xufTtcblxuLy8gSW4gdGhlb3J5LCB3cyBzaG91bGQgcmVxdWlyZSAxIHJvdW5kIHRyaXAuIEJ1dCBpbiBjaHJvbWUsIHRoaXMgaXNcbi8vIG5vdCB2ZXJ5IHN0YWJsZSBvdmVyIFNTTC4gTW9zdCBsaWtlbHkgYSB3cyBjb25uZWN0aW9uIHJlcXVpcmVzIGFcbi8vIHNlcGFyYXRlIFNTTCBjb25uZWN0aW9uLCBpbiB3aGljaCBjYXNlIDIgcm91bmQgdHJpcHMgYXJlIGFuXG4vLyBhYnNvbHV0ZSBtaW51bXVtLlxuV2ViU29ja2V0VHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi90cmFucy13ZWJzb2NrZXQuanNcblxuXG4vLyAgICAgICAgIFsqXSBJbmNsdWRpbmcgbGliL3RyYW5zLXNlbmRlci5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxudmFyIEJ1ZmZlcmVkU2VuZGVyID0gZnVuY3Rpb24oKSB7fTtcbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kX2NvbnN0cnVjdG9yID0gZnVuY3Rpb24oc2VuZGVyKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoYXQuc2VuZF9idWZmZXIgPSBbXTtcbiAgICB0aGF0LnNlbmRlciA9IHNlbmRlcjtcbn07XG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuZG9TZW5kID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0LnNlbmRfYnVmZmVyLnB1c2gobWVzc2FnZSk7XG4gICAgaWYgKCF0aGF0LnNlbmRfc3RvcCkge1xuICAgICAgICB0aGF0LnNlbmRfc2NoZWR1bGUoKTtcbiAgICB9XG59O1xuXG4vLyBGb3IgcG9sbGluZyB0cmFuc3BvcnRzIGluIGEgc2l0dWF0aW9uIHdoZW4gaW4gdGhlIG1lc3NhZ2UgY2FsbGJhY2ssXG4vLyBuZXcgbWVzc2FnZSBpcyBiZWluZyBzZW5kLiBJZiB0aGUgc2VuZGluZyBjb25uZWN0aW9uIHdhcyBzdGFydGVkXG4vLyBiZWZvcmUgcmVjZWl2aW5nIG9uZSwgaXQgaXMgcG9zc2libGUgdG8gc2F0dXJhdGUgdGhlIG5ldHdvcmsgYW5kXG4vLyB0aW1lb3V0IGR1ZSB0byB0aGUgbGFjayBvZiByZWNlaXZpbmcgc29ja2V0LiBUbyBhdm9pZCB0aGF0IHdlIGRlbGF5XG4vLyBzZW5kaW5nIG1lc3NhZ2VzIGJ5IHNvbWUgc21hbGwgdGltZSwgaW4gb3JkZXIgdG8gbGV0IHJlY2VpdmluZ1xuLy8gY29ubmVjdGlvbiBiZSBzdGFydGVkIGJlZm9yZWhhbmQuIFRoaXMgaXMgb25seSBhIGhhbGZtZWFzdXJlIGFuZFxuLy8gZG9lcyBub3QgZml4IHRoZSBiaWcgcHJvYmxlbSwgYnV0IGl0IGRvZXMgbWFrZSB0aGUgdGVzdHMgZ28gbW9yZVxuLy8gc3RhYmxlIG9uIHNsb3cgbmV0d29ya3MuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZF9zY2hlZHVsZV93YWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciB0cmVmO1xuICAgIHRoYXQuc2VuZF9zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoYXQuc2VuZF9zdG9wID0gbnVsbDtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgIH07XG4gICAgdHJlZiA9IHV0aWxzLmRlbGF5KDI1LCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5zZW5kX3N0b3AgPSBudWxsO1xuICAgICAgICB0aGF0LnNlbmRfc2NoZWR1bGUoKTtcbiAgICB9KTtcbn07XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kX3NjaGVkdWxlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIGlmICh0aGF0LnNlbmRfYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHBheWxvYWQgPSAnWycgKyB0aGF0LnNlbmRfYnVmZmVyLmpvaW4oJywnKSArICddJztcbiAgICAgICAgdGhhdC5zZW5kX3N0b3AgPSB0aGF0LnNlbmRlcih0aGF0LnRyYW5zX3VybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbmRfc3RvcCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuc2VuZF9zY2hlZHVsZV93YWl0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoYXQuc2VuZF9idWZmZXIgPSBbXTtcbiAgICB9XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZF9kZXN0cnVjdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIGlmICh0aGF0Ll9zZW5kX3N0b3ApIHtcbiAgICAgICAgdGhhdC5fc2VuZF9zdG9wKCk7XG4gICAgfVxuICAgIHRoYXQuX3NlbmRfc3RvcCA9IG51bGw7XG59O1xuXG52YXIganNvblBHZW5lcmljU2VuZGVyID0gZnVuY3Rpb24odXJsLCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgIGlmICghKCdfc2VuZF9mb3JtJyBpbiB0aGF0KSkge1xuICAgICAgICB2YXIgZm9ybSA9IHRoYXQuX3NlbmRfZm9ybSA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gICAgICAgIHZhciBhcmVhID0gdGhhdC5fc2VuZF9hcmVhID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgICAgIGFyZWEubmFtZSA9ICdkJztcbiAgICAgICAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBmb3JtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGZvcm0uZW5jdHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgICBmb3JtLmFjY2VwdENoYXJzZXQgPSBcIlVURi04XCI7XG4gICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG4gICAgICAgIF9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xuICAgIH1cbiAgICB2YXIgZm9ybSA9IHRoYXQuX3NlbmRfZm9ybTtcbiAgICB2YXIgYXJlYSA9IHRoYXQuX3NlbmRfYXJlYTtcbiAgICB2YXIgaWQgPSAnYScgKyB1dGlscy5yYW5kb21fc3RyaW5nKDgpO1xuICAgIGZvcm0udGFyZ2V0ID0gaWQ7XG4gICAgZm9ybS5hY3Rpb24gPSB1cmwgKyAnL2pzb25wX3NlbmQ/aT0nICsgaWQ7XG5cbiAgICB2YXIgaWZyYW1lO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuICAgICAgICBpZnJhbWUgPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPGlmcmFtZSBuYW1lPVwiJysgaWQgKydcIj4nKTtcbiAgICB9IGNhdGNoKHgpIHtcbiAgICAgICAgaWZyYW1lID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICBpZnJhbWUubmFtZSA9IGlkO1xuICAgIH1cbiAgICBpZnJhbWUuaWQgPSBpZDtcbiAgICBmb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICB0cnkge1xuICAgICAgICBhcmVhLnZhbHVlID0gcGF5bG9hZDtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgdXRpbHMubG9nKCdZb3VyIGJyb3dzZXIgaXMgc2VyaW91c2x5IGJyb2tlbi4gR28gaG9tZSEgJyArIGUubWVzc2FnZSk7XG4gICAgfVxuICAgIGZvcm0uc3VibWl0KCk7XG5cbiAgICB2YXIgY29tcGxldGVkID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIWlmcmFtZS5vbmVycm9yKSByZXR1cm47XG4gICAgICAgIGlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBpZnJhbWUub25lcnJvciA9IGlmcmFtZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICAvLyBPcGVyYSBtaW5pIGRvZXNuJ3QgbGlrZSBpZiB3ZSBHQyBpZnJhbWVcbiAgICAgICAgLy8gaW1tZWRpYXRlbHksIHRodXMgdGhpcyB0aW1lb3V0LlxuICAgICAgICB1dGlscy5kZWxheSg1MDAsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICBhcmVhLnZhbHVlID0gJyc7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfTtcbiAgICBpZnJhbWUub25lcnJvciA9IGlmcmFtZS5vbmxvYWQgPSBjb21wbGV0ZWQ7XG4gICAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGlmcmFtZS5yZWFkeVN0YXRlID09ICdjb21wbGV0ZScpIGNvbXBsZXRlZCgpO1xuICAgIH07XG4gICAgcmV0dXJuIGNvbXBsZXRlZDtcbn07XG5cbnZhciBjcmVhdGVBamF4U2VuZGVyID0gZnVuY3Rpb24oQWpheE9iamVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbih1cmwsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB4byA9IG5ldyBBamF4T2JqZWN0KCdQT1NUJywgdXJsICsgJy94aHJfc2VuZCcsIHBheWxvYWQpO1xuICAgICAgICB4by5vbmZpbmlzaCA9IGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICAgICAgICAgICAgY2FsbGJhY2soc3RhdHVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFib3J0X3JlYXNvbikge1xuICAgICAgICAgICAgY2FsbGJhY2soMCwgYWJvcnRfcmVhc29uKTtcbiAgICAgICAgfTtcbiAgICB9O1xufTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvdHJhbnMtc2VuZGVyLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi90cmFucy1qc29ucC1yZWNlaXZlci5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxuLy8gUGFydHMgZGVyaXZlZCBmcm9tIFNvY2tldC5pbzpcbi8vICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFybkJvb3N0L3NvY2tldC5pby9ibG9iLzAuNi4xNy9saWIvc29ja2V0LmlvL3RyYW5zcG9ydHMvanNvbnAtcG9sbGluZy5qc1xuLy8gYW5kIGpRdWVyeS1KU09OUDpcbi8vICAgIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvanF1ZXJ5LWpzb25wL3NvdXJjZS9icm93c2UvdHJ1bmsvY29yZS9qcXVlcnkuanNvbnAuanNcbnZhciBqc29uUEdlbmVyaWNSZWNlaXZlciA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcbiAgICB2YXIgdHJlZjtcbiAgICB2YXIgc2NyaXB0ID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIHZhciBzY3JpcHQyOyAgLy8gT3BlcmEgc3luY2hyb25vdXMgbG9hZCB0cmljay5cbiAgICB2YXIgY2xvc2Vfc2NyaXB0ID0gZnVuY3Rpb24oZnJhbWUpIHtcbiAgICAgICAgaWYgKHNjcmlwdDIpIHtcbiAgICAgICAgICAgIHNjcmlwdDIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQyKTtcbiAgICAgICAgICAgIHNjcmlwdDIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY3JpcHQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICAgICAgICAgIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gc2NyaXB0Lm9uZXJyb3IgPVxuICAgICAgICAgICAgICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25jbGljayA9IG51bGw7XG4gICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgY2FsbGJhY2soZnJhbWUpO1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIElFOSBmaXJlcyAnZXJyb3InIGV2ZW50IGFmdGVyIG9yc2Mgb3IgYmVmb3JlLCBpbiByYW5kb20gb3JkZXIuXG4gICAgdmFyIGxvYWRlZF9va2F5ID0gZmFsc2U7XG4gICAgdmFyIGVycm9yX3RpbWVyID0gbnVsbDtcblxuICAgIHNjcmlwdC5pZCA9ICdhJyArIHV0aWxzLnJhbmRvbV9zdHJpbmcoOCk7XG4gICAgc2NyaXB0LnNyYyA9IHVybDtcbiAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgIHNjcmlwdC5jaGFyc2V0ID0gJ1VURi04JztcbiAgICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCFlcnJvcl90aW1lcikge1xuICAgICAgICAgICAgLy8gRGVsYXkgZmlyaW5nIGNsb3NlX3NjcmlwdC5cbiAgICAgICAgICAgIGVycm9yX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxvYWRlZF9va2F5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlX3NjcmlwdCh1dGlscy5jbG9zZUZyYW1lKFxuICAgICAgICAgICAgICAgICAgICAgICAgMTAwNixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbmVycm9yKVwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGNsb3NlX3NjcmlwdCh1dGlscy5jbG9zZUZyYW1lKDEwMDYsIFwiSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbmxvYWQpXCIpKTtcbiAgICB9O1xuXG4gICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKC9sb2FkZWR8Y2xvc2VkLy50ZXN0KHNjcmlwdC5yZWFkeVN0YXRlKSkge1xuICAgICAgICAgICAgaWYgKHNjcmlwdCAmJiBzY3JpcHQuaHRtbEZvciAmJiBzY3JpcHQub25jbGljaykge1xuICAgICAgICAgICAgICAgIGxvYWRlZF9va2F5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBJRSwgYWN0dWFsbHkgZXhlY3V0ZSB0aGUgc2NyaXB0LlxuICAgICAgICAgICAgICAgICAgICBzY3JpcHQub25jbGljaygpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgY2xvc2Vfc2NyaXB0KHV0aWxzLmNsb3NlRnJhbWUoMTAwNiwgXCJKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9ucmVhZHlzdGF0ZWNoYW5nZSlcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBJRTogZXZlbnQvaHRtbEZvci9vbmNsaWNrIHRyaWNrLlxuICAgIC8vIE9uZSBjYW4ndCByZWx5IG9uIHByb3BlciBvcmRlciBmb3Igb25yZWFkeXN0YXRlY2hhbmdlLiBJbiBvcmRlciB0b1xuICAgIC8vIG1ha2Ugc3VyZSwgc2V0IGEgJ2h0bWxGb3InIGFuZCAnZXZlbnQnIHByb3BlcnRpZXMsIHNvIHRoYXRcbiAgICAvLyBzY3JpcHQgY29kZSB3aWxsIGJlIGluc3RhbGxlZCBhcyAnb25jbGljaycgaGFuZGxlciBmb3IgdGhlXG4gICAgLy8gc2NyaXB0IG9iamVjdC4gTGF0ZXIsIG9ucmVhZHlzdGF0ZWNoYW5nZSwgbWFudWFsbHkgZXhlY3V0ZSB0aGlzXG4gICAgLy8gY29kZS4gRkYgYW5kIENocm9tZSBkb2Vzbid0IHdvcmsgd2l0aCAnZXZlbnQnIGFuZCAnaHRtbEZvcidcbiAgICAvLyBzZXQuIEZvciByZWZlcmVuY2Ugc2VlOlxuICAgIC8vICAgaHR0cDovL2phdWJvdXJnLm5ldC8yMDEwLzA3L2xvYWRpbmctc2NyaXB0LWFzLW9uY2xpY2staGFuZGxlci1vZi5odG1sXG4gICAgLy8gQWxzbywgcmVhZCBvbiB0aGF0IGFib3V0IHNjcmlwdCBvcmRlcmluZzpcbiAgICAvLyAgIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9EeW5hbWljX1NjcmlwdF9FeGVjdXRpb25fT3JkZXJcbiAgICBpZiAodHlwZW9mIHNjcmlwdC5hc3luYyA9PT0gJ3VuZGVmaW5lZCcgJiYgX2RvY3VtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgICAgIC8vIEFjY29yZGluZyB0byBtb3ppbGxhIGRvY3MsIGluIHJlY2VudCBicm93c2VycyBzY3JpcHQuYXN5bmMgZGVmYXVsdHNcbiAgICAgICAgLy8gdG8gJ3RydWUnLCBzbyB3ZSBtYXkgdXNlIGl0IHRvIGRldGVjdCBhIGdvb2QgYnJvd3NlcjpcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSFRNTC9FbGVtZW50L3NjcmlwdFxuICAgICAgICBpZiAoIS9vcGVyYS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgICAgIC8vIE5haXZlbHkgYXNzdW1lIHdlJ3JlIGluIElFXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHNjcmlwdC5odG1sRm9yID0gc2NyaXB0LmlkO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5ldmVudCA9IFwib25jbGlja1wiO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPcGVyYSwgc2Vjb25kIHN5bmMgc2NyaXB0IGhhY2tcbiAgICAgICAgICAgIHNjcmlwdDIgPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgICBzY3JpcHQyLnRleHQgPSBcInRyeXt2YXIgYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdcIitzY3JpcHQuaWQrXCInKTsgaWYoYSlhLm9uZXJyb3IoKTt9Y2F0Y2goeCl7fTtcIjtcbiAgICAgICAgICAgIHNjcmlwdC5hc3luYyA9IHNjcmlwdDIuYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHNjcmlwdC5hc3luYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBtb3N0bHkgZm9yIEtvbnF1ZXJvciAtIHN0dXBpZCB0aW1lciwgMzUgc2Vjb25kcyBzaGFsbCBiZSBwbGVudHkuXG4gICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlX3NjcmlwdCh1dGlscy5jbG9zZUZyYW1lKDEwMDYsIFwiSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5ICh0aW1lb3V0KVwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSwgMzUwMDApO1xuXG4gICAgdmFyIGhlYWQgPSBfZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICBoZWFkLmluc2VydEJlZm9yZShzY3JpcHQsIGhlYWQuZmlyc3RDaGlsZCk7XG4gICAgaWYgKHNjcmlwdDIpIHtcbiAgICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0MiwgaGVhZC5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb3NlX3NjcmlwdDtcbn07XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL3RyYW5zLWpzb25wLXJlY2VpdmVyLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi90cmFucy1qc29ucC1wb2xsaW5nLmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG4vLyBUaGUgc2ltcGxlc3QgYW5kIG1vc3Qgcm9idXN0IHRyYW5zcG9ydCwgdXNpbmcgdGhlIHdlbGwta25vdyBjcm9zc1xuLy8gZG9tYWluIGhhY2sgLSBKU09OUC4gVGhpcyB0cmFuc3BvcnQgaXMgcXVpdGUgaW5lZmZpY2llbnQgLSBvbmVcbi8vIG1zc2FnZSBjb3VsZCB1c2UgdXAgdG8gb25lIGh0dHAgcmVxdWVzdC4gQnV0IGF0IGxlYXN0IGl0IHdvcmtzIGFsbW9zdFxuLy8gZXZlcnl3aGVyZS5cbi8vIEtub3duIGxpbWl0YXRpb25zOlxuLy8gICBvIHlvdSB3aWxsIGdldCBhIHNwaW5uaW5nIGN1cnNvclxuLy8gICBvIGZvciBLb25xdWVyb3IgYSBkdW1iIHRpbWVyIGlzIG5lZWRlZCB0byBkZXRlY3QgZXJyb3JzXG5cblxudmFyIEpzb25QVHJhbnNwb3J0ID0gU29ja0pTWydqc29ucC1wb2xsaW5nJ10gPSBmdW5jdGlvbihyaSwgdHJhbnNfdXJsKSB7XG4gICAgdXRpbHMucG9sbHV0ZUdsb2JhbE5hbWVzcGFjZSgpO1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0LnJpID0gcmk7XG4gICAgdGhhdC50cmFuc191cmwgPSB0cmFuc191cmw7XG4gICAgdGhhdC5zZW5kX2NvbnN0cnVjdG9yKGpzb25QR2VuZXJpY1NlbmRlcik7XG4gICAgdGhhdC5fc2NoZWR1bGVfcmVjdigpO1xufTtcblxuLy8gSW5oZXJpdG5hY2Vcbkpzb25QVHJhbnNwb3J0LnByb3RvdHlwZSA9IG5ldyBCdWZmZXJlZFNlbmRlcigpO1xuXG5Kc29uUFRyYW5zcG9ydC5wcm90b3R5cGUuX3NjaGVkdWxlX3JlY3YgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGF0Ll9yZWN2X3N0b3AgPSBudWxsO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgLy8gbm8gZGF0YSAtIGhlYXJ0YmVhdDtcbiAgICAgICAgICAgIGlmICghdGhhdC5faXNfY2xvc2luZykge1xuICAgICAgICAgICAgICAgIHRoYXQucmkuX2RpZE1lc3NhZ2UoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIG1lc3NhZ2UgY2FuIGJlIGEgY2xvc2UgbWVzc2FnZSwgYW5kIGNoYW5nZSBpc19jbG9zaW5nIHN0YXRlLlxuICAgICAgICBpZiAoIXRoYXQuX2lzX2Nsb3NpbmcpIHtcbiAgICAgICAgICAgIHRoYXQuX3NjaGVkdWxlX3JlY3YoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhhdC5fcmVjdl9zdG9wID0ganNvblBSZWNlaXZlcldyYXBwZXIodGhhdC50cmFuc191cmwgKyAnL2pzb25wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uUEdlbmVyaWNSZWNlaXZlciwgY2FsbGJhY2spO1xufTtcblxuSnNvblBUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuSnNvblBUcmFuc3BvcnQubmVlZF9ib2R5ID0gdHJ1ZTtcblxuXG5Kc29uUFRyYW5zcG9ydC5wcm90b3R5cGUuZG9DbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoYXQuX2lzX2Nsb3NpbmcgPSB0cnVlO1xuICAgIGlmICh0aGF0Ll9yZWN2X3N0b3ApIHtcbiAgICAgICAgdGhhdC5fcmVjdl9zdG9wKCk7XG4gICAgfVxuICAgIHRoYXQucmkgPSB0aGF0Ll9yZWN2X3N0b3AgPSBudWxsO1xuICAgIHRoYXQuc2VuZF9kZXN0cnVjdG9yKCk7XG59O1xuXG5cbi8vIEFic3RyYWN0IGF3YXkgY29kZSB0aGF0IGhhbmRsZXMgZ2xvYmFsIG5hbWVzcGFjZSBwb2xsdXRpb24uXG52YXIganNvblBSZWNlaXZlcldyYXBwZXIgPSBmdW5jdGlvbih1cmwsIGNvbnN0cnVjdFJlY2VpdmVyLCB1c2VyX2NhbGxiYWNrKSB7XG4gICAgdmFyIGlkID0gJ2EnICsgdXRpbHMucmFuZG9tX3N0cmluZyg2KTtcbiAgICB2YXIgdXJsX2lkID0gdXJsICsgJz9jPScgKyBlc2NhcGUoV1ByZWZpeCArICcuJyArIGlkKTtcbiAgICAvLyBDYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBleGFjdGx5IG9uY2UuXG4gICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24oZnJhbWUpIHtcbiAgICAgICAgZGVsZXRlIF93aW5kb3dbV1ByZWZpeF1baWRdO1xuICAgICAgICB1c2VyX2NhbGxiYWNrKGZyYW1lKTtcbiAgICB9O1xuXG4gICAgdmFyIGNsb3NlX3NjcmlwdCA9IGNvbnN0cnVjdFJlY2VpdmVyKHVybF9pZCwgY2FsbGJhY2spO1xuICAgIF93aW5kb3dbV1ByZWZpeF1baWRdID0gY2xvc2Vfc2NyaXB0O1xuICAgIHZhciBzdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChfd2luZG93W1dQcmVmaXhdW2lkXSkge1xuICAgICAgICAgICAgX3dpbmRvd1tXUHJlZml4XVtpZF0odXRpbHMuY2xvc2VGcmFtZSgxMDAwLCBcIkpTT05QIHVzZXIgYWJvcnRlZCByZWFkXCIpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHN0b3A7XG59O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi90cmFucy1qc29ucC1wb2xsaW5nLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi90cmFucy14aHIuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbnZhciBBamF4QmFzZWRUcmFuc3BvcnQgPSBmdW5jdGlvbigpIHt9O1xuQWpheEJhc2VkVHJhbnNwb3J0LnByb3RvdHlwZSA9IG5ldyBCdWZmZXJlZFNlbmRlcigpO1xuXG5BamF4QmFzZWRUcmFuc3BvcnQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKHJpLCB0cmFuc191cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybF9zdWZmaXgsIFJlY2VpdmVyLCBBamF4T2JqZWN0KSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoYXQucmkgPSByaTtcbiAgICB0aGF0LnRyYW5zX3VybCA9IHRyYW5zX3VybDtcbiAgICB0aGF0LnNlbmRfY29uc3RydWN0b3IoY3JlYXRlQWpheFNlbmRlcihBamF4T2JqZWN0KSk7XG4gICAgdGhhdC5wb2xsID0gbmV3IFBvbGxpbmcocmksIFJlY2VpdmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zX3VybCArIHVybF9zdWZmaXgsIEFqYXhPYmplY3QpO1xufTtcblxuQWpheEJhc2VkVHJhbnNwb3J0LnByb3RvdHlwZS5kb0NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgaWYgKHRoYXQucG9sbCkge1xuICAgICAgICB0aGF0LnBvbGwuYWJvcnQoKTtcbiAgICAgICAgdGhhdC5wb2xsID0gbnVsbDtcbiAgICB9XG59O1xuXG4vLyB4aHItc3RyZWFtaW5nXG52YXIgWGhyU3RyZWFtaW5nVHJhbnNwb3J0ID0gU29ja0pTWyd4aHItc3RyZWFtaW5nJ10gPSBmdW5jdGlvbihyaSwgdHJhbnNfdXJsKSB7XG4gICAgdGhpcy5ydW4ocmksIHRyYW5zX3VybCwgJy94aHJfc3RyZWFtaW5nJywgWGhyUmVjZWl2ZXIsIHV0aWxzLlhIUkNvcnNPYmplY3QpO1xufTtcblxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LnByb3RvdHlwZSA9IG5ldyBBamF4QmFzZWRUcmFuc3BvcnQoKTtcblxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBTdXBwb3J0IGZvciBDT1JTIEFqYXggYWthIEFqYXgyPyBPcGVyYSAxMiBjbGFpbXMgQ09SUyBidXRcbiAgICAvLyBkb2Vzbid0IGRvIHN0cmVhbWluZy5cbiAgICByZXR1cm4gKF93aW5kb3cuWE1MSHR0cFJlcXVlc3QgJiZcbiAgICAgICAgICAgICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpICYmXG4gICAgICAgICAgICAoIS9vcGVyYS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpKTtcbn07XG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG4vLyBTYWZhcmkgZ2V0cyBjb25mdXNlZCB3aGVuIGEgc3RyZWFtaW5nIGFqYXggcmVxdWVzdCBpcyBzdGFydGVkXG4vLyBiZWZvcmUgb25sb2FkLiBUaGlzIGNhdXNlcyB0aGUgbG9hZCBpbmRpY2F0b3IgdG8gc3BpbiBpbmRlZmluZXRlbHkuXG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQubmVlZF9ib2R5ID0gdHJ1ZTtcblxuXG4vLyBBY2NvcmRpbmcgdG86XG4vLyAgIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTY0MTUwNy9kZXRlY3QtYnJvd3Nlci1zdXBwb3J0LWZvci1jcm9zcy1kb21haW4teG1saHR0cHJlcXVlc3RzXG4vLyAgIGh0dHA6Ly9oYWNrcy5tb3ppbGxhLm9yZy8yMDA5LzA3L2Nyb3NzLXNpdGUteG1saHR0cHJlcXVlc3Qtd2l0aC1jb3JzL1xuXG5cbi8vIHhkci1zdHJlYW1pbmdcbnZhciBYZHJTdHJlYW1pbmdUcmFuc3BvcnQgPSBTb2NrSlNbJ3hkci1zdHJlYW1pbmcnXSA9IGZ1bmN0aW9uKHJpLCB0cmFuc191cmwpIHtcbiAgICB0aGlzLnJ1bihyaSwgdHJhbnNfdXJsLCAnL3hocl9zdHJlYW1pbmcnLCBYaHJSZWNlaXZlciwgdXRpbHMuWERST2JqZWN0KTtcbn07XG5cblhkclN0cmVhbWluZ1RyYW5zcG9ydC5wcm90b3R5cGUgPSBuZXcgQWpheEJhc2VkVHJhbnNwb3J0KCk7XG5cblhkclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhX3dpbmRvdy5YRG9tYWluUmVxdWVzdDtcbn07XG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG5cblxuLy8geGhyLXBvbGxpbmdcbnZhciBYaHJQb2xsaW5nVHJhbnNwb3J0ID0gU29ja0pTWyd4aHItcG9sbGluZyddID0gZnVuY3Rpb24ocmksIHRyYW5zX3VybCkge1xuICAgIHRoaXMucnVuKHJpLCB0cmFuc191cmwsICcveGhyJywgWGhyUmVjZWl2ZXIsIHV0aWxzLlhIUkNvcnNPYmplY3QpO1xufTtcblxuWGhyUG9sbGluZ1RyYW5zcG9ydC5wcm90b3R5cGUgPSBuZXcgQWpheEJhc2VkVHJhbnNwb3J0KCk7XG5cblhoclBvbGxpbmdUcmFuc3BvcnQuZW5hYmxlZCA9IFhoclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkO1xuWGhyUG9sbGluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cblxuLy8geGRyLXBvbGxpbmdcbnZhciBYZHJQb2xsaW5nVHJhbnNwb3J0ID0gU29ja0pTWyd4ZHItcG9sbGluZyddID0gZnVuY3Rpb24ocmksIHRyYW5zX3VybCkge1xuICAgIHRoaXMucnVuKHJpLCB0cmFuc191cmwsICcveGhyJywgWGhyUmVjZWl2ZXIsIHV0aWxzLlhEUk9iamVjdCk7XG59O1xuXG5YZHJQb2xsaW5nVHJhbnNwb3J0LnByb3RvdHlwZSA9IG5ldyBBamF4QmFzZWRUcmFuc3BvcnQoKTtcblxuWGRyUG9sbGluZ1RyYW5zcG9ydC5lbmFibGVkID0gWGRyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQ7XG5YZHJQb2xsaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvdHJhbnMteGhyLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi90cmFucy1pZnJhbWUuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbi8vIEZldyBjb29sIHRyYW5zcG9ydHMgZG8gd29yayBvbmx5IGZvciBzYW1lLW9yaWdpbi4gSW4gb3JkZXIgdG8gbWFrZVxuLy8gdGhlbSB3b3JraW5nIGNyb3NzLWRvbWFpbiB3ZSBzaGFsbCB1c2UgaWZyYW1lLCBzZXJ2ZWQgZm9ybSB0aGVcbi8vIHJlbW90ZSBkb21haW4uIE5ldyBicm93c2VycywgaGF2ZSBjYXBhYmlsaXRpZXMgdG8gY29tbXVuaWNhdGUgd2l0aFxuLy8gY3Jvc3MgZG9tYWluIGlmcmFtZSwgdXNpbmcgcG9zdE1lc3NhZ2UoKS4gSW4gSUUgaXQgd2FzIGltcGxlbWVudGVkXG4vLyBmcm9tIElFIDgrLCBidXQgb2YgY291cnNlLCBJRSBnb3Qgc29tZSBkZXRhaWxzIHdyb25nOlxuLy8gICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2NjMTk3MDE1KHY9VlMuODUpLmFzcHhcbi8vICAgIGh0dHA6Ly9zdGV2ZXNvdWRlcnMuY29tL21pc2MvdGVzdC1wb3N0bWVzc2FnZS5waHBcblxudmFyIElmcmFtZVRyYW5zcG9ydCA9IGZ1bmN0aW9uKCkge307XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuaV9jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKHJpLCB0cmFuc191cmwsIGJhc2VfdXJsKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoYXQucmkgPSByaTtcbiAgICB0aGF0Lm9yaWdpbiA9IHV0aWxzLmdldE9yaWdpbihiYXNlX3VybCk7XG4gICAgdGhhdC5iYXNlX3VybCA9IGJhc2VfdXJsO1xuICAgIHRoYXQudHJhbnNfdXJsID0gdHJhbnNfdXJsO1xuXG4gICAgdmFyIGlmcmFtZV91cmwgPSBiYXNlX3VybCArICcvaWZyYW1lLmh0bWwnO1xuICAgIGlmICh0aGF0LnJpLl9vcHRpb25zLmRldmVsKSB7XG4gICAgICAgIGlmcmFtZV91cmwgKz0gJz90PScgKyAoK25ldyBEYXRlKTtcbiAgICB9XG4gICAgdGhhdC53aW5kb3dfaWQgPSB1dGlscy5yYW5kb21fc3RyaW5nKDgpO1xuICAgIGlmcmFtZV91cmwgKz0gJyMnICsgdGhhdC53aW5kb3dfaWQ7XG5cbiAgICB0aGF0LmlmcmFtZU9iaiA9IHV0aWxzLmNyZWF0ZUlmcmFtZShpZnJhbWVfdXJsLCBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQucmkuX2RpZENsb3NlKDEwMDYsIFwiVW5hYmxlIHRvIGxvYWQgYW4gaWZyYW1lIChcIiArIHIgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICB0aGF0Lm9ubWVzc2FnZV9jYiA9IHV0aWxzLmJpbmQodGhhdC5vbm1lc3NhZ2UsIHRoYXQpO1xuICAgIHV0aWxzLmF0dGFjaE1lc3NhZ2UodGhhdC5vbm1lc3NhZ2VfY2IpO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5kb0NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgaWYgKHRoYXQuaWZyYW1lT2JqKSB7XG4gICAgICAgIHV0aWxzLmRldGFjaE1lc3NhZ2UodGhhdC5vbm1lc3NhZ2VfY2IpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgICAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cbiAgICAgICAgICAgIGlmICh0aGF0LmlmcmFtZU9iai5pZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgICAgIHRoYXQucG9zdE1lc3NhZ2UoJ2MnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgdGhhdC5pZnJhbWVPYmouY2xlYW51cCgpO1xuICAgICAgICB0aGF0LmlmcmFtZU9iaiA9IG51bGw7XG4gICAgICAgIHRoYXQub25tZXNzYWdlX2NiID0gdGhhdC5pZnJhbWVPYmogPSBudWxsO1xuICAgIH1cbn07XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBpZiAoZS5vcmlnaW4gIT09IHRoYXQub3JpZ2luKSByZXR1cm47XG4gICAgdmFyIHdpbmRvd19pZCA9IGUuZGF0YS5zbGljZSgwLCA4KTtcbiAgICB2YXIgdHlwZSA9IGUuZGF0YS5zbGljZSg4LCA5KTtcbiAgICB2YXIgZGF0YSA9IGUuZGF0YS5zbGljZSg5KTtcblxuICAgIGlmICh3aW5kb3dfaWQgIT09IHRoYXQud2luZG93X2lkKSByZXR1cm47XG5cbiAgICBzd2l0Y2godHlwZSkge1xuICAgIGNhc2UgJ3MnOlxuICAgICAgICB0aGF0LmlmcmFtZU9iai5sb2FkZWQoKTtcbiAgICAgICAgdGhhdC5wb3N0TWVzc2FnZSgncycsIEpTT04uc3RyaW5naWZ5KFtTb2NrSlMudmVyc2lvbiwgdGhhdC5wcm90b2NvbCwgdGhhdC50cmFuc191cmwsIHRoYXQuYmFzZV91cmxdKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3QnOlxuICAgICAgICB0aGF0LnJpLl9kaWRNZXNzYWdlKGRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLnBvc3RNZXNzYWdlID0gZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0LmlmcmFtZU9iai5wb3N0KHRoYXQud2luZG93X2lkICsgdHlwZSArIChkYXRhIHx8ICcnKSwgdGhhdC5vcmlnaW4pO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5kb1NlbmQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIHRoaXMucG9zdE1lc3NhZ2UoJ20nLCBtZXNzYWdlKTtcbn07XG5cbklmcmFtZVRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gcG9zdE1lc3NhZ2UgbWlzYmVoYXZlcyBpbiBrb25xdWVyb3IgNC42LjUgLSB0aGUgbWVzc2FnZXMgYXJlIGRlbGl2ZXJlZCB3aXRoXG4gICAgLy8gaHVnZSBkZWxheSwgb3Igbm90IGF0IGFsbC5cbiAgICB2YXIga29ucXVlcm9yID0gbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdLb25xdWVyb3InKSAhPT0gLTE7XG4gICAgcmV0dXJuICgodHlwZW9mIF93aW5kb3cucG9zdE1lc3NhZ2UgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIHR5cGVvZiBfd2luZG93LnBvc3RNZXNzYWdlID09PSAnb2JqZWN0JykgJiYgKCFrb25xdWVyb3IpKTtcbn07XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL3RyYW5zLWlmcmFtZS5qc1xuXG5cbi8vICAgICAgICAgWypdIEluY2x1ZGluZyBsaWIvdHJhbnMtaWZyYW1lLXdpdGhpbi5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxudmFyIGN1cnJfd2luZG93X2lkO1xuXG52YXIgcG9zdE1lc3NhZ2UgPSBmdW5jdGlvbiAodHlwZSwgZGF0YSkge1xuICAgIGlmKHBhcmVudCAhPT0gX3dpbmRvdykge1xuICAgICAgICBwYXJlbnQucG9zdE1lc3NhZ2UoY3Vycl93aW5kb3dfaWQgKyB0eXBlICsgKGRhdGEgfHwgJycpLCAnKicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWxzLmxvZyhcIkNhbid0IHBvc3RNZXNzYWdlLCBubyBwYXJlbnQgd2luZG93LlwiLCB0eXBlLCBkYXRhKTtcbiAgICB9XG59O1xuXG52YXIgRmFjYWRlSlMgPSBmdW5jdGlvbigpIHt9O1xuRmFjYWRlSlMucHJvdG90eXBlLl9kaWRDbG9zZSA9IGZ1bmN0aW9uIChjb2RlLCByZWFzb24pIHtcbiAgICBwb3N0TWVzc2FnZSgndCcsIHV0aWxzLmNsb3NlRnJhbWUoY29kZSwgcmVhc29uKSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl9kaWRNZXNzYWdlID0gZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgcG9zdE1lc3NhZ2UoJ3QnLCBmcmFtZSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl9kb1NlbmQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRoaXMuX3RyYW5zcG9ydC5kb1NlbmQoZGF0YSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl9kb0NsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdHJhbnNwb3J0LmRvQ2xlYW51cCgpO1xufTtcblxudXRpbHMucGFyZW50X29yaWdpbiA9IHVuZGVmaW5lZDtcblxuU29ja0pTLmJvb3RzdHJhcF9pZnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZmFjYWRlO1xuICAgIGN1cnJfd2luZG93X2lkID0gX2RvY3VtZW50LmxvY2F0aW9uLmhhc2guc2xpY2UoMSk7XG4gICAgdmFyIG9uTWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYoZS5zb3VyY2UgIT09IHBhcmVudCkgcmV0dXJuO1xuICAgICAgICBpZih0eXBlb2YgdXRpbHMucGFyZW50X29yaWdpbiA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICB1dGlscy5wYXJlbnRfb3JpZ2luID0gZS5vcmlnaW47XG4gICAgICAgIGlmIChlLm9yaWdpbiAhPT0gdXRpbHMucGFyZW50X29yaWdpbikgcmV0dXJuO1xuXG4gICAgICAgIHZhciB3aW5kb3dfaWQgPSBlLmRhdGEuc2xpY2UoMCwgOCk7XG4gICAgICAgIHZhciB0eXBlID0gZS5kYXRhLnNsaWNlKDgsIDkpO1xuICAgICAgICB2YXIgZGF0YSA9IGUuZGF0YS5zbGljZSg5KTtcbiAgICAgICAgaWYgKHdpbmRvd19pZCAhPT0gY3Vycl93aW5kb3dfaWQpIHJldHVybjtcbiAgICAgICAgc3dpdGNoKHR5cGUpIHtcbiAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICB2YXIgcCA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICB2YXIgdmVyc2lvbiA9IHBbMF07XG4gICAgICAgICAgICB2YXIgcHJvdG9jb2wgPSBwWzFdO1xuICAgICAgICAgICAgdmFyIHRyYW5zX3VybCA9IHBbMl07XG4gICAgICAgICAgICB2YXIgYmFzZV91cmwgPSBwWzNdO1xuICAgICAgICAgICAgaWYgKHZlcnNpb24gIT09IFNvY2tKUy52ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgdXRpbHMubG9nKFwiSW5jb21wYXRpYmlsZSBTb2NrSlMhIE1haW4gc2l0ZSB1c2VzOlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgXFxcIlwiICsgdmVyc2lvbiArIFwiXFxcIiwgdGhlIGlmcmFtZTpcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiIFxcXCJcIiArIFNvY2tKUy52ZXJzaW9uICsgXCJcXFwiLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdXRpbHMuZmxhdFVybCh0cmFuc191cmwpIHx8ICF1dGlscy5mbGF0VXJsKGJhc2VfdXJsKSkge1xuICAgICAgICAgICAgICAgIHV0aWxzLmxvZyhcIk9ubHkgYmFzaWMgdXJscyBhcmUgc3VwcG9ydGVkIGluIFNvY2tKU1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdXRpbHMuaXNTYW1lT3JpZ2luVXJsKHRyYW5zX3VybCkgfHxcbiAgICAgICAgICAgICAgICAhdXRpbHMuaXNTYW1lT3JpZ2luVXJsKGJhc2VfdXJsKSkge1xuICAgICAgICAgICAgICAgIHV0aWxzLmxvZyhcIkNhbid0IGNvbm5lY3QgdG8gZGlmZmVyZW50IGRvbWFpbiBmcm9tIHdpdGhpbiBhbiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiaWZyYW1lLiAoXCIgKyBKU09OLnN0cmluZ2lmeShbX3dpbmRvdy5sb2NhdGlvbi5ocmVmLCB0cmFuc191cmwsIGJhc2VfdXJsXSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcIilcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmFjYWRlID0gbmV3IEZhY2FkZUpTKCk7XG4gICAgICAgICAgICBmYWNhZGUuX3RyYW5zcG9ydCA9IG5ldyBGYWNhZGVKU1twcm90b2NvbF0oZmFjYWRlLCB0cmFuc191cmwsIGJhc2VfdXJsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgIGZhY2FkZS5fZG9TZW5kKGRhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgaWYgKGZhY2FkZSlcbiAgICAgICAgICAgICAgICBmYWNhZGUuX2RvQ2xlYW51cCgpO1xuICAgICAgICAgICAgZmFjYWRlID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIGFsZXJ0KCd0ZXN0IHRpY2tlcicpO1xuICAgIC8vIGZhY2FkZSA9IG5ldyBGYWNhZGVKUygpO1xuICAgIC8vIGZhY2FkZS5fdHJhbnNwb3J0ID0gbmV3IEZhY2FkZUpTWyd3LWlmcmFtZS14aHItcG9sbGluZyddKGZhY2FkZSwgJ2h0dHA6Ly9ob3N0LmNvbTo5OTk5L3RpY2tlci8xMi9iYXNkJyk7XG5cbiAgICB1dGlscy5hdHRhY2hNZXNzYWdlKG9uTWVzc2FnZSk7XG5cbiAgICAvLyBTdGFydFxuICAgIHBvc3RNZXNzYWdlKCdzJyk7XG59O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi90cmFucy1pZnJhbWUtd2l0aGluLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi9pbmZvLmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG52YXIgSW5mb1JlY2VpdmVyID0gZnVuY3Rpb24oYmFzZV91cmwsIEFqYXhPYmplY3QpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdXRpbHMuZGVsYXkoZnVuY3Rpb24oKXt0aGF0LmRvWGhyKGJhc2VfdXJsLCBBamF4T2JqZWN0KTt9KTtcbn07XG5cbkluZm9SZWNlaXZlci5wcm90b3R5cGUgPSBuZXcgRXZlbnRFbWl0dGVyKFsnZmluaXNoJ10pO1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLmRvWGhyID0gZnVuY3Rpb24oYmFzZV91cmwsIEFqYXhPYmplY3QpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIHQwID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICB2YXIgeG8gPSBuZXcgQWpheE9iamVjdCgnR0VUJywgYmFzZV91cmwgKyAnL2luZm8nKTtcblxuICAgIHZhciB0cmVmID0gdXRpbHMuZGVsYXkoODAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCl7eG8ub250aW1lb3V0KCk7fSk7XG5cbiAgICB4by5vbmZpbmlzaCA9IGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICAgIHRyZWYgPSBudWxsO1xuICAgICAgICBpZiAoc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIHZhciBydHQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gdDA7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IEpTT04ucGFyc2UodGV4dCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZm8gIT09ICdvYmplY3QnKSBpbmZvID0ge307XG4gICAgICAgICAgICB0aGF0LmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGF0LmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB4by5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgeG8uY2xvc2UoKTtcbiAgICAgICAgdGhhdC5lbWl0KCdmaW5pc2gnKTtcbiAgICB9O1xufTtcblxudmFyIEluZm9SZWNlaXZlcklmcmFtZSA9IGZ1bmN0aW9uKGJhc2VfdXJsKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBnbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaWZyID0gbmV3IElmcmFtZVRyYW5zcG9ydCgpO1xuICAgICAgICBpZnIucHJvdG9jb2wgPSAndy1pZnJhbWUtaW5mby1yZWNlaXZlcic7XG4gICAgICAgIHZhciBmdW4gPSBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHIgPT09ICdzdHJpbmcnICYmIHIuc3Vic3RyKDAsMSkgPT09ICdtJykge1xuICAgICAgICAgICAgICAgIHZhciBkID0gSlNPTi5wYXJzZShyLnN1YnN0cigxKSk7XG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSBkWzBdLCBydHQgPSBkWzFdO1xuICAgICAgICAgICAgICAgIHRoYXQuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhhdC5lbWl0KCdmaW5pc2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmci5kb0NsZWFudXAoKTtcbiAgICAgICAgICAgIGlmciA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtb2NrX3JpID0ge1xuICAgICAgICAgICAgX29wdGlvbnM6IHt9LFxuICAgICAgICAgICAgX2RpZENsb3NlOiBmdW4sXG4gICAgICAgICAgICBfZGlkTWVzc2FnZTogZnVuXG4gICAgICAgIH07XG4gICAgICAgIGlmci5pX2NvbnN0cnVjdG9yKG1vY2tfcmksIGJhc2VfdXJsLCBiYXNlX3VybCk7XG4gICAgfVxuICAgIGlmKCFfZG9jdW1lbnQuYm9keSkge1xuICAgICAgICB1dGlscy5hdHRhY2hFdmVudCgnbG9hZCcsIGdvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnbygpO1xuICAgIH1cbn07XG5JbmZvUmVjZWl2ZXJJZnJhbWUucHJvdG90eXBlID0gbmV3IEV2ZW50RW1pdHRlcihbJ2ZpbmlzaCddKTtcblxuXG52YXIgSW5mb1JlY2VpdmVyRmFrZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIEl0IG1heSBub3QgYmUgcG9zc2libGUgdG8gZG8gY3Jvc3MgZG9tYWluIEFKQVggdG8gZ2V0IHRoZSBpbmZvXG4gICAgLy8gZGF0YSwgZm9yIGV4YW1wbGUgZm9yIElFNy4gQnV0IHdlIHdhbnQgdG8gcnVuIEpTT05QLCBzbyBsZXQnc1xuICAgIC8vIGZha2UgdGhlIHJlc3BvbnNlLCB3aXRoIHJ0dD0ycyAocnRvPTZzKS5cbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdXRpbHMuZGVsYXkoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoYXQuZW1pdCgnZmluaXNoJywge30sIDIwMDApO1xuICAgIH0pO1xufTtcbkluZm9SZWNlaXZlckZha2UucHJvdG90eXBlID0gbmV3IEV2ZW50RW1pdHRlcihbJ2ZpbmlzaCddKTtcblxudmFyIGNyZWF0ZUluZm9SZWNlaXZlciA9IGZ1bmN0aW9uKGJhc2VfdXJsKSB7XG4gICAgaWYgKHV0aWxzLmlzU2FtZU9yaWdpblVybChiYXNlX3VybCkpIHtcbiAgICAgICAgLy8gSWYsIGZvciBzb21lIHJlYXNvbiwgd2UgaGF2ZSBTb2NrSlMgbG9jYWxseSAtIHRoZXJlJ3Mgbm9cbiAgICAgICAgLy8gbmVlZCB0byBzdGFydCB1cCB0aGUgY29tcGxleCBtYWNoaW5lcnkuIEp1c3QgdXNlIGFqYXguXG4gICAgICAgIHJldHVybiBuZXcgSW5mb1JlY2VpdmVyKGJhc2VfdXJsLCB1dGlscy5YSFJMb2NhbE9iamVjdCk7XG4gICAgfVxuICAgIHN3aXRjaCAodXRpbHMuaXNYSFJDb3JzQ2FwYWJsZSgpKSB7XG4gICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gbmV3IEluZm9SZWNlaXZlcihiYXNlX3VybCwgdXRpbHMuWEhSQ29yc09iamVjdCk7XG4gICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gbmV3IEluZm9SZWNlaXZlcihiYXNlX3VybCwgdXRpbHMuWERST2JqZWN0KTtcbiAgICBjYXNlIDM6XG4gICAgICAgIC8vIE9wZXJhXG4gICAgICAgIHJldHVybiBuZXcgSW5mb1JlY2VpdmVySWZyYW1lKGJhc2VfdXJsKTtcbiAgICBkZWZhdWx0OlxuICAgICAgICAvLyBJRSA3XG4gICAgICAgIHJldHVybiBuZXcgSW5mb1JlY2VpdmVyRmFrZSgpO1xuICAgIH07XG59O1xuXG5cbnZhciBXSW5mb1JlY2VpdmVySWZyYW1lID0gRmFjYWRlSlNbJ3ctaWZyYW1lLWluZm8tcmVjZWl2ZXInXSA9IGZ1bmN0aW9uKHJpLCBfdHJhbnNfdXJsLCBiYXNlX3VybCkge1xuICAgIHZhciBpciA9IG5ldyBJbmZvUmVjZWl2ZXIoYmFzZV91cmwsIHV0aWxzLlhIUkxvY2FsT2JqZWN0KTtcbiAgICBpci5vbmZpbmlzaCA9IGZ1bmN0aW9uKGluZm8sIHJ0dCkge1xuICAgICAgICByaS5fZGlkTWVzc2FnZSgnbScrSlNPTi5zdHJpbmdpZnkoW2luZm8sIHJ0dF0pKTtcbiAgICAgICAgcmkuX2RpZENsb3NlKCk7XG4gICAgfVxufTtcbldJbmZvUmVjZWl2ZXJJZnJhbWUucHJvdG90eXBlLmRvQ2xlYW51cCA9IGZ1bmN0aW9uKCkge307XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL2luZm8uanNcblxuXG4vLyAgICAgICAgIFsqXSBJbmNsdWRpbmcgbGliL3RyYW5zLWlmcmFtZS1ldmVudHNvdXJjZS5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxudmFyIEV2ZW50U291cmNlSWZyYW1lVHJhbnNwb3J0ID0gU29ja0pTWydpZnJhbWUtZXZlbnRzb3VyY2UnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhhdC5wcm90b2NvbCA9ICd3LWlmcmFtZS1ldmVudHNvdXJjZSc7XG4gICAgdGhhdC5pX2NvbnN0cnVjdG9yLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG59O1xuXG5FdmVudFNvdXJjZUlmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUgPSBuZXcgSWZyYW1lVHJhbnNwb3J0KCk7XG5cbkV2ZW50U291cmNlSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICgnRXZlbnRTb3VyY2UnIGluIF93aW5kb3cpICYmIElmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCk7XG59O1xuXG5FdmVudFNvdXJjZUlmcmFtZVRyYW5zcG9ydC5uZWVkX2JvZHkgPSB0cnVlO1xuRXZlbnRTb3VyY2VJZnJhbWVUcmFuc3BvcnQucm91bmRUcmlwcyA9IDM7IC8vIGh0bWwsIGphdmFzY3JpcHQsIGV2ZW50c291cmNlXG5cblxuLy8gdy1pZnJhbWUtZXZlbnRzb3VyY2VcbnZhciBFdmVudFNvdXJjZVRyYW5zcG9ydCA9IEZhY2FkZUpTWyd3LWlmcmFtZS1ldmVudHNvdXJjZSddID0gZnVuY3Rpb24ocmksIHRyYW5zX3VybCkge1xuICAgIHRoaXMucnVuKHJpLCB0cmFuc191cmwsICcvZXZlbnRzb3VyY2UnLCBFdmVudFNvdXJjZVJlY2VpdmVyLCB1dGlscy5YSFJMb2NhbE9iamVjdCk7XG59XG5FdmVudFNvdXJjZVRyYW5zcG9ydC5wcm90b3R5cGUgPSBuZXcgQWpheEJhc2VkVHJhbnNwb3J0KCk7XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL3RyYW5zLWlmcmFtZS1ldmVudHNvdXJjZS5qc1xuXG5cbi8vICAgICAgICAgWypdIEluY2x1ZGluZyBsaWIvdHJhbnMtaWZyYW1lLXhoci1wb2xsaW5nLmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG52YXIgWGhyUG9sbGluZ0lmcmFtZVRyYW5zcG9ydCA9IFNvY2tKU1snaWZyYW1lLXhoci1wb2xsaW5nJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoYXQucHJvdG9jb2wgPSAndy1pZnJhbWUteGhyLXBvbGxpbmcnO1xuICAgIHRoYXQuaV9jb25zdHJ1Y3Rvci5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xufTtcblxuWGhyUG9sbGluZ0lmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUgPSBuZXcgSWZyYW1lVHJhbnNwb3J0KCk7XG5cblhoclBvbGxpbmdJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3dpbmRvdy5YTUxIdHRwUmVxdWVzdCAmJiBJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpO1xufTtcblxuWGhyUG9sbGluZ0lmcmFtZVRyYW5zcG9ydC5uZWVkX2JvZHkgPSB0cnVlO1xuWGhyUG9sbGluZ0lmcmFtZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMzsgLy8gaHRtbCwgamF2YXNjcmlwdCwgeGhyXG5cblxuLy8gdy1pZnJhbWUteGhyLXBvbGxpbmdcbnZhciBYaHJQb2xsaW5nSVRyYW5zcG9ydCA9IEZhY2FkZUpTWyd3LWlmcmFtZS14aHItcG9sbGluZyddID0gZnVuY3Rpb24ocmksIHRyYW5zX3VybCkge1xuICAgIHRoaXMucnVuKHJpLCB0cmFuc191cmwsICcveGhyJywgWGhyUmVjZWl2ZXIsIHV0aWxzLlhIUkxvY2FsT2JqZWN0KTtcbn07XG5cblhoclBvbGxpbmdJVHJhbnNwb3J0LnByb3RvdHlwZSA9IG5ldyBBamF4QmFzZWRUcmFuc3BvcnQoKTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvdHJhbnMtaWZyYW1lLXhoci1wb2xsaW5nLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi90cmFucy1pZnJhbWUtaHRtbGZpbGUuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbi8vIFRoaXMgdHJhbnNwb3J0IGdlbmVyYWxseSB3b3JrcyBpbiBhbnkgYnJvd3NlciwgYnV0IHdpbGwgY2F1c2UgYVxuLy8gc3Bpbm5pbmcgY3Vyc29yIHRvIGFwcGVhciBpbiBhbnkgYnJvd3NlciBvdGhlciB0aGFuIElFLlxuLy8gV2UgbWF5IHRlc3QgdGhpcyB0cmFuc3BvcnQgaW4gYWxsIGJyb3dzZXJzIC0gd2h5IG5vdCwgYnV0IGluXG4vLyBwcm9kdWN0aW9uIGl0IHNob3VsZCBiZSBvbmx5IHJ1biBpbiBJRS5cblxudmFyIEh0bWxGaWxlSWZyYW1lVHJhbnNwb3J0ID0gU29ja0pTWydpZnJhbWUtaHRtbGZpbGUnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhhdC5wcm90b2NvbCA9ICd3LWlmcmFtZS1odG1sZmlsZSc7XG4gICAgdGhhdC5pX2NvbnN0cnVjdG9yLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG59O1xuXG4vLyBJbmhlcml0YW5jZS5cbkh0bWxGaWxlSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZSA9IG5ldyBJZnJhbWVUcmFuc3BvcnQoKTtcblxuSHRtbEZpbGVJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpO1xufTtcblxuSHRtbEZpbGVJZnJhbWVUcmFuc3BvcnQubmVlZF9ib2R5ID0gdHJ1ZTtcbkh0bWxGaWxlSWZyYW1lVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAzOyAvLyBodG1sLCBqYXZhc2NyaXB0LCBodG1sZmlsZVxuXG5cbi8vIHctaWZyYW1lLWh0bWxmaWxlXG52YXIgSHRtbEZpbGVUcmFuc3BvcnQgPSBGYWNhZGVKU1sndy1pZnJhbWUtaHRtbGZpbGUnXSA9IGZ1bmN0aW9uKHJpLCB0cmFuc191cmwpIHtcbiAgICB0aGlzLnJ1bihyaSwgdHJhbnNfdXJsLCAnL2h0bWxmaWxlJywgSHRtbGZpbGVSZWNlaXZlciwgdXRpbHMuWEhSTG9jYWxPYmplY3QpO1xufTtcbkh0bWxGaWxlVHJhbnNwb3J0LnByb3RvdHlwZSA9IG5ldyBBamF4QmFzZWRUcmFuc3BvcnQoKTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvdHJhbnMtaWZyYW1lLWh0bWxmaWxlLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi90cmFucy1wb2xsaW5nLmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG52YXIgUG9sbGluZyA9IGZ1bmN0aW9uKHJpLCBSZWNlaXZlciwgcmVjdl91cmwsIEFqYXhPYmplY3QpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhhdC5yaSA9IHJpO1xuICAgIHRoYXQuUmVjZWl2ZXIgPSBSZWNlaXZlcjtcbiAgICB0aGF0LnJlY3ZfdXJsID0gcmVjdl91cmw7XG4gICAgdGhhdC5BamF4T2JqZWN0ID0gQWpheE9iamVjdDtcbiAgICB0aGF0Ll9zY2hlZHVsZVJlY3YoKTtcbn07XG5cblBvbGxpbmcucHJvdG90eXBlLl9zY2hlZHVsZVJlY3YgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIHBvbGwgPSB0aGF0LnBvbGwgPSBuZXcgdGhhdC5SZWNlaXZlcih0aGF0LnJlY3ZfdXJsLCB0aGF0LkFqYXhPYmplY3QpO1xuICAgIHZhciBtc2dfY291bnRlciA9IDA7XG4gICAgcG9sbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIG1zZ19jb3VudGVyICs9IDE7XG4gICAgICAgIHRoYXQucmkuX2RpZE1lc3NhZ2UoZS5kYXRhKTtcbiAgICB9O1xuICAgIHBvbGwub25jbG9zZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhhdC5wb2xsID0gcG9sbCA9IHBvbGwub25tZXNzYWdlID0gcG9sbC5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgaWYgKCF0aGF0LnBvbGxfaXNfY2xvc2luZykge1xuICAgICAgICAgICAgaWYgKGUucmVhc29uID09PSAncGVybWFuZW50Jykge1xuICAgICAgICAgICAgICAgIHRoYXQucmkuX2RpZENsb3NlKDEwMDYsICdQb2xsaW5nIGVycm9yICgnICsgZS5yZWFzb24gKyAnKScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGF0Ll9zY2hlZHVsZVJlY3YoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0LnBvbGxfaXNfY2xvc2luZyA9IHRydWU7XG4gICAgaWYgKHRoYXQucG9sbCkge1xuICAgICAgICB0aGF0LnBvbGwuYWJvcnQoKTtcbiAgICB9XG59O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi90cmFucy1wb2xsaW5nLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi90cmFucy1yZWNlaXZlci1ldmVudHNvdXJjZS5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxudmFyIEV2ZW50U291cmNlUmVjZWl2ZXIgPSBmdW5jdGlvbih1cmwpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIGVzID0gbmV3IEV2ZW50U291cmNlKHVybCk7XG4gICAgZXMub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGF0LmRpc3BhdGNoRXZlbnQobmV3IFNpbXBsZUV2ZW50KCdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7J2RhdGEnOiB1bmVzY2FwZShlLmRhdGEpfSkpO1xuICAgIH07XG4gICAgdGhhdC5lc19jbG9zZSA9IGVzLm9uZXJyb3IgPSBmdW5jdGlvbihlLCBhYm9ydF9yZWFzb24pIHtcbiAgICAgICAgLy8gRVMgb24gcmVjb25uZWN0aW9uIGhhcyByZWFkeVN0YXRlID0gMCBvciAxLlxuICAgICAgICAvLyBvbiBuZXR3b3JrIGVycm9yIGl0J3MgQ0xPU0VEID0gMlxuICAgICAgICB2YXIgcmVhc29uID0gYWJvcnRfcmVhc29uID8gJ3VzZXInIDpcbiAgICAgICAgICAgIChlcy5yZWFkeVN0YXRlICE9PSAyID8gJ25ldHdvcmsnIDogJ3Blcm1hbmVudCcpO1xuICAgICAgICB0aGF0LmVzX2Nsb3NlID0gZXMub25tZXNzYWdlID0gZXMub25lcnJvciA9IG51bGw7XG4gICAgICAgIC8vIEV2ZW50U291cmNlIHJlY29ubmVjdHMgYXV0b21hdGljYWxseS5cbiAgICAgICAgZXMuY2xvc2UoKTtcbiAgICAgICAgZXMgPSBudWxsO1xuICAgICAgICAvLyBTYWZhcmkgYW5kIGNocm9tZSA8IDE1IGNyYXNoIGlmIHdlIGNsb3NlIHdpbmRvdyBiZWZvcmVcbiAgICAgICAgLy8gd2FpdGluZyBmb3IgRVMgY2xlYW51cC4gU2VlOlxuICAgICAgICAvLyAgIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04OTE1NVxuICAgICAgICB1dGlscy5kZWxheSgyMDAsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5kaXNwYXRjaEV2ZW50KG5ldyBTaW1wbGVFdmVudCgnY2xvc2UnLCB7cmVhc29uOiByZWFzb259KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH07XG59O1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZSA9IG5ldyBSRXZlbnRUYXJnZXQoKTtcblxuRXZlbnRTb3VyY2VSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgaWYgKHRoYXQuZXNfY2xvc2UpIHtcbiAgICAgICAgdGhhdC5lc19jbG9zZSh7fSwgdHJ1ZSk7XG4gICAgfVxufTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvdHJhbnMtcmVjZWl2ZXItZXZlbnRzb3VyY2UuanNcblxuXG4vLyAgICAgICAgIFsqXSBJbmNsdWRpbmcgbGliL3RyYW5zLXJlY2VpdmVyLWh0bWxmaWxlLmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG52YXIgX2lzX2llX2h0bWxmaWxlX2NhcGFibGU7XG52YXIgaXNJZUh0bWxmaWxlQ2FwYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChfaXNfaWVfaHRtbGZpbGVfY2FwYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICgnQWN0aXZlWE9iamVjdCcgaW4gX3dpbmRvdykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfaXNfaWVfaHRtbGZpbGVfY2FwYWJsZSA9ICEhbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2lzX2llX2h0bWxmaWxlX2NhcGFibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX2lzX2llX2h0bWxmaWxlX2NhcGFibGU7XG59O1xuXG5cbnZhciBIdG1sZmlsZVJlY2VpdmVyID0gZnVuY3Rpb24odXJsKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHV0aWxzLnBvbGx1dGVHbG9iYWxOYW1lc3BhY2UoKTtcblxuICAgIHRoYXQuaWQgPSAnYScgKyB1dGlscy5yYW5kb21fc3RyaW5nKDYsIDI2KTtcbiAgICB1cmwgKz0gKCh1cmwuaW5kZXhPZignPycpID09PSAtMSkgPyAnPycgOiAnJicpICtcbiAgICAgICAgJ2M9JyArIGVzY2FwZShXUHJlZml4ICsgJy4nICsgdGhhdC5pZCk7XG5cbiAgICB2YXIgY29uc3RydWN0b3IgPSBpc0llSHRtbGZpbGVDYXBhYmxlKCkgP1xuICAgICAgICB1dGlscy5jcmVhdGVIdG1sZmlsZSA6IHV0aWxzLmNyZWF0ZUlmcmFtZTtcblxuICAgIHZhciBpZnJhbWVPYmo7XG4gICAgX3dpbmRvd1tXUHJlZml4XVt0aGF0LmlkXSA9IHtcbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmcmFtZU9iai5sb2FkZWQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVzc2FnZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHRoYXQuZGlzcGF0Y2hFdmVudChuZXcgU2ltcGxlRXZlbnQoJ21lc3NhZ2UnLCB7J2RhdGEnOiBkYXRhfSkpO1xuICAgICAgICB9LFxuICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LmlmcmFtZV9jbG9zZSh7fSwgJ25ldHdvcmsnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhhdC5pZnJhbWVfY2xvc2UgPSBmdW5jdGlvbihlLCBhYm9ydF9yZWFzb24pIHtcbiAgICAgICAgaWZyYW1lT2JqLmNsZWFudXAoKTtcbiAgICAgICAgdGhhdC5pZnJhbWVfY2xvc2UgPSBpZnJhbWVPYmogPSBudWxsO1xuICAgICAgICBkZWxldGUgX3dpbmRvd1tXUHJlZml4XVt0aGF0LmlkXTtcbiAgICAgICAgdGhhdC5kaXNwYXRjaEV2ZW50KG5ldyBTaW1wbGVFdmVudCgnY2xvc2UnLCB7cmVhc29uOiBhYm9ydF9yZWFzb259KSk7XG4gICAgfTtcbiAgICBpZnJhbWVPYmogPSBjb25zdHJ1Y3Rvcih1cmwsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5pZnJhbWVfY2xvc2Uoe30sICdwZXJtYW5lbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbn07XG5cbkh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlID0gbmV3IFJFdmVudFRhcmdldCgpO1xuXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBpZiAodGhhdC5pZnJhbWVfY2xvc2UpIHtcbiAgICAgICAgdGhhdC5pZnJhbWVfY2xvc2Uoe30sICd1c2VyJyk7XG4gICAgfVxufTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvdHJhbnMtcmVjZWl2ZXItaHRtbGZpbGUuanNcblxuXG4vLyAgICAgICAgIFsqXSBJbmNsdWRpbmcgbGliL3RyYW5zLXJlY2VpdmVyLXhoci5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxudmFyIFhoclJlY2VpdmVyID0gZnVuY3Rpb24odXJsLCBBamF4T2JqZWN0KSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBidWZfcG9zID0gMDtcblxuICAgIHRoYXQueG8gPSBuZXcgQWpheE9iamVjdCgnUE9TVCcsIHVybCwgbnVsbCk7XG4gICAgdGhhdC54by5vbmNodW5rID0gZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gICAgICAgIGlmIChzdGF0dXMgIT09IDIwMCkgcmV0dXJuO1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgdmFyIGJ1ZiA9IHRleHQuc2xpY2UoYnVmX3Bvcyk7XG4gICAgICAgICAgICB2YXIgcCA9IGJ1Zi5pbmRleE9mKCdcXG4nKTtcbiAgICAgICAgICAgIGlmIChwID09PSAtMSkgYnJlYWs7XG4gICAgICAgICAgICBidWZfcG9zICs9IHArMTtcbiAgICAgICAgICAgIHZhciBtc2cgPSBidWYuc2xpY2UoMCwgcCk7XG4gICAgICAgICAgICB0aGF0LmRpc3BhdGNoRXZlbnQobmV3IFNpbXBsZUV2ZW50KCdtZXNzYWdlJywge2RhdGE6IG1zZ30pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhhdC54by5vbmZpbmlzaCA9IGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICAgICAgICB0aGF0LnhvLm9uY2h1bmsoc3RhdHVzLCB0ZXh0KTtcbiAgICAgICAgdGhhdC54byA9IG51bGw7XG4gICAgICAgIHZhciByZWFzb24gPSBzdGF0dXMgPT09IDIwMCA/ICduZXR3b3JrJyA6ICdwZXJtYW5lbnQnO1xuICAgICAgICB0aGF0LmRpc3BhdGNoRXZlbnQobmV3IFNpbXBsZUV2ZW50KCdjbG9zZScsIHtyZWFzb246IHJlYXNvbn0pKTtcbiAgICB9XG59O1xuXG5YaHJSZWNlaXZlci5wcm90b3R5cGUgPSBuZXcgUkV2ZW50VGFyZ2V0KCk7XG5cblhoclJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBpZiAodGhhdC54bykge1xuICAgICAgICB0aGF0LnhvLmNsb3NlKCk7XG4gICAgICAgIHRoYXQuZGlzcGF0Y2hFdmVudChuZXcgU2ltcGxlRXZlbnQoJ2Nsb3NlJywge3JlYXNvbjogJ3VzZXInfSkpO1xuICAgICAgICB0aGF0LnhvID0gbnVsbDtcbiAgICB9XG59O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi90cmFucy1yZWNlaXZlci14aHIuanNcblxuXG4vLyAgICAgICAgIFsqXSBJbmNsdWRpbmcgbGliL3Rlc3QtaG9va3MuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbi8vIEZvciB0ZXN0aW5nXG5Tb2NrSlMuZ2V0VXRpbHMgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB1dGlscztcbn07XG5cblNvY2tKUy5nZXRJZnJhbWVUcmFuc3BvcnQgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBJZnJhbWVUcmFuc3BvcnQ7XG59O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi90ZXN0LWhvb2tzLmpzXG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBTb2NrSlM7XG4gICAgICAgICAgfSkoKTtcbmlmICgnX3NvY2tqc19vbmxvYWQnIGluIHdpbmRvdykgc2V0VGltZW91dChfc29ja2pzX29ubG9hZCwgMSk7XG5cbi8vIEFNRCBjb21wbGlhbmNlXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKCdzb2NranMnLCBbXSwgZnVuY3Rpb24oKXtyZXR1cm4gU29ja0pTO30pO1xufVxuXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTb2NrSlM7XG59XG4vLyAgICAgWypdIEVuZCBvZiBsaWIvaW5kZXguanNcblxuLy8gWypdIEVuZCBvZiBsaWIvYWxsLmpzXG5cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnKTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwidmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaW1tZWRpYXRlSWRzID0ge307XG52YXIgbmV4dEltbWVkaWF0ZUlkID0gMDtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHsgdGltZW91dC5jbG9zZSgpOyB9O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIFRoYXQncyBub3QgaG93IG5vZGUuanMgaW1wbGVtZW50cyBpdCBidXQgdGhlIGV4cG9zZWQgYXBpIGlzIHRoZSBzYW1lLlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBmdW5jdGlvbihmbikge1xuICB2YXIgaWQgPSBuZXh0SW1tZWRpYXRlSWQrKztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZhbHNlIDogc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGltbWVkaWF0ZUlkc1tpZF0gPSB0cnVlO1xuXG4gIG5leHRUaWNrKGZ1bmN0aW9uIG9uTmV4dFRpY2soKSB7XG4gICAgaWYgKGltbWVkaWF0ZUlkc1tpZF0pIHtcbiAgICAgIC8vIGZuLmNhbGwoKSBpcyBmYXN0ZXIgc28gd2Ugb3B0aW1pemUgZm9yIHRoZSBjb21tb24gdXNlLWNhc2VcbiAgICAgIC8vIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FsbC1hcHBseS1zZWd1XG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGlkcyBmcm9tIGxlYWtpbmdcbiAgICAgIGV4cG9ydHMuY2xlYXJJbW1lZGlhdGUoaWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBjbGVhckltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xlYXJJbW1lZGlhdGUgOiBmdW5jdGlvbihpZCkge1xuICBkZWxldGUgaW1tZWRpYXRlSWRzW2lkXTtcbn07IiwidmFyIHRyYXZlcnNlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG5ldyBUcmF2ZXJzZShvYmopO1xufTtcblxuZnVuY3Rpb24gVHJhdmVyc2UgKG9iaikge1xuICAgIHRoaXMudmFsdWUgPSBvYmo7XG59XG5cblRyYXZlcnNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocHMpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMudmFsdWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcy5sZW5ndGg7IGkgKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHBzW2ldO1xuICAgICAgICBpZiAoIW5vZGUgfHwgIWhhc093blByb3BlcnR5LmNhbGwobm9kZSwga2V5KSkge1xuICAgICAgICAgICAgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlW2tleV07XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChwcykge1xuICAgIHZhciBub2RlID0gdGhpcy52YWx1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBzLmxlbmd0aDsgaSArKykge1xuICAgICAgICB2YXIga2V5ID0gcHNbaV07XG4gICAgICAgIGlmICghbm9kZSB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChub2RlLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHBzLCB2YWx1ZSkge1xuICAgIHZhciBub2RlID0gdGhpcy52YWx1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBzLmxlbmd0aCAtIDE7IGkgKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHBzW2ldO1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwobm9kZSwga2V5KSkgbm9kZVtrZXldID0ge307XG4gICAgICAgIG5vZGUgPSBub2RlW2tleV07XG4gICAgfVxuICAgIG5vZGVbcHNbaV1dID0gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChjYikge1xuICAgIHJldHVybiB3YWxrKHRoaXMudmFsdWUsIGNiLCB0cnVlKTtcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgdGhpcy52YWx1ZSA9IHdhbGsodGhpcy52YWx1ZSwgY2IsIGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoY2IsIGluaXQpIHtcbiAgICB2YXIgc2tpcCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDE7XG4gICAgdmFyIGFjYyA9IHNraXAgPyB0aGlzLnZhbHVlIDogaW5pdDtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUm9vdCB8fCAhc2tpcCkge1xuICAgICAgICAgICAgYWNjID0gY2IuY2FsbCh0aGlzLCBhY2MsIHgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjYztcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5wYXRocyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWNjID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGFjYy5wdXNoKHRoaXMucGF0aCk7IFxuICAgIH0pO1xuICAgIHJldHVybiBhY2M7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUubm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFjYyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICBhY2MucHVzaCh0aGlzLm5vZGUpO1xuICAgIH0pO1xuICAgIHJldHVybiBhY2M7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudHMgPSBbXSwgbm9kZXMgPSBbXTtcbiAgICBcbiAgICByZXR1cm4gKGZ1bmN0aW9uIGNsb25lIChzcmMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50c1tpXSA9PT0gc3JjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ29iamVjdCcgJiYgc3JjICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZHN0ID0gY29weShzcmMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwYXJlbnRzLnB1c2goc3JjKTtcbiAgICAgICAgICAgIG5vZGVzLnB1c2goZHN0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yRWFjaChvYmplY3RLZXlzKHNyYyksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkc3Rba2V5XSA9IGNsb25lKHNyY1trZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwYXJlbnRzLnBvcCgpO1xuICAgICAgICAgICAgbm9kZXMucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gZHN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNyYztcbiAgICAgICAgfVxuICAgIH0pKHRoaXMudmFsdWUpO1xufTtcblxuZnVuY3Rpb24gd2FsayAocm9vdCwgY2IsIGltbXV0YWJsZSkge1xuICAgIHZhciBwYXRoID0gW107XG4gICAgdmFyIHBhcmVudHMgPSBbXTtcbiAgICB2YXIgYWxpdmUgPSB0cnVlO1xuICAgIFxuICAgIHJldHVybiAoZnVuY3Rpb24gd2Fsa2VyIChub2RlXykge1xuICAgICAgICB2YXIgbm9kZSA9IGltbXV0YWJsZSA/IGNvcHkobm9kZV8pIDogbm9kZV87XG4gICAgICAgIHZhciBtb2RpZmllcnMgPSB7fTtcbiAgICAgICAgXG4gICAgICAgIHZhciBrZWVwR29pbmcgPSB0cnVlO1xuICAgICAgICBcbiAgICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICAgICAgbm9kZSA6IG5vZGUsXG4gICAgICAgICAgICBub2RlXyA6IG5vZGVfLFxuICAgICAgICAgICAgcGF0aCA6IFtdLmNvbmNhdChwYXRoKSxcbiAgICAgICAgICAgIHBhcmVudCA6IHBhcmVudHNbcGFyZW50cy5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHBhcmVudHMgOiBwYXJlbnRzLFxuICAgICAgICAgICAga2V5IDogcGF0aC5zbGljZSgtMSlbMF0sXG4gICAgICAgICAgICBpc1Jvb3QgOiBwYXRoLmxlbmd0aCA9PT0gMCxcbiAgICAgICAgICAgIGxldmVsIDogcGF0aC5sZW5ndGgsXG4gICAgICAgICAgICBjaXJjdWxhciA6IG51bGwsXG4gICAgICAgICAgICB1cGRhdGUgOiBmdW5jdGlvbiAoeCwgc3RvcEhlcmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmlzUm9vdCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wYXJlbnQubm9kZVtzdGF0ZS5rZXldID0geDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUubm9kZSA9IHg7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3BIZXJlKSBrZWVwR29pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZGVsZXRlJyA6IGZ1bmN0aW9uIChzdG9wSGVyZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5wYXJlbnQubm9kZVtzdGF0ZS5rZXldO1xuICAgICAgICAgICAgICAgIGlmIChzdG9wSGVyZSkga2VlcEdvaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlIDogZnVuY3Rpb24gKHN0b3BIZXJlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoc3RhdGUucGFyZW50Lm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnBhcmVudC5ub2RlLnNwbGljZShzdGF0ZS5rZXksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLnBhcmVudC5ub2RlW3N0YXRlLmtleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdG9wSGVyZSkga2VlcEdvaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2V5cyA6IG51bGwsXG4gICAgICAgICAgICBiZWZvcmUgOiBmdW5jdGlvbiAoZikgeyBtb2RpZmllcnMuYmVmb3JlID0gZiB9LFxuICAgICAgICAgICAgYWZ0ZXIgOiBmdW5jdGlvbiAoZikgeyBtb2RpZmllcnMuYWZ0ZXIgPSBmIH0sXG4gICAgICAgICAgICBwcmUgOiBmdW5jdGlvbiAoZikgeyBtb2RpZmllcnMucHJlID0gZiB9LFxuICAgICAgICAgICAgcG9zdCA6IGZ1bmN0aW9uIChmKSB7IG1vZGlmaWVycy5wb3N0ID0gZiB9LFxuICAgICAgICAgICAgc3RvcCA6IGZ1bmN0aW9uICgpIHsgYWxpdmUgPSBmYWxzZSB9LFxuICAgICAgICAgICAgYmxvY2sgOiBmdW5jdGlvbiAoKSB7IGtlZXBHb2luZyA9IGZhbHNlIH1cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGlmICghYWxpdmUpIHJldHVybiBzdGF0ZTtcbiAgICAgICAgXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZS5ub2RlID09PSAnb2JqZWN0JyAmJiBzdGF0ZS5ub2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5rZXlzIHx8IHN0YXRlLm5vZGVfICE9PSBzdGF0ZS5ub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmtleXMgPSBvYmplY3RLZXlzKHN0YXRlLm5vZGUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHN0YXRlLmlzTGVhZiA9IHN0YXRlLmtleXMubGVuZ3RoID09IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRzW2ldLm5vZGVfID09PSBub2RlXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2lyY3VsYXIgPSBwYXJlbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pc0xlYWYgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlLmtleXMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBzdGF0ZS5ub3RMZWFmID0gIXN0YXRlLmlzTGVhZjtcbiAgICAgICAgICAgIHN0YXRlLm5vdFJvb3QgPSAhc3RhdGUuaXNSb290O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB1cGRhdGVTdGF0ZSgpO1xuICAgICAgICBcbiAgICAgICAgLy8gdXNlIHJldHVybiB2YWx1ZXMgdG8gdXBkYXRlIGlmIGRlZmluZWRcbiAgICAgICAgdmFyIHJldCA9IGNiLmNhbGwoc3RhdGUsIHN0YXRlLm5vZGUpO1xuICAgICAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQgJiYgc3RhdGUudXBkYXRlKSBzdGF0ZS51cGRhdGUocmV0KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChtb2RpZmllcnMuYmVmb3JlKSBtb2RpZmllcnMuYmVmb3JlLmNhbGwoc3RhdGUsIHN0YXRlLm5vZGUpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFrZWVwR29pbmcpIHJldHVybiBzdGF0ZTtcbiAgICAgICAgXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUubm9kZSA9PSAnb2JqZWN0J1xuICAgICAgICAmJiBzdGF0ZS5ub2RlICE9PSBudWxsICYmICFzdGF0ZS5jaXJjdWxhcikge1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdXBkYXRlU3RhdGUoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yRWFjaChzdGF0ZS5rZXlzLCBmdW5jdGlvbiAoa2V5LCBpKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5wcmUpIG1vZGlmaWVycy5wcmUuY2FsbChzdGF0ZSwgc3RhdGUubm9kZVtrZXldLCBrZXkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHdhbGtlcihzdGF0ZS5ub2RlW2tleV0pO1xuICAgICAgICAgICAgICAgIGlmIChpbW11dGFibGUgJiYgaGFzT3duUHJvcGVydHkuY2FsbChzdGF0ZS5ub2RlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLm5vZGVba2V5XSA9IGNoaWxkLm5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNoaWxkLmlzTGFzdCA9IGkgPT0gc3RhdGUua2V5cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIGNoaWxkLmlzRmlyc3QgPSBpID09IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5wb3N0KSBtb2RpZmllcnMucG9zdC5jYWxsKHN0YXRlLCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcGF0aC5wb3AoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFyZW50cy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKG1vZGlmaWVycy5hZnRlcikgbW9kaWZpZXJzLmFmdGVyLmNhbGwoc3RhdGUsIHN0YXRlLm5vZGUpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0pKHJvb3QpLm5vZGU7XG59XG5cbmZ1bmN0aW9uIGNvcHkgKHNyYykge1xuICAgIGlmICh0eXBlb2Ygc3JjID09PSAnb2JqZWN0JyAmJiBzcmMgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGRzdDtcbiAgICAgICAgXG4gICAgICAgIGlmIChpc0FycmF5KHNyYykpIHtcbiAgICAgICAgICAgIGRzdCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRGF0ZShzcmMpKSB7XG4gICAgICAgICAgICBkc3QgPSBuZXcgRGF0ZShzcmMuZ2V0VGltZSA/IHNyYy5nZXRUaW1lKCkgOiBzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUmVnRXhwKHNyYykpIHtcbiAgICAgICAgICAgIGRzdCA9IG5ldyBSZWdFeHAoc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Vycm9yKHNyYykpIHtcbiAgICAgICAgICAgIGRzdCA9IHsgbWVzc2FnZTogc3JjLm1lc3NhZ2UgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Jvb2xlYW4oc3JjKSkge1xuICAgICAgICAgICAgZHN0ID0gbmV3IEJvb2xlYW4oc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc051bWJlcihzcmMpKSB7XG4gICAgICAgICAgICBkc3QgPSBuZXcgTnVtYmVyKHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTdHJpbmcoc3JjKSkge1xuICAgICAgICAgICAgZHN0ID0gbmV3IFN0cmluZyhzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKE9iamVjdC5jcmVhdGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKSB7XG4gICAgICAgICAgICBkc3QgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihzcmMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzcmMuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgZHN0ID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJvdG8gPVxuICAgICAgICAgICAgICAgIChzcmMuY29uc3RydWN0b3IgJiYgc3JjLmNvbnN0cnVjdG9yLnByb3RvdHlwZSlcbiAgICAgICAgICAgICAgICB8fCBzcmMuX19wcm90b19fXG4gICAgICAgICAgICAgICAgfHwge31cbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHZhciBUID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICBULnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgICAgICAgZHN0ID0gbmV3IFQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZvckVhY2gob2JqZWN0S2V5cyhzcmMpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBkc3Rba2V5XSA9IHNyY1trZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRzdDtcbiAgICB9XG4gICAgZWxzZSByZXR1cm4gc3JjO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMgKG9iaikge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSByZXMucHVzaChrZXkpXG4gICAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHRvUyAob2JqKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSB9XG5mdW5jdGlvbiBpc0RhdGUgKG9iaikgeyByZXR1cm4gdG9TKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJyB9XG5mdW5jdGlvbiBpc1JlZ0V4cCAob2JqKSB7IHJldHVybiB0b1Mob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXScgfVxuZnVuY3Rpb24gaXNFcnJvciAob2JqKSB7IHJldHVybiB0b1Mob2JqKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB9XG5mdW5jdGlvbiBpc0Jvb2xlYW4gKG9iaikgeyByZXR1cm4gdG9TKG9iaikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJyB9XG5mdW5jdGlvbiBpc051bWJlciAob2JqKSB7IHJldHVybiB0b1Mob2JqKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScgfVxuZnVuY3Rpb24gaXNTdHJpbmcgKG9iaikgeyByZXR1cm4gdG9TKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nIH1cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkgKHhzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICh4cywgZm4pIHtcbiAgICBpZiAoeHMuZm9yRWFjaCkgcmV0dXJuIHhzLmZvckVhY2goZm4pXG4gICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZuKHhzW2ldLCBpLCB4cyk7XG4gICAgfVxufTtcblxuZm9yRWFjaChvYmplY3RLZXlzKFRyYXZlcnNlLnByb3RvdHlwZSksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICB0cmF2ZXJzZVtrZXldID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgdmFyIHQgPSBuZXcgVHJhdmVyc2Uob2JqKTtcbiAgICAgICAgcmV0dXJuIHRba2V5XS5hcHBseSh0LCBhcmdzKTtcbiAgICB9O1xufSk7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eSB8fCBmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICByZXR1cm4ga2V5IGluIG9iajtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiIsIi8vIFJldHVybnMgYSB3cmFwcGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHdyYXBwZWQgY2FsbGJhY2tcbi8vIFRoZSB3cmFwcGVyIGZ1bmN0aW9uIHNob3VsZCBkbyBzb21lIHN0dWZmLCBhbmQgcmV0dXJuIGFcbi8vIHByZXN1bWFibHkgZGlmZmVyZW50IGNhbGxiYWNrIGZ1bmN0aW9uLlxuLy8gVGhpcyBtYWtlcyBzdXJlIHRoYXQgb3duIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkLCBzbyB0aGF0XG4vLyBkZWNvcmF0aW9ucyBhbmQgc3VjaCBhcmUgbm90IGxvc3QgYWxvbmcgdGhlIHdheS5cbm1vZHVsZS5leHBvcnRzID0gd3JhcHB5XG5mdW5jdGlvbiB3cmFwcHkgKGZuLCBjYikge1xuICBpZiAoZm4gJiYgY2IpIHJldHVybiB3cmFwcHkoZm4pKGNiKVxuXG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbmVlZCB3cmFwcGVyIGZ1bmN0aW9uJylcblxuICBPYmplY3Qua2V5cyhmbikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIHdyYXBwZXJba10gPSBmbltrXVxuICB9KVxuXG4gIHJldHVybiB3cmFwcGVyXG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXVxuICAgIH1cbiAgICB2YXIgcmV0ID0gZm4uYXBwbHkodGhpcywgYXJncylcbiAgICB2YXIgY2IgPSBhcmdzW2FyZ3MubGVuZ3RoLTFdXG4gICAgaWYgKHR5cGVvZiByZXQgPT09ICdmdW5jdGlvbicgJiYgcmV0ICE9PSBjYikge1xuICAgICAgT2JqZWN0LmtleXMoY2IpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0W2tdID0gY2Jba11cbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxufVxuIl19
